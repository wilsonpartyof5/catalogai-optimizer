var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(x, {
  get: (a, b) => (typeof require < "u" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require < "u")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);

// node_modules/@remix-run/web-stream/src/stream.cjs
var require_stream = __commonJS({
  "node_modules/@remix-run/web-stream/src/stream.cjs"(exports, module) {
    module.exports = __require("web-streams-polyfill/ponyfill");
  }
});

// node_modules/@remix-run/web-blob/dist/src/blob.cjs
var require_blob = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/blob.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = __require("web-encoding"), webStream = require_stream(), WebBlob = class Blob3 {
      /**
       * @param {BlobPart[]} [init]
       * @param {BlobPropertyBag} [options]
       */
      constructor(init = [], options = {}) {
        let parts = [], size2 = 0;
        for (let part of init)
          if (typeof part == "string") {
            let bytes = new webEncoding.TextEncoder().encode(part);
            parts.push(bytes), size2 += bytes.byteLength;
          } else if (part instanceof WebBlob)
            size2 += part.size, parts.push(...part._parts);
          else if (part instanceof ArrayBuffer)
            parts.push(new Uint8Array(part)), size2 += part.byteLength;
          else if (part instanceof Uint8Array)
            parts.push(part), size2 += part.byteLength;
          else if (ArrayBuffer.isView(part)) {
            let { buffer, byteOffset, byteLength } = part;
            parts.push(new Uint8Array(buffer, byteOffset, byteLength)), size2 += byteLength;
          } else {
            let bytes = new webEncoding.TextEncoder().encode(String(part));
            parts.push(bytes), size2 += bytes.byteLength;
          }
        this._size = size2, this._type = readType(options.type), this._parts = parts, Object.defineProperties(this, {
          _size: { enumerable: !1 },
          _type: { enumerable: !1 },
          _parts: { enumerable: !1 }
        });
      }
      /**
       * A string indicating the MIME type of the data contained in the Blob.
       * If the type is unknown, this string is empty.
       * @type {string}
       */
      get type() {
        return this._type;
      }
      /**
       * The size, in bytes, of the data contained in the Blob object.
       * @type {number}
       */
      get size() {
        return this._size;
      }
      /**
       * Returns a new Blob object containing the data in the specified range of
       * bytes of the blob on which it's called.
       * @param {number} [start=0] - An index into the Blob indicating the first
       * byte to include in the new Blob. If you specify a negative value, it's
       * treated as an offset from the end of the Blob toward the beginning. For
       * example, `-10` would be the 10th from last byte in the Blob. The default
       * value is `0`. If you specify a value for start that is larger than the
       * size of the source Blob, the returned Blob has size 0 and contains no
       * data.
       * @param {number} [end] - An index into the `Blob` indicating the first byte
       *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
       * this index is not included). If you specify a negative value, it's treated
       * as an offset from the end of the Blob toward the beginning. For example,
       * `-10` would be the 10th from last byte in the `Blob`. The default value is
       * size.
       * @param {string} [type] - The content type to assign to the new Blob;
       * this will be the value of its type property. The default value is an empty
       * string.
       * @returns {Blob}
       */
      slice(start = 0, end = this.size, type = "") {
        let { size: size2, _parts } = this, offset = start < 0 ? Math.max(size2 + start, 0) : Math.min(start, size2), limit = end < 0 ? Math.max(size2 + end, 0) : Math.min(end, size2), span = Math.max(limit - offset, 0), blob = new Blob3([], { type });
        if (span === 0)
          return blob;
        let blobSize = 0, blobParts = [];
        for (let part of _parts) {
          let { byteLength } = part;
          if (offset > 0 && byteLength <= offset)
            offset -= byteLength, limit -= byteLength;
          else {
            let chunk = part.subarray(offset, Math.min(byteLength, limit));
            if (blobParts.push(chunk), blobSize += chunk.byteLength, offset = 0, blobSize >= span)
              break;
          }
        }
        return blob._parts = blobParts, blob._size = blobSize, blob;
      }
      /**
       * Returns a promise that resolves with an ArrayBuffer containing the entire
       * contents of the Blob as binary data.
       * @returns {Promise<ArrayBuffer>}
       */
      // eslint-disable-next-line require-await
      async arrayBuffer() {
        let buffer = new ArrayBuffer(this.size), bytes = new Uint8Array(buffer), offset = 0;
        for (let part of this._parts)
          bytes.set(part, offset), offset += part.byteLength;
        return buffer;
      }
      /**
       * Returns a promise that resolves with a USVString containing the entire
       * contents of the Blob interpreted as UTF-8 text.
       * @returns {Promise<string>}
       */
      // eslint-disable-next-line require-await
      async text() {
        let decoder = new webEncoding.TextDecoder(), text2 = "";
        for (let part of this._parts)
          text2 += decoder.decode(part);
        return text2;
      }
      /**
       * @returns {BlobStream}
       */
      stream() {
        return new BlobStream(this._parts);
      }
      /**
       * @returns {string}
       */
      toString() {
        return "[object Blob]";
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, Blob2 = WebBlob, BlobStream = class extends webStream.ReadableStream {
      /**
       * @param {Uint8Array[]} chunks
       */
      constructor(chunks) {
        super(new BlobStreamController(chunks.values()), { type: "bytes" }), this._chunks = chunks;
      }
      /**
       * @param {Object} [_options]
       * @property {boolean} [_options.preventCancel]
       * @returns {AsyncIterator<Uint8Array>}
       */
      async *[Symbol.asyncIterator](_options) {
        let reader = this.getReader();
        yield* this._chunks, reader.releaseLock();
      }
    }, BlobStreamController = class {
      /**
       * @param {Iterator<Uint8Array>} chunks
       */
      constructor(chunks) {
        this.chunks = chunks;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      start(controller) {
        this.work(controller), this.isWorking = !1, this.isCancelled = !1;
      }
      /**
       *
       * @param {ReadableStreamDefaultController} controller
       */
      async work(controller) {
        let { chunks } = this;
        for (this.isWorking = !0; !this.isCancelled && (controller.desiredSize || 0) > 0; ) {
          let next = null;
          try {
            next = chunks.next();
          } catch (error) {
            controller.error(error);
            break;
          }
          next && (!next.done && !this.isCancelled ? controller.enqueue(next.value) : controller.close());
        }
        this.isWorking = !1;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      pull(controller) {
        this.isWorking || this.work(controller);
      }
      cancel() {
        this.isCancelled = !0;
      }
    }, readType = (input = "") => {
      let type = String(input).toLowerCase();
      return /[^\u0020-\u007E]/.test(type) ? "" : type;
    };
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob2;
  }
});

// node_modules/@remix-run/web-blob/dist/src/lib.node.cjs
var require_lib_node = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = __require("web-encoding"), webStream = require_stream(), blob = require_blob(), Blob2 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
    // @see https://github.com/nodejs/node/issues/42108
    // NodeBlob ||
    blob.Blob;
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob2;
  }
});

// node_modules/@remix-run/web-file/dist/src/file.cjs
var require_file = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/file.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), File2 = class extends webBlob.Blob {
      /**
       *
       * @param {BlobPart[]} init
       * @param {string} name - A USVString representing the file name or the path
       * to the file.
       * @param {FilePropertyBag} [options]
       */
      constructor(init, name = panic(new TypeError("File constructor requires name argument")), options = {}) {
        super(init, options), this._name = name, this._lastModified = options.lastModified || Date.now();
      }
      /**
       * The name of the file referenced by the File object.
       * @type {string}
       */
      get name() {
        return this._name;
      }
      /**
       * The path the URL of the File is relative to.
       * @type {string}
       */
      get webkitRelativePath() {
        return "";
      }
      /**
       * Returns the last modified time of the file, in millisecond since the UNIX
       * epoch (January 1st, 1970 at Midnight).
       * @returns {number}
       */
      get lastModified() {
        return this._lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    exports.File = File2;
  }
});

// node_modules/@remix-run/web-file/dist/src/lib.node.cjs
var require_lib_node2 = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), file = require_file(), File2 = file.File;
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    exports.File = File2;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/form-data.cjs
var require_form_data = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/form-data.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var FormData2 = class {
      /**
       * @param {HTMLFormElement} [form]
       */
      constructor(form) {
        if (this._entries = [], Object.defineProperty(this, "_entries", { enumerable: !1 }), isHTMLFormElement(form))
          for (let element of form.elements)
            if (isSelectElement(element))
              for (let option of element.options)
                option.selected && this.append(element.name, option.value);
            else
              isInputElement2(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name && this.append(element.name, element.value);
      }
      get [Symbol.toStringTag]() {
        return "FormData";
      }
      /**
       * Appends a new value onto an existing key inside a FormData object, or adds
       * the key if it does not already exist.
       *
       * The difference between `set` and `append` is that if the specified key
       * already exists, `set` will overwrite all existing values with the new one,
       * whereas `append` will append the new value onto the end of the existing
       * set of values.
       *
       * @param {string} name
       * @param {string|Blob|File} value - The name of the field whose data is
       * contained in value.
       * @param {string} [filename] - The filename reported to the server, when a
       * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
       * `"blob"`. The default filename for a `File` is the it's name.
       */
      append(name, value = panic(
        new TypeError("FormData.append: requires at least 2 arguments")
      ), filename) {
        this._entries.push([name, toEntryValue(value, filename)]);
      }
      /**
       * Deletes a key and all its values from a FormData object.
       *
       * @param {string} name
       */
      delete(name = panic(new TypeError("FormData.delete: requires string argument"))) {
        let entries = this._entries, index = 0;
        for (; index < entries.length; ) {
          let [entryName] = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entryName === name ? entries.splice(index, 1) : index++;
        }
      }
      /**
       * Returns the first value associated with a given key from within a
       * FormData object.
       *
       * @param {string} name
       * @returns {FormDataEntryValue|null}
       */
      get(name = panic(new TypeError("FormData.get: requires string argument"))) {
        for (let [entryName, value] of this._entries)
          if (entryName === name)
            return value;
        return null;
      }
      /**
       * Returns an array of all the values associated with a given key from within
       * a FormData.
       *
       * @param {string} name
       * @returns {FormDataEntryValue[]}
       */
      getAll(name = panic(new TypeError("FormData.getAll: requires string argument"))) {
        let values2 = [];
        for (let [entryName, value] of this._entries)
          entryName === name && values2.push(value);
        return values2;
      }
      /**
       * Returns a boolean stating whether a FormData object contains a certain key.
       *
       * @param {string} name
       */
      has(name = panic(new TypeError("FormData.has: requires string argument"))) {
        for (let [entryName] of this._entries)
          if (entryName === name)
            return !0;
        return !1;
      }
      /**
       * Sets a new value for an existing key inside a FormData object, or adds the
       * key/value if it does not already exist.
       *
       * @param {string} name
       * @param {string|Blob|File} value
       * @param {string} [filename]
       */
      set(name, value = panic(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
        let index = 0, { _entries: entries } = this, entryValue = toEntryValue(value, filename), wasSet = !1;
        for (; index < entries.length; ) {
          let entry2 = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entry2[0] === name ? wasSet ? entries.splice(index, 1) : (wasSet = !0, entry2[1] = entryValue, index++) : index++;
        }
        wasSet || entries.push([name, entryValue]);
      }
      /**
       * Method returns an iterator allowing to go through all key/value pairs
       * contained in this object.
       */
      entries() {
        return this._entries.values();
      }
      /**
       * Returns an iterator allowing to go through all keys of the key/value pairs
       * contained in this object.
       *
       * @returns {IterableIterator<string>}
       */
      *keys() {
        for (let [name] of this._entries)
          yield name;
      }
      /**
       * Returns an iterator allowing to go through all values contained in this
       * object.
       *
       * @returns {IterableIterator<FormDataEntryValue>}
       */
      *values() {
        for (let [_, value] of this._entries)
          yield value;
      }
      [Symbol.iterator]() {
        return this._entries.values();
      }
      /**
       * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
       * @param {any} [thisArg]
       * @returns {void}
       */
      forEach(fn, thisArg) {
        for (let [key, value] of this._entries)
          fn.call(thisArg, value, key, this);
      }
    }, isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]", toEntryValue = (value, filename) => {
      if (isFile(value))
        return filename != null ? new BlobFile([value], filename, value) : value;
      if (isBlob(value))
        return new BlobFile([value], filename ?? "blob");
      if (filename != null && filename != "")
        throw new TypeError(
          "filename is only supported when value is Blob or File"
        );
      return `${value}`;
    }, isFile = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name == "string", isBlob = (value) => Object.prototype.toString.call(value) === "[object Blob]", BlobFile = class {
      /**
       * @param {[Blob]} parts
       * @param {string} name
       * @param {FilePropertyBag} [options]
       */
      constructor([blob], name, { lastModified = Date.now() } = {}) {
        this.blob = blob, this.name = name, this.lastModified = lastModified;
      }
      get webkitRelativePath() {
        return "";
      }
      get size() {
        return this.blob.size;
      }
      get type() {
        return this.blob.type;
      }
      /**
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [contentType]
       */
      slice(start, end, contentType) {
        return this.blob.slice(start, end, contentType);
      }
      stream() {
        return this.blob.stream();
      }
      text() {
        return this.blob.text();
      }
      arrayBuffer() {
        return this.blob.arrayBuffer();
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    function isSelectElement(element) {
      return element.tagName === "SELECT";
    }
    function isInputElement2(element) {
      return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
    }
    exports.FormData = FormData2;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs
var require_lib_node3 = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formData = require_form_data(), FormData2 = formData.FormData;
    exports.FormData = FormData2;
  }
});

// node_modules/@remix-run/web-fetch/dist/lib.node.cjs
var require_lib_node4 = __commonJS({
  "node_modules/@remix-run/web-fetch/dist/lib.node.cjs"(exports, module) {
    "use strict";
    var http = __require("http"), https = __require("https"), zlib = __require("zlib"), fs = __require("fs"), mime = __require("mrmime"), dataUriToBuffer = __require("data-uri-to-buffer"), buffer = __require("buffer"), Stream = __require("stream"), util = __require("util"), webBlob = require_lib_node(), webFile = require_lib_node2(), webFormData = require_lib_node3(), crypto2 = __require("crypto"), multipartParser = __require("@web3-storage/multipart-parser"), url = __require("url"), abortController = __require("abort-controller"), FetchBaseError = class extends Error {
      /**
       * @param {string} message 
       * @param {string} type 
       */
      constructor(message, type) {
        super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    }, FetchError = class extends FetchBaseError {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} type -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
      }
    }, NAME = Symbol.toStringTag, isURLSearchParameters = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME] === "URLSearchParams", isBlob = (object) => typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME]);
    function isFormData(object) {
      return typeof object == "object" && typeof object.append == "function" && typeof object.set == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.delete == "function" && typeof object.keys == "function" && typeof object.values == "function" && typeof object.entries == "function" && typeof object.constructor == "function" && object[NAME] === "FormData";
    }
    var isMultipartFormDataStream = (value) => value instanceof Stream && typeof value.getBoundary == "function" && typeof value.hasKnownLength == "function" && typeof value.getLengthSync == "function", isAbortSignal = (object) => typeof object == "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget"), isReadableStream = (value) => typeof value == "object" && typeof value.getReader == "function" && typeof value.cancel == "function" && typeof value.tee == "function", isIterable = (value) => value && Symbol.iterator in value, carriage = `\r
`, dashes = "-".repeat(2), carriageLength = Buffer.byteLength(carriage), getFooter = (boundary2) => `${dashes}${boundary2}${dashes}${carriage.repeat(2)}`;
    function getHeader2(boundary2, name, field) {
      let header = "";
      if (header += `${dashes}${boundary2}${carriage}`, header += `Content-Disposition: form-data; name="${name}"`, isBlob(field)) {
        let { name: name2 = "blob", type } = (
          /** @type {Blob & {name?:string}} */
          field
        );
        header += `; filename="${name2}"${carriage}`, header += `Content-Type: ${type || "application/octet-stream"}`;
      }
      return `${header}${carriage.repeat(2)}`;
    }
    var getBoundary = () => crypto2.randomBytes(8).toString("hex");
    async function* formDataIterator(form, boundary2) {
      let encoder2 = new TextEncoder();
      for (let [name, value] of form)
        yield encoder2.encode(getHeader2(boundary2, name, value)), isBlob(value) ? yield* value.stream() : yield encoder2.encode(value), yield encoder2.encode(carriage);
      yield encoder2.encode(getFooter(boundary2));
    }
    function getFormDataLength(form, boundary2) {
      let length = 0;
      for (let [name, value] of form)
        length += Buffer.byteLength(getHeader2(boundary2, name, value)), isBlob(value) ? length += value.size : length += Buffer.byteLength(String(value)), length += carriageLength;
      return length += Buffer.byteLength(getFooter(boundary2)), length;
    }
    var toFormData = async (source) => {
      let { body, headers } = source, contentType = headers?.get("Content-Type") || "";
      if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
        let form = new webFormData.FormData(), bodyText = await source.text();
        return new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v)), form;
      }
      let [type, boundary2] = contentType.split(/\s*;\s*boundary=/);
      if (type === "multipart/form-data" && boundary2 != null && body != null) {
        let form = new webFormData.FormData(), parts = multipartParser.iterateMultipart(body, boundary2);
        for await (let { name, data: data3, filename, contentType: contentType2 } of parts)
          typeof filename == "string" ? form.append(name, new webFile.File([data3], filename, { type: contentType2 })) : typeof filename < "u" ? form.append(name, new webFile.File([], "", { type: contentType2 })) : form.append(name, new TextDecoder().decode(data3), filename);
        return form;
      } else
        throw new TypeError("Could not parse content as FormData.");
    }, encoder = new util.TextEncoder(), decoder = new util.TextDecoder(), encode2 = (text2) => encoder.encode(text2), decode2 = (bytes) => decoder.decode(bytes), { readableHighWaterMark } = new Stream.Readable(), INTERNALS$2 = Symbol("Body internals"), Body = class {
      /**
       * @param {BodyInit|Stream|null} body
       * @param {{size?:number}} options
       */
      constructor(body, {
        size: size2 = 0
      } = {}) {
        let state = {
          /** @type {null|ReadableStream<Uint8Array>} */
          body: null,
          /** @type {string|null} */
          type: null,
          /** @type {number|null} */
          size: null,
          /** @type {null|string} */
          boundary: null,
          disturbed: !1,
          /** @type {null|Error} */
          error: null
        };
        if (this[INTERNALS$2] = state, body === null)
          state.body = null, state.size = 0;
        else if (isURLSearchParameters(body)) {
          let bytes = encode2(body.toString());
          state.body = fromBytes(bytes), state.size = bytes.byteLength, state.type = "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isBlob(body))
          state.size = body.size, state.type = body.type || null, state.body = body.stream();
        else if (body instanceof Uint8Array)
          state.body = fromBytes(body), state.size = body.byteLength;
        else if (util.types.isAnyArrayBuffer(body)) {
          let bytes = new Uint8Array(body);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (ArrayBuffer.isView(body)) {
          let bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (isReadableStream(body))
          state.body = body;
        else if (isFormData(body)) {
          let boundary2 = `NodeFetchFormDataBoundary${getBoundary()}`;
          state.type = `multipart/form-data; boundary=${boundary2}`, state.size = getFormDataLength(body, boundary2), state.body = fromAsyncIterable(formDataIterator(body, boundary2));
        } else if (isMultipartFormDataStream(body))
          state.type = `multipart/form-data; boundary=${body.getBoundary()}`, state.size = body.hasKnownLength() ? body.getLengthSync() : null, state.body = fromStream(body);
        else if (body instanceof Stream)
          state.body = fromStream(body);
        else {
          let bytes = encode2(String(body));
          state.type = "text/plain;charset=UTF-8", state.size = bytes.byteLength, state.body = fromBytes(bytes);
        }
        this.size = size2;
      }
      /** @type {Headers} */
      /* c8 ignore next 3 */
      get headers() {
        throw new TypeError("'get headers' called on an object that does not implements interface.");
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let { buffer: buffer2, byteOffset, byteLength } = await consumeBody(this);
        return buffer2.slice(byteOffset, byteOffset + byteLength);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        let ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].type || "", buf = await consumeBody(this);
        return new webBlob.Blob([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        return JSON.parse(await this.text());
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        let buffer2 = await consumeBody(this);
        return decode2(buffer2);
      }
      /**
       * @returns {Promise<FormData>}
       */
      async formData() {
        return toFormData(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: !0 },
      bodyUsed: { enumerable: !0 },
      arrayBuffer: { enumerable: !0 },
      blob: { enumerable: !0 },
      json: { enumerable: !0 },
      text: { enumerable: !0 },
      formData: { enumerable: !0 }
    });
    async function consumeBody(data3) {
      let state = data3[INTERNALS$2];
      if (state.disturbed)
        throw new TypeError(`body used already for: ${data3.url}`);
      if (state.disturbed = !0, state.error)
        throw state.error;
      let { body } = state;
      if (body === null)
        return new Uint8Array(0);
      let [buffer2, chunks, limit] = data3.size > 0 ? [new Uint8Array(data3.size), [], data3.size] : [null, [], 1 / 0], offset = 0, source = streamIterator(body);
      try {
        for await (let chunk of source) {
          let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            let error = new FetchError(`content size at ${data3.url} over limit: ${limit}`, "max-size");
            throw source.throw(error), error;
          } else
            buffer2 ? buffer2.set(bytes, offset) : chunks.push(bytes);
          offset += bytes.byteLength;
        }
        if (buffer2) {
          if (offset < buffer2.byteLength)
            throw new FetchError(`Premature close of server response while trying to fetch ${data3.url}`, "premature-close");
          return buffer2;
        } else
          return writeBytes(new Uint8Array(offset), chunks);
      } catch (error) {
        if (error instanceof FetchBaseError)
          throw error;
        if (error && error.name === "AbortError")
          throw error;
        {
          let e = (
            /** @type {import('./errors/fetch-error').SystemError} */
            error
          );
          throw new FetchError(`Invalid response body while trying to fetch ${data3.url}: ${e.message}`, "system", e);
        }
      }
    }
    var clone = (instance) => {
      let { body } = instance;
      if (instance.bodyUsed)
        throw new Error("cannot clone body after it is used");
      if (!body)
        return null;
      let [left, right] = body.tee();
      return instance[INTERNALS$2].body = left, right;
    }, extractContentType = (source) => source[INTERNALS$2].type, getTotalBytes = (source) => source[INTERNALS$2].size, writeToStream = (dest, { body }) => {
      body === null ? dest.end() : Stream.Readable.from(streamIterator(body)).pipe(dest);
    }, StreamIterableIterator = class {
      /**
       * @param {ReadableStream<T>} stream
       */
      constructor(stream) {
        this.stream = stream, this.reader = null;
      }
      /**
       * @returns {AsyncGenerator<T, void, void>}
       */
      [Symbol.asyncIterator]() {
        return this;
      }
      getReader() {
        if (this.reader)
          return this.reader;
        let reader = this.stream.getReader();
        return this.reader = reader, reader;
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      next() {
        return (
          /** @type {Promise<IteratorResult<T, void>>} */
          this.getReader().read()
        );
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async return() {
        return this.reader && await this.reader.cancel(), { done: !0, value: void 0 };
      }
      /**
       * 
       * @param {any} error 
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async throw(error) {
        return await this.getReader().cancel(error), { done: !0, value: void 0 };
      }
    }, streamIterator = (stream) => new StreamIterableIterator(stream), writeBytes = (buffer2, chunks) => {
      let offset = 0;
      for (let chunk of chunks)
        buffer2.set(chunk, offset), offset += chunk.byteLength;
      return buffer2;
    }, fromBytes = (bytes) => new webBlob.ReadableStream({
      start(controller) {
        controller.enqueue(bytes), controller.close();
      }
    }), fromAsyncIterable = (content) => new webBlob.ReadableStream(new AsyncIterablePump(content)), AsyncIterablePump = class {
      /**
       * @param {AsyncIterable<Uint8Array>} source
       */
      constructor(source) {
        this.source = source[Symbol.asyncIterator]();
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      async pull(controller) {
        try {
          for (; controller.desiredSize || 0 > 0; ) {
            let next = await this.source.next();
            if (next.done) {
              controller.close();
              break;
            } else
              controller.enqueue(next.value);
          }
        } catch (error) {
          controller.error(error);
        }
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        reason ? typeof this.source.throw == "function" ? this.source.throw(reason) : typeof this.source.return == "function" && this.source.return() : typeof this.source.return == "function" && this.source.return();
      }
    }, fromStream = (source) => {
      let pump = new StreamPump(source);
      return new webBlob.ReadableStream(pump, pump);
    }, StreamPump = class {
      /**
       * @param {Stream & {
       * 	readableHighWaterMark?: number
       * 	readable?:boolean,
       * 	resume?: () => void,
       * 	pause?: () => void
       * 	destroy?: (error?:Error) => void
       * }} stream
       */
      constructor(stream) {
        this.highWaterMark = stream.readableHighWaterMark || readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      /**
       * @param {Uint8Array} [chunk]
       */
      size(chunk) {
        return chunk?.byteLength || 0;
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      /**
       * @param {Uint8Array|string} chunk
       */
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      /**
       * @param {Error} error 
       */
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    }, validators = http, validateHeaderName = (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~:]+$/.test(name)) {
        let err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        throw Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), err;
      }
    }, validateHeaderValue = typeof validators.validateHeaderValue == "function" ? validators.validateHeaderValue : (
      /**
       * @param {string} name
       * @param {string} value
       */
      (name, value) => {
        if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
          let err = new TypeError(`Invalid character in header content ["${name}"]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" }), err;
        }
      }
    ), Headers2 = class extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init) {
        let result = [];
        if (init instanceof Headers2) {
          let raw = init.raw();
          for (let [name, values2] of Object.entries(raw))
            result.push(...values2.map((value) => [name, value]));
        } else if (init != null)
          if (isIterable(init))
            result = [...init].map((pair) => {
              if (typeof pair != "object" || util.types.isBoxedPrimitive(pair))
                throw new TypeError("Each header pair must be an iterable object");
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2)
                throw new TypeError("Each header pair must be a name/value tuple");
              return [...pair];
            });
          else if (typeof init == "object" && init !== null)
            result.push(...Object.entries(init));
          else
            throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName(name), validateHeaderValue(name, String(value)), [String(name).toLowerCase(), String(value)])) : [], super(result), new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase(),
                  String(value)
                ));
              case "delete":
              case "has":
              case "getAll":
                return (name) => (validateHeaderName(name), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase()
                ));
              case "keys":
                return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
              default:
                return Reflect.get(target, p, receiver);
            }
          }
          /* c8 ignore next */
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      /**
       *
       * @param {string} name
       */
      get(name) {
        let values2 = this.getAll(name);
        if (values2.length === 0)
          return null;
        let value = values2.join(", ");
        return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
      }
      /**
       * @param {(value: string, key: string, parent: this) => void} callback
       * @param {any} thisArg
       * @returns {void}
       */
      forEach(callback2, thisArg = void 0) {
        for (let name of this.keys())
          if (name.toLowerCase() === "set-cookie") {
            let cookies = this.getAll(name);
            for (; cookies.length > 0; )
              Reflect.apply(callback2, thisArg, [cookies.shift(), name, this]);
          } else
            Reflect.apply(callback2, thisArg, [this.get(name), name, this]);
      }
      /**
       * @returns {IterableIterator<string>}
       */
      *values() {
        for (let name of this.keys())
          if (name.toLowerCase() === "set-cookie") {
            let cookies = this.getAll(name);
            for (; cookies.length > 0; )
              yield (
                /** @type {string} */
                cookies.shift()
              );
          } else
            yield (
              /** @type {string} */
              this.get(name)
            );
      }
      /**
       * @returns {IterableIterator<[string, string]>}
       */
      *entries() {
        for (let name of this.keys())
          if (name.toLowerCase() === "set-cookie") {
            let cookies = this.getAll(name);
            for (; cookies.length > 0; )
              yield [
                name,
                /** @type {string} */
                cookies.shift()
              ];
          } else
            yield [
              name,
              /** @type {string} */
              this.get(name)
            ];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce(
          (result, key) => (result[key] = this.getAll(key), result),
          /** @type {Record<string, string[]>} */
          {}
        );
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce(
          (result, key) => {
            let values2 = this.getAll(key);
            return key === "host" ? result[key] = values2[0] : result[key] = values2.length > 1 ? values2 : values2[0], result;
          },
          /** @type {Record<string, string|string[]>} */
          {}
        );
      }
    };
    Object.defineProperties(
      Headers2.prototype,
      ["get", "entries", "forEach", "values"].reduce(
        (result, property) => (result[property] = { enumerable: !0 }, result),
        /** @type {Record<string, {enumerable:true}>} */
        {}
      )
    );
    function fromRawHeaders(headers = []) {
      return new Headers2(
        headers.reduce(
          (result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result),
          /** @type {string[][]} */
          []
        ).filter(([name, value]) => {
          try {
            return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
          } catch {
            return !1;
          }
        })
      );
    }
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect = (code) => redirectStatus.has(code), INTERNALS$1 = Symbol("Response internals"), Response2 = class extends Body {
      /**
       * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
       * @param {ResponseInit & Ext} [options] - Response options
       */
      constructor(body = null, options = {}) {
        super(body, options);
        let status = options.status || 200, headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType(this);
          contentType && headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter || 0,
          highWaterMark: options.highWaterMark
        };
      }
      /**
       * @type {ResponseType}
       */
      get type() {
        return "default";
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      /**
       * @type {Headers}
       */
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @returns {Response}
       */
      clone() {
        return new Response2(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          size: this.size
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url2, status = 302) {
        if (!isRedirect(status))
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Response2(null, {
          headers: {
            location: new URL(url2).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: !0 },
      status: { enumerable: !0 },
      ok: { enumerable: !0 },
      redirected: { enumerable: !0 },
      statusText: { enumerable: !0 },
      headers: { enumerable: !0 },
      clone: { enumerable: !0 }
    });
    var getSearch = (parsedURL) => {
      if (parsedURL.search)
        return parsedURL.search;
      let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    }, INTERNALS = Symbol("Request internals"), forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]), normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]), isRequest = (object) => typeof object == "object" && typeof object[INTERNALS] == "object", Request2 = class extends Body {
      /**
       * @param {string|Request|URL} info  Url or Request instance
       * @param {RequestInit & RequestExtraOptions} init   Custom options
       */
      constructor(info, init = {}) {
        let parsedURL, settings;
        isRequest(info) ? (parsedURL = new URL(info.url), settings = info) : (parsedURL = new URL(info), settings = {});
        let method = init.method || settings.method || "GET";
        if (forbiddenMethods.has(method.toUpperCase()))
          throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
        normalizedMethods.has(method.toUpperCase()) && (method = method.toUpperCase());
        let inputBody = init.body != null ? init.body : isRequest(info) && info.body !== null ? clone(info) : null;
        if (inputBody != null && (method === "GET" || method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body");
        super(inputBody, {
          size: init.size || settings.size || 0
        });
        let input = settings, headers = (
          /** @type {globalThis.Headers} */
          new Headers2(init.headers || input.headers || {})
        );
        if (inputBody !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType(this);
          contentType && headers.append("Content-Type", contentType);
        }
        let signal = "signal" in init ? init.signal : isRequest(input) ? input.signal : null;
        if (signal != null && !isAbortSignal(signal))
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        if (!signal) {
          let AbortControllerConstructor = typeof AbortController < "u" ? AbortController : abortController.AbortController;
          signal = new AbortControllerConstructor().signal;
        }
        this[INTERNALS] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          credentials: init.credentials || "same-origin",
          parsedURL,
          signal: signal || null
        }, this.keepalive, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1;
      }
      /**
       * @type {RequestCache}
       */
      get cache() {
        return "default";
      }
      /**
       * @type {RequestCredentials}
       */
      get credentials() {
        return this[INTERNALS].credentials;
      }
      /**
       * @type {RequestDestination}
       */
      get destination() {
        return "";
      }
      get integrity() {
        return "";
      }
      /** @type {RequestMode} */
      get mode() {
        return "cors";
      }
      /** @type {string} */
      get referrer() {
        return "";
      }
      /** @type {ReferrerPolicy} */
      get referrerPolicy() {
        return "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      /**
       * @type {string}
       */
      get url() {
        return url.format(this[INTERNALS].parsedURL);
      }
      /**
       * @type {globalThis.Headers}
       */
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      /**
       * @returns {AbortSignal}
       */
      get signal() {
        return this[INTERNALS].signal;
      }
      /**
       * Clone this request
       *
       * @return  {globalThis.Request}
       */
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: !0 },
      url: { enumerable: !0 },
      headers: { enumerable: !0 },
      redirect: { enumerable: !0 },
      clone: { enumerable: !0 },
      signal: { enumerable: !0 }
    });
    var getNodeRequestOptions = (request2) => {
      let { parsedURL } = request2[INTERNALS], headers = new Headers2(request2[INTERNALS].headers);
      headers.has("Accept") || headers.set("Accept", "*/*");
      let contentLengthValue = null;
      if (request2.body === null && /^(post|put)$/i.test(request2.method) && (contentLengthValue = "0"), request2.body !== null) {
        let totalBytes = getTotalBytes(request2);
        typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request2.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate,br");
      let { agent } = request2;
      typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
      let search = getSearch(parsedURL);
      return {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        // @ts-ignore - it does not has a query
        query: parsedURL.query,
        href: parsedURL.href,
        method: request2.method,
        // @ts-ignore - not sure what this supposed to do
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request2.insecureHTTPParser,
        agent
      };
    }, AbortError = class extends FetchBaseError {
      /**
       * @param {string} message 
       * @param {string} [type]
       */
      constructor(message, type = "aborted") {
        super(message, type);
      }
    }, supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
    async function fetch2(url2, options_ = {}) {
      return new Promise((resolve, reject) => {
        let request2 = new Request2(url2, options_), options = getNodeRequestOptions(request2);
        if (!supportedSchemas.has(options.protocol))
          throw new TypeError(`node-fetch cannot load ${url2}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
        if (options.protocol === "data:") {
          let data3 = dataUriToBuffer(request2.url.toString()), response2 = new Response2(data3, { headers: { "Content-Type": data3.typeFull } });
          resolve(response2);
          return;
        }
        if (options.protocol === "file:") {
          let stream = fs.createReadStream(new URL(request2.url)), type = mime.lookup(request2.url) || "application/octet-stream", response2 = new Response2(stream, { headers: { "Content-Type": type } });
          resolve(response2);
          return;
        }
        let send = (options.protocol === "https:" ? https : http).request, { signal } = request2, response = null, response_ = null, abort = () => {
          let error = new AbortError("The operation was aborted.");
          reject(error), request2.body && request2.body.cancel(error), response_ && response_.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        let abortAndFinalize = () => {
          abort(), finalize();
        }, request_ = send(options);
        signal && signal.addEventListener("abort", abortAndFinalize);
        let finalize = () => {
          request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
        };
        request_.on("error", (err) => {
          reject(new FetchError(`request to ${request2.url} failed, reason: ${err.message}`, "system", err)), finalize();
        }), fixResponseChunkedTransferBadEnding(request_, (err) => {
          signal && signal.aborted || response_?.emit("error", err);
        }), parseInt(process.version.substring(1)) < 14 && request_.on("socket", (s) => {
          s.prependListener("close", (hadError) => {
            let hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              let err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_?.emit("error", err);
            }
          });
        }), request_.on("response", (incoming) => {
          response_ = incoming, request_.setTimeout(0);
          let headers = fromRawHeaders(response_.rawHeaders);
          if (isRedirect(Number(response_.statusCode))) {
            let location = headers.get("Location"), locationURL = location === null ? null : new URL(location, request2.url);
            switch (request2.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request2.url}`, "no-redirect")), finalize();
                return;
              case "manual":
                locationURL !== null && headers.set("Location", locationURL.toString());
                break;
              case "follow": {
                if (locationURL === null)
                  break;
                if (request2.counter >= request2.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request2.url}`, "max-redirect")), finalize();
                  return;
                }
                let requestOptions = {
                  headers: new Headers2(request2.headers),
                  follow: request2.follow,
                  counter: request2.counter + 1,
                  agent: request2.agent,
                  compress: request2.compress,
                  method: request2.method,
                  // Note: We can not use `request.body` because send would have
                  // consumed it already.
                  body: options_.body,
                  signal,
                  size: request2.size
                }, isStreamBody = requestOptions.body instanceof webBlob.ReadableStream || requestOptions.body instanceof Stream.Readable;
                if (response_.statusCode !== 303 && isStreamBody) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
                  return;
                }
                (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request2.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), fetch2(new Request2(locationURL.href, requestOptions)).then(resolve, reject), finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request2.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          signal && response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = Stream.pipeline(response_, new Stream.PassThrough(), reject);
          process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
          let responseOptions = {
            url: request2.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request2.size,
            counter: request2.counter,
            highWaterMark: request2.highWaterMark
          }, codings = headers.get("Content-Encoding");
          if (!request2.compress || request2.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response2(body, responseOptions), resolve(response);
            return;
          }
          let zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream.pipeline(body, zlib.createGunzip(zlibOptions), reject), response = new Response2(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            Stream.pipeline(response_, new Stream.PassThrough(), reject).once("data", (chunk) => {
              (chunk[0] & 15) === 8 ? body = Stream.pipeline(body, zlib.createInflate(), reject) : body = Stream.pipeline(body, zlib.createInflateRaw(), reject), response = new Response2(fromAsyncIterable(body), responseOptions), resolve(response);
            });
            return;
          }
          if (codings === "br") {
            body = Stream.pipeline(body, zlib.createBrotliDecompress(), reject), response = new Response2(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          response = new Response2(fromAsyncIterable(body), responseOptions), resolve(response);
        }), writeToStream(request_, request2);
      });
    }
    function fixResponseChunkedTransferBadEnding(request2, errorCallback) {
      let LAST_CHUNK = buffer.Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
      request2.on("response", (response) => {
        let { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      }), request2.on("socket", (socket) => {
        let onSocketClose = () => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            let error = Object.assign(new Error("Premature close"), {
              code: "ERR_STREAM_PREMATURE_CLOSE"
            });
            errorCallback(error);
          }
        }, onData = (buf) => {
          properLastChunkReceived = buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
        };
        socket.prependListener("close", onSocketClose), socket.on("data", onData);
        let removeSocketListeners = () => {
          socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
        };
        request2.on("close", removeSocketListeners), request2.on("abort", removeSocketListeners);
      });
    }
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webBlob.ReadableStream;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: !0,
      get: function() {
        return webFile.File;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFormData.FormData;
      }
    });
    exports.Headers = Headers2;
    exports.Request = Request2;
    exports.Response = Response2;
    exports.default = fetch2;
    exports.fetch = fetch2;
    exports = module.exports = Object.assign(fetch2, exports);
  }
});

// node_modules/@remix-run/node/dist/globals.js
var require_globals = __commonJS({
  "node_modules/@remix-run/node/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function installGlobals({
      nativeFetch
    } = {}) {
      if (nativeFetch) {
        let {
          File: UndiciFile,
          fetch: undiciFetch,
          FormData: UndiciFormData,
          Headers: UndiciHeaders,
          Request: UndiciRequest,
          Response: UndiciResponse
        } = __require("undici");
        global.File = UndiciFile, global.Headers = UndiciHeaders, global.Request = UndiciRequest, global.Response = UndiciResponse, global.fetch = undiciFetch, global.FormData = UndiciFormData;
      } else {
        let {
          File: RemixFile,
          fetch: RemixFetch,
          FormData: RemixFormData,
          Headers: RemixHeaders,
          Request: RemixRequest,
          Response: RemixResponse
        } = require_lib_node4();
        global.File = RemixFile, global.Headers = RemixHeaders, global.Request = RemixRequest, global.Response = RemixResponse, global.fetch = RemixFetch, global.FormData = RemixFormData;
      }
    }
    exports.installGlobals = installGlobals;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/warnings.js
function warnOnce(condition, message) {
  !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
}
var alreadyWarned, init_warnings = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/warnings.js"() {
    alreadyWarned = {};
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/cookies.js
import { parse, serialize } from "cookie";
async function encodeCookieValue(sign, value, secrets) {
  let encoded = encodeData(value);
  return secrets.length > 0 && (encoded = await sign(encoded, secrets[0])), encoded;
}
async function decodeCookieValue(unsign, value, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value, secret);
      if (unsignedValue !== !1)
        return decodeData(unsignedValue);
    }
    return null;
  }
  return decodeData(value);
}
function encodeData(value) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
}
function decodeData(value) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value))));
  } catch {
    return {};
  }
}
function myEscape(value) {
  let str = value.toString(), result = "", index = 0, chr, code;
  for (; index < str.length; )
    chr = str.charAt(index++), /[\w*+\-./@]/.exec(chr) ? result += chr : (code = chr.charCodeAt(0), code < 256 ? result += "%" + hex(code, 2) : result += "%u" + hex(code, 4).toUpperCase());
  return result;
}
function hex(code, length) {
  let result = code.toString(16);
  for (; result.length < length; )
    result = "0" + result;
  return result;
}
function myUnescape(value) {
  let str = value.toString(), result = "", index = 0, chr, part;
  for (; index < str.length; ) {
    if (chr = str.charAt(index++), chr === "%") {
      if (str.charAt(index) === "u") {
        if (part = str.slice(index + 1, index + 5), /^[\da-f]{4}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16)), index += 5;
          continue;
        }
      } else if (part = str.slice(index, index + 2), /^[\da-f]{2}$/i.exec(part)) {
        result += String.fromCharCode(parseInt(part, 16)), index += 2;
        continue;
      }
    }
    result += chr;
  }
  return result;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
}
var createCookieFactory, isCookie, init_cookies = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/cookies.js"() {
    init_warnings();
    createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets = [],
        ...options
      } = {
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge < "u" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = parse(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/formData.js
import { streamMultipart } from "@web3-storage/multipart-parser";
function composeUploadHandlers(...handlers) {
  return async (part) => {
    for (let handler of handlers) {
      let value = await handler(part);
      if (typeof value < "u" && value !== null)
        return value;
    }
  };
}
async function parseMultipartFormData(request2, uploadHandler) {
  let contentType = request2.headers.get("Content-Type") || "", [type, boundary2] = contentType.split(/\s*;\s*boundary=/);
  if (!request2.body || !boundary2 || type !== "multipart/form-data")
    throw new TypeError("Could not parse content as FormData.");
  let formData = new FormData(), parts = streamMultipart(request2.body, boundary2);
  for await (let part of parts) {
    if (part.done)
      break;
    typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
    let value = await uploadHandler(part);
    typeof value < "u" && value !== null && formData.append(part.name, value);
  }
  return formData;
}
var init_formData = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/formData.js"() {
  }
});

// node_modules/@remix-run/router/dist/router.js
var router_exports = {};
__export(router_exports, {
  AbortedDeferredError: () => AbortedDeferredError,
  Action: () => Action,
  IDLE_BLOCKER: () => IDLE_BLOCKER,
  IDLE_FETCHER: () => IDLE_FETCHER,
  IDLE_NAVIGATION: () => IDLE_NAVIGATION,
  UNSAFE_DEFERRED_SYMBOL: () => UNSAFE_DEFERRED_SYMBOL,
  UNSAFE_DeferredData: () => DeferredData,
  UNSAFE_ErrorResponseImpl: () => ErrorResponseImpl,
  UNSAFE_convertRouteMatchToUiMatch: () => convertRouteMatchToUiMatch,
  UNSAFE_convertRoutesToDataRoutes: () => convertRoutesToDataRoutes,
  UNSAFE_decodePath: () => decodePath,
  UNSAFE_getResolveToMatches: () => getResolveToMatches,
  UNSAFE_invariant: () => invariant,
  UNSAFE_warning: () => warning,
  createBrowserHistory: () => createBrowserHistory,
  createHashHistory: () => createHashHistory,
  createMemoryHistory: () => createMemoryHistory,
  createPath: () => createPath,
  createRouter: () => createRouter,
  createStaticHandler: () => createStaticHandler,
  data: () => data,
  defer: () => defer,
  generatePath: () => generatePath,
  getStaticContextFromError: () => getStaticContextFromError,
  getToPathname: () => getToPathname,
  isDataWithResponseInit: () => isDataWithResponseInit,
  isDeferredData: () => isDeferredData,
  isRouteErrorResponse: () => isRouteErrorResponse,
  joinPaths: () => joinPaths,
  json: () => json,
  matchPath: () => matchPath,
  matchRoutes: () => matchRoutes,
  normalizePathname: () => normalizePathname,
  parsePath: () => parsePath,
  redirect: () => redirect,
  redirectDocument: () => redirectDocument,
  replace: () => replace,
  resolvePath: () => resolvePath,
  resolveTo: () => resolveTo,
  stripBasename: () => stripBasename
});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
function createMemoryHistory(options) {
  options === void 0 && (options = {});
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = !1
  } = options, entries;
  entries = initialEntries.map((entry2, index2) => createMemoryLocation(entry2, typeof entry2 == "string" ? null : entry2.state, index2 === 0 ? "default" : void 0));
  let index = clampIndex(initialIndex ?? entries.length - 1), action8 = Action.Pop, listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state, key) {
    state === void 0 && (state = null);
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    return warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to)), location;
  }
  function createHref(to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return {
    get index() {
      return index;
    },
    get action() {
      return action8;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref,
    createURL(to) {
      return new URL(createHref(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to == "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action8 = Action.Push;
      let nextLocation = createMemoryLocation(to, state);
      index += 1, entries.splice(index, entries.length, nextLocation), v5Compat && listener && listener({
        action: action8,
        location: nextLocation,
        delta: 1
      });
    },
    replace(to, state) {
      action8 = Action.Replace;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation, v5Compat && listener && listener({
        action: action8,
        location: nextLocation,
        delta: 0
      });
    },
    go(delta) {
      action8 = Action.Pop;
      let nextIndex = clampIndex(index + delta), nextLocation = entries[nextIndex];
      index = nextIndex, listener && listener({
        action: action8,
        location: nextLocation,
        delta
      });
    },
    listen(fn) {
      return listener = fn, () => {
        listener = null;
      };
    }
  };
}
function createBrowserHistory(options) {
  options === void 0 && (options = {});
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createHashHistory(options) {
  options === void 0 && (options = {});
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substr(1));
    return !pathname.startsWith("/") && !pathname.startsWith(".") && (pathname = "/" + pathname), createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base"), href = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href, hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to == "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === !1 || value === null || typeof value > "u")
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    typeof console < "u" && console.warn(message);
    try {
      throw new Error(message);
    } catch {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state, key) {
  return state === void 0 && (state = null), _extends({
    pathname: typeof current == "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to == "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
    let searchIndex = path.indexOf("?");
    searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  options === void 0 && (options = {});
  let {
    window: window2 = document.defaultView,
    v5Compat = !1
  } = options, globalHistory = window2.history, action8 = Action.Pop, listener = null, index = getIndex();
  index == null && (index = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {
    idx: index
  }), ""));
  function getIndex() {
    return (globalHistory.state || {
      idx: null
    }).idx;
  }
  function handlePop() {
    action8 = Action.Pop;
    let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex, listener && listener({
      action: action8,
      location: history.location,
      delta
    });
  }
  function push(to, state) {
    action8 = Action.Push;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to), index = getIndex() + 1;
    let historyState = getHistoryState(location, index), url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError")
        throw error;
      window2.location.assign(url);
    }
    v5Compat && listener && listener({
      action: action8,
      location: history.location,
      delta: 1
    });
  }
  function replace3(to, state) {
    action8 = Action.Replace;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to), index = getIndex();
    let historyState = getHistoryState(location, index), url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
      action: action8,
      location: history.location,
      delta: 0
    });
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href, href = typeof to == "string" ? to : createPath(to);
    return href = href.replace(/ $/, "%20"), invariant(base, "No window.location.(origin|href) available to create URL for href: " + href), new URL(href, base);
  }
  let history = {
    get action() {
      return action8;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener)
        throw new Error("A history only accepts one active listener");
      return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
        window2.removeEventListener(PopStateEventType, handlePop), listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace3,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
function isIndexRoute(route) {
  return route.index === !0;
}
function convertRoutesToDataRoutes(routes2, mapRouteProperties2, parentPath, manifest) {
  return parentPath === void 0 && (parentPath = []), manifest === void 0 && (manifest = {}), routes2.map((route, index) => {
    let treePath = [...parentPath, String(index)], id = typeof route.id == "string" ? route.id : treePath.join("-");
    if (invariant(route.index !== !0 || !route.children, "Cannot specify children on an index route"), invariant(!manifest[id], 'Found a route id collision on id "' + id + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(route)) {
      let indexRoute = _extends({}, route, mapRouteProperties2(route), {
        id
      });
      return manifest[id] = indexRoute, indexRoute;
    } else {
      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties2(route), {
        id,
        children: void 0
      });
      return manifest[id] = pathOrLayoutRoute, route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest)), pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes2, locationArg, basename) {
  return basename === void 0 && (basename = "/"), matchRoutesImpl(routes2, locationArg, basename, !1);
}
function matchRoutesImpl(routes2, locationArg, basename, allowPartial) {
  let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null)
    return null;
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i = 0; matches2 == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches2 = matchRouteBranch(branches[i], decoded, allowPartial);
  }
  return matches2;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = "");
  let flattenRoute = (route, index, relativePath) => {
    let meta2 = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === !0,
      childrenIndex: index,
      route
    };
    meta2.relativePath.startsWith("/") && (invariant(meta2.relativePath.startsWith(parentPath), 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta2.relativePath = meta2.relativePath.slice(parentPath.length));
    let path = joinPaths([parentPath, meta2.relativePath]), routesMeta = parentsMeta.concat(meta2);
    route.children && route.children.length > 0 && (invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
    ), flattenRoutes(route.children, branches, routesMeta, path)), !(route.path == null && !route.index) && branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  return routes2.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?")))
      flattenRoute(route, index);
    else
      for (let exploded of explodeOptionalSegments(route.path))
        flattenRoute(route, index, exploded);
  }), branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments, isOptional = first.endsWith("?"), required = first.replace(/\?$/, "");
  if (rest.length === 0)
    return isOptional ? [required, ""] : [required];
  let restExploded = explodeOptionalSegments(rest.join("/")), result = [];
  return result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/"))), isOptional && result.push(...restExploded), result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
function computeScore(path, index) {
  let segments = path.split("/"), initialScore = segments.length;
  return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  return a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  allowPartial === void 0 && (allowPartial = !1);
  let {
    routesMeta
  } = branch, matchedParams = {}, matchedPathname = "/", matches2 = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i], end = i === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname), route = meta2.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index && (match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end: !1
    }, remainingPathname)), !match)
      return null;
    Object.assign(matchedParams, match.params), matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
  }
  return matches2;
}
function generatePath(originalPath, params) {
  params === void 0 && (params = {});
  let path = originalPath;
  path.endsWith("*") && path !== "*" && !path.endsWith("/*") && (warning(!1, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')), path = path.replace(/\*$/, "/*"));
  let prefix = path.startsWith("/") ? "/" : "", stringify = (p) => p == null ? "" : typeof p == "string" ? p : String(p), segments = path.split(/\/+/).map((segment, index, array) => {
    if (index === array.length - 1 && segment === "*")
      return stringify(params["*"]);
    let keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      let [, key, optional] = keyMatch, param = params[key];
      return invariant(optional === "?" || param != null, 'Missing ":' + key + '" param'), stringify(param);
    }
    return segment.replace(/\?$/g, "");
  }).filter((segment) => !!segment);
  return prefix + segments.join("/");
}
function matchPath(pattern, pathname) {
  typeof pattern == "string" && (pattern = {
    path: pattern,
    caseSensitive: !1,
    end: !0
  });
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
  return {
    params: compiledParams.reduce((memo7, _ref, index) => {
      let {
        paramName,
        isOptional
      } = _ref;
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      let value = captureGroups[index];
      return isOptional && !value ? memo7[paramName] = void 0 : memo7[paramName] = (value || "").replace(/%2F/g, "/"), memo7;
    }, {}),
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  caseSensitive === void 0 && (caseSensitive = !1), end === void 0 && (end = !0), warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => (params.push({
    paramName,
    isOptional: isOptional != null
  }), isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return path.endsWith("*") ? (params.push({
    paramName: "*"
  }), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    return warning(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ").")), value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
    return null;
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
  return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  fromPathname === void 0 && (fromPathname = "/");
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to == "string" ? parsePath(to) : to;
  return {
    pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  return relativePath.split("/").forEach((segment) => {
    segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
  }), segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches2) {
  return matches2.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches2, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches2);
  return v7_relativeSplatPath ? pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase) : pathMatches.map((match) => match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  isPathRelative === void 0 && (isPathRelative = !1);
  let to;
  typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
  let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from;
  if (toPathname == null)
    from = locationPathname;
  else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      for (; toSegments[0] === ".."; )
        toSegments.shift(), routePathnameIndex -= 1;
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
}
function data(data3, init) {
  return new DataWithResponseInit(data3, typeof init == "number" ? {
    status: init
  } : init);
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === !0;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value))
    return value;
  if (value._error)
    throw value._error;
  return value._data;
}
function isRouteErrorResponse(error) {
  return error != null && typeof error.status == "number" && typeof error.statusText == "string" && typeof error.internal == "boolean" && "data" in error;
}
function createRouter(init) {
  let routerWindow = init.window ? init.window : typeof window < "u" ? window : void 0, isBrowser2 = typeof routerWindow < "u" && typeof routerWindow.document < "u" && typeof routerWindow.document.createElement < "u", isServer2 = !isBrowser2;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init.mapRouteProperties)
    mapRouteProperties2 = init.mapRouteProperties;
  else if (init.detectErrorBoundary) {
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else
    mapRouteProperties2 = defaultMapRouteProperties;
  let manifest = {}, dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest), inFlightDataRoutes, basename = init.basename || "/", dataStrategyImpl = init.dataStrategy || defaultDataStrategy, patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation, future2 = _extends({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, init.future), unlistenHistory = null, subscribers = /* @__PURE__ */ new Set(), savedScrollPositions2 = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = init.hydrationData != null, initialMatches = matchRoutes(dataRoutes, init.history.location, basename), initialMatchesIsFOW = !1, initialErrors = null;
  if (initialMatches == null && !patchRoutesOnNavigationImpl) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    }), {
      matches: matches2,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches2, initialErrors = {
      [route.id]: error
    };
  }
  initialMatches && !init.hydrationData && checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname).active && (initialMatches = null);
  let initialized;
  if (initialMatches)
    if (initialMatches.some((m) => m.route.lazy))
      initialized = !1;
    else if (!initialMatches.some((m) => m.route.loader))
      initialized = !0;
    else if (future2.v7_partialHydration) {
      let loaderData = init.hydrationData ? init.hydrationData.loaderData : null, errors = init.hydrationData ? init.hydrationData.errors : null;
      if (errors) {
        let idx = initialMatches.findIndex((m) => errors[m.route.id] !== void 0);
        initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
      } else
        initialized = initialMatches.every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    } else
      initialized = init.hydrationData != null;
  else if (initialized = !1, initialMatches = [], future2.v7_partialHydration) {
    let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);
    fogOfWar.active && fogOfWar.matches && (initialMatchesIsFOW = !0, initialMatches = fogOfWar.matches);
  }
  let router, state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, pendingAction = Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, pendingViewTransitionEnabled = !1, appliedViewTransitions = /* @__PURE__ */ new Map(), removePageHideEventListener = null, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = /* @__PURE__ */ new Set(), fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), fetchLoadMatches = /* @__PURE__ */ new Map(), activeFetchers = /* @__PURE__ */ new Map(), deletedFetchers = /* @__PURE__ */ new Set(), activeDeferreds = /* @__PURE__ */ new Map(), blockerFunctions = /* @__PURE__ */ new Map(), unblockBlockerHistoryUpdate;
  function initialize() {
    if (unlistenHistory = init.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (unblockBlockerHistoryUpdate) {
        unblockBlockerHistoryUpdate(), unblockBlockerHistoryUpdate = void 0;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        let nextHistoryUpdatePromise = new Promise((resolve) => {
          unblockBlockerHistoryUpdate = resolve;
        });
        init.history.go(delta * -1), updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            }), nextHistoryUpdatePromise.then(() => init.history.go(delta));
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER), updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    }), isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions), removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    return state.initialized || startNavigation(Action.Pop, state.location, {
      initialHydration: !0
    }), router;
  }
  function dispose() {
    unlistenHistory && unlistenHistory(), removePageHideEventListener && removePageHideEventListener(), subscribers.clear(), pendingNavigationController && pendingNavigationController.abort(), state.fetchers.forEach((_, key) => deleteFetcher(key)), state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  function subscribe(fn) {
    return subscribers.add(fn), () => subscribers.delete(fn);
  }
  function updateState(newState, opts) {
    opts === void 0 && (opts = {}), state = _extends({}, state, newState);
    let completedFetchers = [], deletedFetchersKeys = [];
    future2.v7_fetcherPersist && state.fetchers.forEach((fetcher, key) => {
      fetcher.state === "idle" && (deletedFetchers.has(key) ? deletedFetchersKeys.push(key) : completedFetchers.push(key));
    }), deletedFetchers.forEach((key) => {
      !state.fetchers.has(key) && !fetchControllers.has(key) && deletedFetchersKeys.push(key);
    }), [...subscribers].forEach((subscriber) => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      viewTransitionOpts: opts.viewTransitionOpts,
      flushSync: opts.flushSync === !0
    })), future2.v7_fetcherPersist ? (completedFetchers.forEach((key) => state.fetchers.delete(key)), deletedFetchersKeys.forEach((key) => deleteFetcher(key))) : deletedFetchersKeys.forEach((key) => deletedFetchers.delete(key));
  }
  function completeNavigation(location, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp, isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== !0, actionData;
    newState.actionData ? Object.keys(newState.actionData).length > 0 ? actionData = newState.actionData : actionData = null : isActionReload ? actionData = state.actionData : actionData = null;
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData, blockers = state.blockers;
    blockers.size > 0 && (blockers = new Map(blockers), blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER)));
    let preventScrollReset = pendingPreventScrollReset === !0 || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== !0;
    inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0), isUninterruptedRevalidation || pendingAction === Action.Pop || (pendingAction === Action.Push ? init.history.push(location, location.state) : pendingAction === Action.Replace && init.history.replace(location, location.state));
    let viewTransitionOpts;
    if (pendingAction === Action.Pop) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      priorPaths && priorPaths.has(location.pathname) ? viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      } : appliedViewTransitions.has(location.pathname) && (viewTransitionOpts = {
        currentLocation: location,
        nextLocation: state.location
      });
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      toPaths ? toPaths.add(location.pathname) : (toPaths = /* @__PURE__ */ new Set([location.pathname]), appliedViewTransitions.set(state.location.pathname, toPaths)), viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState(_extends({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: !0,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === !0
    }), pendingAction = Action.Pop, pendingPreventScrollReset = !1, pendingViewTransitionEnabled = !1, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [];
  }
  async function navigate(to, opts) {
    if (typeof to == "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, to, future2.v7_relativeSplatPath, opts?.fromRouteId, opts?.relative), {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !1, normalizedPath, opts), currentLocation = state.location, nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = Action.Push;
    userReplace === !0 ? historyAction = Action.Replace : userReplace === !1 || submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = Action.Replace);
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === !0 : void 0, flushSync = (opts && opts.flushSync) === !0, blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          }), navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER), updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync
    });
  }
  function revalidate() {
    if (interruptActiveLoads(), updateState({
      revalidation: "loading"
    }), state.navigation.state !== "submitting") {
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      startNavigation(pendingAction || state.historyAction, state.navigation.location, {
        overrideNavigation: state.navigation,
        // Proxy through any rending view transition
        enableViewTransition: pendingViewTransitionEnabled === !0
      });
    }
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort(), pendingNavigationController = null, pendingAction = historyAction, isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0, saveScrollPosition(state.location, state.matches), pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0, pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === !0;
    let routesToUse = inFlightDataRoutes || dataRoutes, loadingNavigation = opts && opts.overrideNavigation, matches2 = opts != null && opts.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      state.matches
    ) : matchRoutes(routesToUse, location, basename), flushSync = (opts && opts.flushSync) === !0;
    if (matches2 && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches: matches2
      }, {
        flushSync
      });
      return;
    }
    let fogOfWar = checkFogOfWar(matches2, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches && (matches2 = fogOfWar.matches), !matches2) {
      let {
        error,
        notFoundMatches,
        route
      } = handleNavigational404(location.pathname);
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request2 = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission), pendingActionResult;
    if (opts && opts.pendingError)
      pendingActionResult = [findNearestBoundary(matches2).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(request2, location, opts.submission, matches2, fogOfWar.active, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited)
        return;
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null, completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches2 = actionResult.matches || matches2, pendingActionResult = actionResult.pendingActionResult, loadingNavigation = getLoadingNavigation(location, opts.submission), flushSync = !1, fogOfWar.active = !1, request2 = createClientSideRequest(init.history, request2.url, request2.signal);
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(request2, location, matches2, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === !0, flushSync, pendingActionResult);
    shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({
      matches: updatedMatches || matches2
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    })));
  }
  async function handleAction(request2, location, submission, matches2, isFogOfWar, opts) {
    opts === void 0 && (opts = {}), interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    if (updateState({
      navigation
    }, {
      flushSync: opts.flushSync === !0
    }), isFogOfWar) {
      let discoverResult = await discoverRoutes(matches2, location.pathname, request2.signal);
      if (discoverResult.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, {
            type: ResultType.error,
            error: discoverResult.error
          }]
        };
      } else if (discoverResult.matches)
        matches2 = discoverResult.matches;
      else {
        let {
          notFoundMatches,
          error,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          pendingActionResult: [route.id, {
            type: ResultType.error,
            error
          }]
        };
      }
    }
    let result, actionMatch = getTargetMatch(matches2, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy)
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request2.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    else if (result = (await callDataStrategy("action", state, request2, [actionMatch], matches2, null))[actionMatch.route.id], request2.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (isRedirectResult(result)) {
      let replace3;
      return opts && opts.replace != null ? replace3 = opts.replace : replace3 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request2.url), basename) === state.location.pathname + state.location.search, await startRedirectNavigation(request2, result, !0, {
        submission,
        replace: replace3
      }), {
        shortCircuited: !0
      };
    }
    if (isDeferredResult(result))
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches2, actionMatch.route.id);
      return (opts && opts.replace) !== !0 && (pendingAction = Action.Push), {
        matches: matches2,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches: matches2,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request2, location, matches2, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace3, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission), activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation), shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future2.v7_partialHydration || !initialHydration);
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(_extends({
          navigation: loadingNavigation
        }, actionData !== void 0 ? {
          actionData
        } : {}), {
          flushSync
        });
      }
      let discoverResult = await discoverRoutes(matches2, location.pathname, request2.signal);
      if (discoverResult.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (discoverResult.matches)
        matches2 = discoverResult.matches;
      else {
        let {
          error,
          notFoundMatches,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes, [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches2, activeSubmission, location, future2.v7_partialHydration && initialHydration === !0, future2.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    if (cancelActiveDeferreds((routeId) => !(matches2 && matches2.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId)), pendingNavigationLoadId = ++incrementingLoadId, matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      return completeNavigation(location, _extends({
        matches: matches2,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      }), {
        shortCircuited: !0
      };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        actionData !== void 0 && (updates.actionData = actionData);
      }
      revalidatingFetchers.length > 0 && (updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers)), updateState(updates, {
        flushSync
      });
    }
    revalidatingFetchers.forEach((rf) => {
      abortFetcher(rf.key), rf.controller && fetchControllers.set(rf.key, rf.controller);
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
    pendingNavigationController && pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches2, matchesToLoad, revalidatingFetchers, request2);
    if (request2.signal.aborted)
      return {
        shortCircuited: !0
      };
    pendingNavigationController && pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations), revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
    let redirect4 = findRedirect(loaderResults);
    if (redirect4)
      return await startRedirectNavigation(request2, redirect4.result, !0, {
        replace: replace3
      }), {
        shortCircuited: !0
      };
    if (redirect4 = findRedirect(fetcherResults), redirect4)
      return fetchRedirectIds.add(redirect4.key), await startRedirectNavigation(request2, redirect4.result, !0, {
        replace: replace3
      }), {
        shortCircuited: !0
      };
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches2, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        (aborted || deferredData.done) && activeDeferreds.delete(routeId);
      });
    }), future2.v7_partialHydration && initialHydration && state.errors && (errors = _extends({}, state.errors, errors));
    let updatedFetchers = markFetchRedirectsDone(), didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId), shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends({
      matches: matches2,
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1]))
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    if (state.actionData)
      return Object.keys(state.actionData).length === 0 ? null : state.actionData;
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    return revalidatingFetchers.forEach((rf) => {
      let fetcher = state.fetchers.get(rf.key), revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
      state.fetchers.set(rf.key, revalidatingFetcher);
    }), new Map(state.fetchers);
  }
  function fetch2(key, routeId, href, opts) {
    if (isServer2)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    abortFetcher(key);
    let flushSync = (opts && opts.flushSync) === !0, routesToUse = inFlightDataRoutes || dataRoutes, normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, href, future2.v7_relativeSplatPath, routeId, opts?.relative), matches2 = matchRoutes(routesToUse, normalizedPath, basename), fogOfWar = checkFogOfWar(matches2, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches && (matches2 = fogOfWar.matches), !matches2) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !0, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches2, path), preventScrollReset = (opts && opts.preventScrollReset) === !0;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches2, fogOfWar.active, flushSync, preventScrollReset, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    }), handleFetcherLoader(key, routeId, path, match, matches2, fogOfWar.active, flushSync, preventScrollReset, submission);
  }
  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
    interruptActiveLoads(), fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        return setFetcherError(key, routeId, error, {
          flushSync
        }), !0;
      }
      return !1;
    }
    if (!isFogOfWar && detectAndHandle405Error(match))
      return;
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(requestMatches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted")
        return;
      if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (discoverResult.matches) {
        if (requestMatches = discoverResult.matches, match = getTargetMatch(requestMatches, path), detectAndHandle405Error(match))
          return;
      } else {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId, actionResult = (await callDataStrategy("action", state, fetchRequest, [match], requestMatches, key))[match.route.id];
    if (fetchRequest.signal.aborted) {
      fetchControllers.get(key) === abortController && fetchControllers.delete(key);
      return;
    }
    if (future2.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult))
        if (fetchControllers.delete(key), pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else
          return fetchRedirectIds.add(key), updateFetcherState(key, getLoadingFetcher(submission)), startRedirectNavigation(fetchRequest, actionResult, !1, {
            fetcherSubmission: submission,
            preventScrollReset
          });
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult))
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    let nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal), routesToUse = inFlightDataRoutes || dataRoutes, matches2 = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches2, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches2, submission, nextLocation, !1, future2.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);
    revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
      let staleKey = rf.key, existingFetcher2 = state.fetchers.get(staleKey), revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher), abortFetcher(staleKey), rf.controller && fetchControllers.set(staleKey, rf.controller);
    }), updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches2, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted)
      return;
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations), fetchReloadIds.delete(key), fetchControllers.delete(key), revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
    let redirect4 = findRedirect(loaderResults);
    if (redirect4)
      return startRedirectNavigation(revalidationRequest, redirect4.result, !1, {
        preventScrollReset
      });
    if (redirect4 = findRedirect(fetcherResults), redirect4)
      return fetchRedirectIds.add(redirect4.key), startRedirectNavigation(revalidationRequest, redirect4.result, !1, {
        preventScrollReset
      });
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches2, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId), state.navigation.state === "loading" && loadId > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {
      matches: matches2,
      loaderData,
      errors,
      fetchers: new Map(state.fetchers)
    })) : (updateState({
      errors,
      loaderData: mergeLoaderData(state.loaderData, loaderData, matches2, errors),
      fetchers: new Map(state.fetchers)
    }), isRevalidationRequired = !1);
  }
  async function handleFetcherLoader(key, routeId, path, match, matches2, isFogOfWar, flushSync, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync
    });
    let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches2, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted")
        return;
      if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (discoverResult.matches)
        matches2 = discoverResult.matches, match = getTargetMatch(matches2, path);
      else {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId, result = (await callDataStrategy("loader", state, fetchRequest, [match], matches2, key))[match.route.id];
    if (isDeferredResult(result) && (result = await resolveDeferredData(result, fetchRequest.signal, !0) || result), fetchControllers.get(key) === abortController && fetchControllers.delete(key), !fetchRequest.signal.aborted) {
      if (deletedFetchers.has(key)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
      if (isRedirectResult(result))
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key), await startRedirectNavigation(fetchRequest, result, !1, {
            preventScrollReset
          });
          return;
        }
      if (isErrorResult(result)) {
        setFetcherError(key, routeId, result.error);
        return;
      }
      invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"), updateFetcherState(key, getDoneFetcher(result.data));
    }
  }
  async function startRedirectNavigation(request2, redirect4, isNavigation, _temp2) {
    let {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace: replace3
    } = _temp2 === void 0 ? {} : _temp2;
    redirect4.response.headers.has("X-Remix-Revalidate") && (isRevalidationRequired = !0);
    let location = redirect4.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response"), location = normalizeRedirectLocation(location, new URL(request2.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: !0
    });
    if (isBrowser2) {
      let isDocumentReload = !1;
      if (redirect4.response.headers.has("X-Remix-Reload-Document"))
        isDocumentReload = !0;
      else if (ABSOLUTE_URL_REGEX.test(location)) {
        let url = init.history.createURL(location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        replace3 ? routerWindow.location.replace(location) : routerWindow.location.assign(location);
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace3 === !0 || redirect4.response.headers.has("X-Remix-Replace") ? Action.Replace : Action.Push, {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    !submission && !fetcherSubmission && formMethod && formAction && formEncType && (submission = getSubmissionFromNavigation(state.navigation));
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect4.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod))
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends({}, activeSubmission, {
          formAction: location
        }),
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, state2, request2, matchesToLoad, matches2, fetcherKey) {
    let results, dataResults = {};
    try {
      results = await callDataStrategyImpl(dataStrategyImpl, type, state2, request2, matchesToLoad, matches2, fetcherKey, manifest, mapRouteProperties2);
    } catch (e) {
      return matchesToLoad.forEach((m) => {
        dataResults[m.route.id] = {
          type: ResultType.error,
          error: e
        };
      }), dataResults;
    }
    for (let [routeId, result] of Object.entries(results))
      if (isRedirectDataStrategyResultResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: ResultType.redirect,
          response: normalizeRelativeRoutingRedirectResponse(response, request2, routeId, matches2, basename, future2.v7_relativeSplatPath)
        };
      } else
        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(state2, matches2, matchesToLoad, fetchersToLoad, request2) {
    let currentMatches = state2.matches, loaderResultsPromise = callDataStrategy("loader", state2, request2, matchesToLoad, matches2, null), fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f) => {
      if (f.matches && f.match && f.controller) {
        let result = (await callDataStrategy("loader", state2, createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, f.key))[f.match.route.id];
        return {
          [f.key]: result
        };
      } else
        return Promise.resolve({
          [f.key]: {
            type: ResultType.error,
            error: getInternalRouterError(404, {
              pathname: f.path
            })
          }
        });
    })), loaderResults = await loaderResultsPromise, fetcherResults = (await fetcherResultsPromise).reduce((acc, r) => Object.assign(acc, r), {});
    return await Promise.all([resolveNavigationDeferredResults(matches2, loaderResults, request2.signal, currentMatches, state2.loaderData), resolveFetcherDeferredResults(matches2, fetcherResults, fetchersToLoad)]), {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = !0, cancelledDeferredRoutes.push(...cancelActiveDeferreds()), fetchLoadMatches.forEach((_, key) => {
      fetchControllers.has(key) && cancelledFetcherLoads.add(key), abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    opts === void 0 && (opts = {}), state.fetchers.set(key, fetcher), updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === !0
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    opts === void 0 && (opts = {});
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key), updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === !0
    });
  }
  function getFetcher(key) {
    return activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1), deletedFetchers.has(key) && deletedFetchers.delete(key), state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key)) && abortFetcher(key), fetchLoadMatches.delete(key), fetchReloadIds.delete(key), fetchRedirectIds.delete(key), future2.v7_fetcherPersist && deletedFetchers.delete(key), cancelledFetcherLoads.delete(key), state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    let count = (activeFetchers.get(key) || 0) - 1;
    count <= 0 ? (activeFetchers.delete(key), deletedFetchers.add(key), future2.v7_fetcherPersist || deleteFetcher(key)) : activeFetchers.set(key, count), updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    controller && (controller.abort(), fetchControllers.delete(key));
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key), doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [], updatedFetchers = !1;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key), fetcher.state === "loading" && (fetchRedirectIds.delete(key), doneKeys.push(key), updatedFetchers = !0);
    }
    return markFetchersDone(doneKeys), updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds)
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key), fetcher.state === "loading" && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
      }
    return markFetchersDone(yeetedKeys), yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    return blockerFunctions.get(key) !== fn && blockerFunctions.set(key, fn), blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key), blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker), updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0)
      return;
    blockerFunctions.size > 1 && warning(!1, "A router only supports one blocker at a time");
    let entries = Array.from(blockerFunctions.entries()), [blockerKey, blockerFunction] = entries[entries.length - 1], blocker = state.blockers.get(blockerKey);
    if (!(blocker && blocker.state === "proceeding") && blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    }))
      return blockerKey;
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, {
      pathname
    }), routesToUse = inFlightDataRoutes || dataRoutes, {
      matches: matches2,
      route
    } = getShortCircuitMatches(routesToUse);
    return cancelActiveDeferreds(), {
      notFoundMatches: matches2,
      route,
      error
    };
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    return activeDeferreds.forEach((dfd, routeId) => {
      (!predicate || predicate(routeId)) && (dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId));
    }), cancelledRouteIds;
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    if (savedScrollPositions2 = positions, getScrollPosition = getPosition, getScrollRestorationKey = getKey || null, !initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = !0;
      let y = getSavedScrollPosition(state.location, state.matches);
      y != null && updateState({
        restoreScrollPosition: y
      });
    }
    return () => {
      savedScrollPositions2 = null, getScrollPosition = null, getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches2) {
    return getScrollRestorationKey && getScrollRestorationKey(location, matches2.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))) || location.key;
  }
  function saveScrollPosition(location, matches2) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key = getScrollKey(location, matches2);
      savedScrollPositions2[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches2) {
    if (savedScrollPositions2) {
      let key = getScrollKey(location, matches2), y = savedScrollPositions2[key];
      if (typeof y == "number")
        return y;
    }
    return null;
  }
  function checkFogOfWar(matches2, routesToUse, pathname) {
    if (patchRoutesOnNavigationImpl)
      if (matches2) {
        if (Object.keys(matches2[0].params).length > 0)
          return {
            active: !0,
            matches: matchRoutesImpl(routesToUse, pathname, basename, !0)
          };
      } else
        return {
          active: !0,
          matches: matchRoutesImpl(routesToUse, pathname, basename, !0) || []
        };
    return {
      active: !1,
      matches: null
    };
  }
  async function discoverRoutes(matches2, pathname, signal, fetcherKey) {
    if (!patchRoutesOnNavigationImpl)
      return {
        type: "success",
        matches: matches2
      };
    let partialMatches = matches2;
    for (; ; ) {
      let isNonHMR = inFlightDataRoutes == null, routesToUse = inFlightDataRoutes || dataRoutes, localManifest = manifest;
      try {
        await patchRoutesOnNavigationImpl({
          signal,
          path: pathname,
          matches: partialMatches,
          fetcherKey,
          patch: (routeId, children) => {
            signal.aborted || patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
          }
        });
      } catch (e) {
        return {
          type: "error",
          error: e,
          partialMatches
        };
      } finally {
        isNonHMR && !signal.aborted && (dataRoutes = [...dataRoutes]);
      }
      if (signal.aborted)
        return {
          type: "aborted"
        };
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches)
        return {
          type: "success",
          matches: newMatches
        };
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, !0);
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i) => m.route.id === newPartialMatches[i].route.id))
        return {
          type: "success",
          matches: null
        };
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {}, inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    patchRoutesImpl(routeId, children, inFlightDataRoutes || dataRoutes, manifest, mapRouteProperties2), isNonHMR && (dataRoutes = [...dataRoutes], updateState({}));
  }
  return router = {
    get basename() {
      return basename;
    },
    get future() {
      return future2;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    encodeLocation: (to) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  }, router;
}
function createStaticHandler(routes2, opts) {
  invariant(routes2.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {}, basename = (opts ? opts.basename : null) || "/", mapRouteProperties2;
  if (opts != null && opts.mapRouteProperties)
    mapRouteProperties2 = opts.mapRouteProperties;
  else if (opts != null && opts.detectErrorBoundary) {
    let detectErrorBoundary = opts.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else
    mapRouteProperties2 = defaultMapRouteProperties;
  let future2 = _extends({
    v7_relativeSplatPath: !1,
    v7_throwAbortReason: !1
  }, opts ? opts.future : null), dataRoutes = convertRoutesToDataRoutes(routes2, mapRouteProperties2, void 0, manifest);
  async function query(request2, _temp3) {
    let {
      requestContext,
      skipLoaderErrorBubbling,
      dataStrategy
    } = _temp3 === void 0 ? {} : _temp3, url = new URL(request2.url), method = request2.method, location = createLocation("", createPath(url), null, "default"), matches2 = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      }), {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!matches2) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      }), {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      return {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let result = await queryImpl(request2, location, matches2, requestContext, dataStrategy || null, skipLoaderErrorBubbling === !0, null);
    return isResponse(result) ? result : _extends({
      location,
      basename
    }, result);
  }
  async function queryRoute(request2, _temp4) {
    let {
      routeId,
      requestContext,
      dataStrategy
    } = _temp4 === void 0 ? {} : _temp4, url = new URL(request2.url), method = request2.method, location = createLocation("", createPath(url), null, "default"), matches2 = matchRoutes(dataRoutes, location, basename);
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")
      throw getInternalRouterError(405, {
        method
      });
    if (!matches2)
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    let match = routeId ? matches2.find((m) => m.route.id === routeId) : getTargetMatch(matches2, location);
    if (routeId && !match)
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    if (!match)
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    let result = await queryImpl(request2, location, matches2, requestContext, dataStrategy || null, !1, match);
    if (isResponse(result))
      return result;
    let error = result.errors ? Object.values(result.errors)[0] : void 0;
    if (error !== void 0)
      throw error;
    if (result.actionData)
      return Object.values(result.actionData)[0];
    if (result.loaderData) {
      var _result$activeDeferre;
      let data3 = Object.values(result.loaderData)[0];
      return (_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id] && (data3[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id]), data3;
    }
  }
  async function queryImpl(request2, location, matches2, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {
    invariant(request2.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request2.method.toLowerCase()))
        return await submit(request2, matches2, routeMatch || getTargetMatch(matches2, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null);
      let result = await loadRouteData(request2, matches2, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch);
      return isResponse(result) ? result : _extends({}, result, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (e) {
      if (isDataStrategyResult(e) && isResponse(e.result)) {
        if (e.type === ResultType.error)
          throw e.result;
        return e.result;
      }
      if (isRedirectResponse(e))
        return e;
      throw e;
    }
  }
  async function submit(request2, matches2, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request2.method,
        pathname: new URL(request2.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest)
        throw error;
      result = {
        type: ResultType.error,
        error
      };
    } else
      result = (await callDataStrategy("action", request2, [actionMatch], matches2, isRouteRequest, requestContext, dataStrategy))[actionMatch.route.id], request2.signal.aborted && throwStaticHandlerAbortedError(request2, isRouteRequest, future2);
    if (isRedirectResult(result))
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    if (isDeferredResult(result)) {
      let error = getInternalRouterError(400, {
        type: "defer-action"
      });
      if (isRouteRequest)
        throw error;
      result = {
        type: ResultType.error,
        error
      };
    }
    if (isRouteRequest) {
      if (isErrorResult(result))
        throw result.error;
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let loaderRequest = new Request(request2.url, {
      headers: request2.headers,
      redirect: request2.redirect,
      signal: request2.signal
    });
    if (isErrorResult(result)) {
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches2, actionMatch.route.id), context2 = await loadRouteData(loaderRequest, matches2, requestContext, dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);
      return _extends({}, context2, {
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: _extends({}, result.headers ? {
          [actionMatch.route.id]: result.headers
        } : {})
      });
    }
    let context = await loadRouteData(loaderRequest, matches2, requestContext, dataStrategy, skipLoaderErrorBubbling, null);
    return _extends({}, context, {
      actionData: {
        [actionMatch.route.id]: result.data
      }
    }, result.statusCode ? {
      statusCode: result.statusCode
    } : {}, {
      actionHeaders: result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {}
    });
  }
  async function loadRouteData(request2, matches2, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {
    let isRouteRequest = routeMatch != null;
    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))
      throw getInternalRouterError(400, {
        method: request2.method,
        pathname: new URL(request2.url).pathname,
        routeId: routeMatch?.route.id
      });
    let matchesToLoad = (routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches2, pendingActionResult[0]) : matches2).filter((m) => m.route.loader || m.route.lazy);
    if (matchesToLoad.length === 0)
      return {
        matches: matches2,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches2.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    let results = await callDataStrategy("loader", request2, matchesToLoad, matches2, isRouteRequest, requestContext, dataStrategy);
    request2.signal.aborted && throwStaticHandlerAbortedError(request2, isRouteRequest, future2);
    let activeDeferreds = /* @__PURE__ */ new Map(), context = processRouteLoaderData(matches2, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling), executedLoaders = new Set(matchesToLoad.map((match) => match.route.id));
    return matches2.forEach((match) => {
      executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
    }), _extends({}, context, {
      matches: matches2,
      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    });
  }
  async function callDataStrategy(type, request2, matchesToLoad, matches2, isRouteRequest, requestContext, dataStrategy) {
    let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, type, null, request2, matchesToLoad, matches2, null, manifest, mapRouteProperties2, requestContext), dataResults = {};
    return await Promise.all(matches2.map(async (match) => {
      if (!(match.route.id in results))
        return;
      let result = results[match.route.id];
      if (isRedirectDataStrategyResultResult(result)) {
        let response = result.result;
        throw normalizeRelativeRoutingRedirectResponse(response, request2, match.route.id, matches2, basename, future2.v7_relativeSplatPath);
      }
      if (isResponse(result.result) && isRouteRequest)
        throw result;
      dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
    })), dataResults;
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
function getStaticContextFromError(routes2, context, error) {
  return _extends({}, context, {
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [context._deepestRenderedBoundaryId || routes2[0].id]: error
    }
  });
}
function throwStaticHandlerAbortedError(request2, isRouteRequest, future2) {
  if (future2.v7_throwAbortReason && request2.signal.reason !== void 0)
    throw request2.signal.reason;
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(method + "() call aborted: " + request2.method + " " + request2.url);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches2, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches, activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match of matches2)
      if (contextualMatches.push(match), match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
  } else
    contextualMatches = matches2, activeRouteMatch = matches2[matches2.length - 1];
  let path = resolveTo(to || ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to == null && (path.search = location.search, path.hash = location.hash), (to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex)
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search), indexValues = params.getAll("index");
      params.delete("index"), indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? "?" + qs : "";
    }
  }
  return prependBasename && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), createPath(path);
}
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts))
    return {
      path
    };
  if (opts.formMethod && !isValidMethod(opts.formMethod))
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  }), rawFormMethod = opts.formMethod || "get", formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase(), formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod))
        return getInvalidBodyError();
      let text2 = typeof opts.body == "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name, value] = _ref3;
          return "" + acc + name + "=" + value + `
`;
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text: text2
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod))
        return getInvalidBodyError();
      try {
        let json14 = typeof opts.body == "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: json14,
            text: void 0
          }
        };
      } catch {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData == "function", "FormData is not available in this environment");
  let searchParams, formData;
  if (opts.formData)
    searchParams = convertFormDataToSearchParams(opts.formData), formData = opts.formData;
  else if (opts.body instanceof FormData)
    searchParams = convertFormDataToSearchParams(opts.body), formData = opts.body;
  else if (opts.body instanceof URLSearchParams)
    searchParams = opts.body, formData = convertSearchParamsToFormData(searchParams);
  else if (opts.body == null)
    searchParams = new URLSearchParams(), formData = new FormData();
  else
    try {
      searchParams = new URLSearchParams(opts.body), formData = convertSearchParamsToFormData(searchParams);
    } catch {
      return getInvalidBodyError();
    }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod))
    return {
      path,
      submission
    };
  let parsedPath = parsePath(path);
  return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append("index", ""), parsedPath.search = "?" + searchParams, {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches2, boundaryId, includeBoundary) {
  includeBoundary === void 0 && (includeBoundary = !1);
  let index = matches2.findIndex((m) => m.route.id === boundaryId);
  return index >= 0 ? matches2.slice(0, includeBoundary ? index + 1 : index) : matches2;
}
function getMatchesToLoad(history, state, matches2, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location), boundaryMatches = matches2;
  initialHydration && state.errors ? boundaryMatches = getLoaderMatchesUntilBoundary(matches2, Object.keys(state.errors)[0], !0) : pendingActionResult && isErrorResult(pendingActionResult[1]) && (boundaryMatches = getLoaderMatchesUntilBoundary(matches2, pendingActionResult[0]));
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0, shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400, navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy)
      return !0;
    if (route.loader == null)
      return !1;
    if (initialHydration)
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id))
      return !0;
    let currentRouteMatch = state.matches[index], nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  }), revalidatingFetchers = [];
  return fetchLoadMatches.forEach((f, key) => {
    if (initialHydration || !matches2.some((m) => m.route.id === f.routeId) || deletedFetchers.has(key))
      return;
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key), fetcherMatch = getTargetMatch(fetcherMatches, f.path), shouldRevalidate = !1;
    fetchRedirectIds.has(key) ? shouldRevalidate = !1 : cancelledFetcherLoads.has(key) ? (cancelledFetcherLoads.delete(key), shouldRevalidate = !0) : fetcher && fetcher.state !== "idle" && fetcher.data === void 0 ? shouldRevalidate = isRevalidationRequired : shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({
      currentUrl,
      currentParams: state.matches[state.matches.length - 1].params,
      nextUrl,
      nextParams: matches2[matches2.length - 1].params
    }, submission, {
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? !1 : isRevalidationRequired
    })), shouldRevalidate && revalidatingFetchers.push({
      key,
      routeId: f.routeId,
      path: f.path,
      matches: fetcherMatches,
      match: fetcherMatch,
      controller: new AbortController()
    });
  }), [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy)
    return !0;
  if (!route.loader)
    return !1;
  let hasData = loaderData != null && loaderData[route.id] !== void 0, hasError = errors != null && errors[route.id] !== void 0;
  return !hasData && hasError ? !1 : typeof route.loader == "function" && route.loader.hydrate === !0 ? !0 : !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id
  ), isMissingData = currentLoaderData[match.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice == "boolean")
      return routeChoice;
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  var _childrenToPatch;
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(route, "No route found to patch children into: routeId = " + routeId), route.children || (route.children = []), childrenToPatch = route.children;
  } else
    childrenToPatch = routesToUse;
  let uniqueChildren = children.filter((newRoute) => !childrenToPatch.some((existingRoute) => isSameRoute(newRoute, existingRoute))), newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || "0")], manifest);
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  return "id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id ? !0 : newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive ? (!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0) ? !0 : newRoute.children.every((aChild, i) => {
    var _existingRoute$childr;
    return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some((bChild) => isSameRoute(aChild, bChild));
  }) : !1;
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy)
    return;
  let lazyRoute = await route.lazy();
  if (!route.lazy)
    return;
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let isPropertyStaticallyDefined = routeToUpdate[lazyRouteProperty] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.')), !isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty) && (routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
  }
  Object.assign(routeToUpdate, routeUpdates), Object.assign(routeToUpdate, _extends({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
async function defaultDataStrategy(_ref4) {
  let {
    matches: matches2
  } = _ref4, matchesToLoad = matches2.filter((m) => m.shouldLoad);
  return (await Promise.all(matchesToLoad.map((m) => m.resolve()))).reduce((acc, result, i) => Object.assign(acc, {
    [matchesToLoad[i].route.id]: result
  }), {});
}
async function callDataStrategyImpl(dataStrategyImpl, type, state, request2, matchesToLoad, matches2, fetcherKey, manifest, mapRouteProperties2, requestContext) {
  let loadRouteDefinitionsPromises = matches2.map((m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0), dsMatches = matches2.map((match, i) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i], shouldLoad = matchesToLoad.some((m) => m.route.id === match.route.id);
    return _extends({}, match, {
      shouldLoad,
      resolve: async (handlerOverride) => (handlerOverride && request2.method === "GET" && (match.route.lazy || match.route.loader) && (shouldLoad = !0), shouldLoad ? callLoaderOrAction(type, request2, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({
        type: ResultType.data,
        result: void 0
      }))
    });
  }), results = await dataStrategyImpl({
    matches: dsMatches,
    request: request2,
    params: matches2[0].params,
    fetcherKey,
    context: requestContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch {
  }
  return results;
}
async function callLoaderOrAction(type, request2, match, loadRoutePromise, handlerOverride, staticContext) {
  let result, onReject, runHandler = (handler) => {
    let reject, abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject(), request2.signal.addEventListener("abort", onReject);
    let actualHandler = (ctx) => typeof handler != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type + '" [routeId: ' + match.route.id + "]"))) : handler({
      request: request2,
      params: match.params,
      context: staticContext
    }, ...ctx !== void 0 ? [ctx] : []), handlerPromise = (async () => {
      try {
        return {
          type: "data",
          result: await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler())
        };
      } catch (e) {
        return {
          type: "error",
          result: e
        };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (loadRoutePromise)
      if (handler) {
        let handlerError, [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e) => {
            handlerError = e;
          }),
          loadRoutePromise
        ]);
        if (handlerError !== void 0)
          throw handlerError;
        result = value;
      } else if (await loadRoutePromise, handler = match.route[type], handler)
        result = await runHandler(handler);
      else if (type === "action") {
        let url = new URL(request2.url), pathname = url.pathname + url.search;
        throw getInternalRouterError(405, {
          method: request2.method,
          pathname,
          routeId: match.route.id
        });
      } else
        return {
          type: ResultType.data,
          result: void 0
        };
    else if (handler)
      result = await runHandler(handler);
    else {
      let url = new URL(request2.url), pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    }
    invariant(result.result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e) {
    return {
      type: ResultType.error,
      result: e
    };
  } finally {
    onReject && request2.signal.removeEventListener("abort", onReject);
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let {
    result,
    type
  } = dataStrategyResult;
  if (isResponse(result)) {
    let data3;
    try {
      let contentType = result.headers.get("Content-Type");
      contentType && /\bapplication\/json\b/.test(contentType) ? result.body == null ? data3 = null : data3 = await result.json() : data3 = await result.text();
    } catch (e) {
      return {
        type: ResultType.error,
        error: e
      };
    }
    return type === ResultType.error ? {
      type: ResultType.error,
      error: new ErrorResponseImpl(result.status, result.statusText, data3),
      statusCode: result.status,
      headers: result.headers
    } : {
      type: ResultType.data,
      data: data3,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    if (isDataWithResponseInit(result)) {
      var _result$init3, _result$init4;
      if (result.data instanceof Error) {
        var _result$init, _result$init2;
        return {
          type: ResultType.error,
          error: result.data,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: (_result$init2 = result.init) != null && _result$init2.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(((_result$init3 = result.init) == null ? void 0 : _result$init3.status) || 500, void 0, result.data),
        statusCode: isRouteErrorResponse(result) ? result.status : void 0,
        headers: (_result$init4 = result.init) != null && _result$init4.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDeferredData(result)) {
    var _result$init5, _result$init6;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,
      headers: ((_result$init6 = result.init) == null ? void 0 : _result$init6.headers) && new Headers(result.init.headers)
    };
  }
  if (isDataWithResponseInit(result)) {
    var _result$init7, _result$init8;
    return {
      type: ResultType.data,
      data: result.data,
      statusCode: (_result$init7 = result.init) == null ? void 0 : _result$init7.status,
      headers: (_result$init8 = result.init) != null && _result$init8.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function normalizeRelativeRoutingRedirectResponse(response, request2, routeId, matches2, basename, v7_relativeSplatPath) {
  let location = response.headers.get("Location");
  if (invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"), !ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches2.slice(0, matches2.findIndex((m) => m.route.id === routeId) + 1);
    location = normalizeTo(new URL(request2.url), trimmedMatches, basename, !0, location, v7_relativeSplatPath), response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    let normalizedLocation = location, url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation), isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename)
      return url.pathname + url.search + url.hash;
  }
  return location;
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString(), init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init.method = formMethod.toUpperCase(), formEncType === "application/json" ? (init.headers = new Headers({
      "Content-Type": formEncType
    }), init.body = JSON.stringify(submission.json)) : formEncType === "text/plain" ? init.body = submission.text : formEncType === "application/x-www-form-urlencoded" && submission.formData ? init.body = convertFormDataToSearchParams(submission.formData) : init.body = submission.formData;
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries())
    searchParams.append(key, typeof value == "string" ? value : value.name);
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries())
    formData.append(key, value);
  return formData;
}
function processRouteLoaderData(matches2, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {}, pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  return matches2.forEach((match) => {
    if (!(match.route.id in results))
      return;
    let id = match.route.id, result = results[id];
    if (invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData"), isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0 && (error = pendingError, pendingError = void 0), errors = errors || {}, skipLoaderErrorBubbling)
        errors[id] = error;
      else {
        let boundaryMatch = findNearestBoundary(matches2, id);
        errors[boundaryMatch.route.id] == null && (errors[boundaryMatch.route.id] = error);
      }
      loaderData[id] = void 0, foundError || (foundError = !0, statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500), result.headers && (loaderHeaders[id] = result.headers);
    } else
      isDeferredResult(result) ? (activeDeferreds.set(id, result.deferredData), loaderData[id] = result.deferredData.data, result.statusCode != null && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode), result.headers && (loaderHeaders[id] = result.headers)) : (loaderData[id] = result.data, result.statusCode && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode), result.headers && (loaderHeaders[id] = result.headers));
  }), pendingError !== void 0 && pendingActionResult && (errors = {
    [pendingActionResult[0]]: pendingError
  }, loaderData[pendingActionResult[0]] = void 0), {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches2, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(
    matches2,
    results,
    pendingActionResult,
    activeDeferreds,
    !1
    // This method is only called client side so we always want to bubble
  );
  return revalidatingFetchers.forEach((rf) => {
    let {
      key,
      match,
      controller
    } = rf, result = fetcherResults[key];
    if (invariant(result, "Did not find corresponding fetcher result"), !(controller && controller.signal.aborted))
      if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);
        errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {
          [boundaryMatch.route.id]: result.error
        })), state.fetchers.delete(key);
      } else if (isRedirectResult(result))
        invariant(!1, "Unhandled fetcher revalidation redirect");
      else if (isDeferredResult(result))
        invariant(!1, "Unhandled fetcher deferred data");
      else {
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
      }
  }), {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches2, errors) {
  let mergedLoaderData = _extends({}, newLoaderData);
  for (let match of matches2) {
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id) ? newLoaderData[id] !== void 0 && (mergedLoaderData[id] = newLoaderData[id]) : loaderData[id] !== void 0 && match.route.loader && (mergedLoaderData[id] = loaderData[id]), errors && errors.hasOwnProperty(id))
      break;
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  return pendingActionResult ? isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  } : {};
}
function findNearestBoundary(matches2, routeId) {
  return (routeId ? matches2.slice(0, matches2.findIndex((m) => m.route.id === routeId) + 1) : [...matches2]).reverse().find((m) => m.route.hasErrorBoundary === !0) || matches2[0];
}
function getShortCircuitMatches(routes2) {
  let route = routes2.length === 1 ? routes2[0] : routes2.find((r) => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type,
    message
  } = _temp5 === void 0 ? {} : _temp5, statusText = "Unknown Server Error", errorMessage = "Unknown @remix-run/router error";
  return status === 400 ? (statusText = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request." : type === "defer-action" ? errorMessage = "defer() is not supported in actions" : type === "invalid-body" && (errorMessage = "Unable to encode submission body")) : status === 403 ? (statusText = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"') : status === 404 ? (statusText = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : status === 405 && (statusText = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request." : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"')), new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), !0);
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i = entries.length - 1; i >= 0; i--) {
    let [key, result] = entries[i];
    if (isRedirectResult(result))
      return {
        key,
        result
      };
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path == "string" ? parsePath(path) : path;
  return createPath(_extends({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a, b) {
  return a.pathname !== b.pathname || a.search !== b.search ? !1 : a.hash === "" ? b.hash !== "" : a.hash === b.hash ? !0 : b.hash !== "";
}
function isDataStrategyResult(result) {
  return result != null && typeof result == "object" && "type" in result && "result" in result && (result.type === ResultType.data || result.type === ResultType.error);
}
function isRedirectDataStrategyResultResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDataWithResponseInit(value) {
  return typeof value == "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
}
function isResponse(value) {
  return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
}
function isRedirectResponse(result) {
  if (!isResponse(result))
    return !1;
  let status = result.status, location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveNavigationDeferredResults(matches2, results, signal, currentMatches, currentLoaderData) {
  let entries = Object.entries(results);
  for (let index = 0; index < entries.length; index++) {
    let [routeId, result] = entries[index], match = matches2.find((m) => m?.route.id === routeId);
    if (!match)
      continue;
    let currentMatch = currentMatches.find((m) => m.route.id === match.route.id), isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
    isDeferredResult(result) && isRevalidatingLoader && await resolveDeferredData(result, signal, !1).then((result2) => {
      result2 && (results[routeId] = result2);
    });
  }
}
async function resolveFetcherDeferredResults(matches2, results, revalidatingFetchers) {
  for (let index = 0; index < revalidatingFetchers.length; index++) {
    let {
      key,
      routeId,
      controller
    } = revalidatingFetchers[index], result = results[key];
    matches2.find((m) => m?.route.id === routeId) && isDeferredResult(result) && (invariant(controller, "Expected an AbortController for revalidating fetcher deferred result"), await resolveDeferredData(result, controller.signal, !0).then((result2) => {
      result2 && (results[key] = result2);
    }));
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0 && (unwrap = !1), !await result.deferredData.resolveData(signal)) {
    if (unwrap)
      try {
        return {
          type: ResultType.data,
          data: result.deferredData.unwrappedData
        };
      } catch (e) {
        return {
          type: ResultType.error,
          error: e
        };
      }
    return {
      type: ResultType.data,
      data: result.deferredData.data
    };
  }
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v) => v === "");
}
function getTargetMatch(matches2, location) {
  let search = typeof location == "string" ? parsePath(location).search : location.search;
  if (matches2[matches2.length - 1].route.index && hasNakedIndexQuery(search || ""))
    return matches2[matches2.length - 1];
  let pathMatches = getPathContributingMatches(matches2);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text: text2,
    formData,
    json: json14
  } = navigation;
  if (!(!formMethod || !formAction || !formEncType)) {
    if (text2 != null)
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: void 0,
        text: text2
      };
    if (formData != null)
      return {
        formMethod,
        formAction,
        formEncType,
        formData,
        json: void 0,
        text: void 0
      };
    if (json14 !== void 0)
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: json14,
        text: void 0
      };
  }
}
function getLoadingNavigation(location, submission) {
  return submission ? {
    state: "loading",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  } : {
    state: "loading",
    location,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function getSubmittingNavigation(location, submission) {
  return {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
}
function getLoadingFetcher(submission, data3) {
  return submission ? {
    state: "loading",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: data3
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data3
  };
}
function getSubmittingFetcher(submission, existingFetcher) {
  return {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
}
function getDoneFetcher(data3) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data3
  };
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json14 = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json14 || {}))
        v && Array.isArray(v) && transitions.set(k, new Set(v || []));
    }
  } catch {
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json14 = {};
    for (let [k, v] of transitions)
      json14[k] = [...v];
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json14));
    } catch (error) {
      warning(!1, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
var Action, PopStateEventType, ResultType, immutableRouteKeys, paramRe, dynamicSegmentValue, indexRouteValue, emptySegmentValue, staticSegmentValue, splatPenalty, isSplat, joinPaths, normalizePathname, normalizeSearch, normalizeHash, json, DataWithResponseInit, AbortedDeferredError, DeferredData, defer, redirect, redirectDocument, replace, ErrorResponseImpl, validMutationMethodsArr, validMutationMethods, validRequestMethodsArr, validRequestMethods, redirectStatusCodes, redirectPreserveMethodStatusCodes, IDLE_NAVIGATION, IDLE_FETCHER, IDLE_BLOCKER, ABSOLUTE_URL_REGEX, defaultMapRouteProperties, TRANSITIONS_STORAGE_KEY, UNSAFE_DEFERRED_SYMBOL, init_router = __esm({
  "node_modules/@remix-run/router/dist/router.js"() {
    (function(Action2) {
      Action2.Pop = "POP", Action2.Push = "PUSH", Action2.Replace = "REPLACE";
    })(Action || (Action = {}));
    PopStateEventType = "popstate";
    (function(ResultType2) {
      ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
    })(ResultType || (ResultType = {}));
    immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    paramRe = /^:[\w-]+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s) => s === "*";
    joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, json = function(data3, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data3), _extends({}, responseInit, {
        headers
      }));
    }, DataWithResponseInit = class {
      constructor(data3, init) {
        this.type = "DataWithResponseInit", this.data = data3, this.init = init || null;
      }
    };
    AbortedDeferredError = class extends Error {
    }, DeferredData = class {
      constructor(data3, responseInit) {
        this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], invariant(data3 && typeof data3 == "object" && !Array.isArray(data3), "defer() only accepts plain objects");
        let reject;
        this.abortPromise = new Promise((_, r) => reject = r), this.controller = new AbortController();
        let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
        this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort), this.controller.signal.addEventListener("abort", onAbort), this.data = Object.entries(data3).reduce((acc, _ref2) => {
          let [key, value] = _ref2;
          return Object.assign(acc, {
            [key]: this.trackPromise(key, value)
          });
        }, {}), this.done && this.unlistenAbortSignal(), this.init = responseInit;
      }
      trackPromise(key, value) {
        if (!(value instanceof Promise))
          return value;
        this.deferredKeys.push(key), this.pendingKeysSet.add(key);
        let promise = Promise.race([value, this.abortPromise]).then((data3) => this.onSettle(promise, key, void 0, data3), (error) => this.onSettle(promise, key, error));
        return promise.catch(() => {
        }), Object.defineProperty(promise, "_tracked", {
          get: () => !0
        }), promise;
      }
      onSettle(promise, key, error, data3) {
        if (this.controller.signal.aborted && error instanceof AbortedDeferredError)
          return this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {
            get: () => error
          }), Promise.reject(error);
        if (this.pendingKeysSet.delete(key), this.done && this.unlistenAbortSignal(), error === void 0 && data3 === void 0) {
          let undefinedError = new Error('Deferred data for key "' + key + '" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
          return Object.defineProperty(promise, "_error", {
            get: () => undefinedError
          }), this.emit(!1, key), Promise.reject(undefinedError);
        }
        return data3 === void 0 ? (Object.defineProperty(promise, "_error", {
          get: () => error
        }), this.emit(!1, key), Promise.reject(error)) : (Object.defineProperty(promise, "_data", {
          get: () => data3
        }), this.emit(!1, key), data3);
      }
      emit(aborted, settledKey) {
        this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));
      }
      subscribe(fn) {
        return this.subscribers.add(fn), () => this.subscribers.delete(fn);
      }
      cancel() {
        this.controller.abort(), this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k)), this.emit(!0);
      }
      async resolveData(signal) {
        let aborted = !1;
        if (!this.done) {
          let onAbort = () => this.cancel();
          signal.addEventListener("abort", onAbort), aborted = await new Promise((resolve) => {
            this.subscribe((aborted2) => {
              signal.removeEventListener("abort", onAbort), (aborted2 || this.done) && resolve(aborted2);
            });
          });
        }
        return aborted;
      }
      get done() {
        return this.pendingKeysSet.size === 0;
      }
      get unwrappedData() {
        return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((acc, _ref3) => {
          let [key, value] = _ref3;
          return Object.assign(acc, {
            [key]: unwrapTrackedPromise(value)
          });
        }, {});
      }
      get pendingKeys() {
        return Array.from(this.pendingKeysSet);
      }
    };
    defer = function(data3, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init;
      return new DeferredData(data3, responseInit);
    }, redirect = function(url, init) {
      init === void 0 && (init = 302);
      let responseInit = init;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url), new Response(null, _extends({}, responseInit, {
        headers
      }));
    }, redirectDocument = (url, init) => {
      let response = redirect(url, init);
      return response.headers.set("X-Remix-Reload-Document", "true"), response;
    }, replace = (url, init) => {
      let response = redirect(url, init);
      return response.headers.set("X-Remix-Replace", "true"), response;
    }, ErrorResponseImpl = class {
      constructor(status, statusText, data3, internal) {
        internal === void 0 && (internal = !1), this.status = status, this.statusText = statusText || "", this.internal = internal, data3 instanceof Error ? (this.data = data3.toString(), this.error = data3) : this.data = data3;
      }
    };
    validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]), IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    }, IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    }, IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    }, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    }), TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
    UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/mode.js
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}
var ServerMode, init_mode = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/mode.js"() {
    ServerMode = /* @__PURE__ */ function(ServerMode2) {
      return ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test", ServerMode2;
    }({});
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/errors.js
function sanitizeError(error, serverMode) {
  if (error instanceof Error && serverMode !== ServerMode.Development) {
    let sanitized = new Error("Unexpected Server Error");
    return sanitized.stack = void 0, sanitized;
  }
  return error;
}
function sanitizeErrors(errors, serverMode) {
  return Object.entries(errors).reduce((acc, [routeId, error]) => Object.assign(acc, {
    [routeId]: sanitizeError(error, serverMode)
  }), {});
}
function serializeError(error, serverMode) {
  let sanitized = sanitizeError(error, serverMode);
  return {
    message: sanitized.message,
    stack: sanitized.stack
  };
}
function serializeErrors(errors, serverMode) {
  if (!errors)
    return null;
  let entries = Object.entries(errors), serialized = {};
  for (let [key, val] of entries)
    if (isRouteErrorResponse(val))
      serialized[key] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    else if (val instanceof Error) {
      let sanitized = sanitizeError(val, serverMode);
      serialized[key] = {
        message: sanitized.message,
        stack: sanitized.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...sanitized.name !== "Error" ? {
          __subType: sanitized.name
        } : {}
      };
    } else
      serialized[key] = val;
  return serialized;
}
var init_errors = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/errors.js"() {
    init_router();
    init_mode();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/responses.js
function isDeferredData2(value) {
  let deferred = value;
  return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
}
function isResponse2(value) {
  return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
}
function isRedirectStatusCode(statusCode) {
  return redirectStatusCodes2.has(statusCode);
}
function isRedirectResponse2(response) {
  return isRedirectStatusCode(response.status);
}
function isTrackedPromise2(value) {
  return value != null && typeof value.then == "function" && value._tracked === !0;
}
function createDeferredReadableStream(deferredData, signal, serverMode) {
  let encoder = new TextEncoder();
  return new ReadableStream({
    async start(controller) {
      let criticalData = {}, preresolvedKeys = [];
      for (let [key, value] of Object.entries(deferredData.data))
        isTrackedPromise2(value) ? (criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`, (typeof value._data < "u" || typeof value._error < "u") && preresolvedKeys.push(key)) : criticalData[key] = value;
      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + `

`));
      for (let preresolvedKey of preresolvedKeys)
        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);
      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {
        settledKey && enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);
      });
      await deferredData.resolveData(signal), unsubscribe(), controller.close();
    }
  });
}
function enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {
  "_error" in promise ? controller.enqueue(encoder.encode("error:" + JSON.stringify({
    [settledKey]: promise._error instanceof Error ? serializeError(promise._error, serverMode) : promise._error
  }) + `

`)) : controller.enqueue(encoder.encode("data:" + JSON.stringify({
    [settledKey]: promise._data ?? null
  }) + `

`));
}
var json3, defer3, redirect3, replace2, redirectDocument2, redirectStatusCodes2, DEFERRED_VALUE_PLACEHOLDER_PREFIX, init_responses = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/responses.js"() {
    init_router();
    init_errors();
    json3 = (data3, init = {}) => json(data3, init), defer3 = (data3, init = {}) => defer(data3, init), redirect3 = (url, init = 302) => redirect(url, init), replace2 = (url, init = 302) => replace(url, init), redirectDocument2 = (url, init = 302) => redirectDocument(url, init);
    redirectStatusCodes2 = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/headers.js
import { splitCookiesString } from "set-cookie-parser";
function getDocumentHeaders(build, context) {
  let boundaryIdx = context.errors ? context.matches.findIndex((m) => context.errors[m.route.id]) : -1, matches2 = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches, errorHeaders;
  if (boundaryIdx >= 0) {
    let {
      actionHeaders,
      actionData,
      loaderHeaders,
      loaderData
    } = context;
    context.matches.slice(boundaryIdx).some((match) => {
      let id = match.route.id;
      return actionHeaders[id] && (!actionData || actionData[id] === void 0) ? errorHeaders = actionHeaders[id] : loaderHeaders[id] && loaderData[id] === void 0 && (errorHeaders = loaderHeaders[id]), errorHeaders != null;
    });
  }
  return matches2.reduce((parentHeaders, match, idx) => {
    let {
      id
    } = match.route, routeModule = build.routes[id].module, loaderHeaders = context.loaderHeaders[id] || new Headers(), actionHeaders = context.actionHeaders[id] || new Headers(), includeErrorHeaders = errorHeaders != null && idx === matches2.length - 1, includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
    if (routeModule.headers == null) {
      let headers2 = new Headers(parentHeaders);
      return includeErrorCookies && prependCookies(errorHeaders, headers2), prependCookies(actionHeaders, headers2), prependCookies(loaderHeaders, headers2), headers2;
    }
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders,
      errorHeaders: includeErrorHeaders ? errorHeaders : void 0
    }) : routeModule.headers : void 0);
    return includeErrorCookies && prependCookies(errorHeaders, headers), prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    var _childHeaders$getSetC;
    let cookies = splitCookiesString(parentSetCookieString), childCookies = new Set((_childHeaders$getSetC = childHeaders.getSetCookie) === null || _childHeaders$getSetC === void 0 ? void 0 : _childHeaders$getSetC.call(childHeaders));
    cookies.forEach((cookie) => {
      childCookies.has(cookie) || childHeaders.append("Set-Cookie", cookie);
    });
  }
}
var init_headers = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/headers.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/single-fetch.js
import { encode } from "turbo-stream";
function getSingleFetchDataStrategy({
  isActionDataRequest,
  loadRouteIds
} = {}) {
  return async ({
    request: request2,
    matches: matches2
  }) => {
    if (isActionDataRequest && request2.method === "GET")
      return {};
    let matchesToLoad = loadRouteIds ? matches2.filter((m) => loadRouteIds.includes(m.route.id)) : matches2;
    return (await Promise.all(matchesToLoad.map((match) => match.resolve()))).reduce((acc, result, i) => Object.assign(acc, {
      [matchesToLoad[i].route.id]: result
    }), {});
  };
}
async function singleFetchAction(build, serverMode, staticHandler, request2, handlerUrl, loadContext, handleError) {
  try {
    let handlerRequest = new Request(handlerUrl, {
      method: request2.method,
      body: request2.body,
      headers: request2.headers,
      signal: request2.signal,
      ...request2.body ? {
        duplex: "half"
      } : void 0
    }), result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: !0,
      dataStrategy: getSingleFetchDataStrategy({
        isActionDataRequest: !0
      })
    });
    if (isResponse2(result))
      return {
        result: getSingleFetchRedirect(result.status, result.headers, build.basename),
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    let context = result, headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location"))
      return {
        result: getSingleFetchRedirect(context.statusCode, headers, build.basename),
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    context.errors && (Object.values(context.errors).forEach((err) => {
      (!isRouteErrorResponse(err) || err.error) && handleError(err);
    }), context.errors = sanitizeErrors(context.errors, serverMode));
    let singleFetchResult;
    return context.errors ? singleFetchResult = {
      error: Object.values(context.errors)[0]
    } : singleFetchResult = {
      data: Object.values(context.actionData || {})[0]
    }, {
      result: singleFetchResult,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    return handleError(error), {
      result: {
        error
      },
      headers: new Headers(),
      status: 500
    };
  }
}
async function singleFetchLoaders(build, serverMode, staticHandler, request2, handlerUrl, loadContext, handleError) {
  try {
    var _URL$searchParams$get;
    let handlerRequest = new Request(handlerUrl, {
      headers: request2.headers,
      signal: request2.signal
    }), loadRouteIds = ((_URL$searchParams$get = new URL(request2.url).searchParams.get("_routes")) === null || _URL$searchParams$get === void 0 ? void 0 : _URL$searchParams$get.split(",")) || void 0, result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: !0,
      dataStrategy: getSingleFetchDataStrategy({
        loadRouteIds
      })
    });
    if (isResponse2(result))
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)
        },
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    let context = result, headers = getDocumentHeaders(build, context);
    if (isRedirectStatusCode(context.statusCode) && headers.has("Location"))
      return {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)
        },
        headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      };
    context.errors && (Object.values(context.errors).forEach((err) => {
      (!isRouteErrorResponse(err) || err.error) && handleError(err);
    }), context.errors = sanitizeErrors(context.errors, serverMode));
    let results = {};
    return (loadRouteIds ? context.matches.filter((m) => m.route.loader && loadRouteIds.includes(m.route.id)) : context.matches).forEach((m) => {
      var _context$loaderData, _context$errors;
      let data3 = (_context$loaderData = context.loaderData) === null || _context$loaderData === void 0 ? void 0 : _context$loaderData[m.route.id], error = (_context$errors = context.errors) === null || _context$errors === void 0 ? void 0 : _context$errors[m.route.id];
      error !== void 0 ? results[m.route.id] = {
        error
      } : data3 !== void 0 && (results[m.route.id] = {
        data: data3
      });
    }), {
      result: results,
      headers,
      status: context.statusCode
    };
  } catch (error) {
    return handleError(error), {
      result: {
        root: {
          error
        }
      },
      headers: new Headers(),
      status: 500
    };
  }
}
function getSingleFetchRedirect(status, headers, basename) {
  let redirect4 = headers.get("Location");
  return basename && (redirect4 = stripBasename(redirect4, basename) || redirect4), {
    redirect: redirect4,
    status,
    revalidate: (
      // Technically X-Remix-Revalidate isn't needed here - that was an implementation
      // detail of ?_data requests as our way to tell the front end to revalidate when
      // we didn't have a response body to include that information in.
      // With single fetch, we tell the front end via this revalidate boolean field.
      // However, we're respecting it for now because it may be something folks have
      // used in their own responses
      // TODO(v3): Consider removing or making this official public API
      headers.has("X-Remix-Revalidate") || headers.has("Set-Cookie")
    ),
    reload: headers.has("X-Remix-Reload-Document"),
    replace: headers.has("X-Remix-Replace")
  };
}
function encodeViaTurboStream(data3, requestSignal, streamTimeout, serverMode) {
  let controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(new Error("Server Timeout")), typeof streamTimeout == "number" ? streamTimeout : 4950);
  return requestSignal.addEventListener("abort", () => clearTimeout(timeoutId)), encode(data3, {
    signal: controller.signal,
    plugins: [(value) => {
      if (value instanceof Error) {
        let {
          name,
          message,
          stack
        } = serverMode === ServerMode.Production ? sanitizeError(value, serverMode) : value;
        return ["SanitizedError", name, message, stack];
      }
      if (value instanceof ErrorResponseImpl) {
        let {
          data: data4,
          status,
          statusText
        } = value;
        return ["ErrorResponse", data4, status, statusText];
      }
      if (value && typeof value == "object" && SingleFetchRedirectSymbol in value)
        return ["SingleFetchRedirect", value[SingleFetchRedirectSymbol]];
    }],
    postPlugins: [(value) => {
      if (value && typeof value == "object")
        return ["SingleFetchClassInstance", Object.fromEntries(Object.entries(value))];
    }, () => ["SingleFetchFallback"]]
  });
}
function data2(value, init) {
  return data(value, init);
}
var SingleFetchRedirectSymbol, SINGLE_FETCH_REDIRECT_STATUS, init_single_fetch = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/single-fetch.js"() {
    init_router();
    init_errors();
    init_headers();
    init_mode();
    init_responses();
    SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect"), SINGLE_FETCH_REDIRECT_STATUS = 202;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/entry.js
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo7, routeId) => (memo7[routeId] = manifest[routeId].module, memo7), {});
}
var init_entry = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/entry.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/invariant.js
function invariant2(value, message) {
  if (value === !1 || value === null || typeof value > "u")
    throw console.error("The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new"), new Error(message);
}
var init_invariant = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/invariant.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js
function matchServerRoutes(routes2, pathname, basename) {
  let matches2 = matchRoutes(routes2, pathname, basename);
  return matches2 ? matches2.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  })) : null;
}
var init_routeMatching = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js"() {
    init_router();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/data.js
async function callRouteAction({
  loadContext,
  action: action8,
  params,
  request: request2,
  routeId,
  singleFetch
}) {
  let result = await action8({
    request: singleFetch ? stripRoutesParam(stripIndexParam(request2)) : stripDataParam(stripIndexParam(request2)),
    context: loadContext,
    params
  });
  if (result === void 0)
    throw new Error(`You defined an action for route "${routeId}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  return singleFetch || isResponse2(result) ? result : json3(result);
}
async function callRouteLoader({
  loadContext,
  loader: loader10,
  params,
  request: request2,
  routeId,
  singleFetch
}) {
  let result = await loader10({
    request: singleFetch ? stripRoutesParam(stripIndexParam(request2)) : stripDataParam(stripIndexParam(request2)),
    context: loadContext,
    params
  });
  if (result === void 0)
    throw new Error(`You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  return isDeferredData2(result) ? result.init && isRedirectStatusCode(result.init.status || 200) ? redirect3(new Headers(result.init.headers).get("Location"), result.init) : result : singleFetch || isResponse2(result) ? result : json3(result);
}
function stripIndexParam(request2) {
  let url = new URL(request2.url), indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues)
    indexValue && indexValuesToKeep.push(indexValue);
  for (let toKeep of indexValuesToKeep)
    url.searchParams.append("index", toKeep);
  let init = {
    method: request2.method,
    body: request2.body,
    headers: request2.headers,
    signal: request2.signal
  };
  return init.body && (init.duplex = "half"), new Request(url.href, init);
}
function stripDataParam(request2) {
  let url = new URL(request2.url);
  url.searchParams.delete("_data");
  let init = {
    method: request2.method,
    body: request2.body,
    headers: request2.headers,
    signal: request2.signal
  };
  return init.body && (init.duplex = "half"), new Request(url.href, init);
}
function stripRoutesParam(request2) {
  let url = new URL(request2.url);
  url.searchParams.delete("_routes");
  let init = {
    method: request2.method,
    body: request2.body,
    headers: request2.headers,
    signal: request2.signal
  };
  return init.body && (init.duplex = "half"), new Request(url.href, init);
}
var init_data = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/data.js"() {
    init_responses();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routes.js
function groupRoutesByParentId(manifest) {
  let routes2 = {};
  return Object.values(manifest).forEach((route) => {
    let parentId = route.parentId || "";
    routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
  }), routes2;
}
function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
}
function createStaticHandlerDataRoutes(manifest, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
  return (routesByParentId[parentId] || []).map((route) => {
    let commonRoute = {
      // Always include root due to default boundaries
      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      loader: route.module.loader ? (
        // Need to use RR's version here to permit the optional context even
        // though we know it'll always be provided in remix
        (args, dataStrategyCtx) => callRouteLoader({
          request: args.request,
          params: args.params,
          loadContext: args.context,
          loader: route.module.loader,
          routeId: route.id,
          singleFetch: future2.v3_singleFetch === !0
        })
      ) : void 0,
      action: route.module.action ? (args, dataStrategyCtx) => callRouteAction({
        request: args.request,
        params: args.params,
        loadContext: args.context,
        action: route.module.action,
        routeId: route.id,
        singleFetch: future2.v3_singleFetch === !0
      }) : void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: !0,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createStaticHandlerDataRoutes(manifest, future2, route.id, routesByParentId),
      ...commonRoute
    };
  });
}
var init_routes = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routes.js"() {
    init_data();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/markup.js
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var ESCAPE_LOOKUP, ESCAPE_REGEX, init_markup = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/markup.js"() {
    ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js
function createServerHandoffString(serverHandoff) {
  return escapeHtml(JSON.stringify(serverHandoff));
}
var init_serverHandoff = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js"() {
    init_markup();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/dev.js
async function broadcastDevReady(build, origin) {
  if (origin ??= "", !origin)
    throw Error("Dev server origin not set");
  let url = new URL(origin);
  url.pathname = "ping";
  let response = await fetch(url.href, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      buildHash: build.assets.version
    })
  }).catch((error) => {
    throw console.error(`Could not reach Remix dev server at ${url}`), error;
  });
  if (!response.ok)
    throw console.error(`Could not reach Remix dev server at ${url} (${response.status})`), Error(await response.text());
}
function logDevReady(build) {
  console.log(`[REMIX DEV] ${build.assets.version} ready`);
}
function setDevServerHooks(devServerHooks) {
  globalThis[globalDevServerHooksKey] = devServerHooks;
}
function getDevServerHooks() {
  return globalThis[globalDevServerHooksKey];
}
var globalDevServerHooksKey, init_dev = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/dev.js"() {
    globalDevServerHooksKey = "__remix_devServerHooks";
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/deprecations.js
function resourceRouteJsonWarning(type, routeId) {
  return `\u26A0\uFE0F REMIX FUTURE CHANGE: Externally-accessed resource routes will no longer be able to return raw JavaScript objects or \`null\` in React Router v7 when Single Fetch becomes the default. You can prepare for this change at your convenience by wrapping the data returned from your \`${type}\` function in the \`${routeId}\` route with \`json()\`.  For instructions on making this change, see https://remix.run/docs/en/v2.13.1/guides/single-fetch#resource-routes`;
}
var init_deprecations = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/deprecations.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/server.js
function derive(build, mode2) {
  var _build$future, _build$future2;
  let routes2 = createRoutes(build.routes), dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future), serverMode = isServerMode(mode2) ? mode2 : ServerMode.Production, staticHandler = createStaticHandler(dataRoutes, {
    basename: build.basename,
    future: {
      v7_relativeSplatPath: ((_build$future = build.future) === null || _build$future === void 0 ? void 0 : _build$future.v3_relativeSplatPath) === !0,
      v7_throwAbortReason: ((_build$future2 = build.future) === null || _build$future2 === void 0 ? void 0 : _build$future2.v3_throwAbortReason) === !0
    }
  }), errorHandler = build.entry.module.handleError || ((error, {
    request: request2
  }) => {
    serverMode !== ServerMode.Test && !request2.signal.aborted && console.error(
      // @ts-expect-error This is "private" from users but intended for internal use
      isRouteErrorResponse(error) && error.error ? error.error : error
    );
  });
  return {
    routes: routes2,
    dataRoutes,
    serverMode,
    staticHandler,
    errorHandler
  };
}
async function handleManifestRequest(build, routes2, url) {
  if (build.assets.version !== url.searchParams.get("version"))
    return new Response(null, {
      status: 204,
      headers: {
        "X-Remix-Reload-Document": "true"
      }
    });
  let patches = {};
  if (url.searchParams.has("p")) {
    let paths = /* @__PURE__ */ new Set();
    url.searchParams.getAll("p").forEach((path) => {
      path.startsWith("/") || (path = `/${path}`);
      let segments = path.split("/").slice(1);
      segments.forEach((_, i) => {
        let partialPath = segments.slice(0, i + 1).join("/");
        paths.add(`/${partialPath}`);
      });
    });
    for (let path of paths) {
      let matches2 = matchServerRoutes(routes2, path, build.basename);
      if (matches2)
        for (let match of matches2) {
          let routeId = match.route.id;
          patches[routeId] = build.assets.routes[routeId];
        }
    }
    return json3(patches, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", {
    status: 400
  });
}
async function handleDataRequest(serverMode, build, staticHandler, routeId, request2, loadContext, handleError) {
  try {
    let response = await staticHandler.queryRoute(request2, {
      routeId,
      requestContext: loadContext
    });
    if (isRedirectResponse2(response))
      return createRemixRedirectResponse(response, build.basename);
    if (UNSAFE_DEFERRED_SYMBOL in response) {
      let deferredData = response[UNSAFE_DEFERRED_SYMBOL], body = createDeferredReadableStream(deferredData, request2.signal, serverMode), init = deferredData.init || {}, headers = new Headers(init.headers);
      return headers.set("Content-Type", "text/remix-deferred"), headers.set("X-Remix-Response", "yes"), init.headers = headers, new Response(body, init);
    }
    return response = safelySetHeader(response, "X-Remix-Response", "yes"), response;
  } catch (error) {
    if (isResponse2(error))
      return safelySetHeader(error, "X-Remix-Catch", "yes");
    if (isRouteErrorResponse(error))
      return handleError(error), errorResponseToJson(error, serverMode);
    let errorInstance = error instanceof Error || error instanceof DOMException ? error : new Error("Unexpected Server Error");
    return handleError(errorInstance), json(serializeError(errorInstance, serverMode), {
      status: 500,
      headers: {
        "X-Remix-Error": "yes"
      }
    });
  }
}
async function handleSingleFetchRequest(serverMode, build, staticHandler, request2, handlerUrl, loadContext, handleError) {
  let {
    result,
    headers,
    status
  } = request2.method !== "GET" ? await singleFetchAction(build, serverMode, staticHandler, request2, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request2, handlerUrl, loadContext, handleError), resultHeaders = new Headers(headers);
  return resultHeaders.set("X-Remix-Response", "yes"), NO_BODY_STATUS_CODES.has(status) ? new Response(null, {
    status,
    headers: resultHeaders
  }) : (resultHeaders.set("Content-Type", "text/x-script"), new Response(encodeViaTurboStream(result, request2.signal, build.entry.module.streamTimeout, serverMode), {
    status: status || 200,
    headers: resultHeaders
  }));
}
async function handleDocumentRequest(serverMode, build, staticHandler, request2, loadContext, handleError, criticalCss) {
  let context;
  try {
    context = await staticHandler.query(request2, {
      requestContext: loadContext
    });
  } catch (error) {
    return handleError(error), new Response(null, {
      status: 500
    });
  }
  if (isResponse2(context))
    return context;
  let headers = getDocumentHeaders(build, context);
  if (NO_BODY_STATUS_CODES.has(context.statusCode))
    return new Response(null, {
      status: context.statusCode,
      headers
    });
  context.errors && (Object.values(context.errors).forEach((err) => {
    (!isRouteErrorResponse(err) || err.error) && handleError(err);
  }), context.errors = sanitizeErrors(context.errors, serverMode));
  let state = {
    loaderData: context.loaderData,
    actionData: context.actionData,
    errors: serializeErrors(context.errors, serverMode)
  }, entryContext = {
    manifest: build.assets,
    routeModules: createEntryRouteModules(build.routes),
    staticHandlerContext: context,
    criticalCss,
    serverHandoffString: createServerHandoffString({
      basename: build.basename,
      criticalCss,
      future: build.future,
      isSpaMode: build.isSpaMode,
      ...build.future.v3_singleFetch ? null : {
        state
      }
    }),
    ...build.future.v3_singleFetch ? {
      serverHandoffStream: encodeViaTurboStream(state, request2.signal, build.entry.module.streamTimeout, serverMode),
      renderMeta: {}
    } : null,
    future: build.future,
    isSpaMode: build.isSpaMode,
    serializeError: (err) => serializeError(err, serverMode)
  }, handleDocumentRequestFunction = build.entry.module.default;
  try {
    return await handleDocumentRequestFunction(request2, context.statusCode, headers, entryContext, loadContext);
  } catch (error) {
    handleError(error);
    let errorForSecondRender = error;
    if (isResponse2(error))
      try {
        let data3 = await unwrapResponse(error);
        errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data3);
      } catch {
      }
    context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender), context.errors && (context.errors = sanitizeErrors(context.errors, serverMode));
    let state2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors, serverMode)
    };
    entryContext = {
      ...entryContext,
      staticHandlerContext: context,
      serverHandoffString: createServerHandoffString({
        basename: build.basename,
        future: build.future,
        isSpaMode: build.isSpaMode,
        ...build.future.v3_singleFetch ? null : {
          state: state2
        }
      }),
      ...build.future.v3_singleFetch ? {
        serverHandoffStream: encodeViaTurboStream(state2, request2.signal, build.entry.module.streamTimeout, serverMode),
        renderMeta: {}
      } : null
    };
    try {
      return await handleDocumentRequestFunction(request2, context.statusCode, headers, entryContext, loadContext);
    } catch (error2) {
      return handleError(error2), returnLastResortErrorResponse(error2, serverMode);
    }
  }
}
async function handleResourceRequest(serverMode, build, staticHandler, routeId, request2, loadContext, handleError) {
  try {
    let response = await staticHandler.queryRoute(request2, {
      routeId,
      requestContext: loadContext
    });
    return typeof response == "object" && response !== null && invariant2(!(UNSAFE_DEFERRED_SYMBOL in response), `You cannot return a \`defer()\` response from a Resource Route.  Did you forget to export a default UI component from the "${routeId}" route?`), build.future.v3_singleFetch && !isResponse2(response) && (console.warn(resourceRouteJsonWarning(request2.method === "GET" ? "loader" : "action", routeId)), response = json3(response)), invariant2(isResponse2(response), "Expected a Response to be returned from queryRoute"), response;
  } catch (error) {
    return isResponse2(error) ? safelySetHeader(error, "X-Remix-Catch", "yes") : isRouteErrorResponse(error) ? (error && handleError(error), errorResponseToJson(error, serverMode)) : (handleError(error), returnLastResortErrorResponse(error, serverMode));
  }
}
function errorResponseToJson(errorResponse, serverMode) {
  return json(serializeError(
    // @ts-expect-error This is "private" from users but intended for internal use
    errorResponse.error || new Error("Unexpected Server Error"),
    serverMode
  ), {
    status: errorResponse.status,
    statusText: errorResponse.statusText,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function returnLastResortErrorResponse(error, serverMode) {
  let message = "Unexpected Server Error";
  return serverMode !== ServerMode.Production && (message += `

${String(error)}`), new Response(message, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function unwrapResponse(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();
}
function createRemixRedirectResponse(response, basename) {
  let headers = new Headers(response.headers), redirectUrl = headers.get("Location");
  return headers.set("X-Remix-Redirect", basename && stripBasename(redirectUrl, basename) || redirectUrl), headers.set("X-Remix-Status", String(response.status)), headers.delete("Location"), response.headers.get("Set-Cookie") !== null && headers.set("X-Remix-Revalidate", "yes"), new Response(null, {
    status: 204,
    headers
  });
}
function safelySetHeader(response, name, value) {
  let headers = new Headers(response.headers);
  return headers.set(name, value), new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers,
    duplex: response.body ? "half" : void 0
  });
}
var NO_BODY_STATUS_CODES, createRequestHandler, init_server = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/server.js"() {
    init_router();
    init_entry();
    init_errors();
    init_headers();
    init_invariant();
    init_mode();
    init_routeMatching();
    init_routes();
    init_responses();
    init_serverHandoff();
    init_dev();
    init_single_fetch();
    init_deprecations();
    NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([100, 101, 204, 205, 304]);
    createRequestHandler = (build, mode2) => {
      let _build, routes2, serverMode, staticHandler, errorHandler;
      return async function(request2, loadContext = {}) {
        if (_build = typeof build == "function" ? await build() : build, mode2 ??= _build.mode, typeof build == "function") {
          let derived = derive(_build, mode2);
          routes2 = derived.routes, serverMode = derived.serverMode, staticHandler = derived.staticHandler, errorHandler = derived.errorHandler;
        } else if (!routes2 || !serverMode || !staticHandler || !errorHandler) {
          let derived = derive(_build, mode2);
          routes2 = derived.routes, serverMode = derived.serverMode, staticHandler = derived.staticHandler, errorHandler = derived.errorHandler;
        }
        let url = new URL(request2.url), params = {}, handleError = (error) => {
          if (mode2 === ServerMode.Development) {
            var _getDevServerHooks, _getDevServerHooks$pr;
            (_getDevServerHooks = getDevServerHooks()) === null || _getDevServerHooks === void 0 || (_getDevServerHooks$pr = _getDevServerHooks.processRequestError) === null || _getDevServerHooks$pr === void 0 || _getDevServerHooks$pr.call(_getDevServerHooks, error);
          }
          errorHandler(error, {
            context: loadContext,
            params,
            request: request2
          });
        }, manifestUrl = `${_build.basename ?? "/"}/__manifest`.replace(/\/+/g, "/");
        if (url.pathname === manifestUrl)
          try {
            return await handleManifestRequest(_build, routes2, url);
          } catch (e) {
            return handleError(e), new Response("Unknown Server Error", {
              status: 500
            });
          }
        let matches2 = matchServerRoutes(routes2, url.pathname, _build.basename);
        matches2 && matches2.length > 0 && Object.assign(params, matches2[0].params);
        let response;
        if (url.searchParams.has("_data")) {
          _build.future.v3_singleFetch && handleError(new Error("Warning: Single fetch-enabled apps should not be making ?_data requests, this is likely to break in the future"));
          let routeId = url.searchParams.get("_data");
          response = await handleDataRequest(serverMode, _build, staticHandler, routeId, request2, loadContext, handleError), _build.entry.module.handleDataRequest && (response = await _build.entry.module.handleDataRequest(response, {
            context: loadContext,
            params,
            request: request2
          }), isRedirectResponse2(response) && (response = createRemixRedirectResponse(response, _build.basename)));
        } else if (_build.future.v3_singleFetch && url.pathname.endsWith(".data")) {
          let handlerUrl = new URL(request2.url);
          handlerUrl.pathname = handlerUrl.pathname.replace(/\.data$/, "").replace(/^\/_root$/, "/");
          let singleFetchMatches = matchServerRoutes(routes2, handlerUrl.pathname, _build.basename);
          if (response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request2, handlerUrl, loadContext, handleError), _build.entry.module.handleDataRequest && (response = await _build.entry.module.handleDataRequest(response, {
            context: loadContext,
            params: singleFetchMatches ? singleFetchMatches[0].params : {},
            request: request2
          }), isRedirectResponse2(response))) {
            let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);
            request2.method === "GET" && (result = {
              [SingleFetchRedirectSymbol]: result
            });
            let headers = new Headers(response.headers);
            return headers.set("Content-Type", "text/x-script"), new Response(encodeViaTurboStream(result, request2.signal, _build.entry.module.streamTimeout, serverMode), {
              status: SINGLE_FETCH_REDIRECT_STATUS,
              headers
            });
          }
        } else if (matches2 && matches2[matches2.length - 1].route.module.default == null && matches2[matches2.length - 1].route.module.ErrorBoundary == null)
          response = await handleResourceRequest(serverMode, _build, staticHandler, matches2.slice(-1)[0].route.id, request2, loadContext, handleError);
        else {
          var _getDevServerHooks2, _getDevServerHooks2$g;
          let criticalCss = mode2 === ServerMode.Development ? await ((_getDevServerHooks2 = getDevServerHooks()) === null || _getDevServerHooks2 === void 0 || (_getDevServerHooks2$g = _getDevServerHooks2.getCriticalCss) === null || _getDevServerHooks2$g === void 0 ? void 0 : _getDevServerHooks2$g.call(_getDevServerHooks2, _build, url.pathname)) : void 0;
          response = await handleDocumentRequest(serverMode, _build, staticHandler, request2, loadContext, handleError, criticalCss);
        }
        return request2.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions.js
function flash(name) {
  return `__flash_${name}__`;
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
}
var createSession, isSession, createSessionStorageFactory, init_sessions = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions.js"() {
    init_cookies();
    init_warnings();
    createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            return map.delete(flashName), value;
          }
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options), data3 = id && await readData(id);
          return createSession(data3 || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data: data3
          } = session, expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;
          return id ? await updateData(id, data3, expires) : id = await createData(data3, expires), cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options,
            maxAge: void 0,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js
var createCookieSessionStorageFactory, init_cookieStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js"() {
    init_cookies();
    init_sessions();
    createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          return createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            maxAge: void 0,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js
var createMemorySessionStorageFactory, init_memoryStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js"() {
    createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data3, expires) {
          let id = Math.random().toString(36).substring(2, 10);
          return map.set(id, {
            data: data3,
            expires
          }), id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data: data3,
              expires
            } = map.get(id);
            if (!expires || expires > /* @__PURE__ */ new Date())
              return data3;
            expires && map.delete(id);
          }
          return null;
        },
        async updateData(id, data3, expires) {
          map.set(id, {
            data: data3,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js
var MaxPartSizeExceededError, init_errors2 = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js"() {
    MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js
function createMemoryUploadHandler({
  filter,
  maxPartSize = 3e6
} = {}) {
  return async ({
    filename,
    contentType,
    name,
    data: data3
  }) => {
    if (filter && !await filter({
      filename,
      contentType,
      name
    }))
      return;
    let size2 = 0, chunks = [];
    for await (let chunk of data3) {
      if (size2 += chunk.byteLength, size2 > maxPartSize)
        throw new MaxPartSizeExceededError(name, maxPartSize);
      chunks.push(chunk);
    }
    return typeof filename == "string" ? new File(chunks, filename, {
      type: contentType
    }) : await new Blob(chunks, {
      type: contentType
    }).text();
  };
}
var init_memoryUploadHandler = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js"() {
    init_errors2();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  MaxPartSizeExceededError: () => MaxPartSizeExceededError,
  UNSAFE_SingleFetchRedirectSymbol: () => SingleFetchRedirectSymbol,
  broadcastDevReady: () => broadcastDevReady,
  createCookieFactory: () => createCookieFactory,
  createCookieSessionStorageFactory: () => createCookieSessionStorageFactory,
  createMemorySessionStorageFactory: () => createMemorySessionStorageFactory,
  createRequestHandler: () => createRequestHandler,
  createSession: () => createSession,
  createSessionStorageFactory: () => createSessionStorageFactory,
  data: () => data2,
  defer: () => defer3,
  isCookie: () => isCookie,
  isSession: () => isSession,
  json: () => json3,
  logDevReady: () => logDevReady,
  redirect: () => redirect3,
  redirectDocument: () => redirectDocument2,
  replace: () => replace2,
  unstable_composeUploadHandlers: () => composeUploadHandlers,
  unstable_createMemoryUploadHandler: () => createMemoryUploadHandler,
  unstable_parseMultipartFormData: () => parseMultipartFormData,
  unstable_setDevServerHooks: () => setDevServerHooks
});
var init_esm = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/index.js"() {
    init_cookies();
    init_formData();
    init_responses();
    init_single_fetch();
    init_server();
    init_sessions();
    init_cookieStorage();
    init_memoryStorage();
    init_memoryUploadHandler();
    init_errors2();
    init_dev();
  }
});

// node_modules/@remix-run/node/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/node/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookieSignature = __require("cookie-signature");
    function _interopDefaultLegacy(e) {
      return e && typeof e == "object" && "default" in e ? e : { default: e };
    }
    var cookieSignature__default = /* @__PURE__ */ _interopDefaultLegacy(cookieSignature), sign = async (value, secret) => cookieSignature__default.default.sign(value, secret), unsign = async (signed, secret) => cookieSignature__default.default.unsign(signed, secret);
    exports.sign = sign;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/node/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/node/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = (init_esm(), __toCommonJS(esm_exports)), crypto2 = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto2.sign,
      unsign: crypto2.unsign
    }), createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/node/dist/sessions/fileStorage.js
var require_fileStorage = __commonJS({
  "node_modules/@remix-run/node/dist/sessions/fileStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto2 = __require("node:crypto"), node_fs = __require("node:fs"), path = __require("node:path"), implementations = require_implementations();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var crypto__namespace = /* @__PURE__ */ _interopNamespace(crypto2), path__namespace = /* @__PURE__ */ _interopNamespace(path);
    function createFileSessionStorage({
      cookie,
      dir
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data3, expires) {
          let content = JSON.stringify({
            data: data3,
            expires
          });
          for (; ; ) {
            let randomBytes = crypto__namespace.webcrypto.getRandomValues(new Uint8Array(8)), id = Buffer.from(randomBytes).toString("hex");
            try {
              let file = getFile(dir, id);
              return await node_fs.promises.mkdir(path__namespace.dirname(file), {
                recursive: !0
              }), await node_fs.promises.writeFile(file, content, {
                encoding: "utf-8",
                flag: "wx"
              }), id;
            } catch (error) {
              if (error.code !== "EEXIST")
                throw error;
            }
          }
        },
        async readData(id) {
          try {
            let file = getFile(dir, id), content = JSON.parse(await node_fs.promises.readFile(file, "utf-8")), data3 = content.data, expires = typeof content.expires == "string" ? new Date(content.expires) : null;
            return !expires || expires > /* @__PURE__ */ new Date() ? data3 : (expires && await node_fs.promises.unlink(file), null);
          } catch (error) {
            if (error.code !== "ENOENT")
              throw error;
            return null;
          }
        },
        async updateData(id, data3, expires) {
          let content = JSON.stringify({
            data: data3,
            expires
          }), file = getFile(dir, id);
          await node_fs.promises.mkdir(path__namespace.dirname(file), {
            recursive: !0
          }), await node_fs.promises.writeFile(file, content, "utf-8");
        },
        async deleteData(id) {
          if (id)
            try {
              await node_fs.promises.unlink(getFile(dir, id));
            } catch (error) {
              if (error.code !== "ENOENT")
                throw error;
            }
        }
      });
    }
    function getFile(dir, id) {
      return path__namespace.join(dir, id.slice(0, 4), id.slice(4));
    }
    exports.createFileSessionStorage = createFileSessionStorage;
    exports.getFile = getFile;
  }
});

// node_modules/@remix-run/node/dist/stream.js
var require_stream2 = __commonJS({
  "node_modules/@remix-run/node/dist/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var node_stream = __require("node:stream");
    async function writeReadableStreamToWritable(stream, writable) {
      let reader = stream.getReader(), flushable = writable;
      try {
        for (; ; ) {
          let {
            done,
            value
          } = await reader.read();
          if (done) {
            writable.end();
            break;
          }
          writable.write(value), typeof flushable.flush == "function" && flushable.flush();
        }
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function writeAsyncIterableToWritable(iterable, writable) {
      try {
        for await (let chunk of iterable)
          writable.write(chunk);
        writable.end();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function readableStreamToString(stream, encoding) {
      let reader = stream.getReader(), chunks = [];
      for (; ; ) {
        let {
          done,
          value
        } = await reader.read();
        if (done)
          break;
        value && chunks.push(value);
      }
      return Buffer.concat(chunks).toString(encoding);
    }
    var createReadableStreamFromReadable2 = (source) => {
      let pump = new StreamPump(source);
      return new ReadableStream(pump, pump);
    }, StreamPump = class {
      constructor(stream) {
        this.highWaterMark = stream.readableHighWaterMark || new node_stream.Stream.Readable().readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      size(chunk) {
        return chunk?.byteLength || 0;
      }
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    };
    exports.createReadableStreamFromReadable = createReadableStreamFromReadable2;
    exports.readableStreamToString = readableStreamToString;
    exports.writeAsyncIterableToWritable = writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = writeReadableStreamToWritable;
  }
});

// node_modules/@remix-run/node/dist/upload/fileUploadHandler.js
var require_fileUploadHandler = __commonJS({
  "node_modules/@remix-run/node/dist/upload/fileUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto2 = __require("node:crypto"), node_fs = __require("node:fs"), promises = __require("node:fs/promises"), node_os = __require("node:os"), path = __require("node:path"), node_stream = __require("node:stream"), node_util = __require("node:util"), serverRuntime = (init_esm(), __toCommonJS(esm_exports)), streamSlice = __require("stream-slice"), stream = require_stream2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var streamSlice__namespace = /* @__PURE__ */ _interopNamespace(streamSlice), defaultFilePathResolver = ({
      filename
    }) => {
      let ext = filename ? path.extname(filename) : "";
      return "upload_" + crypto2.randomBytes(4).readUInt32LE(0) + ext;
    };
    async function uniqueFile(filepath) {
      let ext = path.extname(filepath), uniqueFilepath = filepath;
      for (let i = 1; await promises.stat(uniqueFilepath).then(() => !0).catch(() => !1); i++)
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${(/* @__PURE__ */ new Date()).getTime()}${ext}`;
      return uniqueFilepath;
    }
    function createFileUploadHandler({
      directory = node_os.tmpdir(),
      avoidFileConflicts = !0,
      file = defaultFilePathResolver,
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        name,
        filename,
        contentType,
        data: data3
      }) => {
        if (!filename || filter && !await filter({
          name,
          filename,
          contentType
        }))
          return;
        let dir = typeof directory == "string" ? directory : directory({
          name,
          filename,
          contentType
        });
        if (!dir)
          return;
        let filedir = path.resolve(dir), path$1 = typeof file == "string" ? file : file({
          name,
          filename,
          contentType
        });
        if (!path$1)
          return;
        let filepath = path.resolve(filedir, path$1);
        avoidFileConflicts && (filepath = await uniqueFile(filepath)), await promises.mkdir(path.dirname(filepath), {
          recursive: !0
        }).catch(() => {
        });
        let writeFileStream = node_fs.createWriteStream(filepath), size2 = 0, deleteFile = !1;
        try {
          for await (let chunk of data3) {
            if (size2 += chunk.byteLength, size2 > maxPartSize)
              throw deleteFile = !0, new serverRuntime.MaxPartSizeExceededError(name, maxPartSize);
            writeFileStream.write(chunk);
          }
        } finally {
          writeFileStream.end(), await node_util.promisify(node_stream.finished)(writeFileStream), deleteFile && await promises.rm(filepath).catch(() => {
          });
        }
        return new NodeOnDiskFile(filepath, contentType);
      };
    }
    var NodeOnDiskFile = class {
      lastModified = 0;
      webkitRelativePath = "";
      // TODO: remove this property once TS fixed File class regression
      //  https://github.com/microsoft/TypeScript/issues/52166
      prototype = File.prototype;
      constructor(filepath, type, slicer) {
        this.filepath = filepath, this.type = type, this.slicer = slicer, this.name = path.basename(filepath);
      }
      get size() {
        let stats = node_fs.statSync(this.filepath);
        if (this.slicer) {
          let slice = this.slicer.end - this.slicer.start;
          return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
      }
      slice(start, end, type) {
        var _this$slicer;
        typeof start == "number" && start < 0 && (start = this.size + start), typeof end == "number" && end < 0 && (end = this.size + end);
        let startOffset = ((_this$slicer = this.slicer) === null || _this$slicer === void 0 ? void 0 : _this$slicer.start) || 0;
        return start = startOffset + (start || 0), end = startOffset + (end || this.size), new NodeOnDiskFile(
          this.filepath,
          typeof type == "string" ? type : this.type,
          {
            start,
            end
          }
          // TODO: remove this typecast once TS fixed File class regression
          //  https://github.com/microsoft/TypeScript/issues/52166
        );
      }
      async arrayBuffer() {
        let stream2 = node_fs.createReadStream(this.filepath);
        return this.slicer && (stream2 = stream2.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), new Promise((resolve, reject) => {
          let buf = [];
          stream2.on("data", (chunk) => buf.push(chunk)), stream2.on("end", () => resolve(Buffer.concat(buf))), stream2.on("error", (err) => reject(err));
        });
      }
      stream() {
        let stream$1 = node_fs.createReadStream(this.filepath);
        return this.slicer && (stream$1 = stream$1.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), stream.createReadableStreamFromReadable(stream$1);
      }
      async text() {
        return stream.readableStreamToString(this.stream());
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      remove() {
        return promises.unlink(this.filepath);
      }
      getFilePath() {
        return this.filepath;
      }
    };
    exports.NodeOnDiskFile = NodeOnDiskFile;
    exports.createFileUploadHandler = createFileUploadHandler;
  }
});

// node_modules/@remix-run/node/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/node/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var globals = require_globals(), fileStorage = require_fileStorage(), fileUploadHandler = require_fileUploadHandler(), implementations = require_implementations(), stream = require_stream2(), serverRuntime = (init_esm(), __toCommonJS(esm_exports));
    exports.installGlobals = globals.installGlobals;
    exports.createFileSessionStorage = fileStorage.createFileSessionStorage;
    exports.NodeOnDiskFile = fileUploadHandler.NodeOnDiskFile;
    exports.unstable_createFileUploadHandler = fileUploadHandler.createFileUploadHandler;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    exports.createReadableStreamFromReadable = stream.createReadableStreamFromReadable;
    exports.readableStreamToString = stream.readableStreamToString;
    exports.writeAsyncIterableToWritable = stream.writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = stream.writeReadableStreamToWritable;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "broadcastDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.broadcastDevReady;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "data", {
      enumerable: !0,
      get: function() {
        return serverRuntime.data;
      }
    });
    Object.defineProperty(exports, "defer", {
      enumerable: !0,
      get: function() {
        return serverRuntime.defer;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "logDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.logDevReady;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "redirectDocument", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirectDocument;
      }
    });
    Object.defineProperty(exports, "replace", {
      enumerable: !0,
      get: function() {
        return serverRuntime.replace;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      return a === null || typeof a != "object" ? null : (a = z && a[z] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var B = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = !0;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (b != null)
        for (d in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (g === 1)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          c[d] === void 0 && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === l;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      (k === "undefined" || k === "boolean") && (a = null);
      var h = !1;
      if (a === null)
        h = !0;
      else
        switch (k) {
          case "string":
          case "number":
            h = !0;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = !0;
            }
        }
      if (h)
        return h = a, c = c(h), a = d === "" ? "." + Q(h, 0) : d, I(c) ? (e = "", a != null && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : c != null && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      if (h = 0, d = d === "" ? "." : d + ":", I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), typeof f == "function")
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if (k === "object")
        throw b = String(a), Error("Objects are not valid as a React child (found: " + (b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (a == null)
        return a;
      var d = [], c = 0;
      return R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      }), d;
    }
    function T(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b(), b.then(function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 1, a._result = b2);
        }, function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 2, a._result = b2);
        }), a._status === -1 && (a._status = 0, a._result = b);
      }
      if (a._status === 1)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    function X() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      return S(a, function() {
        b++;
      }), b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.act = X;
    exports.cloneElement = function(a, b, e) {
      if (a == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (k = b.ref, h = K.current), b.key !== void 0 && (c = "" + b.key), a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      return a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: t, _context: a }, a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: b === void 0 ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = X;
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.3.1";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_production_min();
  }
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
    "use strict";
    var aa = require_react(), ca = __require("scheduler");
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b) {
      ha(a, b), ha(a + "Capture", b);
    }
    function ha(a, b) {
      for (ea[a] = b, a = 0; a < b.length; a++)
        da.add(b[a]);
    }
    var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      return ja.call(ma, a) ? !0 : ja.call(la, a) ? !1 : ka.test(a) ? ma[a] = !0 : (la[a] = !0, !1);
    }
    function pa(a, b, c, d) {
      if (c !== null && c.type === 0)
        return !1;
      switch (typeof b) {
        case "function":
        case "symbol":
          return !0;
        case "boolean":
          return d ? !1 : c !== null ? !c.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
        default:
          return !1;
      }
    }
    function qa(a, b, c, d) {
      if (b === null || typeof b > "u" || pa(a, b, c, d))
        return !0;
      if (d)
        return !1;
      if (c !== null)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return b === !1;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return !1;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = e, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = f, this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      (e !== null ? e.type !== 0 : d || !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N") && (qa(b, c, e, d) && (c = null), d || e === null ? oa(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === !0 ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var Ia = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.cache");
    Symbol.for("react.tracing_marker");
    var Ja = Symbol.iterator;
    function Ka(a) {
      return a === null || typeof a != "object" ? null : (a = Ja && a[Ja] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (La === void 0)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
      return `
` + La + a;
    }
    var Na = !1;
    function Oa(a, b) {
      if (!a || Na)
        return "";
      Na = !0;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && typeof l.stack == "string") {
          for (var e = l.stack.split(`
`), f = d.stack.split(`
`), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
            h--;
          for (; 1 <= g && 0 <= h; g--, h--)
            if (e[g] !== f[h]) {
              if (g !== 1 || h !== 1)
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = `
` + e[g].replace(" at new ", " at ");
                    return a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName)), k;
                  }
                while (1 <= g && 0 <= h);
              break;
            }
        }
      } finally {
        Na = !1, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, !1), a;
        case 11:
          return a = Oa(a.type.render, !1), a;
        case 1:
          return a = Oa(a.type, !0), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case Ga:
            return b = a.displayName || null, b !== null ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload, a = a._init;
            try {
              return Qa(a(b));
            } catch {
            }
        }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof b == "function")
            return b.displayName || b.name || null;
          if (typeof b == "string")
            return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
        var e = c.get, f = c.set;
        return Object.defineProperty(a, b, { configurable: !0, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2, f.call(this, a2);
        } }), Object.defineProperty(a, b, { enumerable: c.enumerable }), { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null, delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return !1;
      var b = a._valueTracker;
      if (!b)
        return !0;
      var c = b.getValue(), d = "";
      return a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value), a = d, a !== c ? (b.setValue(a), !0) : !1;
    }
    function Xa(a) {
      if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
        return null;
      try {
        return a.activeElement || a.body;
      } catch {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c ?? a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
      c = Sa(b.value != null ? b.value : c), a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
    }
    function ab(a, b) {
      b = b.checked, b != null && ta(a, "checked", b, !1);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (c != null)
        d === "number" ? (c === 0 && a.value === "" || a.value != c) && (a.value = "" + c) : a.value !== "" + c && (a.value = "" + c);
      else if (d === "submit" || d === "reset") {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue)), b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
    }
    function db2(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
          return;
        b = "" + a._wrapperState.initialValue, c || b === a.value || (a.value = b), a.defaultValue = b;
      }
      c = a.name, c !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, c !== "" && (a.name = c);
    }
    function cb(a, b, c) {
      (b !== "number" || Xa(a.ownerDocument) !== a) && (c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c));
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      if (a = a.options, b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = !0;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
      } else {
        for (c = "" + Sa(c), b = null, e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = !0, d && (a[e].defaultSelected = !0);
            return;
          }
          b !== null || a[e].disabled || (b = a[e]);
        }
        b !== null && (b.selected = !0);
      }
    }
    function gb(a, b) {
      if (b.dangerouslySetInnerHTML != null)
        throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (c == null) {
        if (c = b.children, b = b.defaultValue, c != null) {
          if (b != null)
            throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length)
              throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        b == null && (b = ""), c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c)), d != null && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return a == null || a === "http://www.w3.org/1999/xhtml" ? kb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
        a.innerHTML = b;
      else {
        for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>", b = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && c.nodeType === 3) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return b == null || typeof b == "boolean" || b === "" ? "" : c || typeof b != "number" || b === 0 || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = c.indexOf("--") === 0, e = rb(c, b[c], d);
          c === "float" && (c = "cssFloat"), d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var tb = A({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
          throw Error(p(137, a));
        if (b.dangerouslySetInnerHTML != null) {
          if (b.children != null)
            throw Error(p(60));
          if (typeof b.dangerouslySetInnerHTML != "object" || !("__html" in b.dangerouslySetInnerHTML))
            throw Error(p(61));
        }
        if (b.style != null && typeof b.style != "object")
          throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (a.indexOf("-") === -1)
        return typeof b.is == "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var wb = null;
    function xb(a) {
      return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if (typeof yb != "function")
          throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        if (Ab = zb = null, Bb(a), b)
          for (a = 0; a < b.length; a++)
            Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = !1;
    function Jb(a, b, c) {
      if (Ib)
        return a(b, c);
      Ib = !0;
      try {
        return Gb(a, b, c);
      } finally {
        Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb());
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (c === null)
        return null;
      var d = Db(c);
      if (d === null)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !d;
            break a;
          default:
            a = !1;
        }
      if (a)
        return null;
      if (c && typeof c != "function")
        throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = !1;
    if (ia)
      try {
        Mb = {}, Object.defineProperty(Mb, "passive", { get: function() {
          Lb = !0;
        } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
      } catch {
        Lb = !1;
      }
    var Mb;
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function(a) {
      Ob = !0, Pb = a;
    } };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = !1, Pb = null, Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      if (Tb.apply(this, arguments), Ob) {
        if (Ob) {
          var l = Pb;
          Ob = !1, Pb = null;
        } else
          throw Error(p(198));
        Qb || (Qb = !0, Rb = l);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, b.flags & 4098 && (c = b.return), a = b.return;
        while (a);
      }
      return b.tag === 3 ? c : null;
    }
    function Wb(a) {
      if (a.tag === 13) {
        var b = a.memoizedState;
        if (b === null && (a = a.alternate, a !== null && (b = a.memoizedState)), b !== null)
          return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        if (b = Vb(a), b === null)
          throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (e === null)
          break;
        var f = e.alternate;
        if (f === null) {
          if (d = e.return, d !== null) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c)
              return Xb(e), a;
            if (f === d)
              return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return)
          c = e, d = f;
        else {
          for (var g = !1, h = e.child; h; ) {
            if (h === c) {
              g = !0, c = e, d = f;
              break;
            }
            if (h === d) {
              g = !0, d = e, c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = !0, c = f, d = e;
                break;
              }
              if (h === d) {
                g = !0, d = f, c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g)
              throw Error(p(189));
          }
        }
        if (c.alternate !== d)
          throw Error(p(190));
      }
      if (c.tag !== 3)
        throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      return a = Yb(a), a !== null ? $b(a) : null;
    }
    function $b(a) {
      if (a.tag === 5 || a.tag === 6)
        return a;
      for (a = a.child; a !== null; ) {
        var b = $b(a);
        if (b !== null)
          return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
          lc.onCommitFiberRoot(kc, a, void 0, (a.current.flags & 128) === 128);
        } catch {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (c === 0)
        return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (g !== 0) {
        var h = g & ~e;
        h !== 0 ? d = tc(h) : (f &= g, f !== 0 && (d = tc(f)));
      } else
        g = c & ~e, g !== 0 ? d = tc(g) : f !== 0 && (d = tc(f));
      if (d === 0)
        return 0;
      if (b !== 0 && b !== d && !(b & e) && (e = d & -d, f = b & -b, e >= f || e === 16 && (f & 4194240) !== 0))
        return b;
      if (d & 4 && (d |= c & 16), b = a.entangledLanes, b !== 0)
        for (a = a.entanglements, b &= d; 0 < b; )
          c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        k === -1 ? (!(h & c) || h & d) && (e[g] = vc(h, b)) : k <= b && (a.expiredLanes |= h), f &= ~h;
      }
    }
    function xc(a) {
      return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      return rc <<= 1, !(rc & 4194240) && (rc = 64), a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b, b !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, b = 31 - oc(b), a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= b, a.mutableReadLanes &= b, a.entangledLanes &= b, b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0, d[e] = -1, a[e] = -1, c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b), c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      return a === null || a.nativeEvent !== f ? (a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, b !== null && (b = Cb(b), b !== null && Fc(b)), a) : (a.eventSystemFlags |= d, b = a.targetContainers, e !== null && b.indexOf(e) === -1 && b.push(e), a);
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), !0;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), !0;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), !0;
        case "pointerover":
          var f = e.pointerId;
          return Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e)), !0;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
      }
      return !1;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (b !== null) {
        var c = Vb(b);
        if (c !== null) {
          if (b = c.tag, b === 13) {
            if (b = Wb(c), b !== null) {
              a.blockedOn = b, Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (b === 3 && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (c === null) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d, c.target.dispatchEvent(d), wb = null;
        } else
          return b = Cb(c), b !== null && Fc(b), a.blockedOn = c, !1;
        b.shift();
      }
      return !0;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      for (Lc !== null && ad(Lc, a), Mc !== null && ad(Mc, a), Nc !== null && ad(Nc, a), Oc.forEach(b), Pc.forEach(b), c = 0; c < Qc.length; c++)
        d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], c.blockedOn === null); )
        Vc(c), c.blockedOn === null && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = !0;
    function ed(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (e === null)
          hd(a, b, d, id, c), Sc(a, d);
        else if (Uc(e, a, b, c, d))
          d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; e !== null; ) {
            var f = Cb(e);
            if (f !== null && Ec(f), f = Yc(a, b, c, d), f === null && hd(a, b, d, id, c), f === e)
              break;
            e = f;
          }
          e !== null && d.stopPropagation();
        } else
          hd(a, b, d, null, c);
      }
    }
    var id = null;
    function Yc(a, b, c, d) {
      if (id = null, a = xb(d), a = Wc(a), a !== null)
        if (b = Vb(a), b === null)
          a = null;
        else if (c = b.tag, c === 13) {
          if (a = Wb(b), a !== null)
            return a;
          a = null;
        } else if (c === 3) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return b.tag === 3 ? b.stateNode.containerInfo : null;
          a = null;
        } else
          b !== a && (a = null);
      return id = a, null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
        ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      return "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
    }
    function pd() {
      return !0;
    }
    function qd() {
      return !1;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2, this._targetInst = e, this.type = d, this.nativeEvent = f, this.target = g, this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        return this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this;
      }
      return A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = !0;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue != "unknown" && (a2.returnValue = !1), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble != "unknown" && (a2.cancelBubble = !0), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd }), b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      return "movementX" in a ? a.movementX : (a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a), wd);
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if (b !== "Unidentified")
          return b;
      }
      return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return a.type === "keypress" ? od(a) : 0;
    }, keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }, which: function(a) {
      return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = !1;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return $d.indexOf(b.keyCode) !== -1;
        case "keydown":
          return b.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function he(a) {
      return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
    }
    var ie = !1;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          return b.which !== 32 ? null : (fe = !0, ee);
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie)
        return a === "compositionend" || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && b.locale !== "ko" ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b === "input" ? !!le[a.type] : b === "textarea";
    }
    function ne(a, b, c, d) {
      Eb(d), b = oe(b, "onChange"), 0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b))
        return a;
    }
    function ve(a, b) {
      if (a === "change")
        return b;
    }
    var we = !1;
    ia && (ia ? (ye = "oninput" in document, ye || (ze = document.createElement("div"), ze.setAttribute("oninput", "return;"), ye = typeof ze.oninput == "function"), xe = ye) : xe = !1, we = xe && (!document.documentMode || 9 < document.documentMode));
    var xe, ye, ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if (a.propertyName === "value" && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a)), Jb(re, b);
      }
    }
    function Ce(a, b, c) {
      a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
    }
    function De(a) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return te(qe);
    }
    function Ee(a, b) {
      if (a === "click")
        return te(b);
    }
    function Fe(a, b) {
      if (a === "input" || a === "change")
        return te(b);
    }
    function Ge(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = typeof Object.is == "function" ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b))
        return !0;
      if (typeof a != "object" || a === null || typeof b != "object" || b === null)
        return !1;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return !1;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e]))
          return !1;
      }
      return !0;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (c.nodeType === 3) {
          if (d = a + c.textContent.length, a <= b && d >= b)
            return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? !0 : a && a.nodeType === 3 ? !1 : b && b.nodeType === 3 ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = typeof b.contentWindow.location.href == "string";
        } catch {
          c = !1;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
    }
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (d !== null && Ne(c)) {
          if (b = d.start, a = d.end, a === void 0 && (a = b), "selectionStart" in c)
            c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = d.end === void 0 ? f : Math.min(d.end, e), !a.extend && f > d && (e = d, d = f, f = e), e = Ke(c, f);
            var g = Ke(
              c,
              d
            );
            e && g && (a.rangeCount !== 1 || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        for (b = [], a = c; a = a.parentNode; )
          a.nodeType === 1 && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        for (typeof c.focus == "function" && c.focus(), c = 0; c < b.length; c++)
          a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = !1;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
      Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a, b) {
      var c = {};
      return c[a.toLowerCase()] = b.toLowerCase(), c["Webkit" + a] = "webkit" + b, c["Moz" + a] = "moz" + b, c;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b = We[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Ye)
          return Xe[a] = b[c];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b), fa(b, [a]);
    }
    for (gf = 0; gf < ef.length; gf++)
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1), ff(jf, "on" + kf);
    var hf, jf, kf, gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c, Ub(d, b, void 0, a), a.currentTarget = null;
    }
    function se(a, b) {
      b = (b & 4) !== 0;
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              if (h = h.listener, k !== f && e.isPropagationStopped())
                break a;
              nf(e, h, l), f = k;
            }
          else
            for (g = 0; g < d.length; g++) {
              if (h = d[g], k = h.instance, l = h.currentTarget, h = h.listener, k !== f && e.isPropagationStopped())
                break a;
              nf(e, h, l), f = k;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = !1, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      c === void 0 && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, !1), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4), pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = !0, da.forEach(function(b2) {
          b2 !== "selectionchange" && (mf.has(b2) || qf(b2, !1, a), qf(b2, !0, a));
        });
        var b = a.nodeType === 9 ? a : a.ownerDocument;
        b === null || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a), e = void 0, !Lb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = !0), d ? e !== void 0 ? a.addEventListener(b, c, { capture: !0, passive: e }) : a.addEventListener(b, c, !0) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, !1);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (!(b & 1) && !(b & 2) && d !== null)
        a:
          for (; ; ) {
            if (d === null)
              return;
            var g = d.tag;
            if (g === 3 || g === 4) {
              var h = d.stateNode.containerInfo;
              if (h === e || h.nodeType === 8 && h.parentNode === e)
                break;
              if (g === 4)
                for (g = d.return; g !== null; ) {
                  var k = g.tag;
                  if ((k === 3 || k === 4) && (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e))
                    return;
                  g = g.return;
                }
              for (; h !== null; ) {
                if (g = Wc(h), g === null)
                  return;
                if (k = g.tag, k === 5 || k === 6) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
      Jb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (h2 !== void 0) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (od(c) === 0)
                  break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus", k2 = Fd;
                break;
              case "focusout":
                n = "blur", k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (c.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = (b & 4) !== 0, J = !t && a === "scroll", x = t ? h2 !== null ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d2, u; w !== null; ) {
              u = w;
              var F = u.stateNode;
              if (u.tag === 5 && F !== null && (u = F, x !== null && (F = Kb(w, x), F != null && t.push(tf(w, F, u)))), J)
                break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (!(b & 7)) {
          a: {
            if (h2 = a === "mouseover" || a === "pointerover", k2 = a === "mouseout" || a === "pointerout", h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf]))
              break a;
            if ((k2 || h2) && (h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window, k2 ? (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, n !== null && (J = Vb(n), n !== J || n.tag !== 5 && n.tag !== 6) && (n = null)) : (k2 = null, n = d2), k2 !== n)) {
              if (t = Bd, F = "onMouseLeave", x = "onMouseEnter", w = "mouse", (a === "pointerout" || a === "pointerover") && (t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer"), J = k2 == null ? h2 : ue(k2), u = n == null ? h2 : ue(n), h2 = new t(F, w + "leave", k2, c, e2), h2.target = J, h2.relatedTarget = u, F = null, Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t), J = F, k2 && n)
                b: {
                  for (t = k2, x = n, w = 0, u = t; u; u = vf(u))
                    w++;
                  for (u = 0, F = x; F; F = vf(F))
                    u++;
                  for (; 0 < w - u; )
                    t = vf(t), w--;
                  for (; 0 < u - w; )
                    x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || x !== null && t === x.alternate)
                      break b;
                    t = vf(t), x = vf(x);
                  }
                  t = null;
                }
              else
                t = null;
              k2 !== null && wf(g2, h2, k2, t, !1), n !== null && J !== null && wf(g2, J, n, t, !0);
            }
          }
          a: {
            if (h2 = d2 ? ue(d2) : window, k2 = h2.nodeName && h2.nodeName.toLowerCase(), k2 === "select" || k2 === "input" && h2.type === "file")
              var na = ve;
            else if (me(h2))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k2 = h2.nodeName) && k2.toLowerCase() === "input" && (h2.type === "checkbox" || h2.type === "radio") && (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2), a === "focusout" && (xa = h2._wrapperState) && xa.controlled && h2.type === "number" && cb(h2, "number", h2.value);
          }
          switch (xa = d2 ? ue(d2) : window, a) {
            case "focusin":
              (me(xa) || xa.contentEditable === "true") && (Qe = xa, Re = d2, Se = null);
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = !1, Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c) && (ba = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (ba = "onCompositionStart");
          ba && (de && c.locale !== "ko" && (ie || ba !== "onCompositionStart" ? ba === "onCompositionEnd" && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), $a !== null && (ba.data = $a)))), ($a = ce ? je(a, c) : ke(a, c)) && (d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a));
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; a !== null; ) {
        var e = a, f = e.stateNode;
        e.tag === 5 && f !== null && (e = f, f = Kb(a, c), f != null && d.unshift(tf(a, f, e)), f = Kb(a, b), f != null && d.push(tf(a, f, e))), a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== 5);
      return a || null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; c !== null && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (k !== null && k === d)
          break;
        h.tag === 5 && l !== null && (h = l, e ? (k = Kb(c, f), k != null && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), k != null && g.push(tf(c, k, h)))), c = c.return;
      }
      g.length !== 0 && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return (typeof a == "string" ? a : "" + a).replace(xf, `
`).replace(yf, "");
    }
    function Af(a, b, c) {
      if (b = zf(b), zf(a) !== b && c)
        throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b) {
      return a === "textarea" || a === "noscript" || typeof b.children == "string" || typeof b.children == "number" || typeof b.dangerouslySetInnerHTML == "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
    }
    var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        if (a.removeChild(c), e && e.nodeType === 8)
          if (c = e.data, c === "/$") {
            if (d === 0) {
              a.removeChild(e), bd(b);
              return;
            }
            d--;
          } else
            c !== "$" && c !== "$?" && c !== "$!" || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; a != null; a = a.nextSibling) {
        var b = a.nodeType;
        if (b === 1 || b === 3)
          break;
        if (b === 8) {
          if (b = a.data, b === "$" || b === "$!" || b === "$?")
            break;
          if (b === "/$")
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "$" || c === "$!" || c === "$?") {
            if (b === 0)
              return a;
            b--;
          } else
            c === "/$" && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          if (c = b.alternate, b.child !== null || c !== null && c.child !== null)
            for (a = Mf(a); a !== null; ) {
              if (c = a[Of])
                return c;
              a = Mf(a);
            }
          return b;
        }
        a = c, c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      return a = a[Of] || a[uf], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
    }
    function ue(a) {
      if (a.tag === 5 || a.tag === 6)
        return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++, Sf[Tf] = a.current, a.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(!1), Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c)
        e[f] = b[f];
      return d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e), e;
    }
    function Zf(a) {
      return a = a.childContextTypes, a != null;
    }
    function $f() {
      E(Wf), E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf)
        throw Error(p(168));
      G(H, b), G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      if (b = b.childContextTypes, typeof d.getChildContext != "function")
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in b))
          throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, a), G(Wf, Wf.current), !0;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf), G(Wf, c);
    }
    var eg = null, fg = !1, gg = !1;
    function hg(a) {
      eg === null ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = !0, hg(a);
    }
    function jg() {
      if (!gg && eg !== null) {
        gg = !0;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(!0);
            while (d !== null);
          }
          eg = null, fg = !1;
        } catch (e) {
          throw eg !== null && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = !1;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b) {
      kg[lg++] = ng, kg[lg++] = mg, mg = a, ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e), c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32), d >>= g, e -= g, rg = 1 << 32 - oc(b) + e | c << e | d, sg = f + a;
      } else
        rg = 1 << f | c << e | d, sg = a;
    }
    function vg(a) {
      a.return !== null && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = !1, zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED", c.stateNode = b, c.return = a, b = a.deletions, b === null ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          return b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
        case 6:
          return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
        case 13:
          return b = b.nodeType !== 8 ? null : b, b !== null ? (c = qg !== null ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
        default:
          return !1;
      }
    }
    function Dg(a) {
      return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a))
              throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p(418));
          a.flags = a.flags & -4097 | 2, I = !1, xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return !1;
      if (!I)
        return Fg(a), I = !0, !1;
      var b;
      if ((b = a.tag !== 3) && !(b = a.tag !== 5) && (b = a.type, b = b !== "head" && b !== "body" && !Ef(a.type, a.memoizedProps)), b && (b = yg)) {
        if (Dg(a))
          throw Hg(), Error(p(418));
        for (; b; )
          Ag(a, b), b = Lf(b.nextSibling);
      }
      if (Fg(a), a.tag === 13) {
        if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
          throw Error(p(317));
        a: {
          for (a = a.nextSibling, b = 0; a; ) {
            if (a.nodeType === 8) {
              var c = a.data;
              if (c === "/$") {
                if (b === 0) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else
                c !== "$" && c !== "$!" && c !== "$?" || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return !0;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null, I = !1;
    }
    function Jg(a) {
      zg === null ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b, c) {
      if (a = c.ref, a !== null && typeof a != "function" && typeof a != "object") {
        if (c._owner) {
          if (c = c._owner, c) {
            if (c.tag !== 1)
              throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(p(147, a));
          var e = d, f = "" + a;
          return b !== null && b.ref !== null && typeof b.ref == "function" && b.ref._stringRef === f ? b.ref : (b = function(a2) {
            var b2 = e.refs;
            a2 === null ? delete b2[f] : b2[f] = a2;
          }, b._stringRef = f, b);
        }
        if (typeof a != "string")
          throw Error(p(284));
        if (!c._owner)
          throw Error(p(290, a));
      }
      return a;
    }
    function Mg(a, b) {
      throw a = Object.prototype.toString.call(b), Error(p(31, a === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function Ng(a) {
      var b = a._init;
      return b(a._payload);
    }
    function Og(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          d2 === null ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a)
          return null;
        for (; d2 !== null; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); b2 !== null; )
          b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        return a2 = Pg(a2, b2), a2.index = 0, a2.sibling = null, a2;
      }
      function f(b2, c2, d2) {
        return b2.index = d2, a ? (d2 = b2.alternate, d2 !== null ? (d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2) : (b2.flags |= 2, c2)) : (b2.flags |= 1048576, c2);
      }
      function g(b2) {
        return a && b2.alternate === null && (b2.flags |= 2), b2;
      }
      function h(a2, b2, c2, d2) {
        return b2 === null || b2.tag !== 6 ? (b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        return f2 === ya ? m(a2, b2, c2.props.children, d2, c2.key) : b2 !== null && (b2.elementType === f2 || typeof f2 == "object" && f2 !== null && f2.$$typeof === Ha && Ng(f2) === b2.type) ? (d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2) : (d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2);
      }
      function l(a2, b2, c2, d2) {
        return b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation ? (b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2.children || []), b2.return = a2, b2);
      }
      function m(a2, b2, c2, d2, f2) {
        return b2 === null || b2.tag !== 7 ? (b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
      }
      function q(a2, b2, c2) {
        if (typeof b2 == "string" && b2 !== "" || typeof b2 == "number")
          return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
        if (typeof b2 == "object" && b2 !== null) {
          switch (b2.$$typeof) {
            case va:
              return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2))
            return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Mg(a2, b2);
        }
        return null;
      }
      function r(a2, b2, c2, d2) {
        var e2 = b2 !== null ? b2.key : null;
        if (typeof c2 == "string" && c2 !== "" || typeof c2 == "number")
          return e2 !== null ? null : h(a2, b2, "" + c2, d2);
        if (typeof c2 == "object" && c2 !== null) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka(c2))
            return e2 !== null ? null : m(a2, b2, c2, d2, null);
          Mg(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if (typeof d2 == "string" && d2 !== "" || typeof d2 == "number")
          return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if (typeof d2 == "object" && d2 !== null) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, k(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2))
            return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; u !== null && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r(e2, u, h2[w], k2);
          if (n2 === null) {
            u === null && (u = x);
            break;
          }
          a && u && n2.alternate === null && b(e2, u), g2 = f(n2, g2, w), m2 === null ? l2 = n2 : m2.sibling = n2, m2 = n2, u = x;
        }
        if (w === h2.length)
          return c(e2, u), I && tg(e2, w), l2;
        if (u === null) {
          for (; w < h2.length; w++)
            u = q(e2, h2[w], k2), u !== null && (g2 = f(u, g2, w), m2 === null ? l2 = u : m2.sibling = u, m2 = u);
          return I && tg(e2, w), l2;
        }
        for (u = d(e2, u); w < h2.length; w++)
          x = y(u, e2, w, h2[w], k2), x !== null && (a && x.alternate !== null && u.delete(x.key === null ? w : x.key), g2 = f(x, g2, w), m2 === null ? l2 = x : m2.sibling = x, m2 = x);
        return a && u.forEach(function(a2) {
          return b(e2, a2);
        }), I && tg(e2, w), l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if (typeof l2 != "function")
          throw Error(p(150));
        if (h2 = l2.call(h2), h2 == null)
          throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); m2 !== null && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r(e2, m2, n2.value, k2);
          if (t2 === null) {
            m2 === null && (m2 = x);
            break;
          }
          a && m2 && t2.alternate === null && b(e2, m2), g2 = f(t2, g2, w), u === null ? l2 = t2 : u.sibling = t2, u = t2, m2 = x;
        }
        if (n2.done)
          return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
        if (m2 === null) {
          for (; !n2.done; w++, n2 = h2.next())
            n2 = q(e2, n2.value, k2), n2 !== null && (g2 = f(n2, g2, w), u === null ? l2 = n2 : u.sibling = n2, u = n2);
          return I && tg(e2, w), l2;
        }
        for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next())
          n2 = y(m2, e2, w, n2.value, k2), n2 !== null && (a && n2.alternate !== null && m2.delete(n2.key === null ? w : n2.key), g2 = f(n2, g2, w), u === null ? l2 = n2 : u.sibling = n2, u = n2);
        return a && m2.forEach(function(a2) {
          return b(e2, a2);
        }), I && tg(e2, w), l2;
      }
      function J(a2, d2, f2, h2) {
        if (typeof f2 == "object" && f2 !== null && f2.type === ya && f2.key === null && (f2 = f2.props.children), typeof f2 == "object" && f2 !== null) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; l2 !== null; ) {
                  if (l2.key === k2) {
                    if (k2 = f2.type, k2 === ya) {
                      if (l2.tag === 7) {
                        c(a2, l2.sibling), d2 = e(l2, f2.props.children), d2.return = a2, a2 = d2;
                        break a;
                      }
                    } else if (l2.elementType === k2 || typeof k2 == "object" && k2 !== null && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                      c(a2, l2.sibling), d2 = e(l2, f2.props), d2.ref = Lg(a2, l2, f2), d2.return = a2, a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else
                    b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; d2 !== null; ) {
                  if (d2.key === l2)
                    if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling), d2 = e(d2, f2.children || []), d2.return = a2, a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else
                    b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f2, a2.mode, h2), d2.return = a2, a2 = d2;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2))
            return n(a2, d2, f2, h2);
          if (Ka(f2))
            return t(a2, d2, f2, h2);
          Mg(a2, f2);
        }
        return typeof f2 == "string" && f2 !== "" || typeof f2 == "number" ? (f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J;
    }
    var Ug = Og(!0), Vg = Og(!1), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a) {
      var b = Wg.current;
      E(Wg), a._currentValue = b;
    }
    function bh(a, b, c) {
      for (; a !== null; ) {
        var d = a.alternate;
        if ((a.childLanes & b) !== b ? (a.childLanes |= b, d !== null && (d.childLanes |= b)) : d !== null && (d.childLanes & b) !== b && (d.childLanes |= b), a === c)
          break;
        a = a.return;
      }
    }
    function ch(a, b) {
      Xg = a, Zg = Yg = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & b && (dh = !0), a.firstContext = null);
    }
    function eh(a) {
      var b = a._currentValue;
      if (Zg !== a)
        if (a = { context: a, memoizedValue: b, next: null }, Yg === null) {
          if (Xg === null)
            throw Error(p(308));
          Yg = a, Xg.dependencies = { lanes: 0, firstContext: a };
        } else
          Yg = Yg.next = a;
      return b;
    }
    var fh = null;
    function gh(a) {
      fh === null ? fh = [a] : fh.push(a);
    }
    function hh(a, b, c, d) {
      var e = b.interleaved;
      return e === null ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c), b.interleaved = c, ih(a, d);
    }
    function ih(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      for (c !== null && (c.lanes |= b), c = a, a = a.return; a !== null; )
        a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
      return c.tag === 3 ? c.stateNode : null;
    }
    var jh = !1;
    function kh(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a, b) {
      a = a.updateQueue, b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function mh(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a, b, c) {
      var d = a.updateQueue;
      if (d === null)
        return null;
      if (d = d.shared, K & 2) {
        var e = d.pending;
        return e === null ? b.next = b : (b.next = e.next, e.next = b), d.pending = b, ih(a, c);
      }
      return e = d.interleaved, e === null ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b), d.interleaved = b, ih(a, c);
    }
    function oh(a, b, c) {
      if (b = b.updateQueue, b !== null && (b = b.shared, (c & 4194240) !== 0)) {
        var d = b.lanes;
        d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
      }
    }
    function ph(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (d !== null && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        if (c = c.firstBaseUpdate, c !== null) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            f === null ? e = f = g : f = f.next = g, c = c.next;
          } while (c !== null);
          f === null ? e = f = b : f = f.next = b;
        } else
          e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects }, a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate, a === null ? c.firstBaseUpdate = b : a.next = b, c.lastBaseUpdate = b;
    }
    function qh(a, b, c, d) {
      var e = a.updateQueue;
      jh = !1;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (h !== null) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null, g === null ? f = l : g.next = l, g = k;
        var m = a.alternate;
        m !== null && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (h === null ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (f !== null) {
        var q = e.baseState;
        g = 0, m = l = k = null, h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d & r) === r) {
            m !== null && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              switch (r = b, y = c, t.tag) {
                case 1:
                  if (n = t.payload, typeof n == "function") {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  if (n = t.payload, r = typeof n == "function" ? n.call(y, q, r) : n, r == null)
                    break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  jh = !0;
              }
            }
            h.callback !== null && h.lane !== 0 && (a.flags |= 64, r = e.effects, r === null ? e.effects = [h] : r.push(h));
          } else
            y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, m === null ? (l = m = y, k = q) : m = m.next = y, g |= r;
          if (h = h.next, h === null) {
            if (h = e.shared.pending, h === null)
              break;
            r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          }
        } while (1);
        if (m === null && (k = q), e.baseState = k, e.firstBaseUpdate = l, e.lastBaseUpdate = m, b = e.shared.interleaved, b !== null) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else
          f === null && (e.shared.lanes = 0);
        rh |= g, a.lanes = g, a.memoizedState = q;
      }
    }
    function sh(a, b, c) {
      if (a = b.effects, b.effects = null, a !== null)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (e !== null) {
            if (d.callback = null, d = c, typeof e != "function")
              throw Error(p(191, e));
            e.call(d);
          }
        }
    }
    var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
    function xh(a) {
      if (a === th)
        throw Error(p(174));
      return a;
    }
    function yh(a, b) {
      switch (G(wh, b), G(vh, a), G(uh, th), a = b.nodeType, a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(uh), G(uh, b);
    }
    function zh() {
      E(uh), E(vh), E(wh);
    }
    function Ah(a) {
      xh(wh.current);
      var b = xh(uh.current), c = lb(b, a.type);
      b !== c && (G(vh, a), G(uh, c));
    }
    function Bh(a) {
      vh.current === a && (E(uh), E(vh));
    }
    var L = Uf(0);
    function Ch(a) {
      for (var b = a; b !== null; ) {
        if (b.tag === 13) {
          var c = b.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
            return b;
        } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
          if (b.flags & 128)
            return b;
        } else if (b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a = 0; a < Dh.length; a++)
        Dh[a]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = !1, Jh = !1, Kh = 0, Lh = 0;
    function P() {
      throw Error(p(321));
    }
    function Mh(a, b) {
      if (b === null)
        return !1;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He(a[c], b[c]))
          return !1;
      return !0;
    }
    function Nh(a, b, c, d, e, f) {
      if (Hh = f, M = b, b.memoizedState = null, b.updateQueue = null, b.lanes = 0, Fh.current = a === null || a.memoizedState === null ? Oh : Ph, a = c(d, e), Jh) {
        f = 0;
        do {
          if (Jh = !1, Kh = 0, 25 <= f)
            throw Error(p(301));
          f += 1, O = N = null, b.updateQueue = null, Fh.current = Qh, a = c(d, e);
        } while (Jh);
      }
      if (Fh.current = Rh, b = N !== null && N.next !== null, Hh = 0, O = N = M = null, Ih = !1, b)
        throw Error(p(300));
      return a;
    }
    function Sh() {
      var a = Kh !== 0;
      return Kh = 0, a;
    }
    function Th() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return O === null ? M.memoizedState = O = a : O = O.next = a, O;
    }
    function Uh() {
      if (N === null) {
        var a = M.alternate;
        a = a !== null ? a.memoizedState : null;
      } else
        a = N.next;
      var b = O === null ? M.memoizedState : O.next;
      if (b !== null)
        O = b, N = a;
      else {
        if (a === null)
          throw Error(p(310));
        N = a, a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null }, O === null ? M.memoizedState = O = a : O = O.next = a;
      }
      return O;
    }
    function Vh(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function Wh(a) {
      var b = Uh(), c = b.queue;
      if (c === null)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = N, e = d.baseQueue, f = c.pending;
      if (f !== null) {
        if (e !== null) {
          var g = e.next;
          e.next = f.next, f.next = g;
        }
        d.baseQueue = e = f, c.pending = null;
      }
      if (e !== null) {
        f = e.next, d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Hh & m) === m)
            k !== null && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            k === null ? (h = k = q, g = d) : k = k.next = q, M.lanes |= m, rh |= m;
          }
          l = l.next;
        } while (l !== null && l !== f);
        k === null ? g = d : k.next = h, He(d, b.memoizedState) || (dh = !0), b.memoizedState = d, b.baseState = g, b.baseQueue = k, c.lastRenderedState = d;
      }
      if (a = c.interleaved, a !== null) {
        e = a;
        do
          f = e.lane, M.lanes |= f, rh |= f, e = e.next;
        while (e !== a);
      } else
        e === null && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function Xh(a) {
      var b = Uh(), c = b.queue;
      if (c === null)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (e !== null) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (dh = !0), b.memoizedState = f, b.baseQueue === null && (b.baseState = f), c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Yh() {
    }
    function Zh(a, b) {
      var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
      if (f && (d.memoizedState = e, dh = !0), d = d.queue, $h(ai.bind(null, c, d, a), [a]), d.getSnapshot !== b || f || O !== null && O.memoizedState.tag & 1) {
        if (c.flags |= 2048, bi(9, ci.bind(null, c, d, e, b), void 0, null), Q === null)
          throw Error(p(349));
        Hh & 30 || di(c, b, e);
      }
      return e;
    }
    function di(a, b, c) {
      a.flags |= 16384, a = { getSnapshot: b, value: c }, b = M.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, c === null ? b.stores = [a] : c.push(a));
    }
    function ci(a, b, c, d) {
      b.value = c, b.getSnapshot = d, ei(b) && fi(a);
    }
    function ai(a, b, c) {
      return c(function() {
        ei(b) && fi(a);
      });
    }
    function ei(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch {
        return !0;
      }
    }
    function fi(a) {
      var b = ih(a, 1);
      b !== null && gi(b, a, 1, -1);
    }
    function hi(a) {
      var b = Th();
      return typeof a == "function" && (a = a()), b.memoizedState = b.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a }, b.queue = a, a = a.dispatch = ii.bind(null, M, a), [b.memoizedState, a];
    }
    function bi(a, b, c, d) {
      return a = { tag: a, create: b, destroy: c, deps: d, next: null }, b = M.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a)), a;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a, b, c, d) {
      var e = Th();
      M.flags |= a, e.memoizedState = bi(1 | b, c, void 0, d === void 0 ? null : d);
    }
    function li(a, b, c, d) {
      var e = Uh();
      d = d === void 0 ? null : d;
      var f = void 0;
      if (N !== null) {
        var g = N.memoizedState;
        if (f = g.destroy, d !== null && Mh(d, g.deps)) {
          e.memoizedState = bi(b, c, f, d);
          return;
        }
      }
      M.flags |= a, e.memoizedState = bi(1 | b, c, f, d);
    }
    function mi(a, b) {
      return ki(8390656, 8, a, b);
    }
    function $h(a, b) {
      return li(2048, 8, a, b);
    }
    function ni(a, b) {
      return li(4, 2, a, b);
    }
    function oi(a, b) {
      return li(4, 4, a, b);
    }
    function pi(a, b) {
      if (typeof b == "function")
        return a = a(), b(a), function() {
          b(null);
        };
      if (b != null)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function qi(a, b, c) {
      return c = c != null ? c.concat([a]) : null, li(4, 4, pi.bind(null, b, a), c);
    }
    function ri() {
    }
    function si(a, b) {
      var c = Uh();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (c.memoizedState = [a, b], a);
    }
    function ti(a, b) {
      var c = Uh();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (a = a(), c.memoizedState = [a, b], a);
    }
    function ui(a, b, c) {
      return Hh & 21 ? (He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = !0), b) : (a.baseState && (a.baseState = !1, dh = !0), a.memoizedState = c);
    }
    function vi(a, b) {
      var c = C;
      C = c !== 0 && 4 > c ? c : 4, a(!0);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a(!1), b();
      } finally {
        C = c, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a, b, c) {
      var d = yi(a);
      if (c = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null }, zi(a))
        Ai(b, c);
      else if (c = hh(a, b, c, d), c !== null) {
        var e = R();
        gi(c, a, d, e), Bi(c, b, d);
      }
    }
    function ii(a, b, c) {
      var d = yi(a), e = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null };
      if (zi(a))
        Ai(b, e);
      else {
        var f = a.alternate;
        if (a.lanes === 0 && (f === null || f.lanes === 0) && (f = b.lastRenderedReducer, f !== null))
          try {
            var g = b.lastRenderedState, h = f(g, c);
            if (e.hasEagerState = !0, e.eagerState = h, He(h, g)) {
              var k = b.interleaved;
              k === null ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e), b.interleaved = e;
              return;
            }
          } catch {
          } finally {
          }
        c = hh(a, b, e, d), c !== null && (e = R(), gi(c, a, d, e), Bi(c, b, d));
      }
    }
    function zi(a) {
      var b = a.alternate;
      return a === M || b !== null && b === M;
    }
    function Ai(a, b) {
      Jh = Ih = !0;
      var c = a.pending;
      c === null ? b.next = b : (b.next = c.next, c.next = b), a.pending = b;
    }
    function Bi(a, b, c) {
      if (c & 4194240) {
        var d = b.lanes;
        d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
      }
    }
    var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: !1 }, Oh = { readContext: eh, useCallback: function(a, b) {
      return Th().memoizedState = [a, b === void 0 ? null : b], a;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
      return c = c != null ? c.concat([a]) : null, ki(
        4194308,
        4,
        pi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ki(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ki(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Th();
      return b = b === void 0 ? null : b, a = a(), c.memoizedState = [a, b], a;
    }, useReducer: function(a, b, c) {
      var d = Th();
      return b = c !== void 0 ? c(b) : b, d.memoizedState = d.baseState = b, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b }, d.queue = a, a = a.dispatch = xi.bind(null, M, a), [d.memoizedState, a];
    }, useRef: function(a) {
      var b = Th();
      return a = { current: a }, b.memoizedState = a;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
      return Th().memoizedState = a;
    }, useTransition: function() {
      var a = hi(!1), b = a[0];
      return a = vi.bind(null, a[1]), Th().memoizedState = a, [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th();
      if (I) {
        if (c === void 0)
          throw Error(p(407));
        c = c();
      } else {
        if (c = b(), Q === null)
          throw Error(p(349));
        Hh & 30 || di(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      return e.queue = f, mi(ai.bind(
        null,
        d,
        f,
        a
      ), [a]), d.flags |= 2048, bi(9, ci.bind(null, d, f, c, b), void 0, null), c;
    }, useId: function() {
      var a = Th(), b = Q.identifierPrefix;
      if (I) {
        var c = sg, d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c, b = ":" + b + "R" + c, c = Kh++, 0 < c && (b += "H" + c.toString(32)), b += ":";
      } else
        c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: !1 }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a) {
        var b = Uh();
        return ui(b, N.memoizedState, a);
      },
      useTransition: function() {
        var a = Wh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: !1
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a) {
      var b = Uh();
      return N === null ? b.memoizedState = a : ui(b, N.memoizedState, a);
    }, useTransition: function() {
      var a = Xh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: !1 };
    function Ci(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Di(a, b, c, d) {
      b = a.memoizedState, c = c(d, b), c = c == null ? b : A({}, b, c), a.memoizedState = c, a.lanes === 0 && (a.updateQueue.baseState = c);
    }
    var Ei = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : !1;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.payload = b, c != null && (f.callback = c), b = nh(a, f, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.tag = 1, f.payload = b, c != null && (f.callback = c), b = nh(a, f, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi(a), e = mh(c, d);
      e.tag = 2, b != null && (e.callback = b), b = nh(a, e, d), b !== null && (gi(b, a, d, c), oh(b, a, d));
    } };
    function Fi(a, b, c, d, e, f, g) {
      return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
    }
    function Gi(a, b, c) {
      var d = !1, e = Vf, f = b.contextType;
      return typeof f == "object" && f !== null ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = d != null) ? Yf(a, e) : Vf), b = new b(c, f), a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, b.updater = Ei, a.stateNode = b, b._reactInternals = a, d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f), b;
    }
    function Hi(a, b, c, d) {
      a = b.state, typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps(c, d), typeof b.UNSAFE_componentWillReceiveProps == "function" && b.UNSAFE_componentWillReceiveProps(c, d), b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a, b, c, d) {
      var e = a.stateNode;
      e.props = c, e.state = a.memoizedState, e.refs = {}, kh(a);
      var f = b.contextType;
      typeof f == "object" && f !== null ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f)), e.state = a.memoizedState, f = b.getDerivedStateFromProps, typeof f == "function" && (Di(a, b, f, c), e.state = a.memoizedState), typeof b.getDerivedStateFromProps == "function" || typeof e.getSnapshotBeforeUpdate == "function" || typeof e.UNSAFE_componentWillMount != "function" && typeof e.componentWillMount != "function" || (b = e.state, typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState), typeof e.componentDidMount == "function" && (a.flags |= 4194308);
    }
    function Ji(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = `
Error generating stack: ` + f.message + `
` + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Ki(a, b, c) {
      return { value: a, source: null, stack: c ?? null, digest: b ?? null };
    }
    function Li(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Mi = typeof WeakMap == "function" ? WeakMap : Map;
    function Ni(a, b, c) {
      c = mh(-1, c), c.tag = 3, c.payload = { element: null };
      var d = b.value;
      return c.callback = function() {
        Oi || (Oi = !0, Pi = d), Li(a, b);
      }, c;
    }
    function Qi(a, b, c) {
      c = mh(-1, c), c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if (typeof d == "function") {
        var e = b.value;
        c.payload = function() {
          return d(e);
        }, c.callback = function() {
          Li(a, b);
        };
      }
      var f = a.stateNode;
      return f !== null && typeof f.componentDidCatch == "function" && (c.callback = function() {
        Li(a, b), typeof d != "function" && (Ri === null ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
      }), c;
    }
    function Si(a, b, c) {
      var d = a.pingCache;
      if (d === null) {
        d = a.pingCache = new Mi();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else
        e = d.get(b), e === void 0 && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
    }
    function Ui(a) {
      do {
        var b;
        if ((b = a.tag === 13) && (b = a.memoizedState, b = b !== null ? b.dehydrated !== null : !0), b)
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function Vi(a, b, c, d, e) {
      return a.mode & 1 ? (a.flags |= 65536, a.lanes = e, a) : (a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a);
    }
    var Wi = ua.ReactCurrentOwner, dh = !1;
    function Xi(a, b, c, d) {
      b.child = a === null ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
    }
    function Yi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      return ch(b, e), d = Nh(a, b, c, d, f, e), c = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I && c && vg(b), b.flags |= 1, Xi(a, b, d, e), b.child);
    }
    function $i(a, b, c, d, e) {
      if (a === null) {
        var f = c.type;
        return typeof f == "function" && !aj(f) && f.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (b.tag = 15, b.type = f, bj(a, b, f, d, e)) : (a = Rg(c.type, null, d, b, b.mode, e), a.ref = b.ref, a.return = b, b.child = a);
      }
      if (f = a.child, !(a.lanes & e)) {
        var g = f.memoizedProps;
        if (c = c.compare, c = c !== null ? c : Ie, c(g, d) && a.ref === b.ref)
          return Zi(a, b, e);
      }
      return b.flags |= 1, a = Pg(f, d), a.ref = b.ref, a.return = b, b.child = a;
    }
    function bj(a, b, c, d, e) {
      if (a !== null) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref)
          if (dh = !1, b.pendingProps = d = f, (a.lanes & e) !== 0)
            a.flags & 131072 && (dh = !0);
          else
            return b.lanes = a.lanes, Zi(a, b, e);
      }
      return cj(a, b, c, d, e);
    }
    function dj(a, b, c) {
      var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
      if (d.mode === "hidden")
        if (!(b.mode & 1))
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (!(c & 1073741824))
            return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = f !== null ? f.baseLanes : c, G(ej, fj), fj |= d;
        }
      else
        f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
      return Xi(a, b, e, c), b.child;
    }
    function gj(a, b) {
      var c = b.ref;
      (a === null && c !== null || a !== null && a.ref !== c) && (b.flags |= 512, b.flags |= 2097152);
    }
    function cj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      return f = Yf(b, f), ch(b, e), c = Nh(a, b, c, d, f, e), d = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I && d && vg(b), b.flags |= 1, Xi(a, b, c, e), b.child);
    }
    function hj(a, b, c, d, e) {
      if (Zf(c)) {
        var f = !0;
        cg(b);
      } else
        f = !1;
      if (ch(b, e), b.stateNode === null)
        ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = !0;
      else if (a === null) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        typeof l == "object" && l !== null ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = typeof m == "function" || typeof g.getSnapshotBeforeUpdate == "function";
        q || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== d || k !== l) && Hi(b, g, d, l), jh = !1;
        var r = b.memoizedState;
        g.state = r, qh(b, d, g, e), k = b.memoizedState, h !== d || r !== k || Wf.current || jh ? (typeof m == "function" && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (b.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), d = !1);
      } else {
        g = b.stateNode, lh(a, b), h = b.memoizedProps, l = b.type === b.elementType ? h : Ci(b.type, h), g.props = l, q = b.pendingProps, r = g.context, k = c.contextType, typeof k == "object" && k !== null ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = typeof y == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== q || r !== k) && Hi(b, g, d, k), jh = !1, r = b.memoizedState, g.state = r, qh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || jh ? (typeof y == "function" && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || !1) ? (m || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(d, n, k), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(d, n, k)), typeof g.componentDidUpdate == "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (b.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
      }
      return jj(a, b, c, d, f, e);
    }
    function jj(a, b, c, d, e, f) {
      gj(a, b);
      var g = (b.flags & 128) !== 0;
      if (!d && !g)
        return e && dg(b, c, !1), Zi(a, b, f);
      d = b.stateNode, Wi.current = b;
      var h = g && typeof c.getDerivedStateFromError != "function" ? null : d.render();
      return b.flags |= 1, a !== null && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f), b.memoizedState = d.state, e && dg(b, c, !0), b.child;
    }
    function kj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1), yh(a, b.containerInfo);
    }
    function lj(a, b, c, d, e) {
      return Ig(), Jg(e), b.flags |= 256, Xi(a, b, c, d), b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function oj(a, b, c) {
      var d = b.pendingProps, e = L.current, f = !1, g = (b.flags & 128) !== 0, h;
      if ((h = g) || (h = a !== null && a.memoizedState === null ? !1 : (e & 2) !== 0), h ? (f = !0, b.flags &= -129) : (a === null || a.memoizedState !== null) && (e |= 1), G(L, e & 1), a === null)
        return Eg(b), a = b.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (b.mode & 1 ? a.data === "$!" ? b.lanes = 8 : b.lanes = 1073741824 : b.lanes = 1, null) : (g = d.children, a = d.fallback, f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, !(d & 1) && f !== null ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g));
      if (e = a.memoizedState, e !== null && (h = e.dehydrated, h !== null))
        return rj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback, g = b.mode, e = a.child, h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        return !(g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064), h !== null ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2), f.return = b, d.return = b, d.sibling = f, b.child = d, d = f, f = b.child, g = a.child.memoizedState, g = g === null ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions }, f.memoizedState = g, f.childLanes = a.childLanes & ~c, b.memoizedState = mj, d;
      }
      return f = a.child, a = f.sibling, d = Pg(f, { mode: "visible", children: d.children }), !(b.mode & 1) && (d.lanes = c), d.return = b, d.sibling = null, a !== null && (c = b.deletions, c === null ? (b.deletions = [a], b.flags |= 16) : c.push(a)), b.child = d, b.memoizedState = null, d;
    }
    function qj(a, b) {
      return b = pj({ mode: "visible", children: b }, a.mode, 0, null), b.return = a, a.child = b;
    }
    function sj(a, b, c, d) {
      return d !== null && Jg(d), Ug(b, a.child, null, c), a = qj(b, b.pendingProps.children), a.flags |= 2, b.memoizedState = null, a;
    }
    function rj(a, b, c, d, e, f, g) {
      if (c)
        return b.flags & 256 ? (b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d)) : b.memoizedState !== null ? (b.child = a.child, b.flags |= 128, null) : (f = d.fallback, e = b.mode, d = pj({ mode: "visible", children: d.children }, e, 0, null), f = Tg(f, e, g, null), f.flags |= 2, d.return = b, f.return = b, d.sibling = f, b.child = d, b.mode & 1 && Ug(b, a.child, null, g), b.child.memoizedState = nj(g), b.memoizedState = mj, f);
      if (!(b.mode & 1))
        return sj(a, b, g, null);
      if (e.data === "$!") {
        if (d = e.nextSibling && e.nextSibling.dataset, d)
          var h = d.dgst;
        return d = h, f = Error(p(419)), d = Ki(f, d, void 0), sj(a, b, g, d);
      }
      if (h = (g & a.childLanes) !== 0, dh || h) {
        if (d = Q, d !== null) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = e & (d.suspendedLanes | g) ? 0 : e, e !== 0 && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
        }
        return tj(), d = Ki(Error(p(421))), sj(a, b, g, d);
      }
      return e.data === "$?" ? (b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null) : (a = f.treeContext, yg = Lf(e.nextSibling), xg = b, I = !0, zg = null, a !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b), b = qj(b, d.children), b.flags |= 4096, b);
    }
    function vj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      d !== null && (d.lanes |= b), bh(a.return, b, c);
    }
    function wj(a, b, c, d, e) {
      var f = a.memoizedState;
      f === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function xj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      if (Xi(a, b, d.children, c), d = L.current, d & 2)
        d = d & 1 | 2, b.flags |= 128;
      else {
        if (a !== null && a.flags & 128)
          a:
            for (a = b.child; a !== null; ) {
              if (a.tag === 13)
                a.memoizedState !== null && vj(a, c, b);
              else if (a.tag === 19)
                vj(a, c, b);
              else if (a.child !== null) {
                a.child.return = a, a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; a.sibling === null; ) {
                if (a.return === null || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return, a = a.sibling;
            }
        d &= 1;
      }
      if (G(L, d), !(b.mode & 1))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            for (c = b.child, e = null; c !== null; )
              a = c.alternate, a !== null && Ch(a) === null && (e = c), c = c.sibling;
            c = e, c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null), wj(b, !1, e, c, f);
            break;
          case "backwards":
            for (c = null, e = b.child, b.child = null; e !== null; ) {
              if (a = e.alternate, a !== null && Ch(a) === null) {
                b.child = e;
                break;
              }
              a = e.sibling, e.sibling = c, c = e, e = a;
            }
            wj(b, !0, c, null, f);
            break;
          case "together":
            wj(b, !1, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function ij(a, b) {
      !(b.mode & 1) && a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a, b, c) {
      if (a !== null && (b.dependencies = a.dependencies), rh |= b.lanes, !(c & b.childLanes))
        return null;
      if (a !== null && b.child !== a.child)
        throw Error(p(153));
      if (b.child !== null) {
        for (a = b.child, c = Pg(a, a.pendingProps), b.child = c, c.return = b; a.sibling !== null; )
          a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function yj(a, b, c) {
      switch (b.tag) {
        case 3:
          kj(b), Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg, d._currentValue), d._currentValue = e;
          break;
        case 13:
          if (d = b.memoizedState, d !== null)
            return d.dehydrated !== null ? (G(L, L.current & 1), b.flags |= 128, null) : c & b.child.childLanes ? oj(a, b, c) : (G(L, L.current & 1), a = Zi(a, b, c), a !== null ? a.sibling : null);
          G(L, L.current & 1);
          break;
        case 19:
          if (d = (c & b.childLanes) !== 0, a.flags & 128) {
            if (d)
              return xj(a, b, c);
            b.flags |= 128;
          }
          if (e = b.memoizedState, e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null), G(L, L.current), d)
            break;
          return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a, b, c);
      }
      return Zi(a, b, c);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a, b) {
      for (var c = b.child; c !== null; ) {
        if (c.tag === 5 || c.tag === 6)
          a.appendChild(c.stateNode);
        else if (c.tag !== 4 && c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode, xh(uh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e), d = Ya(a, d), f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 }), d = A({}, d, { value: void 0 }), f = [];
            break;
          case "textarea":
            e = gb(a, e), d = gb(a, d), f = [];
            break;
          default:
            typeof e.onClick != "function" && typeof d.onClick == "function" && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e)
          if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && e[l] != null)
            if (l === "style") {
              var h = e[l];
              for (g in h)
                h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else
              l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          if (h = e?.[l], d.hasOwnProperty(l) && k !== h && (k != null || h != null))
            if (l === "style")
              if (h) {
                for (g in h)
                  !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                for (g in k)
                  k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
              } else
                c || (f || (f = []), f.push(
                  l,
                  c
                )), c = k;
            else
              l === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l, k)) : l === "children" ? typeof k != "string" && typeof k != "number" || (f = f || []).push(l, "" + k) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (ea.hasOwnProperty(l) ? (k != null && l === "onScroll" && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        (b.updateQueue = l) && (b.flags |= 4);
      }
    };
    Cj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Dj(a, b) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; b !== null; )
              b.alternate !== null && (c = b), b = b.sibling;
            c === null ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; c !== null; )
              c.alternate !== null && (d = c), c = c.sibling;
            d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
    }
    function S(a) {
      var b = a.alternate !== null && a.alternate.child === a.child, c = 0, d = 0;
      if (b)
        for (var e = a.child; e !== null; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else
        for (e = a.child; e !== null; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      return a.subtreeFlags |= d, a.childLanes = c, b;
    }
    function Ej(a, b, c) {
      var d = b.pendingProps;
      switch (wg(b), b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          return d = b.stateNode, zh(), E(Wf), E(H), Eh(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (a === null || a.child === null) && (Gg(b) ? b.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(b.flags & 256) || (b.flags |= 1024, zg !== null && (Fj(zg), zg = null))), Aj(a, b), S(b), null;
        case 5:
          Bh(b);
          var e = xh(wh.current);
          if (c = b.type, a !== null && b.stateNode != null)
            Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (b.stateNode === null)
                throw Error(p(166));
              return S(b), null;
            }
            if (a = xh(uh.current), Gg(b)) {
              d = b.stateNode, c = b.type;
              var f = b.memoizedProps;
              switch (d[Of] = b, d[Pf] = f, a = (b.mode & 1) !== 0, c) {
                case "dialog":
                  D("cancel", d), D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++)
                    D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  ), D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f), D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple }, D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f), e = null;
              for (var g in f)
                if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  g === "children" ? typeof h == "string" ? d.textContent !== h && (f.suppressHydrationWarning !== !0 && Af(d.textContent, h, a), e = ["children", h]) : typeof h == "number" && d.textContent !== "" + h && (f.suppressHydrationWarning !== !0 && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && h != null && g === "onScroll" && D("scroll", d);
                }
              switch (c) {
                case "input":
                  Va(d), db2(d, f, !0);
                  break;
                case "textarea":
                  Va(d), jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  typeof f.onClick == "function" && (d.onclick = Bf);
              }
              d = e, b.updateQueue = d, d !== null && (b.flags |= 4);
            } else {
              g = e.nodeType === 9 ? e : e.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = kb(c)), a === "http://www.w3.org/1999/xhtml" ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script></script>", a = a.removeChild(a.firstChild)) : typeof d.is == "string" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c), a[Of] = b, a[Pf] = d, zj(a, b, !1, !1), b.stateNode = a;
              a: {
                switch (g = vb(c, d), c) {
                  case "dialog":
                    D("cancel", a), D("close", a), e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a), e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++)
                      D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a), e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    ), D("load", a), e = d;
                    break;
                  case "details":
                    D("toggle", a), e = d;
                    break;
                  case "input":
                    Za(a, d), e = Ya(a, d), D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple }, e = A({}, d, { value: void 0 }), D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d), e = gb(a, d), D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e), h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    f === "style" ? sb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && nb(a, k)) : f === "children" ? typeof k == "string" ? (c !== "textarea" || k !== "") && ob(a, k) : typeof k == "number" && ob(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ea.hasOwnProperty(f) ? k != null && f === "onScroll" && D("scroll", a) : k != null && ta(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va(a), db2(a, d, !1);
                    break;
                  case "textarea":
                    Va(a), jb(a);
                    break;
                  case "option":
                    d.value != null && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple, f = d.value, f != null ? fb(a, !!d.multiple, f, !1) : d.defaultValue != null && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      !0
                    );
                    break;
                  default:
                    typeof e.onClick == "function" && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = !0;
                    break a;
                  default:
                    d = !1;
                }
              }
              d && (b.flags |= 4);
            }
            b.ref !== null && (b.flags |= 512, b.flags |= 2097152);
          }
          return S(b), null;
        case 6:
          if (a && b.stateNode != null)
            Cj(a, b, a.memoizedProps, d);
          else {
            if (typeof d != "string" && b.stateNode === null)
              throw Error(p(166));
            if (c = xh(wh.current), xh(uh.current), Gg(b)) {
              if (d = b.stateNode, c = b.memoizedProps, d[Of] = b, (f = d.nodeValue !== c) && (a = xg, a !== null))
                switch (a.tag) {
                  case 3:
                    Af(d.nodeValue, c, (a.mode & 1) !== 0);
                    break;
                  case 5:
                    a.memoizedProps.suppressHydrationWarning !== !0 && Af(d.nodeValue, c, (a.mode & 1) !== 0);
                }
              f && (b.flags |= 4);
            } else
              d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          return S(b), null;
        case 13:
          if (E(L), d = b.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            if (I && yg !== null && b.mode & 1 && !(b.flags & 128))
              Hg(), Ig(), b.flags |= 98560, f = !1;
            else if (f = Gg(b), d !== null && d.dehydrated !== null) {
              if (a === null) {
                if (!f)
                  throw Error(p(318));
                if (f = b.memoizedState, f = f !== null ? f.dehydrated : null, !f)
                  throw Error(p(317));
                f[Of] = b;
              } else
                Ig(), !(b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b), f = !1;
            } else
              zg !== null && (Fj(zg), zg = null), f = !0;
            if (!f)
              return b.flags & 65536 ? b : null;
          }
          return b.flags & 128 ? (b.lanes = c, b) : (d = d !== null, d !== (a !== null && a.memoizedState !== null) && d && (b.child.flags |= 8192, b.mode & 1 && (a === null || L.current & 1 ? T === 0 && (T = 3) : tj())), b.updateQueue !== null && (b.flags |= 4), S(b), null);
        case 4:
          return zh(), Aj(a, b), a === null && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          if (E(L), f = b.memoizedState, f === null)
            return S(b), null;
          if (d = (b.flags & 128) !== 0, g = f.rendering, g === null)
            if (d)
              Dj(f, !1);
            else {
              if (T !== 0 || a !== null && a.flags & 128)
                for (a = b.child; a !== null; ) {
                  if (g = Ch(a), g !== null) {
                    for (b.flags |= 128, Dj(f, !1), d = g.updateQueue, d !== null && (b.updateQueue = d, b.flags |= 4), b.subtreeFlags = 0, d = c, c = b.child; c !== null; )
                      f = c, a = d, f.flags &= 14680066, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                    return G(L, L.current & 1 | 2), b.child;
                  }
                  a = a.sibling;
                }
              f.tail !== null && B() > Gj && (b.flags |= 128, d = !0, Dj(f, !1), b.lanes = 4194304);
            }
          else {
            if (!d)
              if (a = Ch(g), a !== null) {
                if (b.flags |= 128, d = !0, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Dj(f, !0), f.tail === null && f.tailMode === "hidden" && !g.alternate && !I)
                  return S(b), null;
              } else
                2 * B() - f.renderingStartTime > Gj && c !== 1073741824 && (b.flags |= 128, d = !0, Dj(f, !1), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, c !== null ? c.sibling = g : b.child = g, f.last = g);
          }
          return f.tail !== null ? (b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b) : (S(b), null);
        case 22:
        case 23:
          return Hj(), d = b.memoizedState !== null, a !== null && a.memoizedState !== null !== d && (b.flags |= 8192), d && b.mode & 1 ? fj & 1073741824 && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a, b) {
      switch (wg(b), b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a = b.flags, a & 65536 && !(a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          if (E(L), a = b.memoizedState, a !== null && a.dehydrated !== null) {
            if (b.alternate === null)
              throw Error(p(340));
            Ig();
          }
          return a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(L), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = !1, U = !1, Kj = typeof WeakSet == "function" ? WeakSet : Set, V = null;
    function Lj(a, b) {
      var c = a.ref;
      if (c !== null)
        if (typeof c == "function")
          try {
            c(null);
          } catch (d) {
            W(a, b, d);
          }
        else
          c.current = null;
    }
    function Mj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Nj = !1;
    function Oj(a, b) {
      if (Cf = dd, a = Me(), Ne(a)) {
        if ("selectionStart" in a)
          var c = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && d.rangeCount !== 0) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b:
                for (; ; ) {
                  for (var y; q !== c || e !== 0 && q.nodeType !== 3 || (h = g + e), q !== f || d !== 0 && q.nodeType !== 3 || (k = g + d), q.nodeType === 3 && (g += q.nodeValue.length), (y = q.firstChild) !== null; )
                    r = q, q = y;
                  for (; ; ) {
                    if (q === a)
                      break b;
                    if (r === c && ++l === e && (h = g), r === f && ++m === d && (k = g), (y = q.nextSibling) !== null)
                      break;
                    q = r, r = q.parentNode;
                  }
                  q = y;
                }
              c = h === -1 || k === -1 ? null : { start: h, end: k };
            } else
              c = null;
          }
        c = c || { start: 0, end: 0 };
      } else
        c = null;
      for (Df = { focusedElem: a, selectionRange: c }, dd = !1, V = b; V !== null; )
        if (b = V, a = b.child, (b.subtreeFlags & 1028) !== 0 && a !== null)
          a.return = b, V = a;
        else
          for (; V !== null; ) {
            b = V;
            try {
              var n = b.alternate;
              if (b.flags & 1024)
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (n !== null) {
                      var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                      x.__reactInternalSnapshotBeforeUpdate = w;
                    }
                    break;
                  case 3:
                    var u = b.stateNode.containerInfo;
                    u.nodeType === 1 ? u.textContent = "" : u.nodeType === 9 && u.documentElement && u.removeChild(u.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
            } catch (F) {
              W(b, b.return, F);
            }
            if (a = b.sibling, a !== null) {
              a.return = b.return, V = a;
              break;
            }
            V = b.return;
          }
      return n = Nj, Nj = !1, n;
    }
    function Pj(a, b, c) {
      var d = b.updateQueue;
      if (d = d !== null ? d.lastEffect : null, d !== null) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0, f !== void 0 && Mj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a, b) {
      if (b = b.updateQueue, b = b !== null ? b.lastEffect : null, b !== null) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Rj(a) {
      var b = a.ref;
      if (b !== null) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        typeof b == "function" ? b(a) : b.current = a;
      }
    }
    function Sj(a) {
      var b = a.alternate;
      b !== null && (a.alternate = null, Sj(b)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (b = a.stateNode, b !== null && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
    }
    function Tj(a) {
      return a.tag === 5 || a.tag === 3 || a.tag === 4;
    }
    function Uj(a) {
      a:
        for (; ; ) {
          for (; a.sibling === null; ) {
            if (a.return === null || Tj(a.return))
              return null;
            a = a.return;
          }
          for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
            if (a.flags & 2 || a.child === null || a.tag === 4)
              continue a;
            a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Vj(a, b, c) {
      var d = a.tag;
      if (d === 5 || d === 6)
        a = a.stateNode, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c != null || b.onclick !== null || (b.onclick = Bf));
      else if (d !== 4 && (a = a.child, a !== null))
        for (Vj(a, b, c), a = a.sibling; a !== null; )
          Vj(a, b, c), a = a.sibling;
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (d === 5 || d === 6)
        a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (d !== 4 && (a = a.child, a !== null))
        for (Wj(a, b, c), a = a.sibling; a !== null; )
          Wj(a, b, c), a = a.sibling;
    }
    var X = null, Xj = !1;
    function Yj(a, b, c) {
      for (c = c.child; c !== null; )
        Zj(a, b, c), c = c.sibling;
    }
    function Zj(a, b, c) {
      if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
          lc.onCommitFiberUnmount(kc, c);
        } catch {
        }
      switch (c.tag) {
        case 5:
          U || Lj(c, b);
        case 6:
          var d = X, e = Xj;
          X = null, Yj(a, b, c), X = d, Xj = e, X !== null && (Xj ? (a = X, c = c.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          X !== null && (Xj ? (a = X, c = c.stateNode, a.nodeType === 8 ? Kf(a.parentNode, c) : a.nodeType === 1 && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d = X, e = Xj, X = c.stateNode.containerInfo, Xj = !0, Yj(a, b, c), X = d, Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag, g !== void 0 && (f & 2 || f & 4) && Mj(c, b, g), e = e.next;
            } while (e !== d);
          }
          Yj(a, b, c);
          break;
        case 1:
          if (!U && (Lj(c, b), d = c.stateNode, typeof d.componentWillUnmount == "function"))
            try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
          Yj(a, b, c);
          break;
        case 21:
          Yj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || c.memoizedState !== null, Yj(a, b, c), U = d) : Yj(a, b, c);
          break;
        default:
          Yj(a, b, c);
      }
    }
    function ak(a) {
      var b = a.updateQueue;
      if (b !== null) {
        a.updateQueue = null;
        var c = a.stateNode;
        c === null && (c = a.stateNode = new Kj()), b.forEach(function(b2) {
          var d = bk.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a, b) {
      var c = b.deletions;
      if (c !== null)
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a:
              for (; h !== null; ) {
                switch (h.tag) {
                  case 5:
                    X = h.stateNode, Xj = !1;
                    break a;
                  case 3:
                    X = h.stateNode.containerInfo, Xj = !0;
                    break a;
                  case 4:
                    X = h.stateNode.containerInfo, Xj = !0;
                    break a;
                }
                h = h.return;
              }
            if (X === null)
              throw Error(p(160));
            Zj(f, g, e), X = null, Xj = !1;
            var k = e.alternate;
            k !== null && (k.return = null), e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; b !== null; )
          dk(b, a), b = b.sibling;
    }
    function dk(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (ck(b, a), ek(a), d & 4) {
            try {
              Pj(3, a, a.return), Qj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Pj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return);
          break;
        case 5:
          if (ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return), a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, e != null)) {
            var f = a.memoizedProps, g = c !== null ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            if (a.updateQueue = null, k !== null)
              try {
                h === "input" && f.type === "radio" && f.name != null && ab(e, f), vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  m === "style" ? sb(e, q) : m === "dangerouslySetInnerHTML" ? nb(e, q) : m === "children" ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    y != null ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (f.defaultValue != null ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      !0
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
          }
          break;
        case 6:
          if (ck(b, a), ek(a), d & 4) {
            if (a.stateNode === null)
              throw Error(p(162));
            e = a.stateNode, f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          if (ck(b, a), ek(a), d & 4 && c !== null && c.memoizedState.isDehydrated)
            try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
          break;
        case 4:
          ck(b, a), ek(a);
          break;
        case 13:
          ck(b, a), ek(a), e = a.child, e.flags & 8192 && (f = e.memoizedState !== null, e.stateNode.isHidden = f, !f || e.alternate !== null && e.alternate.memoizedState !== null || (fk = B())), d & 4 && ak(a);
          break;
        case 22:
          if (m = c !== null && c.memoizedState !== null, a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a), ek(a), d & 8192) {
            if (l = a.memoizedState !== null, (a.stateNode.isHidden = l) && !m && a.mode & 1)
              for (V = a, m = a.child; m !== null; ) {
                for (q = V = m; V !== null; ) {
                  switch (r = V, y = r.child, r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if (typeof n.componentWillUnmount == "function") {
                        d = r, c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (r.memoizedState !== null) {
                        gk(q);
                        continue;
                      }
                  }
                  y !== null ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
            a:
              for (m = null, q = a; ; ) {
                if (q.tag === 5) {
                  if (m === null) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, typeof f.setProperty == "function" ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = k != null && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (q.tag === 6) {
                  if (m === null)
                    try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                } else if ((q.tag !== 22 && q.tag !== 23 || q.memoizedState === null || q === a) && q.child !== null) {
                  q.child.return = q, q = q.child;
                  continue;
                }
                if (q === a)
                  break a;
                for (; q.sibling === null; ) {
                  if (q.return === null || q.return === a)
                    break a;
                  m === q && (m = null), q = q.return;
                }
                m === q && (m = null), q.sibling.return = q.return, q = q.sibling;
              }
          }
          break;
        case 19:
          ck(b, a), ek(a), d & 4 && ak(a);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a
          ), ek(a);
      }
    }
    function ek(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; c !== null; ) {
              if (Tj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f = Uj(a);
              Wj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a);
              Vj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function hk(a, b, c) {
      V = a, ik(a, b, c);
    }
    function ik(a, b, c) {
      for (var d = (a.mode & 1) !== 0; V !== null; ) {
        var e = V, f = e.child;
        if (e.tag === 22 && d) {
          var g = e.memoizedState !== null || Jj;
          if (!g) {
            var h = e.alternate, k = h !== null && h.memoizedState !== null || U;
            h = Jj;
            var l = U;
            if (Jj = g, (U = k) && !l)
              for (V = e; V !== null; )
                g = V, k = g.child, g.tag === 22 && g.memoizedState !== null ? jk(e) : k !== null ? (k.return = g, V = k) : jk(e);
            for (; f !== null; )
              V = f, ik(f, b, c), f = f.sibling;
            V = e, Jj = h, U = l;
          }
          kk(a, b, c);
        } else
          e.subtreeFlags & 8772 && f !== null ? (f.return = e, V = f) : kk(a, b, c);
      }
    }
    function kk(a) {
      for (; V !== null; ) {
        var b = V;
        if (b.flags & 8772) {
          var c = b.alternate;
          try {
            if (b.flags & 8772)
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (c === null)
                      d.componentDidMount();
                    else {
                      var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f = b.updateQueue;
                  f !== null && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (g !== null) {
                    if (c = null, b.child !== null)
                      switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (c === null && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (b.memoizedState === null) {
                    var l = b.alternate;
                    if (l !== null) {
                      var m = l.memoizedState;
                      if (m !== null) {
                        var q = m.dehydrated;
                        q !== null && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
            U || b.flags & 512 && Rj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        if (c = b.sibling, c !== null) {
          c.return = b.return, V = c;
          break;
        }
        V = b.return;
      }
    }
    function gk(a) {
      for (; V !== null; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (c !== null) {
          c.return = b.return, V = c;
          break;
        }
        V = b.return;
      }
    }
    function jk(a) {
      for (; V !== null; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Qj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if (typeof d.componentDidMount == "function") {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (h !== null) {
          h.return = b.return, V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = 1 / 0, uk = null, Oi = !1, Pi = null, Ri = null, vk = !1, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B();
    }
    function yi(a) {
      return a.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()), Bk) : (a = C, a !== 0 || (a = window.event, a = a === void 0 ? 16 : jd(a.type)), a) : 1;
    }
    function gi(a, b, c, d) {
      if (50 < yk)
        throw yk = 0, zk = null, Error(p(185));
      Ac(a, c, d), (!(K & 2) || a !== Q) && (a === Q && (!(K & 2) && (qk |= c), T === 4 && Ck(a, Z)), Dk(a, d), c === 1 && K === 0 && !(b.mode & 1) && (Gj = B() + 500, fg && jg()));
    }
    function Dk(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === Q ? Z : 0);
      if (d === 0)
        c !== null && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        if (c != null && bc(c), b === 1)
          a.tag === 0 ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            !(K & 6) && jg();
          }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Fk(c, Gk.bind(null, a));
        }
        a.callbackPriority = b, a.callbackNode = c;
      }
    }
    function Gk(a, b) {
      if (Ak = -1, Bk = 0, K & 6)
        throw Error(p(327));
      var c = a.callbackNode;
      if (Hk() && a.callbackNode !== c)
        return null;
      var d = uc(a, a === Q ? Z : 0);
      if (d === 0)
        return null;
      if (d & 30 || d & a.expiredLanes || b)
        b = Ik(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Jk();
        (Q !== a || Z !== b) && (uk = null, Gj = B() + 500, Kk(a, b));
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a, h);
          }
        while (1);
        $g(), mk.current = f, K = e, Y !== null ? b = 0 : (Q = null, Z = 0, b = T);
      }
      if (b !== 0) {
        if (b === 2 && (e = xc(a), e !== 0 && (d = e, b = Nk(a, e))), b === 1)
          throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        if (b === 6)
          Ck(a, d);
        else {
          if (e = a.current.alternate, !(d & 30) && !Ok(e) && (b = Ik(a, d), b === 2 && (f = xc(a), f !== 0 && (d = f, b = Nk(a, f))), b === 1))
            throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          switch (a.finishedWork = e, a.finishedLanes = d, b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a, tk, uk);
              break;
            case 3:
              if (Ck(a, d), (d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (uc(a, 0) !== 0)
                  break;
                if (e = a.suspendedLanes, (e & d) !== d) {
                  R(), a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 4:
              if (Ck(a, d), (d & 4194240) === d)
                break;
              for (b = a.eventTimes, e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g, g = b[g], g > e && (e = g), d &= ~f;
              }
              if (d = e, d = B() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d, 10 < d) {
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 5:
              Pk(a, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      return Dk(a, B()), a.callbackNode === c ? Gk.bind(null, a) : null;
    }
    function Nk(a, b) {
      var c = sk;
      return a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256), a = Ik(a, b), a !== 2 && (b = tk, tk = c, b !== null && Fj(b)), a;
    }
    function Fj(a) {
      tk === null ? tk = a : tk.push.apply(tk, a);
    }
    function Ok(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (c !== null && (c = c.stores, c !== null))
            for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (c = b.child, b.subtreeFlags & 16384 && c !== null)
          c.return = b, b = c;
        else {
          if (b === a)
            break;
          for (; b.sibling === null; ) {
            if (b.return === null || b.return === a)
              return !0;
            b = b.return;
          }
          b.sibling.return = b.return, b = b.sibling;
        }
      }
      return !0;
    }
    function Ck(a, b) {
      for (b &= ~rk, b &= ~qk, a.suspendedLanes |= b, a.pingedLanes &= ~b, a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1, b &= ~d;
      }
    }
    function Ek(a) {
      if (K & 6)
        throw Error(p(327));
      Hk();
      var b = uc(a, 0);
      if (!(b & 1))
        return Dk(a, B()), null;
      var c = Ik(a, b);
      if (a.tag !== 0 && c === 2) {
        var d = xc(a);
        d !== 0 && (b = d, c = Nk(a, d));
      }
      if (c === 1)
        throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
      if (c === 6)
        throw Error(p(345));
      return a.finishedWork = a.current.alternate, a.finishedLanes = b, Pk(a, tk, uk), Dk(a, B()), null;
    }
    function Qk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, K === 0 && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a) {
      wk !== null && wk.tag === 0 && !(K & 6) && Hk();
      var b = K;
      K |= 1;
      var c = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a)
          return a();
      } finally {
        C = d, ok.transition = c, K = b, !(K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current, E(ej);
    }
    function Kk(a, b) {
      a.finishedWork = null, a.finishedLanes = 0;
      var c = a.timeoutHandle;
      if (c !== -1 && (a.timeoutHandle = -1, Gf(c)), Y !== null)
        for (c = Y.return; c !== null; ) {
          var d = c;
          switch (wg(d), d.tag) {
            case 1:
              d = d.type.childContextTypes, d != null && $f();
              break;
            case 3:
              zh(), E(Wf), E(H), Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
      if (Q = a, Y = a = Pg(a.current, null), Z = fj = b, T = 0, pk = null, rk = qk = rh = 0, tk = sk = null, fh !== null) {
        for (b = 0; b < fh.length; b++)
          if (c = fh[b], d = c.interleaved, d !== null) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (f !== null) {
              var g = f.next;
              f.next = e, d.next = g;
            }
            c.pending = d;
          }
        fh = null;
      }
      return a;
    }
    function Mk(a, b) {
      do {
        var c = Y;
        try {
          if ($g(), Fh.current = Rh, Ih) {
            for (var d = M.memoizedState; d !== null; ) {
              var e = d.queue;
              e !== null && (e.pending = null), d = d.next;
            }
            Ih = !1;
          }
          if (Hh = 0, O = N = M = null, Jh = !1, Kh = 0, nk.current = null, c === null || c.return === null) {
            T = 1, pk = b, Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            if (b = Z, h.flags |= 32768, k !== null && typeof k == "object" && typeof k.then == "function") {
              var l = k, m = h, q = m.tag;
              if (!(m.mode & 1) && (q === 0 || q === 11 || q === 15)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Ui(g);
              if (y !== null) {
                y.flags &= -257, Vi(y, g, h, f, b), y.mode & 1 && Si(f, l, b), b = y, k = l;
                var n = b.updateQueue;
                if (n === null) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k), b.updateQueue = t;
                } else
                  n.add(k);
                break a;
              } else {
                if (!(b & 1)) {
                  Si(f, l, b), tj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Ui(g);
              if (J !== null) {
                !(J.flags & 65536) && (J.flags |= 256), Vi(J, g, h, f, b), Jg(Ji(k, h));
                break a;
              }
            }
            f = k = Ji(k, h), T !== 4 && (T = 2), sk === null ? sk = [f] : sk.push(f), f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536, b &= -b, f.lanes |= b;
                  var x = Ni(f, k, b);
                  ph(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (!(f.flags & 128) && (typeof w.getDerivedStateFromError == "function" || u !== null && typeof u.componentDidCatch == "function" && (Ri === null || !Ri.has(u)))) {
                    f.flags |= 65536, b &= -b, f.lanes |= b;
                    var F = Qi(f, h, b);
                    ph(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (f !== null);
          }
          Sk(c);
        } catch (na) {
          b = na, Y === c && c !== null && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a = mk.current;
      return mk.current = Rh, a === null ? Rh : a;
    }
    function tj() {
      (T === 0 || T === 3 || T === 2) && (T = 4), Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a, b) {
      var c = K;
      K |= 2;
      var d = Jk();
      (Q !== a || Z !== b) && (uk = null, Kk(a, b));
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a, e);
        }
      while (1);
      if ($g(), K = c, mk.current = d, Y !== null)
        throw Error(p(261));
      return Q = null, Z = 0, T;
    }
    function Tk() {
      for (; Y !== null; )
        Uk(Y);
    }
    function Lk() {
      for (; Y !== null && !cc(); )
        Uk(Y);
    }
    function Uk(a) {
      var b = Vk(a.alternate, a, fj);
      a.memoizedProps = a.pendingProps, b === null ? Sk(a) : Y = b, nk.current = null;
    }
    function Sk(a) {
      var b = a;
      do {
        var c = b.alternate;
        if (a = b.return, b.flags & 32768) {
          if (c = Ij(c, b), c !== null) {
            c.flags &= 32767, Y = c;
            return;
          }
          if (a !== null)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6, Y = null;
            return;
          }
        } else if (c = Ej(c, b, fj), c !== null) {
          Y = c;
          return;
        }
        if (b = b.sibling, b !== null) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (b !== null);
      T === 0 && (T = 5);
    }
    function Pk(a, b, c) {
      var d = C, e = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a, b, c, d);
      } finally {
        ok.transition = e, C = d;
      }
      return null;
    }
    function Wk(a, b, c, d) {
      do
        Hk();
      while (wk !== null);
      if (K & 6)
        throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (c === null)
        return null;
      if (a.finishedWork = null, a.finishedLanes = 0, c === a.current)
        throw Error(p(177));
      a.callbackNode = null, a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      if (Bc(a, f), a === Q && (Y = Q = null, Z = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || vk || (vk = !0, Fk(hc, function() {
        return Hk(), null;
      })), f = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || f) {
        f = ok.transition, ok.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4, nk.current = null, Oj(a, c), dk(c, a), Oe(Df), dd = !!Cf, Df = Cf = null, a.current = c, hk(c, a, e), dc(), K = h, C = g, ok.transition = f;
      } else
        a.current = c;
      if (vk && (vk = !1, wk = a, xk = e), f = a.pendingLanes, f === 0 && (Ri = null), mc(c.stateNode, d), Dk(a, B()), b !== null)
        for (d = a.onRecoverableError, c = 0; c < b.length; c++)
          e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi)
        throw Oi = !1, a = Pi, Pi = null, a;
      return xk & 1 && a.tag !== 0 && Hk(), f = a.pendingLanes, f & 1 ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0, jg(), null;
    }
    function Hk() {
      if (wk !== null) {
        var a = Dc(xk), b = ok.transition, c = C;
        try {
          if (ok.transition = null, C = 16 > a ? 16 : a, wk === null)
            var d = !1;
          else {
            if (a = wk, wk = null, xk = 0, K & 6)
              throw Error(p(331));
            var e = K;
            for (K |= 4, V = a.current; V !== null; ) {
              var f = V, g = f.child;
              if (V.flags & 16) {
                var h = f.deletions;
                if (h !== null) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; V !== null; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m, f);
                      }
                      var q = m.child;
                      if (q !== null)
                        q.return = m, V = q;
                      else
                        for (; V !== null; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          if (Sj(m), m === l) {
                            V = null;
                            break;
                          }
                          if (r !== null) {
                            r.return = y, V = r;
                            break;
                          }
                          V = y;
                        }
                    }
                  }
                  var n = f.alternate;
                  if (n !== null) {
                    var t = n.child;
                    if (t !== null) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null, t = J;
                      } while (t !== null);
                    }
                  }
                  V = f;
                }
              }
              if (f.subtreeFlags & 2064 && g !== null)
                g.return = f, V = g;
              else
                b:
                  for (; V !== null; ) {
                    if (f = V, f.flags & 2048)
                      switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f, f.return);
                      }
                    var x = f.sibling;
                    if (x !== null) {
                      x.return = f.return, V = x;
                      break b;
                    }
                    V = f.return;
                  }
            }
            var w = a.current;
            for (V = w; V !== null; ) {
              g = V;
              var u = g.child;
              if (g.subtreeFlags & 2064 && u !== null)
                u.return = g, V = u;
              else
                b:
                  for (g = w; V !== null; ) {
                    if (h = V, h.flags & 2048)
                      try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h);
                        }
                      } catch (na) {
                        W(h, h.return, na);
                      }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (F !== null) {
                      F.return = h.return, V = F;
                      break b;
                    }
                    V = h.return;
                  }
            }
            if (K = e, jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch {
              }
            d = !0;
          }
          return d;
        } finally {
          C = c, ok.transition = b;
        }
      }
      return !1;
    }
    function Xk(a, b, c) {
      b = Ji(c, b), b = Ni(a, b, 1), a = nh(a, b, 1), b = R(), a !== null && (Ac(a, 1, b), Dk(a, b));
    }
    function W(a, b, c) {
      if (a.tag === 3)
        Xk(a, a, c);
      else
        for (; b !== null; ) {
          if (b.tag === 3) {
            Xk(b, a, c);
            break;
          } else if (b.tag === 1) {
            var d = b.stateNode;
            if (typeof b.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Ri === null || !Ri.has(d))) {
              a = Ji(c, a), a = Qi(b, a, 1), b = nh(b, a, 1), a = R(), b !== null && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      d !== null && d.delete(b), b = R(), a.pingedLanes |= a.suspendedLanes & c, Q === a && (Z & c) === c && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c), Dk(a, b);
    }
    function Yk(a, b) {
      b === 0 && (a.mode & 1 ? (b = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : b = 1);
      var c = R();
      a = ih(a, b), a !== null && (Ac(a, b, c), Dk(a, c));
    }
    function uj(a) {
      var b = a.memoizedState, c = 0;
      b !== null && (c = b.retryLane), Yk(a, c);
    }
    function bk(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode, e = a.memoizedState;
          e !== null && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      d !== null && d.delete(b), Yk(a, c);
    }
    var Vk;
    Vk = function(a, b, c) {
      if (a !== null)
        if (a.memoizedProps !== b.pendingProps || Wf.current)
          dh = !0;
        else {
          if (!(a.lanes & c) && !(b.flags & 128))
            return dh = !1, yj(a, b, c);
          dh = !!(a.flags & 131072);
        }
      else
        dh = !1, I && b.flags & 1048576 && ug(b, ng, b.index);
      switch (b.lanes = 0, b.tag) {
        case 2:
          var d = b.type;
          ij(a, b), a = b.pendingProps;
          var e = Yf(b, H.current);
          ch(b, c), e = Nh(null, b, d, a, e, c);
          var f = Sh();
          return b.flags |= 1, typeof e == "object" && e !== null && typeof e.render == "function" && e.$$typeof === void 0 ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, !0, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child), b;
        case 16:
          d = b.elementType;
          a: {
            switch (ij(a, b), a = b.pendingProps, e = d._init, d = e(d._payload), b.type = d, e = b.tag = Zk(d), a = Ci(d, a), e) {
              case 0:
                b = cj(null, b, d, a, c);
                break a;
              case 1:
                b = hj(null, b, d, a, c);
                break a;
              case 11:
                b = Yi(null, b, d, a, c);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
        case 3:
          a: {
            if (kj(b), a === null)
              throw Error(p(387));
            d = b.pendingProps, f = b.memoizedState, e = f.element, lh(a, b), qh(b, d, null, c);
            var g = b.memoizedState;
            if (d = g.element, f.isDehydrated)
              if (f = { element: d, isDehydrated: !1, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b), b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b), b = lj(a, b, d, c, e);
                break a;
              } else
                for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, c = Vg(b, null, d, c), b.child = c; c; )
                  c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              if (Ig(), d === e) {
                b = Zi(a, b, c);
                break a;
              }
              Xi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), a === null && Eg(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : f !== null && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
        case 6:
          return a === null && Eg(b), null;
        case 13:
          return oj(a, b, c);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
        case 7:
          return Xi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            if (d = b.type._context, e = b.pendingProps, f = b.memoizedProps, g = e.value, G(Wg, d._currentValue), d._currentValue = g, f !== null)
              if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else
                for (f = b.child, f !== null && (f.return = b); f !== null; ) {
                  var h = f.dependencies;
                  if (h !== null) {
                    g = f.child;
                    for (var k = h.firstContext; k !== null; ) {
                      if (k.context === d) {
                        if (f.tag === 1) {
                          k = mh(-1, c & -c), k.tag = 2;
                          var l = f.updateQueue;
                          if (l !== null) {
                            l = l.shared;
                            var m = l.pending;
                            m === null ? k.next = k : (k.next = m.next, m.next = k), l.pending = k;
                          }
                        }
                        f.lanes |= c, k = f.alternate, k !== null && (k.lanes |= c), bh(
                          f.return,
                          c,
                          b
                        ), h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (f.tag === 10)
                    g = f.type === b.type ? null : f.child;
                  else if (f.tag === 18) {
                    if (g = f.return, g === null)
                      throw Error(p(341));
                    g.lanes |= c, h = g.alternate, h !== null && (h.lanes |= c), bh(g, c, b), g = f.sibling;
                  } else
                    g = f.child;
                  if (g !== null)
                    g.return = f;
                  else
                    for (g = f; g !== null; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      if (f = g.sibling, f !== null) {
                        f.return = g.return, g = f;
                        break;
                      }
                      g = g.return;
                    }
                  f = g;
                }
            Xi(a, b, e.children, c), b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
        case 15:
          return bj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, !0, a, c);
        case 19:
          return xj(a, b, c);
        case 22:
          return dj(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a, b) {
      return ac(a, b);
    }
    function $k(a, b, c, d) {
      this.tag = a, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new $k(a, b, c, d);
    }
    function aj(a) {
      return a = a.prototype, !(!a || !a.isReactComponent);
    }
    function Zk(a) {
      if (typeof a == "function")
        return aj(a) ? 1 : 0;
      if (a != null) {
        if (a = a.$$typeof, a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function Pg(a, b) {
      var c = a.alternate;
      return c === null ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = a.flags & 14680064, c.childLanes = a.childLanes, c.lanes = a.lanes, c.child = a.child, c.memoizedProps = a.memoizedProps, c.memoizedState = a.memoizedState, c.updateQueue = a.updateQueue, b = a.dependencies, c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext }, c.sibling = a.sibling, c.index = a.index, c.ref = a.ref, c;
    }
    function Rg(a, b, c, d, e, f) {
      var g = 2;
      if (d = a, typeof a == "function")
        aj(a) && (g = 1);
      else if (typeof a == "string")
        g = 5;
      else
        a:
          switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              g = 8, e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
            case Ia:
              return pj(c, e, f, b);
            default:
              if (typeof a == "object" && a !== null)
                switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    g = 16, d = null;
                    break a;
                }
              throw Error(p(130, a == null ? a : typeof a, ""));
          }
      return b = Bg(g, c, b, e), b.elementType = a, b.type = d, b.lanes = f, b;
    }
    function Tg(a, b, c, d) {
      return a = Bg(7, a, d, b), a.lanes = c, a;
    }
    function pj(a, b, c, d) {
      return a = Bg(22, a, d, b), a.elementType = Ia, a.lanes = c, a.stateNode = { isHidden: !1 }, a;
    }
    function Qg(a, b, c) {
      return a = Bg(6, a, null, b), a.lanes = c, a;
    }
    function Sg(a, b, c) {
      return b = Bg(4, a.children !== null ? a.children : [], a.key, b), b.lanes = c, b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, b;
    }
    function al(a, b, c, d, e) {
      this.tag = b, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null;
    }
    function bl(a, b, c, d, e, f, g, h, k) {
      return a = new al(a, b, c, h, k), b === 1 ? (b = 1, f === !0 && (b |= 8)) : b = 0, f = Bg(3, null, null, b), a.current = f, f.stateNode = a, f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, kh(f), a;
    }
    function cl(a, b, c) {
      var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: wa, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function dl(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || a.tag !== 1)
          throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (b !== null);
        throw Error(p(171));
      }
      if (a.tag === 1) {
        var c = a.type;
        if (Zf(c))
          return bg(a, c, b);
      }
      return b;
    }
    function el(a, b, c, d, e, f, g, h, k) {
      return a = bl(c, d, !0, a, e, f, g, h, k), a.context = dl(null), c = a.current, d = R(), e = yi(c), f = mh(d, e), f.callback = b ?? null, nh(c, f, e), a.current.lanes = e, Ac(a, e, d), Dk(a, d), a;
    }
    function fl(a, b, c, d) {
      var e = b.current, f = R(), g = yi(e);
      return c = dl(c), b.context === null ? b.context = c : b.pendingContext = c, b = mh(f, g), b.payload = { element: a }, d = d === void 0 ? null : d, d !== null && (b.callback = d), a = nh(e, b, g), a !== null && (gi(a, e, g, f), oh(a, e, g)), g;
    }
    function gl(a) {
      if (a = a.current, !a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function hl(a, b) {
      if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
        var c = a.retryLane;
        a.retryLane = c !== 0 && c < b ? c : b;
      }
    }
    function il(a, b) {
      hl(a, b), (a = a.alternate) && hl(a, b);
    }
    function jl() {
      return null;
    }
    var kl = typeof reportError == "function" ? reportError : function(a) {
      console.error(a);
    };
    function ll(a) {
      this._internalRoot = a;
    }
    ml.prototype.render = ll.prototype.render = function(a) {
      var b = this._internalRoot;
      if (b === null)
        throw Error(p(409));
      fl(a, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Rk(function() {
          fl(null, a, null, null);
        }), b[uf] = null;
      }
    };
    function ml(a) {
      this._internalRoot = a;
    }
    ml.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && b !== 0 && b < Qc[c].priority; c++)
          ;
        Qc.splice(c, 0, a), c === 0 && Vc(a);
      }
    };
    function nl(a) {
      return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
    }
    function ol(a) {
      return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
    }
    function pl() {
    }
    function ql(a, b, c, d, e) {
      if (e) {
        if (typeof d == "function") {
          var f = d;
          d = function() {
            var a2 = gl(g);
            f.call(a2);
          };
        }
        var g = el(b, d, a, 0, null, !1, !1, "", pl);
        return a._reactRootContainer = g, a[uf] = g.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(), g;
      }
      for (; e = a.lastChild; )
        a.removeChild(e);
      if (typeof d == "function") {
        var h = d;
        d = function() {
          var a2 = gl(k);
          h.call(a2);
        };
      }
      var k = bl(a, 0, !1, null, null, !1, !1, "", pl);
      return a._reactRootContainer = k, a[uf] = k.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(function() {
        fl(b, k, c, d);
      }), k;
    }
    function rl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if (typeof e == "function") {
          var h = e;
          e = function() {
            var a2 = gl(g);
            h.call(a2);
          };
        }
        fl(b, g, a, e);
      } else
        g = ql(c, b, a, e, d);
      return gl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            c !== 0 && (Cc(b, c | 1), Dk(b, B()), !(K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a, 1);
            if (b2 !== null) {
              var c2 = R();
              gi(b2, a, 1, c2);
            }
          }), il(a, 1);
      }
    };
    Fc = function(a) {
      if (a.tag === 13) {
        var b = ih(a, 134217728);
        if (b !== null) {
          var c = R();
          gi(b, a, 134217728, c);
        }
        il(a, 134217728);
      }
    };
    Gc = function(a) {
      if (a.tag === 13) {
        var b = yi(a), c = ih(a, b);
        if (c !== null) {
          var d = R();
          gi(c, a, b, d);
        }
        il(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          if (bb(a, c), b = c.name, c.type === "radio" && b != null) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]'), b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e)
                  throw Error(p(90));
                Wa(d), bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, b != null && fb(a, !!c.multiple, b, !1);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      return a = Zb(a), a === null ? null : a.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (vl = __REACT_DEVTOOLS_GLOBAL_HOOK__, !vl.isDisabled && vl.supportsFiber))
      try {
        kc = vl.inject(ul), lc = vl;
      } catch {
      }
    var vl;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    exports.createPortal = function(a, b) {
      var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!nl(b))
        throw Error(p(200));
      return cl(a, b, null, c);
    };
    exports.createRoot = function(a, b) {
      if (!nl(a))
        throw Error(p(299));
      var c = !1, d = "", e = kl;
      return b != null && (b.unstable_strictMode === !0 && (c = !0), b.identifierPrefix !== void 0 && (d = b.identifierPrefix), b.onRecoverableError !== void 0 && (e = b.onRecoverableError)), b = bl(a, 1, !1, null, null, c, !1, d, e), a[uf] = b.current, sf(a.nodeType === 8 ? a.parentNode : a), new ll(b);
    };
    exports.findDOMNode = function(a) {
      if (a == null)
        return null;
      if (a.nodeType === 1)
        return a;
      var b = a._reactInternals;
      if (b === void 0)
        throw typeof a.render == "function" ? Error(p(188)) : (a = Object.keys(a).join(","), Error(p(268, a)));
      return a = Zb(b), a = a === null ? null : a.stateNode, a;
    };
    exports.flushSync = function(a) {
      return Rk(a);
    };
    exports.hydrate = function(a, b, c) {
      if (!ol(b))
        throw Error(p(200));
      return rl(null, a, b, !0, c);
    };
    exports.hydrateRoot = function(a, b, c) {
      if (!nl(a))
        throw Error(p(405));
      var d = c != null && c.hydratedSources || null, e = !1, f = "", g = kl;
      if (c != null && (c.unstable_strictMode === !0 && (e = !0), c.identifierPrefix !== void 0 && (f = c.identifierPrefix), c.onRecoverableError !== void 0 && (g = c.onRecoverableError)), b = el(b, null, a, 1, c ?? null, e, !1, f, g), a[uf] = b.current, sf(a), d)
        for (a = 0; a < d.length; a++)
          c = d[a], e = c._getVersion, e = e(c._source), b.mutableSourceEagerHydrationData == null ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
            c,
            e
          );
      return new ml(b);
    };
    exports.render = function(a, b, c) {
      if (!ol(b))
        throw Error(p(200));
      return rl(null, a, b, !1, c);
    };
    exports.unmountComponentAtNode = function(a) {
      if (!ol(a))
        throw Error(p(40));
      return a._reactRootContainer ? (Rk(function() {
        rl(null, null, a, !1, function() {
          a._reactRootContainer = null, a[uf] = null;
        });
      }), !0) : !1;
    };
    exports.unstable_batchedUpdates = Qk;
    exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!ol(c))
        throw Error(p(200));
      if (a == null || a._reactInternals === void 0)
        throw Error(p(38));
      return rl(a, b, c, !1, d);
    };
    exports.version = "18.3.1-next-f1338f8080-20240426";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    function checkDCE() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
    }
    checkDCE(), module.exports = require_react_dom_production_min();
  }
});

// node_modules/react-router/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AbortedDeferredError: () => AbortedDeferredError,
  Await: () => Await,
  MemoryRouter: () => MemoryRouter,
  Navigate: () => Navigate,
  NavigationType: () => Action,
  Outlet: () => Outlet,
  Route: () => Route,
  Router: () => Router,
  RouterProvider: () => RouterProvider,
  Routes: () => Routes,
  UNSAFE_DataRouterContext: () => DataRouterContext,
  UNSAFE_DataRouterStateContext: () => DataRouterStateContext,
  UNSAFE_LocationContext: () => LocationContext,
  UNSAFE_NavigationContext: () => NavigationContext,
  UNSAFE_RouteContext: () => RouteContext,
  UNSAFE_logV6DeprecationWarnings: () => logV6DeprecationWarnings,
  UNSAFE_mapRouteProperties: () => mapRouteProperties,
  UNSAFE_useRouteId: () => useRouteId,
  UNSAFE_useRoutesImpl: () => useRoutesImpl,
  createMemoryRouter: () => createMemoryRouter,
  createPath: () => createPath,
  createRoutesFromChildren: () => createRoutesFromChildren,
  createRoutesFromElements: () => createRoutesFromChildren,
  defer: () => defer,
  generatePath: () => generatePath,
  isRouteErrorResponse: () => isRouteErrorResponse,
  json: () => json,
  matchPath: () => matchPath,
  matchRoutes: () => matchRoutes,
  parsePath: () => parsePath,
  redirect: () => redirect,
  redirectDocument: () => redirectDocument,
  renderMatches: () => renderMatches,
  replace: () => replace,
  resolvePath: () => resolvePath,
  useActionData: () => useActionData,
  useAsyncError: () => useAsyncError,
  useAsyncValue: () => useAsyncValue,
  useBlocker: () => useBlocker,
  useHref: () => useHref,
  useInRouterContext: () => useInRouterContext,
  useLoaderData: () => useLoaderData,
  useLocation: () => useLocation,
  useMatch: () => useMatch,
  useMatches: () => useMatches,
  useNavigate: () => useNavigate,
  useNavigation: () => useNavigation,
  useNavigationType: () => useNavigationType,
  useOutlet: () => useOutlet,
  useOutletContext: () => useOutletContext,
  useParams: () => useParams,
  useResolvedPath: () => useResolvedPath,
  useRevalidator: () => useRevalidator,
  useRouteError: () => useRouteError,
  useRouteLoaderData: () => useRouteLoaderData,
  useRoutes: () => useRoutes
});
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends2.apply(this, arguments);
}
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  useInRouterContext() || invariant(!1);
  let {
    basename,
    navigator: navigator2
  } = React.useContext(NavigationContext), {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  }), joinedPathname = pathname;
  return basename !== "/" && (joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname])), navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
function useLocation() {
  return useInRouterContext() || invariant(!1), React.useContext(LocationContext).location;
}
function useNavigationType() {
  return React.useContext(LocationContext).navigationType;
}
function useMatch(pattern) {
  useInRouterContext() || invariant(!1);
  let {
    pathname
  } = useLocation();
  return React.useMemo(() => matchPath(pattern, decodePath(pathname)), [pathname, pattern]);
}
function useIsomorphicLayoutEffect(cb) {
  React.useContext(NavigationContext).static || React.useLayoutEffect(cb);
}
function useNavigate() {
  let {
    isDataRoute
  } = React.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  useInRouterContext() || invariant(!1);
  let dataRouterContext = React.useContext(DataRouterContext), {
    basename,
    future: future2,
    navigator: navigator2
  } = React.useContext(NavigationContext), {
    matches: matches2
  } = React.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future2.v7_relativeSplatPath)), activeRef = React.useRef(!1);
  return useIsomorphicLayoutEffect(() => {
    activeRef.current = !0;
  }), React.useCallback(function(to, options) {
    if (options === void 0 && (options = {}), !activeRef.current)
      return;
    if (typeof to == "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    dataRouterContext == null && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), (options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
}
function useOutletContext() {
  return React.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = React.useContext(RouteContext).outlet;
  return outlet && /* @__PURE__ */ React.createElement(OutletContext.Provider, {
    value: context
  }, outlet);
}
function useParams() {
  let {
    matches: matches2
  } = React.useContext(RouteContext), routeMatch = matches2[matches2.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2, {
    future: future2
  } = React.useContext(NavigationContext), {
    matches: matches2
  } = React.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getResolveToMatches(matches2, future2.v7_relativeSplatPath));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes2, locationArg) {
  return useRoutesImpl(routes2, locationArg);
}
function useRoutesImpl(routes2, locationArg, dataRouterState, future2) {
  useInRouterContext() || invariant(!1);
  let {
    navigator: navigator2,
    static: isStatic
  } = React.useContext(NavigationContext), {
    matches: parentMatches
  } = React.useContext(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {}, parentPathname = routeMatch ? routeMatch.pathname : "/", parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/", parentRoute = routeMatch && routeMatch.route, locationFromContext = useLocation(), location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg == "string" ? parsePath(locationArg) : locationArg;
    parentPathnameBase === "/" || (_parsedLocationArg$pa = parsedLocationArg.pathname) != null && _parsedLocationArg$pa.startsWith(parentPathnameBase) || invariant(!1), location = parsedLocationArg;
  } else
    location = locationFromContext;
  let pathname = location.pathname || "/", remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    remainingPathname = "/" + pathname.replace(/^\//, "").split("/").slice(parentSegments.length).join("/");
  }
  let matches2 = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes2, {
    pathname: remainingPathname
  }), renderedMatches = _renderMatches(matches2 && matches2.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState, future2);
  return locationArg && renderedMatches ? /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    value: {
      location: _extends2({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, location),
      navigationType: Action.Pop
    }
  }, renderedMatches) : renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError(), message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error), stack = error instanceof Error ? error.stack : null, lightgrey = "rgba(200,200,200, 0.5)", preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  }, codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ React.createElement("pre", {
    style: preStyles
  }, stack) : null, null);
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref, dataRouterContext = React.useContext(DataRouterContext);
  return dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary) && (dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id), /* @__PURE__ */ React.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState, future2) {
  var _dataRouterState;
  if (parentMatches === void 0 && (parentMatches = []), dataRouterState === void 0 && (dataRouterState = null), future2 === void 0 && (future2 = null), matches2 == null) {
    var _future;
    if (!dataRouterState)
      return null;
    if (dataRouterState.errors)
      matches2 = dataRouterState.matches;
    else if ((_future = future2) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0)
      matches2 = dataRouterState.matches;
    else
      return null;
  }
  let renderedMatches = matches2, errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m) => m.route.id && errors?.[m.route.id] !== void 0);
    errorIndex >= 0 || invariant(!1), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = !1, fallbackIndex = -1;
  if (dataRouterState && future2 && future2.v7_partialHydration)
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if ((match.route.HydrateFallback || match.route.hydrateFallbackElement) && (fallbackIndex = i), match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState, needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = !0, fallbackIndex >= 0 ? renderedMatches = renderedMatches.slice(0, fallbackIndex + 1) : renderedMatches = [renderedMatches[0]];
          break;
        }
      }
    }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error, shouldRenderHydrateFallback = !1, errorElement = null, hydrateFallbackElement = null;
    dataRouterState && (error = errors && match.route.id ? errors[match.route.id] : void 0, errorElement = match.route.errorElement || defaultErrorElement, renderFallback && (fallbackIndex < 0 && index === 0 ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), shouldRenderHydrateFallback = !0, hydrateFallbackElement = null) : fallbackIndex === index && (shouldRenderHydrateFallback = !0, hydrateFallbackElement = match.route.hydrateFallbackElement || null)));
    let matches3 = parentMatches.concat(renderedMatches.slice(0, index + 1)), getChildren = () => {
      let children;
      return error ? children = errorElement : shouldRenderHydrateFallback ? children = hydrateFallbackElement : match.route.Component ? children = /* @__PURE__ */ React.createElement(match.route.Component, null) : match.route.element ? children = match.route.element : children = outlet, /* @__PURE__ */ React.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches3,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches3,
        isDataRoute: !0
      }
    }) : getChildren();
  }, null);
}
function useDataRouterContext(hookName) {
  let ctx = React.useContext(DataRouterContext);
  return ctx || invariant(!1), ctx;
}
function useDataRouterState(hookName) {
  let state = React.useContext(DataRouterStateContext);
  return state || invariant(!1), state;
}
function useRouteContext(hookName) {
  let route = React.useContext(RouteContext);
  return route || invariant(!1), route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName), thisRoute = route.matches[route.matches.length - 1];
  return thisRoute.route.id || invariant(!1), thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}
function useNavigation() {
  return useDataRouterState(DataRouterStateHook.UseNavigation).navigation;
}
function useRevalidator() {
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator), state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return React.useMemo(() => ({
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
  }), [dataRouterContext.router.revalidate, state.revalidation]);
}
function useMatches() {
  let {
    matches: matches2,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches2.map((m) => convertRouteMatchToUiMatch(m, loaderData)), [matches2, loaderData]);
}
function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  if (state.errors && state.errors[routeId] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
    return;
  }
  return state.loaderData[routeId];
}
function useRouteLoaderData(routeId) {
  return useDataRouterState(DataRouterStateHook.UseRouteLoaderData).loaderData[routeId];
}
function useActionData() {
  let state = useDataRouterState(DataRouterStateHook.UseActionData), routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);
  return state.actionData ? state.actionData[routeId] : void 0;
}
function useRouteError() {
  var _state$errors;
  let error = React.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook.UseRouteError), routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  return error !== void 0 ? error : (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useAsyncValue() {
  let value = React.useContext(AwaitContext);
  return value?._data;
}
function useAsyncError() {
  let value = React.useContext(AwaitContext);
  return value?._error;
}
function useBlocker(shouldBlock) {
  let {
    router,
    basename
  } = useDataRouterContext(DataRouterHook.UseBlocker), state = useDataRouterState(DataRouterStateHook.UseBlocker), [blockerKey, setBlockerKey] = React.useState(""), blockerFunction = React.useCallback((arg) => {
    if (typeof shouldBlock != "function")
      return !!shouldBlock;
    if (basename === "/")
      return shouldBlock(arg);
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = arg;
    return shouldBlock({
      currentLocation: _extends2({}, currentLocation, {
        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
      }),
      nextLocation: _extends2({}, nextLocation, {
        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
      }),
      historyAction
    });
  }, [basename, shouldBlock]);
  return React.useEffect(() => {
    let key = String(++blockerId);
    return setBlockerKey(key), () => router.deleteBlocker(key);
  }, [router]), React.useEffect(() => {
    blockerKey !== "" && router.getBlocker(blockerKey, blockerFunction);
  }, [router, blockerKey, blockerFunction]), blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable), id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable), activeRef = React.useRef(!1);
  return useIsomorphicLayoutEffect(() => {
    activeRef.current = !0;
  }), React.useCallback(function(to, options) {
    options === void 0 && (options = {}), activeRef.current && (typeof to == "number" ? router.navigate(to) : router.navigate(to, _extends2({
      fromRouteId: id
    }, options)));
  }, [router, id]);
}
function warningOnce(key, cond, message) {
  !cond && !alreadyWarned$1[key] && (alreadyWarned$1[key] = !0);
}
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  renderFuture?.v7_startTransition === void 0 && logDeprecation("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), renderFuture?.v7_relativeSplatPath === void 0 && (!routerFuture || !routerFuture.v7_relativeSplatPath) && logDeprecation("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath"), routerFuture && (routerFuture.v7_fetcherPersist === void 0 && logDeprecation("v7_fetcherPersist", "The persistence behavior of fetchers is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_fetcherpersist"), routerFuture.v7_normalizeFormMethod === void 0 && logDeprecation("v7_normalizeFormMethod", "Casing of `formMethod` fields is being normalized to uppercase in v7", "https://reactrouter.com/v6/upgrading/future#v7_normalizeformmethod"), routerFuture.v7_partialHydration === void 0 && logDeprecation("v7_partialHydration", "`RouterProvider` hydration behavior is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_partialhydration"), routerFuture.v7_skipActionErrorRevalidation === void 0 && logDeprecation("v7_skipActionErrorRevalidation", "The revalidation behavior after 4xx/5xx `action` responses is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_skipactionerrorrevalidation"));
}
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future: future2
  } = _ref, [state, setStateImpl] = React.useState(router.state), {
    v7_startTransition
  } = future2 || {}, setState = React.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]), React.useEffect(() => {
  }, []);
  let navigator2 = React.useMemo(() => ({
    createHref: router.createHref,
    encodeLocation: router.encodeLocation,
    go: (n) => router.navigate(n),
    push: (to, state2, opts) => router.navigate(to, {
      state: state2,
      preventScrollReset: opts?.preventScrollReset
    }),
    replace: (to, state2, opts) => router.navigate(to, {
      replace: !0,
      state: state2,
      preventScrollReset: opts?.preventScrollReset
    })
  }), [router]), basename = router.basename || "/", dataRouterContext = React.useMemo(() => ({
    router,
    navigator: navigator2,
    static: !1,
    basename
  }), [router, navigator2, basename]);
  return React.useEffect(() => logV6DeprecationWarnings(future2, router.future), [router, future2]), /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ React.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ React.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2,
    future: {
      v7_relativeSplatPath: router.future.v7_relativeSplatPath
    }
  }, state.initialized || router.future.v7_partialHydration ? /* @__PURE__ */ React.createElement(DataRoutes, {
    routes: router.routes,
    future: router.future,
    state
  }) : fallbackElement))), null);
}
function DataRoutes(_ref2) {
  let {
    routes: routes2,
    future: future2,
    state
  } = _ref2;
  return useRoutesImpl(routes2, void 0, state, future2);
}
function MemoryRouter(_ref3) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex,
    future: future2
  } = _ref3, historyRef = React.useRef();
  historyRef.current == null && (historyRef.current = createMemoryHistory({
    initialEntries,
    initialIndex,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setStateImpl] = React.useState({
    action: history.action,
    location: history.location
  }), {
    v7_startTransition
  } = future2 || {}, setState = React.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  return React.useLayoutEffect(() => history.listen(setState), [history, setState]), React.useEffect(() => logV6DeprecationWarnings(future2), [future2]), /* @__PURE__ */ React.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future2
  });
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace3,
    state,
    relative
  } = _ref4;
  useInRouterContext() || invariant(!1);
  let {
    future: future2,
    static: isStatic
  } = React.useContext(NavigationContext), {
    matches: matches2
  } = React.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), navigate = useNavigate(), path = resolveTo(to, getResolveToMatches(matches2, future2.v7_relativeSplatPath), locationPathname, relative === "path"), jsonPath = JSON.stringify(path);
  return React.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace3,
    state,
    relative
  }), [navigate, jsonPath, relative, replace3, state]), null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(!1);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = !1,
    future: future2
  } = _ref5;
  useInRouterContext() && invariant(!1);
  let basename = basenameProp.replace(/^\/*/, "/"), navigationContext = React.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends2({
      v7_relativeSplatPath: !1
    }, future2)
  }), [basename, future2, navigator2, staticProp]);
  typeof locationProp == "string" && (locationProp = parsePath(locationProp));
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp, locationContext = React.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    return trailingPathname == null ? null : {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  return locationContext == null ? null : /* @__PURE__ */ React.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
function Await(_ref7) {
  let {
    children,
    errorElement,
    resolve
  } = _ref7;
  return /* @__PURE__ */ React.createElement(AwaitErrorBoundary, {
    resolve,
    errorElement
  }, /* @__PURE__ */ React.createElement(ResolveAwait, null, children));
}
function ResolveAwait(_ref8) {
  let {
    children
  } = _ref8, data3 = useAsyncValue(), toRender = typeof children == "function" ? children(data3) : children;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, toRender);
}
function createRoutesFromChildren(children, parentPath) {
  parentPath === void 0 && (parentPath = []);
  let routes2 = [];
  return React.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ React.isValidElement(element))
      return;
    let treePath = [...parentPath, index];
    if (element.type === React.Fragment) {
      routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    element.type !== Route && invariant(!1), !element.props.index || !element.props.children || invariant(!1);
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    element.props.children && (route.children = createRoutesFromChildren(element.props.children, treePath)), routes2.push(route);
  }), routes2;
}
function renderMatches(matches2) {
  return _renderMatches(matches2);
}
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  return route.Component && Object.assign(updates, {
    element: /* @__PURE__ */ React.createElement(route.Component),
    Component: void 0
  }), route.HydrateFallback && Object.assign(updates, {
    hydrateFallbackElement: /* @__PURE__ */ React.createElement(route.HydrateFallback),
    HydrateFallback: void 0
  }), route.ErrorBoundary && Object.assign(updates, {
    errorElement: /* @__PURE__ */ React.createElement(route.ErrorBoundary),
    ErrorBoundary: void 0
  }), updates;
}
function createMemoryRouter(routes2, opts) {
  return createRouter({
    basename: opts?.basename,
    future: _extends2({}, opts?.future, {
      v7_prependBasename: !0
    }),
    history: createMemoryHistory({
      initialEntries: opts?.initialEntries,
      initialIndex: opts?.initialIndex
    }),
    hydrationData: opts?.hydrationData,
    routes: routes2,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation
  }).initialize();
}
var React, DataRouterContext, DataRouterStateContext, AwaitContext, NavigationContext, LocationContext, RouteContext, RouteErrorContext, OutletContext, defaultErrorElement, RenderErrorBoundary, DataRouterHook, DataRouterStateHook, blockerId, alreadyWarned$1, logDeprecation, START_TRANSITION, startTransitionImpl, AwaitRenderStatus, neverSettledPromise, AwaitErrorBoundary, init_dist = __esm({
  "node_modules/react-router/dist/index.js"() {
    React = __toESM(require_react());
    init_router();
    init_router();
    DataRouterContext = /* @__PURE__ */ React.createContext(null), DataRouterStateContext = /* @__PURE__ */ React.createContext(null), AwaitContext = /* @__PURE__ */ React.createContext(null), NavigationContext = /* @__PURE__ */ React.createContext(null), LocationContext = /* @__PURE__ */ React.createContext(null), RouteContext = /* @__PURE__ */ React.createContext({
      outlet: null,
      matches: [],
      isDataRoute: !1
    }), RouteErrorContext = /* @__PURE__ */ React.createContext(null);
    OutletContext = /* @__PURE__ */ React.createContext(null);
    defaultErrorElement = /* @__PURE__ */ React.createElement(DefaultErrorComponent, null), RenderErrorBoundary = class extends React.Component {
      constructor(props) {
        super(props), this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle" ? {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        } : {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ React.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ React.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    };
    DataRouterHook = /* @__PURE__ */ function(DataRouterHook3) {
      return DataRouterHook3.UseBlocker = "useBlocker", DataRouterHook3.UseRevalidator = "useRevalidator", DataRouterHook3.UseNavigateStable = "useNavigate", DataRouterHook3;
    }(DataRouterHook || {}), DataRouterStateHook = /* @__PURE__ */ function(DataRouterStateHook3) {
      return DataRouterStateHook3.UseBlocker = "useBlocker", DataRouterStateHook3.UseLoaderData = "useLoaderData", DataRouterStateHook3.UseActionData = "useActionData", DataRouterStateHook3.UseRouteError = "useRouteError", DataRouterStateHook3.UseNavigation = "useNavigation", DataRouterStateHook3.UseRouteLoaderData = "useRouteLoaderData", DataRouterStateHook3.UseMatches = "useMatches", DataRouterStateHook3.UseRevalidator = "useRevalidator", DataRouterStateHook3.UseNavigateStable = "useNavigate", DataRouterStateHook3.UseRouteId = "useRouteId", DataRouterStateHook3;
    }(DataRouterStateHook || {});
    blockerId = 0;
    alreadyWarned$1 = {};
    logDeprecation = (flag, msg, link) => ("" + msg + ("You can use the `" + flag + "` future flag to opt-in early. ") + ("For more information, see " + link + "."), void 0);
    START_TRANSITION = "startTransition", startTransitionImpl = React[START_TRANSITION];
    AwaitRenderStatus = /* @__PURE__ */ function(AwaitRenderStatus2) {
      return AwaitRenderStatus2[AwaitRenderStatus2.pending = 0] = "pending", AwaitRenderStatus2[AwaitRenderStatus2.success = 1] = "success", AwaitRenderStatus2[AwaitRenderStatus2.error = 2] = "error", AwaitRenderStatus2;
    }(AwaitRenderStatus || {}), neverSettledPromise = new Promise(() => {
    }), AwaitErrorBoundary = class extends React.Component {
      constructor(props) {
        super(props), this.state = {
          error: null
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("<Await> caught the following error during render", error, errorInfo);
      }
      render() {
        let {
          children,
          errorElement,
          resolve
        } = this.props, promise = null, status = AwaitRenderStatus.pending;
        if (!(resolve instanceof Promise))
          status = AwaitRenderStatus.success, promise = Promise.resolve(), Object.defineProperty(promise, "_tracked", {
            get: () => !0
          }), Object.defineProperty(promise, "_data", {
            get: () => resolve
          });
        else if (this.state.error) {
          status = AwaitRenderStatus.error;
          let renderError = this.state.error;
          promise = Promise.reject().catch(() => {
          }), Object.defineProperty(promise, "_tracked", {
            get: () => !0
          }), Object.defineProperty(promise, "_error", {
            get: () => renderError
          });
        } else
          resolve._tracked ? (promise = resolve, status = "_error" in promise ? AwaitRenderStatus.error : "_data" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (status = AwaitRenderStatus.pending, Object.defineProperty(resolve, "_tracked", {
            get: () => !0
          }), promise = resolve.then((data3) => Object.defineProperty(resolve, "_data", {
            get: () => data3
          }), (error) => Object.defineProperty(resolve, "_error", {
            get: () => error
          })));
        if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError)
          throw neverSettledPromise;
        if (status === AwaitRenderStatus.error && !errorElement)
          throw promise._error;
        if (status === AwaitRenderStatus.error)
          return /* @__PURE__ */ React.createElement(AwaitContext.Provider, {
            value: promise,
            children: errorElement
          });
        if (status === AwaitRenderStatus.success)
          return /* @__PURE__ */ React.createElement(AwaitContext.Provider, {
            value: promise,
            children
          });
        throw promise;
      }
    };
  }
});

// node_modules/react-router-dom/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  AbortedDeferredError: () => AbortedDeferredError,
  Await: () => Await,
  BrowserRouter: () => BrowserRouter,
  Form: () => Form,
  HashRouter: () => HashRouter,
  Link: () => Link,
  MemoryRouter: () => MemoryRouter,
  NavLink: () => NavLink,
  Navigate: () => Navigate,
  NavigationType: () => Action,
  Outlet: () => Outlet,
  Route: () => Route,
  Router: () => Router,
  RouterProvider: () => RouterProvider2,
  Routes: () => Routes,
  ScrollRestoration: () => ScrollRestoration,
  UNSAFE_DataRouterContext: () => DataRouterContext,
  UNSAFE_DataRouterStateContext: () => DataRouterStateContext,
  UNSAFE_ErrorResponseImpl: () => ErrorResponseImpl,
  UNSAFE_FetchersContext: () => FetchersContext,
  UNSAFE_LocationContext: () => LocationContext,
  UNSAFE_NavigationContext: () => NavigationContext,
  UNSAFE_RouteContext: () => RouteContext,
  UNSAFE_ViewTransitionContext: () => ViewTransitionContext,
  UNSAFE_useRouteId: () => useRouteId,
  UNSAFE_useScrollRestoration: () => useScrollRestoration,
  createBrowserRouter: () => createBrowserRouter,
  createHashRouter: () => createHashRouter,
  createMemoryRouter: () => createMemoryRouter,
  createPath: () => createPath,
  createRoutesFromChildren: () => createRoutesFromChildren,
  createRoutesFromElements: () => createRoutesFromChildren,
  createSearchParams: () => createSearchParams,
  defer: () => defer,
  generatePath: () => generatePath,
  isRouteErrorResponse: () => isRouteErrorResponse,
  json: () => json,
  matchPath: () => matchPath,
  matchRoutes: () => matchRoutes,
  parsePath: () => parsePath,
  redirect: () => redirect,
  redirectDocument: () => redirectDocument,
  renderMatches: () => renderMatches,
  replace: () => replace,
  resolvePath: () => resolvePath,
  unstable_HistoryRouter: () => HistoryRouter,
  unstable_usePrompt: () => usePrompt,
  useActionData: () => useActionData,
  useAsyncError: () => useAsyncError,
  useAsyncValue: () => useAsyncValue,
  useBeforeUnload: () => useBeforeUnload,
  useBlocker: () => useBlocker,
  useFetcher: () => useFetcher,
  useFetchers: () => useFetchers,
  useFormAction: () => useFormAction,
  useHref: () => useHref,
  useInRouterContext: () => useInRouterContext,
  useLinkClickHandler: () => useLinkClickHandler,
  useLoaderData: () => useLoaderData,
  useLocation: () => useLocation,
  useMatch: () => useMatch,
  useMatches: () => useMatches,
  useNavigate: () => useNavigate,
  useNavigation: () => useNavigation,
  useNavigationType: () => useNavigationType,
  useOutlet: () => useOutlet,
  useOutletContext: () => useOutletContext,
  useParams: () => useParams,
  useResolvedPath: () => useResolvedPath,
  useRevalidator: () => useRevalidator,
  useRouteError: () => useRouteError,
  useRouteLoaderData: () => useRouteLoaderData,
  useRoutes: () => useRoutes,
  useSearchParams: () => useSearchParams,
  useSubmit: () => useSubmit,
  useViewTransitionState: () => useViewTransitionState
});
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName == "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init) {
  return init === void 0 && (init = ""), new URLSearchParams(typeof init == "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo7, key) => {
    let value = init[key];
    return memo7.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  return defaultSearchParams && defaultSearchParams.forEach((_, key) => {
    searchParams.has(key) || defaultSearchParams.getAll(key).forEach((value) => {
      searchParams.append(key, value);
    });
  }), searchParams;
}
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), _formDataSupportsSubmitter = !1;
    } catch {
      _formDataSupportsSubmitter = !0;
    }
  return _formDataSupportsSubmitter;
}
function getFormEncType(encType) {
  return encType != null && !supportedFormEncTypes.has(encType) ? null : encType;
}
function getFormSubmissionInfo(target, basename) {
  let method, action8, encType, formData, body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action8 = attr ? stripBasename(attr, basename) : null, method = target.getAttribute("method") || defaultMethod, encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType, formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    if (action8 = attr ? stripBasename(attr, basename) : null, method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod, encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType, formData = new FormData(form, target), !isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? name + "." : "";
        formData.append(prefix + "x", "0"), formData.append(prefix + "y", "0");
      } else
        name && formData.append(name, value);
    }
  } else {
    if (isHtmlElement(target))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    method = defaultMethod, action8 = null, encType = defaultEncType, body = target;
  }
  return formData && encType === "text/plain" && (body = formData, formData = void 0), {
    action: action8,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}
function createBrowserRouter(routes2, opts) {
  return createRouter({
    basename: opts?.basename,
    future: _extends3({}, opts?.future, {
      v7_prependBasename: !0
    }),
    history: createBrowserHistory({
      window: opts?.window
    }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes: routes2,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function createHashRouter(routes2, opts) {
  return createRouter({
    basename: opts?.basename,
    future: _extends3({}, opts?.future, {
      v7_prependBasename: !0
    }),
    history: createHashHistory({
      window: opts?.window
    }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes: routes2,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  return state && state.errors && (state = _extends3({}, state, {
    errors: deserializeErrors(state.errors)
  })), state;
}
function deserializeErrors(errors) {
  if (!errors)
    return null;
  let entries = Object.entries(errors), serialized = {};
  for (let [key, val] of entries)
    if (val && val.__type === "RouteErrorResponse")
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === !0);
    else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor == "function")
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "", serialized[key] = error;
          } catch {
          }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "", serialized[key] = error;
      }
    } else
      serialized[key] = val;
  return serialized;
}
function startTransitionSafe(cb) {
  startTransitionImpl2 ? startTransitionImpl2(cb) : cb();
}
function flushSyncSafe(cb) {
  flushSyncImpl ? flushSyncImpl(cb) : cb();
}
function RouterProvider2(_ref) {
  let {
    fallbackElement,
    router,
    future: future2
  } = _ref, [state, setStateImpl] = React2.useState(router.state), [pendingState, setPendingState] = React2.useState(), [vtContext, setVtContext] = React2.useState({
    isTransitioning: !1
  }), [renderDfd, setRenderDfd] = React2.useState(), [transition, setTransition] = React2.useState(), [interruption, setInterruption] = React2.useState(), fetcherData = React2.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition
  } = future2 || {}, optInStartTransition = React2.useCallback((cb) => {
    v7_startTransition ? startTransitionSafe(cb) : cb();
  }, [v7_startTransition]), setState = React2.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      flushSync,
      viewTransitionOpts
    } = _ref2;
    newState.fetchers.forEach((fetcher, key) => {
      fetcher.data !== void 0 && fetcherData.current.set(key, fetcher.data);
    }), deletedFetchers.forEach((key) => fetcherData.current.delete(key));
    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition != "function";
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      flushSync ? flushSyncSafe(() => setStateImpl(newState)) : optInStartTransition(() => setStateImpl(newState));
      return;
    }
    if (flushSync) {
      flushSyncSafe(() => {
        transition && (renderDfd && renderDfd.resolve(), transition.skipTransition()), setVtContext({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      let t = router.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      t.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(void 0), setTransition(void 0), setPendingState(void 0), setVtContext({
            isTransitioning: !1
          });
        });
      }), flushSyncSafe(() => setTransition(t));
      return;
    }
    transition ? (renderDfd && renderDfd.resolve(), transition.skipTransition(), setInterruption({
      state: newState,
      currentLocation: viewTransitionOpts.currentLocation,
      nextLocation: viewTransitionOpts.nextLocation
    })) : (setPendingState(newState), setVtContext({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: viewTransitionOpts.currentLocation,
      nextLocation: viewTransitionOpts.nextLocation
    }));
  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);
  React2.useLayoutEffect(() => router.subscribe(setState), [router, setState]), React2.useEffect(() => {
    vtContext.isTransitioning && !vtContext.flushSync && setRenderDfd(new Deferred());
  }, [vtContext]), React2.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState, renderPromise = renderDfd.promise, transition2 = router.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState)), await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0), setTransition(void 0), setPendingState(void 0), setVtContext({
          isTransitioning: !1
        });
      }), setTransition(transition2);
    }
  }, [optInStartTransition, pendingState, renderDfd, router.window]), React2.useEffect(() => {
    renderDfd && pendingState && state.location.key === pendingState.location.key && renderDfd.resolve();
  }, [renderDfd, transition, state.location, pendingState]), React2.useEffect(() => {
    !vtContext.isTransitioning && interruption && (setPendingState(interruption.state), setVtContext({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: interruption.currentLocation,
      nextLocation: interruption.nextLocation
    }), setInterruption(void 0));
  }, [vtContext.isTransitioning, interruption]), React2.useEffect(() => {
  }, []);
  let navigator2 = React2.useMemo(() => ({
    createHref: router.createHref,
    encodeLocation: router.encodeLocation,
    go: (n) => router.navigate(n),
    push: (to, state2, opts) => router.navigate(to, {
      state: state2,
      preventScrollReset: opts?.preventScrollReset
    }),
    replace: (to, state2, opts) => router.navigate(to, {
      replace: !0,
      state: state2,
      preventScrollReset: opts?.preventScrollReset
    })
  }), [router]), basename = router.basename || "/", dataRouterContext = React2.useMemo(() => ({
    router,
    navigator: navigator2,
    static: !1,
    basename
  }), [router, navigator2, basename]), routerFuture = React2.useMemo(() => ({
    v7_relativeSplatPath: router.future.v7_relativeSplatPath
  }), [router.future.v7_relativeSplatPath]);
  return React2.useEffect(() => logV6DeprecationWarnings(future2, router.future), [future2, router.future]), /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ React2.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ React2.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /* @__PURE__ */ React2.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /* @__PURE__ */ React2.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2,
    future: routerFuture
  }, state.initialized || router.future.v7_partialHydration ? /* @__PURE__ */ React2.createElement(MemoizedDataRoutes, {
    routes: router.routes,
    future: router.future,
    state
  }) : fallbackElement))))), null);
}
function DataRoutes2(_ref3) {
  let {
    routes: routes2,
    future: future2,
    state
  } = _ref3;
  return useRoutesImpl(routes2, void 0, state, future2);
}
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future: future2,
    window: window2
  } = _ref4, historyRef = React2.useRef();
  historyRef.current == null && (historyRef.current = createBrowserHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setStateImpl] = React2.useState({
    action: history.action,
    location: history.location
  }), {
    v7_startTransition
  } = future2 || {}, setState = React2.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  return React2.useLayoutEffect(() => history.listen(setState), [history, setState]), React2.useEffect(() => logV6DeprecationWarnings(future2), [future2]), /* @__PURE__ */ React2.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future2
  });
}
function HashRouter(_ref5) {
  let {
    basename,
    children,
    future: future2,
    window: window2
  } = _ref5, historyRef = React2.useRef();
  historyRef.current == null && (historyRef.current = createHashHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setStateImpl] = React2.useState({
    action: history.action,
    location: history.location
  }), {
    v7_startTransition
  } = future2 || {}, setState = React2.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  return React2.useLayoutEffect(() => history.listen(setState), [history, setState]), React2.useEffect(() => logV6DeprecationWarnings(future2), [future2]), /* @__PURE__ */ React2.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future2
  });
}
function HistoryRouter(_ref6) {
  let {
    basename,
    children,
    future: future2,
    history
  } = _ref6, [state, setStateImpl] = React2.useState({
    action: history.action,
    location: history.location
  }), {
    v7_startTransition
  } = future2 || {}, setState = React2.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  return React2.useLayoutEffect(() => history.listen(setState), [history, setState]), React2.useEffect(() => logV6DeprecationWarnings(future2), [future2]), /* @__PURE__ */ React2.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history,
    future: future2
  });
}
function ScrollRestoration(_ref10) {
  let {
    getKey,
    storageKey
  } = _ref10;
  return useScrollRestoration({
    getKey,
    storageKey
  }), null;
}
function useDataRouterContext2(hookName) {
  let ctx = React2.useContext(DataRouterContext);
  return ctx || invariant(!1), ctx;
}
function useDataRouterState2(hookName) {
  let state = React2.useContext(DataRouterStateContext);
  return state || invariant(!1), state;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp, navigate = useNavigate(), location = useLocation(), path = useResolvedPath(to, {
    relative
  });
  return React2.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace3 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace3,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = React2.useRef(createSearchParams(defaultInit)), hasSetSearchParamsRef = React2.useRef(!1), location = useLocation(), searchParams = React2.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location.search]), navigate = useNavigate(), setSearchParams = React2.useCallback((nextInit, navigateOptions) => {
    let newSearchParams = createSearchParams(typeof nextInit == "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = !0, navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function validateClientSideSubmission() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
function useSubmit() {
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseSubmit), {
    basename
  } = React2.useContext(NavigationContext), currentRouteId = useRouteId();
  return React2.useCallback(function(target, options) {
    options === void 0 && (options = {}), validateClientSideSubmission();
    let {
      action: action8,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === !1) {
      let key = options.fetcherKey || getUniqueFetcherId();
      router.fetch(key, currentRouteId, options.action || action8, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        flushSync: options.flushSync
      });
    } else
      router.navigate(options.action || action8, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        flushSync: options.flushSync,
        viewTransition: options.viewTransition
      });
  }, [router, basename, currentRouteId]);
}
function useFormAction(action8, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2, {
    basename
  } = React2.useContext(NavigationContext), routeContext = React2.useContext(RouteContext);
  routeContext || invariant(!1);
  let [match] = routeContext.matches.slice(-1), path = _extends3({}, useResolvedPath(action8 || ".", {
    relative
  })), location = useLocation();
  if (action8 == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search), indexValues = params.getAll("index");
    if (indexValues.some((v) => v === "")) {
      params.delete("index"), indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? "?" + qs : "";
    }
  }
  return (!action8 || action8 === ".") && match.route.index && (path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index"), basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), createPath(path);
}
function useFetcher(_temp3) {
  var _route$matches;
  let {
    key
  } = _temp3 === void 0 ? {} : _temp3, {
    router
  } = useDataRouterContext2(DataRouterHook2.UseFetcher), state = useDataRouterState2(DataRouterStateHook2.UseFetcher), fetcherData = React2.useContext(FetchersContext), route = React2.useContext(RouteContext), routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
  fetcherData || invariant(!1), route || invariant(!1), routeId == null && invariant(!1);
  let defaultKey = useIdImpl ? useIdImpl() : "", [fetcherKey, setFetcherKey] = React2.useState(key || defaultKey);
  key && key !== fetcherKey ? setFetcherKey(key) : fetcherKey || setFetcherKey(getUniqueFetcherId()), React2.useEffect(() => (router.getFetcher(fetcherKey), () => {
    router.deleteFetcher(fetcherKey);
  }), [router, fetcherKey]);
  let load = React2.useCallback((href, opts) => {
    routeId || invariant(!1), router.fetch(fetcherKey, routeId, href, opts);
  }, [fetcherKey, routeId, router]), submitImpl = useSubmit(), submit = React2.useCallback((target, opts) => {
    submitImpl(target, _extends3({}, opts, {
      navigate: !1,
      fetcherKey
    }));
  }, [fetcherKey, submitImpl]), FetcherForm = React2.useMemo(() => /* @__PURE__ */ React2.forwardRef((props, ref) => /* @__PURE__ */ React2.createElement(Form, _extends3({}, props, {
    navigate: !1,
    fetcherKey,
    ref
  }))), [fetcherKey]), fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER, data3 = fetcherData.get(fetcherKey);
  return React2.useMemo(() => _extends3({
    Form: FetcherForm,
    submit,
    load
  }, fetcher, {
    data: data3
  }), [FetcherForm, submit, load, fetcher, data3]);
}
function useFetchers() {
  let state = useDataRouterState2(DataRouterStateHook2.UseFetchers);
  return Array.from(state.fetchers.entries()).map((_ref11) => {
    let [key, fetcher] = _ref11;
    return _extends3({}, fetcher, {
      key
    });
  });
}
function useScrollRestoration(_temp4) {
  let {
    getKey,
    storageKey
  } = _temp4 === void 0 ? {} : _temp4, {
    router
  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration), {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration), {
    basename
  } = React2.useContext(NavigationContext), location = useLocation(), matches2 = useMatches(), navigation = useNavigation();
  React2.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), usePageHide(React2.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches2) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    try {
      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    } catch {
    }
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches2])), typeof document < "u" && (React2.useLayoutEffect(() => {
    try {
      let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
      sessionPositions && (savedScrollPositions = JSON.parse(sessionPositions));
    } catch {
    }
  }, [storageKey]), React2.useLayoutEffect(() => {
    let getKeyWithoutBasename = getKey && basename !== "/" ? (location2, matches3) => getKey(
      // Strip the basename to match useLocation()
      _extends3({}, location2, {
        pathname: stripBasename(location2.pathname, basename) || location2.pathname
      }),
      matches3
    ) : getKey, disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
    return () => disableScrollRestoration && disableScrollRestoration();
  }, [router, basename, getKey]), React2.useLayoutEffect(() => {
    if (restoreScrollPosition !== !1) {
      if (typeof restoreScrollPosition == "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      preventScrollReset !== !0 && window.scrollTo(0, 0);
    }
  }, [location, restoreScrollPosition, preventScrollReset]));
}
function useBeforeUnload(callback2, options) {
  let {
    capture
  } = options || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    return window.addEventListener("beforeunload", callback2, opts), () => {
      window.removeEventListener("beforeunload", callback2, opts);
    };
  }, [callback2, capture]);
}
function usePageHide(callback2, options) {
  let {
    capture
  } = options || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    return window.addEventListener("pagehide", callback2, opts), () => {
      window.removeEventListener("pagehide", callback2, opts);
    };
  }, [callback2, capture]);
}
function usePrompt(_ref12) {
  let {
    when,
    message
  } = _ref12, blocker = useBlocker(when);
  React2.useEffect(() => {
    blocker.state === "blocked" && (window.confirm(message) ? setTimeout(blocker.proceed, 0) : blocker.reset());
  }, [blocker, message]), React2.useEffect(() => {
    blocker.state === "blocked" && !when && blocker.reset();
  }, [blocker, when]);
}
function useViewTransitionState(to, opts) {
  opts === void 0 && (opts = {});
  let vtContext = React2.useContext(ViewTransitionContext);
  vtContext == null && invariant(!1);
  let {
    basename
  } = useDataRouterContext2(DataRouterHook2.useViewTransitionState), path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning)
    return !1;
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname, nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
var React2, ReactDOM, defaultMethod, defaultEncType, _formDataSupportsSubmitter, supportedFormEncTypes, _excluded, _excluded2, _excluded3, REACT_ROUTER_VERSION, ViewTransitionContext, FetchersContext, START_TRANSITION2, startTransitionImpl2, FLUSH_SYNC, flushSyncImpl, USE_ID, useIdImpl, Deferred, MemoizedDataRoutes, isBrowser, ABSOLUTE_URL_REGEX2, Link, NavLink, Form, DataRouterHook2, DataRouterStateHook2, fetcherId, getUniqueFetcherId, SCROLL_RESTORATION_STORAGE_KEY, savedScrollPositions, init_dist2 = __esm({
  "node_modules/react-router-dom/dist/index.js"() {
    React2 = __toESM(require_react()), ReactDOM = __toESM(require_react_dom());
    init_dist();
    init_dist();
    init_router();
    init_router();
    defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded";
    _formDataSupportsSubmitter = null;
    supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
    _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], REACT_ROUTER_VERSION = "6";
    try {
      window.__reactRouterVersion = REACT_ROUTER_VERSION;
    } catch {
    }
    ViewTransitionContext = /* @__PURE__ */ React2.createContext({
      isTransitioning: !1
    }), FetchersContext = /* @__PURE__ */ React2.createContext(/* @__PURE__ */ new Map()), START_TRANSITION2 = "startTransition", startTransitionImpl2 = React2[START_TRANSITION2], FLUSH_SYNC = "flushSync", flushSyncImpl = ReactDOM[FLUSH_SYNC], USE_ID = "useId", useIdImpl = React2[USE_ID];
    Deferred = class {
      constructor() {
        this.status = "pending", this.promise = new Promise((resolve, reject) => {
          this.resolve = (value) => {
            this.status === "pending" && (this.status = "resolved", resolve(value));
          }, this.reject = (reason) => {
            this.status === "pending" && (this.status = "rejected", reject(reason));
          };
        });
      }
    };
    MemoizedDataRoutes = /* @__PURE__ */ React2.memo(DataRoutes2);
    isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link = /* @__PURE__ */ React2.forwardRef(function(_ref7, ref) {
      let {
        onClick,
        relative,
        reloadDocument,
        replace: replace3,
        state,
        target,
        to,
        preventScrollReset,
        viewTransition
      } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded), {
        basename
      } = React2.useContext(NavigationContext), absoluteHref, isExternal = !1;
      if (typeof to == "string" && ABSOLUTE_URL_REGEX2.test(to) && (absoluteHref = to, isBrowser))
        try {
          let currentUrl = new URL(window.location.href), targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to), path = stripBasename(targetUrl.pathname, basename);
          targetUrl.origin === currentUrl.origin && path != null ? to = path + targetUrl.search + targetUrl.hash : isExternal = !0;
        } catch {
        }
      let href = useHref(to, {
        relative
      }), internalOnClick = useLinkClickHandler(to, {
        replace: replace3,
        state,
        target,
        preventScrollReset,
        relative,
        viewTransition
      });
      function handleClick(event) {
        onClick && onClick(event), event.defaultPrevented || internalOnClick(event);
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ React2.createElement("a", _extends3({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref,
          target
        }))
      );
    }), NavLink = /* @__PURE__ */ React2.forwardRef(function(_ref8, ref) {
      let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = !1,
        className: classNameProp = "",
        end = !1,
        style: styleProp,
        to,
        viewTransition,
        children
      } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2), path = useResolvedPath(to, {
        relative: rest.relative
      }), location = useLocation(), routerState = React2.useContext(DataRouterStateContext), {
        navigator: navigator2,
        basename
      } = React2.useContext(NavigationContext), isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useViewTransitionState(path) && viewTransition === !0, toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname, locationPathname = location.pathname, nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      caseSensitive || (locationPathname = locationPathname.toLowerCase(), nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null, toPathname = toPathname.toLowerCase()), nextLocationPathname && basename && (nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname);
      let endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length, isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/", isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/"), renderProps = {
        isActive,
        isPending,
        isTransitioning
      }, ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
      typeof classNameProp == "function" ? className = classNameProp(renderProps) : className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
      let style = typeof styleProp == "function" ? styleProp(renderProps) : styleProp;
      return /* @__PURE__ */ React2.createElement(Link, _extends3({}, rest, {
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      }), typeof children == "function" ? children(renderProps) : children);
    }), Form = /* @__PURE__ */ React2.forwardRef((_ref9, forwardedRef) => {
      let {
        fetcherKey,
        navigate,
        reloadDocument,
        replace: replace3,
        state,
        method = defaultMethod,
        action: action8,
        onSubmit,
        relative,
        preventScrollReset,
        viewTransition
      } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3), submit = useSubmit(), formAction = useFormAction(action8, {
        relative
      }), formMethod = method.toLowerCase() === "get" ? "get" : "post";
      return /* @__PURE__ */ React2.createElement("form", _extends3({
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : (event) => {
          if (onSubmit && onSubmit(event), event.defaultPrevented)
            return;
          event.preventDefault();
          let submitter = event.nativeEvent.submitter, submitMethod = submitter?.getAttribute("formmethod") || method;
          submit(submitter || event.currentTarget, {
            fetcherKey,
            method: submitMethod,
            navigate,
            replace: replace3,
            state,
            relative,
            preventScrollReset,
            viewTransition
          });
        }
      }, props));
    });
    (function(DataRouterHook3) {
      DataRouterHook3.UseScrollRestoration = "useScrollRestoration", DataRouterHook3.UseSubmit = "useSubmit", DataRouterHook3.UseSubmitFetcher = "useSubmitFetcher", DataRouterHook3.UseFetcher = "useFetcher", DataRouterHook3.useViewTransitionState = "useViewTransitionState";
    })(DataRouterHook2 || (DataRouterHook2 = {}));
    (function(DataRouterStateHook3) {
      DataRouterStateHook3.UseFetcher = "useFetcher", DataRouterStateHook3.UseFetchers = "useFetchers", DataRouterStateHook3.UseScrollRestoration = "useScrollRestoration";
    })(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
    fetcherId = 0, getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
    SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions", savedScrollPositions = {};
  }
});

// node_modules/react-router-dom/server.js
var require_server = __commonJS({
  "node_modules/react-router-dom/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React124 = require_react(), router = (init_router(), __toCommonJS(router_exports)), reactRouter = (init_dist(), __toCommonJS(dist_exports)), reactRouterDom = (init_dist2(), __toCommonJS(dist_exports2));
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React124);
    function StaticRouter({
      basename,
      children,
      location: locationProp = "/",
      future: future2
    }) {
      typeof locationProp == "string" && (locationProp = reactRouterDom.parsePath(locationProp));
      let action8 = router.Action.Pop, location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state != null ? locationProp.state : null,
        key: locationProp.key || "default"
      }, staticNavigator = getStatelessNavigator();
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename,
        children,
        location,
        navigationType: action8,
        navigator: staticNavigator,
        future: future2,
        static: !0
      });
    }
    function StaticRouterProvider2({
      context,
      router: router$1,
      hydrate = !0,
      nonce: nonce2
    }) {
      router$1 && context || router.UNSAFE_invariant(!1);
      let dataRouterContext = {
        router: router$1,
        navigator: getStatelessNavigator(),
        static: !0,
        staticContext: context,
        basename: context.basename || "/"
      }, fetchersContext = /* @__PURE__ */ new Map(), hydrateScript = "";
      if (hydrate !== !1) {
        let data3 = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors2(context.errors)
        };
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${htmlEscape(JSON.stringify(JSON.stringify(data3)))});`;
      }
      let {
        state
      } = dataRouterContext.router;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_FetchersContext.Provider, {
        value: fetchersContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_ViewTransitionContext.Provider, {
        value: {
          isTransitioning: !1
        }
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: dataRouterContext.basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: dataRouterContext.navigator,
        static: dataRouterContext.static,
        future: {
          v7_relativeSplatPath: router$1.future.v7_relativeSplatPath
        }
      }, /* @__PURE__ */ React__namespace.createElement(DataRoutes3, {
        routes: router$1.routes,
        future: router$1.future,
        state
      })))))), hydrateScript ? /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        nonce: nonce2,
        dangerouslySetInnerHTML: {
          __html: hydrateScript
        }
      }) : null);
    }
    function DataRoutes3({
      routes: routes2,
      future: future2,
      state
    }) {
      return reactRouter.UNSAFE_useRoutesImpl(routes2, void 0, state, future2);
    }
    function serializeErrors2(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        router.isRouteErrorResponse(val) ? serialized[key] = {
          ...val,
          __type: "RouteErrorResponse"
        } : val instanceof Error ? serialized[key] = {
          message: val.message,
          __type: "Error",
          // If this is a subclass (i.e., ReferenceError), send up the type so we
          // can re-create the same type during hydration.
          ...val.name !== "Error" ? {
            __subType: val.name
          } : {}
        } : serialized[key] = val;
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
        },
        replace(to) {
          throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
        },
        go(delta) {
          throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
        },
        back() {
          throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
        },
        forward() {
          throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
        }
      };
    }
    function createStaticHandler2(routes2, opts) {
      return router.createStaticHandler(routes2, {
        ...opts,
        mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
      });
    }
    function createStaticRouter2(routes2, context, opts = {}) {
      let manifest = {}, dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes2, reactRouter.UNSAFE_mapRouteProperties, void 0, manifest), matches2 = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      }), msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get future() {
          return {
            v7_fetcherPersist: !1,
            v7_normalizeFormMethod: !1,
            v7_partialHydration: opts.future?.v7_partialHydration === !0,
            v7_prependBasename: !1,
            v7_relativeSplatPath: opts.future?.v7_relativeSplatPath === !0,
            v7_skipActionErrorRevalidation: !1
          };
        },
        get state() {
          return {
            historyAction: router.Action.Pop,
            location: context.location,
            matches: matches2,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: !0,
            navigation: router.IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: !1,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        get window() {
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return router.IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return router.IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        patchRoutes() {
          throw msg("patchRoutes");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalActiveDeferreds: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to == "string" ? to : reactRouterDom.createPath(to);
    }
    function encodeLocation(to) {
      let href = typeof to == "string" ? to : reactRouterDom.createPath(to);
      href = href.replace(/ $/, "%20");
      let encoded = ABSOLUTE_URL_REGEX4.test(href) ? new URL(href) : new URL(href, "http://localhost");
      return {
        pathname: encoded.pathname,
        search: encoded.search,
        hash: encoded.hash
      };
    }
    var ABSOLUTE_URL_REGEX4 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, ESCAPE_LOOKUP3 = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
    function htmlEscape(str) {
      return str.replace(ESCAPE_REGEX3, (match) => ESCAPE_LOOKUP3[match]);
    }
    exports.StaticRouter = StaticRouter;
    exports.StaticRouterProvider = StaticRouterProvider2;
    exports.createStaticHandler = createStaticHandler2;
    exports.createStaticRouter = createStaticRouter2;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js
var require_react_dom_server_legacy_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js"(exports) {
    "use strict";
    var ea = require_react(), fa = __require("stream"), n = Object.prototype.hasOwnProperty, ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = {}, ja = {};
    function ka(a) {
      return n.call(ja, a) ? !0 : n.call(ia, a) ? !1 : ha.test(a) ? ja[a] = !0 : (ia[a] = !0, !1);
    }
    function q(a, b, c, d, f, e, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e, this.removeEmptyString = g;
    }
    var r = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      r[a] = new q(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      r[b] = new q(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      r[a] = new q(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      r[a] = new q(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      r[a] = new q(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      r[a] = new q(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      r[a] = new q(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      r[a] = new q(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      r[a] = new q(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var la = /[\-:]([a-z])/g;
    function ma(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        la,
        ma
      );
      r[b] = new q(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(la, ma);
      r[b] = new q(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(la, ma);
      r[b] = new q(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      r[a] = new q(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    r.xlinkHref = new q("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      r[a] = new q(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var t = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, na = ["Webkit", "ms", "Moz", "O"];
    Object.keys(t).forEach(function(a) {
      na.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), t[b] = t[a];
      });
    });
    var oa = /["'&<>]/;
    function u(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = oa.exec(a);
      if (b) {
        var c = "", d, f = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f !== d && (c += a.substring(f, d)), f = d + 1, c += b;
        }
        a = f !== d ? c + a.substring(f, d) : c;
      }
      return a;
    }
    var pa = /([A-Z])/g, qa = /^ms-/, ra = Array.isArray;
    function v(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function sa(a, b, c) {
      switch (b) {
        case "select":
          return v(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return v(2, null);
        case "math":
          return v(3, null);
        case "foreignObject":
          return v(1, null);
        case "table":
          return v(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return v(5, null);
        case "colgroup":
          return v(7, null);
        case "tr":
          return v(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? v(1, null) : a;
    }
    var ta = /* @__PURE__ */ new Map();
    function ua(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (n.call(c, d)) {
          var f = c[d];
          if (f != null && typeof f != "boolean" && f !== "") {
            if (d.indexOf("--") === 0) {
              var e = u(d);
              f = u(("" + f).trim());
            } else {
              e = d;
              var g = ta.get(e);
              g !== void 0 || (g = u(e.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e, g)), e = g, f = typeof f == "number" ? f === 0 || n.call(
                t,
                d
              ) ? "" + f : f + "px" : u(("" + f).trim());
            }
            b ? (b = !1, a.push(' style="', e, ":", f)) : a.push(";", e, ":", f);
          }
        }
      b || a.push('"');
    }
    function w(a, b, c, d) {
      switch (c) {
        case "style":
          ua(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = r.hasOwnProperty(c) ? r[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(" ", c, '=""');
              break;
            case 4:
              d === !0 ? a.push(" ", c, '=""') : d !== !1 && a.push(" ", c, '="', u(d), '"');
              break;
            case 5:
              isNaN(d) || a.push(" ", c, '="', u(d), '"');
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(" ", c, '="', u(d), '"');
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', u(d), '"');
          }
        } else if (ka(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(" ", c, '="', u(d), '"');
        }
      }
    }
    function x(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function va(a) {
      var b = "";
      return ea.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    function wa(a, b, c, d) {
      a.push(z(c));
      var f = c = null, e;
      for (e in b)
        if (n.call(b, e)) {
          var g = b[e];
          if (g != null)
            switch (e) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f = g;
                break;
              default:
                w(a, d, e, g);
            }
        }
      return a.push(">"), x(a, f, c), typeof c == "string" ? (a.push(u(c)), null) : c;
    }
    var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ya = /* @__PURE__ */ new Map();
    function z(a) {
      var b = ya.get(a);
      if (b === void 0) {
        if (!xa.test(a))
          throw Error("Invalid tag: " + a);
        b = "<" + a, ya.set(a, b);
      }
      return b;
    }
    function za(a, b, c, d, f) {
      switch (b) {
        case "select":
          a.push(z("select"));
          var e = null, g = null;
          for (l in c)
            if (n.call(c, l)) {
              var h = c[l];
              if (h != null)
                switch (l) {
                  case "children":
                    e = h;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    w(a, d, l, h);
                }
            }
          return a.push(">"), x(a, g, e), e;
        case "option":
          g = f.selectedValue, a.push(z("option"));
          var k = h = null, m = null, l = null;
          for (e in c)
            if (n.call(c, e)) {
              var p = c[e];
              if (p != null)
                switch (e) {
                  case "children":
                    h = p;
                    break;
                  case "selected":
                    m = p;
                    break;
                  case "dangerouslySetInnerHTML":
                    l = p;
                    break;
                  case "value":
                    k = p;
                  default:
                    w(a, d, e, p);
                }
            }
          if (g != null)
            if (c = k !== null ? "" + k : va(h), ra(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(' selected=""');
                  break;
                }
            } else
              "" + g === c && a.push(' selected=""');
          else
            m && a.push(' selected=""');
          return a.push(">"), x(a, l, h), h;
        case "textarea":
          a.push(z("textarea")), l = g = e = null;
          for (h in c)
            if (n.call(c, h) && (k = c[h], k != null))
              switch (h) {
                case "children":
                  l = k;
                  break;
                case "value":
                  e = k;
                  break;
                case "defaultValue":
                  g = k;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  w(a, d, h, k);
              }
          if (e === null && g !== null && (e = g), a.push(">"), l != null) {
            if (e != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (ra(l) && 1 < l.length)
              throw Error("<textarea> can only have at most one child.");
            e = "" + l;
          }
          return typeof e == "string" && e[0] === `
` && a.push(`
`), e !== null && a.push(u("" + e)), null;
        case "input":
          a.push(z("input")), k = l = h = e = null;
          for (g in c)
            if (n.call(c, g) && (m = c[g], m != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  k = m;
                  break;
                case "defaultValue":
                  h = m;
                  break;
                case "checked":
                  l = m;
                  break;
                case "value":
                  e = m;
                  break;
                default:
                  w(a, d, g, m);
              }
          return l !== null ? w(a, d, "checked", l) : k !== null && w(a, d, "checked", k), e !== null ? w(a, d, "value", e) : h !== null && w(a, d, "value", h), a.push("/>"), null;
        case "menuitem":
          a.push(z("menuitem"));
          for (var B in c)
            if (n.call(c, B) && (e = c[B], e != null))
              switch (B) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  w(
                    a,
                    d,
                    B,
                    e
                  );
              }
          return a.push(">"), null;
        case "title":
          a.push(z("title")), e = null;
          for (p in c)
            if (n.call(c, p) && (g = c[p], g != null))
              switch (p) {
                case "children":
                  e = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  w(a, d, p, g);
              }
          return a.push(">"), e;
        case "listing":
        case "pre":
          a.push(z(b)), g = e = null;
          for (k in c)
            if (n.call(c, k) && (h = c[k], h != null))
              switch (k) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                default:
                  w(a, d, k, h);
              }
          if (a.push(">"), g != null) {
            if (e != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(`
`, c) : a.push("" + c));
          }
          return typeof e == "string" && e[0] === `
` && a.push(`
`), e;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(z(b));
          for (var C in c)
            if (n.call(c, C) && (e = c[C], e != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  w(a, d, C, e);
              }
          return a.push("/>"), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return wa(a, c, b, d);
        case "html":
          return f.insertionMode === 0 && a.push("<!DOCTYPE html>"), wa(a, c, b, d);
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return wa(a, c, b, d);
          a.push(z(b)), g = e = null;
          for (m in c)
            if (n.call(c, m) && (h = c[m], h != null))
              switch (m) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                case "style":
                  ua(a, d, h);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ka(m) && typeof h != "function" && typeof h != "symbol" && a.push(" ", m, '="', u(h), '"');
              }
          return a.push(">"), x(a, g, e), e;
      }
    }
    function Aa(a, b, c) {
      if (a.push('<!--$?--><template id="'), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return a.push(c), a.push('"></template>');
    }
    function Ba(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 2:
          return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 3:
          return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 4:
          return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 5:
          return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 6:
          return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 7:
          return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ca(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return a.push("</div>");
        case 2:
          return a.push("</svg>");
        case 3:
          return a.push("</math>");
        case 4:
          return a.push("</table>");
        case 5:
          return a.push("</tbody></table>");
        case 6:
          return a.push("</tr></table>");
        case 7:
          return a.push("</colgroup></table>");
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Da = /[<\u2028\u2029]/g;
    function Ea(a) {
      return JSON.stringify(a).replace(Da, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Fa(a, b) {
      return b = b === void 0 ? "" : b, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b + "P:", segmentPrefix: b + "S:", boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: a };
    }
    function Ga() {
      return { insertionMode: 1, selectedValue: null };
    }
    function Ha(a, b, c, d) {
      return c.generateStaticMarkup ? (a.push(u(b)), !1) : (b === "" ? a = d : (d && a.push("<!-- -->"), a.push(u(b)), a = !0), a);
    }
    var A = Object.assign, Ia = Symbol.for("react.element"), Ja = Symbol.for("react.portal"), Ka = Symbol.for("react.fragment"), La = Symbol.for("react.strict_mode"), Ma = Symbol.for("react.profiler"), Na = Symbol.for("react.provider"), Oa = Symbol.for("react.context"), Pa = Symbol.for("react.forward_ref"), Qa = Symbol.for("react.suspense"), Ra = Symbol.for("react.suspense_list"), Sa = Symbol.for("react.memo"), Ta = Symbol.for("react.lazy"), Ua = Symbol.for("react.scope"), Va = Symbol.for("react.debug_trace_mode"), Wa = Symbol.for("react.legacy_hidden"), Xa = Symbol.for("react.default_value"), Ya = Symbol.iterator;
    function Za(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Ka:
          return "Fragment";
        case Ja:
          return "Portal";
        case Ma:
          return "Profiler";
        case La:
          return "StrictMode";
        case Qa:
          return "Suspense";
        case Ra:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Oa:
            return (a.displayName || "Context") + ".Consumer";
          case Na:
            return (a._context.displayName || "Context") + ".Provider";
          case Pa:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case Sa:
            return b = a.displayName || null, b !== null ? b : Za(a.type) || "Memo";
          case Ta:
            b = a._payload, a = a._init;
            try {
              return Za(a(b));
            } catch {
            }
        }
      return null;
    }
    var $a = {};
    function ab(a, b) {
      if (a = a.contextTypes, !a)
        return $a;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var D = null;
    function E(a, b) {
      if (a !== b) {
        a.context._currentValue2 = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          E(a, c);
        }
        b.context._currentValue2 = b.value;
      }
    }
    function bb(a) {
      a.context._currentValue2 = a.parentValue, a = a.parent, a !== null && bb(a);
    }
    function cb(a) {
      var b = a.parent;
      b !== null && cb(b), a.context._currentValue2 = a.value;
    }
    function db2(a, b) {
      if (a.context._currentValue2 = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? E(a, b) : db2(a, b);
    }
    function eb(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? E(a, c) : eb(a, c), b.context._currentValue2 = b.value;
    }
    function F(a) {
      var b = D;
      b !== a && (b === null ? cb(a) : a === null ? bb(b) : b.depth === a.depth ? E(b, a) : b.depth > a.depth ? db2(b, a) : eb(b, a), D = a);
    }
    var fb = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function gb(a, b, c, d) {
      var f = a.state !== void 0 ? a.state : null;
      a.updater = fb, a.props = c, a.state = f;
      var e = { queue: [], replace: !1 };
      a._reactInternals = e;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue2 : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f), f = g == null ? f : A({}, f, g), a.state = f), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && fb.enqueueReplaceState(a, a.state, null), e.queue !== null && 0 < e.queue.length)
          if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e = g ? b[0] : a.state, f = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h = b[g];
              h = typeof h == "function" ? h.call(a, e, c, d) : h, h != null && (f ? (f = !1, e = A({}, e, h)) : A(e, h));
            }
            a.state = e;
          }
        else
          e.queue = null;
    }
    var hb = { id: 1, overflow: "" };
    function ib(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f = 32 - G(d) - 1;
      d &= ~(1 << f), c += 1;
      var e = 32 - G(b) + f;
      if (30 < e) {
        var g = f - f % 5;
        return e = (d & (1 << g) - 1).toString(32), d >>= g, f -= g, { id: 1 << 32 - G(b) + f | c << f | d, overflow: e + a };
      }
      return { id: 1 << e | c << f | d, overflow: a };
    }
    var G = Math.clz32 ? Math.clz32 : jb, kb = Math.log, lb = Math.LN2;
    function jb(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (kb(a) / lb | 0) | 0;
    }
    function mb(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var nb = typeof Object.is == "function" ? Object.is : mb, H = null, ob = null, I = null, J = null, K = !1, L = !1, M = 0, N = null, O = 0;
    function P() {
      if (H === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return H;
    }
    function rb() {
      if (0 < O)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function sb() {
      return J === null ? I === null ? (K = !1, I = J = rb()) : (K = !0, J = I) : J.next === null ? (K = !1, J = J.next = rb()) : (K = !0, J = J.next), J;
    }
    function tb() {
      ob = H = null, L = !1, I = null, O = 0, J = N = null;
    }
    function ub(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function vb(a, b, c) {
      if (H = P(), J = sb(), K) {
        var d = J.queue;
        if (b = d.dispatch, N !== null && (c = N.get(d), c !== void 0)) {
          N.delete(d), d = J.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return J.memoizedState = d, [d, b];
        }
        return [J.memoizedState, b];
      }
      return a = a === ub ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, J.memoizedState = a, a = J.queue = { last: null, dispatch: null }, a = a.dispatch = wb.bind(null, H, a), [J.memoizedState, a];
    }
    function xb(a, b) {
      if (H = P(), J = sb(), b = b === void 0 ? null : b, J !== null) {
        var c = J.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f = 0; f < d.length && f < b.length; f++)
                if (!nb(b[f], d[f])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), J.memoizedState = [a, b], a;
    }
    function wb(a, b, c) {
      if (25 <= O)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === H)
        if (L = !0, a = { action: c, next: null }, N === null && (N = /* @__PURE__ */ new Map()), c = N.get(b), c === void 0)
          N.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function yb() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Q() {
    }
    var zb = { readContext: function(a) {
      return a._currentValue2;
    }, useContext: function(a) {
      return P(), a._currentValue2;
    }, useMemo: xb, useReducer: vb, useRef: function(a) {
      H = P(), J = sb();
      var b = J.memoizedState;
      return b === null ? (a = { current: a }, J.memoizedState = a) : b;
    }, useState: function(a) {
      return vb(ub, a);
    }, useInsertionEffect: Q, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return xb(function() {
        return a;
      }, b);
    }, useImperativeHandle: Q, useEffect: Q, useDebugValue: Q, useDeferredValue: function(a) {
      return P(), a;
    }, useTransition: function() {
      return P(), [!1, yb];
    }, useId: function() {
      var a = ob.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - G(a) - 1)).toString(32) + b;
      var c = R;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = M++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return P(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, R = null, Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Bb(a) {
      return console.error(a), null;
    }
    function S() {
    }
    function Cb(a, b, c, d, f, e, g, h, k) {
      var m = [], l = /* @__PURE__ */ new Set();
      return b = { destination: null, responseState: b, progressiveChunkSize: d === void 0 ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l, pingedTasks: m, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: f === void 0 ? Bb : f, onAllReady: e === void 0 ? S : e, onShellReady: g === void 0 ? S : g, onShellError: h === void 0 ? S : h, onFatalError: k === void 0 ? S : k }, c = T(b, 0, null, c, !1, !1), c.parentFlushed = !0, a = Db(b, a, null, c, l, $a, null, hb), m.push(a), b;
    }
    function Db(a, b, c, d, f, e, g, h) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var k = { node: b, ping: function() {
        var b2 = a.pingedTasks;
        b2.push(k), b2.length === 1 && Eb(a);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
      return f.add(k), k;
    }
    function T(a, b, c, d, f, e) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
    }
    function U(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function V(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Fb(a, b, c, d, f) {
      for (H = {}, ob = b, M = 0, a = c(d, f); L; )
        L = !1, M = 0, O += 1, J = null, a = c(d, f);
      return tb(), a;
    }
    function Gb(a, b, c, d) {
      var f = c.render(), e = d.childContextTypes;
      if (e != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h in c)
            if (!(h in e))
              throw Error((Za(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
          d = A({}, g, c);
        }
        b.legacyContext = d, W(a, b, f), b.legacyContext = g;
      } else
        W(a, b, f);
    }
    function Hb(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Ib(a, b, c, d, f) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f = ab(c, b.legacyContext);
          var e = c.contextType;
          e = new c(d, typeof e == "object" && e !== null ? e._currentValue2 : f), gb(e, c, d, f), Gb(a, b, e, c);
        } else {
          e = ab(c, b.legacyContext), f = Fb(a, b, c, d, e);
          var g = M !== 0;
          if (typeof f == "object" && f !== null && typeof f.render == "function" && f.$$typeof === void 0)
            gb(f, c, d, e), Gb(a, b, f, c);
          else if (g) {
            d = b.treeContext, b.treeContext = ib(d, 1, 0);
            try {
              W(a, b, f);
            } finally {
              b.treeContext = d;
            }
          } else
            W(a, b, f);
        }
      else if (typeof c == "string") {
        switch (f = b.blockedSegment, e = za(f.chunks, c, d, a.responseState, f.formatContext), f.lastPushedText = !1, g = f.formatContext, f.formatContext = sa(g, c, d), Jb(a, b, e), f.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f.chunks.push("</", c, ">");
        }
        f.lastPushedText = !1;
      } else {
        switch (c) {
          case Wa:
          case Va:
          case La:
          case Ma:
          case Ka:
            W(a, b, d.children);
            return;
          case Ra:
            W(a, b, d.children);
            return;
          case Ua:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Qa:
            a: {
              c = b.blockedBoundary, f = b.blockedSegment, e = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, k = T(a, f.chunks.length, h, f.formatContext, !1, !1);
              f.children.push(k), f.lastPushedText = !1;
              var m = T(a, 0, null, f.formatContext, !1, !1);
              m.parentFlushed = !0, b.blockedBoundary = h, b.blockedSegment = m;
              try {
                if (Jb(a, b, d), a.responseState.generateStaticMarkup || m.lastPushedText && m.textEmbedded && m.chunks.push("<!-- -->"), m.status = 1, X(h, m), h.pendingTasks === 0)
                  break a;
              } catch (l) {
                m.status = 4, h.forceClientRender = !0, h.errorDigest = U(a, l);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f;
              }
              b = Db(a, e, c, k, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Pa:
              if (d = Fb(a, b, c.render, d, f), M !== 0) {
                c = b.treeContext, b.treeContext = ib(c, 1, 0);
                try {
                  W(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                W(a, b, d);
              return;
            case Sa:
              c = c.type, d = Hb(c, d), Ib(a, b, c, d, f);
              return;
            case Na:
              if (f = d.children, c = c._context, d = d.value, e = c._currentValue2, c._currentValue2 = d, g = D, D = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e, value: d }, b.context = d, W(a, b, f), a = D, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue2 = d === Xa ? a.context._defaultValue : d, a = D = a.parent, b.context = a;
              return;
            case Oa:
              d = d.children, d = d(c._currentValue2), W(a, b, d);
              return;
            case Ta:
              f = c._init, c = f(c._payload), d = Hb(c, d), Ib(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function W(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Ia:
            Ib(a, b, c.type, c.props, c.ref);
            return;
          case Ja:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ta:
            var d = c._init;
            c = d(c._payload), W(a, b, c);
            return;
        }
        if (ra(c)) {
          Kb(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = Ya && c[Ya] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f = [];
            do
              f.push(c.value), c = d.next();
            while (!c.done);
            Kb(a, b, f);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Ha(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Ha(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function Kb(a, b, c) {
      for (var d = c.length, f = 0; f < d; f++) {
        var e = b.treeContext;
        b.treeContext = ib(e, d, f);
        try {
          Jb(a, b, c[f]);
        } finally {
          b.treeContext = e;
        }
      }
    }
    function Jb(a, b, c) {
      var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
      try {
        return W(a, b, c);
      } catch (k) {
        if (tb(), typeof k == "object" && k !== null && typeof k.then == "function") {
          c = k;
          var g = b.blockedSegment, h = T(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h), g.lastPushedText = !1, a = Db(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, F(e);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, F(e), k;
      }
    }
    function Lb(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, Mb(this, b, a);
    }
    function Nb(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return Nb(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function X(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && X(a, c);
      } else
        a.completedSegments.push(b);
    }
    function Mb(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = S, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && X(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Lb, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (X(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Eb(a) {
      if (a.status !== 2) {
        var b = D, c = Ab.current;
        Ab.current = zb;
        var d = R;
        R = a.responseState;
        try {
          var f = a.pingedTasks, e;
          for (e = 0; e < f.length; e++) {
            var g = f[e], h = a, k = g.blockedSegment;
            if (k.status === 0) {
              F(g.context);
              try {
                W(h, g, g.node), h.responseState.generateStaticMarkup || k.lastPushedText && k.textEmbedded && k.chunks.push("<!-- -->"), g.abortSet.delete(g), k.status = 1, Mb(h, g.blockedBoundary, k);
              } catch (y) {
                if (tb(), typeof y == "object" && y !== null && typeof y.then == "function") {
                  var m = g.ping;
                  y.then(m, m);
                } else {
                  g.abortSet.delete(g), k.status = 4;
                  var l = g.blockedBoundary, p = y, B = U(h, p);
                  if (l === null ? V(h, p) : (l.pendingTasks--, l.forceClientRender || (l.forceClientRender = !0, l.errorDigest = B, l.parentFlushed && h.clientRenderedBoundaries.push(l))), h.allPendingTasks--, h.allPendingTasks === 0) {
                    var C = h.onAllReady;
                    C();
                  }
                }
              } finally {
              }
            }
          }
          f.splice(0, e), a.destination !== null && Ob(a, a.destination);
        } catch (y) {
          U(a, y), V(a, y);
        } finally {
          R = d, Ab.current = c, c === zb && F(b);
        }
      }
    }
    function Y(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, b.push('<template id="'), b.push(a.placeholderPrefix), a = d.toString(16), b.push(a), b.push('"></template>');
        case 1:
          c.status = 2;
          var f = !0;
          d = c.chunks;
          var e = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f = c[g]; e < f.index; e++)
              b.push(d[e]);
            f = Z(a, b, f);
          }
          for (; e < d.length - 1; e++)
            b.push(d[e]);
          return e < d.length && (f = b.push(d[e])), f;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Z(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return Y(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = u(d), b.push(d), b.push('"')), b.push("></template>")), Y(a, b, c), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
      if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f = a.responseState, e = f.nextSuspenseID++;
        return f = f.boundaryPrefix + e.toString(16), d = d.id = f, Aa(b, a.responseState, d), Y(a, b, c), b.push("<!--/$-->");
      }
      if (d.byteSize > a.progressiveChunkSize)
        return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Aa(b, a.responseState, d.id), Y(a, b, c), b.push("<!--/$-->");
      if (a.responseState.generateStaticMarkup || b.push("<!--$-->"), c = d.completedSegments, c.length !== 1)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      return Z(a, b, c[0]), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
    }
    function Pb(a, b, c) {
      return Ba(b, a.responseState, c.formatContext, c.id), Z(a, b, c), Ca(b, c.formatContext);
    }
    function Qb(a, b, c) {
      for (var d = c.completedSegments, f = 0; f < d.length; f++)
        Rb(a, b, c, d[f]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, b.push(a.startInlineScript), a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = !0, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), b.push(d), b.push('","'), b.push(a.segmentPrefix), b.push(c), b.push('")</script>');
    }
    function Rb(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f = d.id;
      if (f === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Pb(a, b, d);
      }
      return Pb(a, b, d), a = a.responseState, b.push(a.startInlineScript), a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = !0, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), b.push(a.segmentPrefix), f = f.toString(16), b.push(f), b.push('","'), b.push(a.placeholderPrefix), b.push(f), b.push('")</script>');
    }
    function Ob(a, b) {
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          Z(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            b.push(d[c]);
          c < d.length && b.push(d[c]);
        }
        var f = a.clientRenderedBoundaries, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          d = b;
          var h = a.responseState, k = g.id, m = g.errorDigest, l = g.errorMessage, p = g.errorComponentStack;
          if (d.push(h.startInlineScript), h.sentClientRenderFunction ? d.push('$RX("') : (h.sentClientRenderFunction = !0, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), k === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (d.push(k), d.push('"'), m || l || p) {
            d.push(",");
            var B = Ea(m || "");
            d.push(B);
          }
          if (l || p) {
            d.push(",");
            var C = Ea(l || "");
            d.push(C);
          }
          if (p) {
            d.push(",");
            var y = Ea(p);
            d.push(y);
          }
          if (!d.push(")</script>")) {
            a.destination = null, e++, f.splice(0, e);
            return;
          }
        }
        f.splice(0, e);
        var aa = a.completedBoundaries;
        for (e = 0; e < aa.length; e++)
          if (!Qb(a, b, aa[e])) {
            a.destination = null, e++, aa.splice(0, e);
            return;
          }
        aa.splice(0, e);
        var ba = a.partialBoundaries;
        for (e = 0; e < ba.length; e++) {
          var pb = ba[e];
          a: {
            f = a, g = b;
            var ca = pb.completedSegments;
            for (h = 0; h < ca.length; h++)
              if (!Rb(f, g, pb, ca[h])) {
                h++, ca.splice(0, h);
                var qb = !1;
                break a;
              }
            ca.splice(0, h), qb = !0;
          }
          if (!qb) {
            a.destination = null, e++, ba.splice(0, e);
            return;
          }
        }
        ba.splice(0, e);
        var da = a.completedBoundaries;
        for (e = 0; e < da.length; e++)
          if (!Qb(a, b, da[e])) {
            a.destination = null, e++, da.splice(0, e);
            return;
          }
        da.splice(0, e);
      } finally {
        a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.push(null);
      }
    }
    function Sb(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          Ob(a, b);
        } catch (c) {
          U(a, c), V(a, c);
        }
      }
    }
    function Tb(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return Nb(c2, a, b);
        }), c.clear(), a.destination !== null && Ob(a, a.destination);
      } catch (d) {
        U(a, d), V(a, d);
      }
    }
    function Ub() {
    }
    function Vb(a, b, c, d) {
      var f = !1, e = null, g = "", h = !1;
      if (a = Cb(a, Fa(c, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Ub, void 0, function() {
        h = !0;
      }, void 0, void 0), Eb(a), Tb(a, d), Sb(a, { push: function(a2) {
        return a2 !== null && (g += a2), !0;
      }, destroy: function(a2) {
        f = !0, e = a2;
      } }), f)
        throw e;
      if (!h)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return g;
    }
    function Wb(a, b) {
      a.prototype = Object.create(b.prototype), a.prototype.constructor = a, a.__proto__ = b;
    }
    var Xb = function(a) {
      function b() {
        var b2 = a.call(this, {}) || this;
        return b2.request = null, b2.startedFlowing = !1, b2;
      }
      Wb(b, a);
      var c = b.prototype;
      return c._destroy = function(a2, b2) {
        Tb(this.request), b2(a2);
      }, c._read = function() {
        this.startedFlowing && Sb(this.request, this);
      }, b;
    }(fa.Readable);
    function Yb() {
    }
    function Zb(a, b) {
      var c = new Xb(), d = Cb(a, Fa(!1, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Yb, function() {
        c.startedFlowing = !0, Sb(d, c);
      }, void 0, void 0);
      return c.request = d, Eb(d), c;
    }
    exports.renderToNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToStaticMarkup = function(a, b) {
      return Vb(a, b, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.renderToStaticNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToString = function(a, b) {
      return Vb(a, b, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.version = "18.3.1";
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.production.min.js
var require_react_dom_server_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.production.min.js"(exports) {
    "use strict";
    var aa = __require("util"), ba = require_react(), k = null, l = 0, q = !0;
    function r(a, b) {
      if (typeof b == "string") {
        if (b.length !== 0)
          if (2048 < 3 * b.length)
            0 < l && (t(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t(a, u.encode(b));
          else {
            var c = k;
            0 < l && (c = k.subarray(l)), c = u.encodeInto(b, c);
            var d = c.read;
            l += c.written, d < b.length && (t(a, k), k = new Uint8Array(2048), l = u.encodeInto(b.slice(d), k).written), l === 2048 && (t(a, k), k = new Uint8Array(2048), l = 0);
          }
      } else
        b.byteLength !== 0 && (2048 < b.byteLength ? (0 < l && (t(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t(a, b)) : (c = k.length - l, c < b.byteLength && (c === 0 ? t(
          a,
          k
        ) : (k.set(b.subarray(0, c), l), l += c, t(a, k), b = b.subarray(c)), k = new Uint8Array(2048), l = 0), k.set(b, l), l += b.byteLength, l === 2048 && (t(a, k), k = new Uint8Array(2048), l = 0)));
    }
    function t(a, b) {
      a = a.write(b), q = q && a;
    }
    function w(a, b) {
      return r(a, b), q;
    }
    function ca(a) {
      k && 0 < l && a.write(k.subarray(0, l)), k = null, l = 0, q = !0;
    }
    var u = new aa.TextEncoder();
    function x(a) {
      return u.encode(a);
    }
    var y = Object.prototype.hasOwnProperty, da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ea = {}, fa = {};
    function ha(a) {
      return y.call(fa, a) ? !0 : y.call(ea, a) ? !1 : da.test(a) ? fa[a] = !0 : (ea[a] = !0, !1);
    }
    function z(a, b, c, d, f, e, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e, this.removeEmptyString = g;
    }
    var A = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      A[a] = new z(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      A[b] = new z(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      A[a] = new z(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      A[a] = new z(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      A[a] = new z(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      A[a] = new z(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      A[a] = new z(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      A[a] = new z(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      A[a] = new z(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var ia = /[\-:]([a-z])/g;
    function ja(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ia,
        ja
      );
      A[b] = new z(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ia, ja);
      A[b] = new z(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ia, ja);
      A[b] = new z(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      A[a] = new z(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    A.xlinkHref = new z("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      A[a] = new z(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var B = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, ka = ["Webkit", "ms", "Moz", "O"];
    Object.keys(B).forEach(function(a) {
      ka.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), B[b] = B[a];
      });
    });
    var la = /["'&<>]/;
    function F(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = la.exec(a);
      if (b) {
        var c = "", d, f = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f !== d && (c += a.substring(f, d)), f = d + 1, c += b;
        }
        a = f !== d ? c + a.substring(f, d) : c;
      }
      return a;
    }
    var ma = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray, ra = x("<script>"), sa = x("</script>"), ta = x('<script src="'), ua = x('<script type="module" src="'), va = x('" async=""></script>'), wa = /(<\/|<)(s)(cript)/gi;
    function xa(a, b, c, d) {
      return "" + b + (c === "s" ? "\\u0073" : "\\u0053") + d;
    }
    function G(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function ya(a, b, c) {
      switch (b) {
        case "select":
          return G(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return G(2, null);
        case "math":
          return G(3, null);
        case "foreignObject":
          return G(1, null);
        case "table":
          return G(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return G(5, null);
        case "colgroup":
          return G(7, null);
        case "tr":
          return G(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? G(1, null) : a;
    }
    var za = x("<!-- -->");
    function Aa(a, b, c, d) {
      return b === "" ? d : (d && a.push(za), a.push(F(b)), !0);
    }
    var Ba = /* @__PURE__ */ new Map(), Ca = x(' style="'), Da = x(":"), Ea = x(";");
    function Fa(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (y.call(c, d)) {
          var f = c[d];
          if (f != null && typeof f != "boolean" && f !== "") {
            if (d.indexOf("--") === 0) {
              var e = F(d);
              f = F(("" + f).trim());
            } else {
              e = d;
              var g = Ba.get(e);
              g !== void 0 || (g = x(F(e.replace(ma, "-$1").toLowerCase().replace(pa, "-ms-"))), Ba.set(e, g)), e = g, f = typeof f == "number" ? f === 0 || y.call(
                B,
                d
              ) ? "" + f : f + "px" : F(("" + f).trim());
            }
            b ? (b = !1, a.push(Ca, e, Da, f)) : a.push(Ea, e, Da, f);
          }
        }
      b || a.push(H);
    }
    var I = x(" "), J = x('="'), H = x('"'), Ga = x('=""');
    function K(a, b, c, d) {
      switch (c) {
        case "style":
          Fa(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = A.hasOwnProperty(c) ? A[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(I, c, Ga);
              break;
            case 4:
              d === !0 ? a.push(I, c, Ga) : d !== !1 && a.push(I, c, J, F(d), H);
              break;
            case 5:
              isNaN(d) || a.push(I, c, J, F(d), H);
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(I, c, J, F(d), H);
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(I, c, J, F(d), H);
          }
        } else if (ha(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(I, c, J, F(d), H);
        }
      }
    }
    var L = x(">"), Ha = x("/>");
    function M(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function Ia(a) {
      var b = "";
      return ba.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    var Ja = x(' selected=""');
    function Ka(a, b, c, d) {
      a.push(N(c));
      var f = c = null, e;
      for (e in b)
        if (y.call(b, e)) {
          var g = b[e];
          if (g != null)
            switch (e) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f = g;
                break;
              default:
                K(a, d, e, g);
            }
        }
      return a.push(L), M(a, f, c), typeof c == "string" ? (a.push(F(c)), null) : c;
    }
    var La = x(`
`), Ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Na = /* @__PURE__ */ new Map();
    function N(a) {
      var b = Na.get(a);
      if (b === void 0) {
        if (!Ma.test(a))
          throw Error("Invalid tag: " + a);
        b = x("<" + a), Na.set(a, b);
      }
      return b;
    }
    var Oa = x("<!DOCTYPE html>");
    function Pa(a, b, c, d, f) {
      switch (b) {
        case "select":
          a.push(N("select"));
          var e = null, g = null;
          for (p in c)
            if (y.call(c, p)) {
              var h = c[p];
              if (h != null)
                switch (p) {
                  case "children":
                    e = h;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    K(a, d, p, h);
                }
            }
          return a.push(L), M(a, g, e), e;
        case "option":
          g = f.selectedValue, a.push(N("option"));
          var m = h = null, n = null, p = null;
          for (e in c)
            if (y.call(c, e)) {
              var v = c[e];
              if (v != null)
                switch (e) {
                  case "children":
                    h = v;
                    break;
                  case "selected":
                    n = v;
                    break;
                  case "dangerouslySetInnerHTML":
                    p = v;
                    break;
                  case "value":
                    m = v;
                  default:
                    K(a, d, e, v);
                }
            }
          if (g != null)
            if (c = m !== null ? "" + m : Ia(h), qa(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(Ja);
                  break;
                }
            } else
              "" + g === c && a.push(Ja);
          else
            n && a.push(Ja);
          return a.push(L), M(a, p, h), h;
        case "textarea":
          a.push(N("textarea")), p = g = e = null;
          for (h in c)
            if (y.call(c, h) && (m = c[h], m != null))
              switch (h) {
                case "children":
                  p = m;
                  break;
                case "value":
                  e = m;
                  break;
                case "defaultValue":
                  g = m;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  K(a, d, h, m);
              }
          if (e === null && g !== null && (e = g), a.push(L), p != null) {
            if (e != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (qa(p) && 1 < p.length)
              throw Error("<textarea> can only have at most one child.");
            e = "" + p;
          }
          return typeof e == "string" && e[0] === `
` && a.push(La), e !== null && a.push(F("" + e)), null;
        case "input":
          a.push(N("input")), m = p = h = e = null;
          for (g in c)
            if (y.call(c, g) && (n = c[g], n != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  m = n;
                  break;
                case "defaultValue":
                  h = n;
                  break;
                case "checked":
                  p = n;
                  break;
                case "value":
                  e = n;
                  break;
                default:
                  K(a, d, g, n);
              }
          return p !== null ? K(a, d, "checked", p) : m !== null && K(a, d, "checked", m), e !== null ? K(a, d, "value", e) : h !== null && K(a, d, "value", h), a.push(Ha), null;
        case "menuitem":
          a.push(N("menuitem"));
          for (var C in c)
            if (y.call(c, C) && (e = c[C], e != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, C, e);
              }
          return a.push(L), null;
        case "title":
          a.push(N("title")), e = null;
          for (v in c)
            if (y.call(c, v) && (g = c[v], g != null))
              switch (v) {
                case "children":
                  e = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  K(a, d, v, g);
              }
          return a.push(L), e;
        case "listing":
        case "pre":
          a.push(N(b)), g = e = null;
          for (m in c)
            if (y.call(c, m) && (h = c[m], h != null))
              switch (m) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                default:
                  K(a, d, m, h);
              }
          if (a.push(L), g != null) {
            if (e != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(La, c) : a.push("" + c));
          }
          return typeof e == "string" && e[0] === `
` && a.push(La), e;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(N(b));
          for (var D in c)
            if (y.call(c, D) && (e = c[D], e != null))
              switch (D) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, D, e);
              }
          return a.push(Ha), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(a, c, b, d);
        case "html":
          return f.insertionMode === 0 && a.push(Oa), Ka(
            a,
            c,
            b,
            d
          );
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return Ka(a, c, b, d);
          a.push(N(b)), g = e = null;
          for (n in c)
            if (y.call(c, n) && (h = c[n], h != null))
              switch (n) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                case "style":
                  Fa(a, d, h);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ha(n) && typeof h != "function" && typeof h != "symbol" && a.push(I, n, J, F(h), H);
              }
          return a.push(L), M(a, g, e), e;
      }
    }
    var Qa = x("</"), Ra = x(">"), Sa = x('<template id="'), Ta = x('"></template>'), Ua = x("<!--$-->"), Va = x('<!--$?--><template id="'), Wa = x('"></template>'), Xa = x("<!--$!-->"), Ya = x("<!--/$-->"), Za = x("<template"), $a = x('"'), ab = x(' data-dgst="');
    x(' data-msg="');
    x(' data-stck="');
    var bb = x("></template>");
    function cb(a, b, c) {
      if (r(a, Va), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return r(a, c), w(a, Wa);
    }
    var db2 = x('<div hidden id="'), eb = x('">'), fb = x("</div>"), gb = x('<svg aria-hidden="true" style="display:none" id="'), hb = x('">'), ib = x("</svg>"), jb = x('<math aria-hidden="true" style="display:none" id="'), kb = x('">'), lb = x("</math>"), mb = x('<table hidden id="'), nb = x('">'), ob = x("</table>"), pb = x('<table hidden><tbody id="'), qb = x('">'), rb = x("</tbody></table>"), sb = x('<table hidden><tr id="'), tb = x('">'), ub = x("</tr></table>"), vb = x('<table hidden><colgroup id="'), wb = x('">'), xb = x("</colgroup></table>");
    function yb(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return r(a, db2), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, eb);
        case 2:
          return r(a, gb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, hb);
        case 3:
          return r(a, jb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, kb);
        case 4:
          return r(a, mb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, nb);
        case 5:
          return r(a, pb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, qb);
        case 6:
          return r(a, sb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, tb);
        case 7:
          return r(a, vb), r(
            a,
            b.segmentPrefix
          ), r(a, d.toString(16)), w(a, wb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function zb(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return w(a, fb);
        case 2:
          return w(a, ib);
        case 3:
          return w(a, lb);
        case 4:
          return w(a, ob);
        case 5:
          return w(a, rb);
        case 6:
          return w(a, ub);
        case 7:
          return w(a, xb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ab = x('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Bb = x('$RS("'), Cb = x('","'), Db = x('")</script>'), Fb = x('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Gb = x('$RC("'), Hb = x('","'), Ib = x('")</script>'), Jb = x('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Kb = x('$RX("'), Lb = x('"'), Mb = x(")</script>"), Nb = x(","), Ob = /[<\u2028\u2029]/g;
    function Pb(a) {
      return JSON.stringify(a).replace(Ob, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var O = Object.assign, Qb = Symbol.for("react.element"), Rb = Symbol.for("react.portal"), Sb = Symbol.for("react.fragment"), Tb = Symbol.for("react.strict_mode"), Ub = Symbol.for("react.profiler"), Vb = Symbol.for("react.provider"), Wb = Symbol.for("react.context"), Xb = Symbol.for("react.forward_ref"), Yb = Symbol.for("react.suspense"), Zb = Symbol.for("react.suspense_list"), $b = Symbol.for("react.memo"), ac = Symbol.for("react.lazy"), bc = Symbol.for("react.scope"), cc = Symbol.for("react.debug_trace_mode"), dc = Symbol.for("react.legacy_hidden"), ec = Symbol.for("react.default_value"), fc = Symbol.iterator;
    function gc(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Sb:
          return "Fragment";
        case Rb:
          return "Portal";
        case Ub:
          return "Profiler";
        case Tb:
          return "StrictMode";
        case Yb:
          return "Suspense";
        case Zb:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Wb:
            return (a.displayName || "Context") + ".Consumer";
          case Vb:
            return (a._context.displayName || "Context") + ".Provider";
          case Xb:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case $b:
            return b = a.displayName || null, b !== null ? b : gc(a.type) || "Memo";
          case ac:
            b = a._payload, a = a._init;
            try {
              return gc(a(b));
            } catch {
            }
        }
      return null;
    }
    var hc = {};
    function ic(a, b) {
      if (a = a.contextTypes, !a)
        return hc;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var P = null;
    function Q(a, b) {
      if (a !== b) {
        a.context._currentValue = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          Q(a, c);
        }
        b.context._currentValue = b.value;
      }
    }
    function jc(a) {
      a.context._currentValue = a.parentValue, a = a.parent, a !== null && jc(a);
    }
    function kc(a) {
      var b = a.parent;
      b !== null && kc(b), a.context._currentValue = a.value;
    }
    function lc(a, b) {
      if (a.context._currentValue = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? Q(a, b) : lc(a, b);
    }
    function mc(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? Q(a, c) : mc(a, c), b.context._currentValue = b.value;
    }
    function nc(a) {
      var b = P;
      b !== a && (b === null ? kc(a) : a === null ? jc(b) : b.depth === a.depth ? Q(b, a) : b.depth > a.depth ? lc(b, a) : mc(b, a), P = a);
    }
    var oc = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function pc(a, b, c, d) {
      var f = a.state !== void 0 ? a.state : null;
      a.updater = oc, a.props = c, a.state = f;
      var e = { queue: [], replace: !1 };
      a._reactInternals = e;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f), f = g == null ? f : O({}, f, g), a.state = f), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && oc.enqueueReplaceState(a, a.state, null), e.queue !== null && 0 < e.queue.length)
          if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e = g ? b[0] : a.state, f = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h = b[g];
              h = typeof h == "function" ? h.call(a, e, c, d) : h, h != null && (f ? (f = !1, e = O({}, e, h)) : O(e, h));
            }
            a.state = e;
          }
        else
          e.queue = null;
    }
    var qc = { id: 1, overflow: "" };
    function rc(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f = 32 - sc(d) - 1;
      d &= ~(1 << f), c += 1;
      var e = 32 - sc(b) + f;
      if (30 < e) {
        var g = f - f % 5;
        return e = (d & (1 << g) - 1).toString(32), d >>= g, f -= g, { id: 1 << 32 - sc(b) + f | c << f | d, overflow: e + a };
      }
      return { id: 1 << e | c << f | d, overflow: a };
    }
    var sc = Math.clz32 ? Math.clz32 : tc, uc = Math.log, vc = Math.LN2;
    function tc(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (uc(a) / vc | 0) | 0;
    }
    function wc(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var xc = typeof Object.is == "function" ? Object.is : wc, R = null, yc = null, zc = null, S = null, T = !1, Ac = !1, U = 0, V = null, Bc = 0;
    function W() {
      if (R === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return R;
    }
    function Cc() {
      if (0 < Bc)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function Dc() {
      return S === null ? zc === null ? (T = !1, zc = S = Cc()) : (T = !0, S = zc) : S.next === null ? (T = !1, S = S.next = Cc()) : (T = !0, S = S.next), S;
    }
    function Ec() {
      yc = R = null, Ac = !1, zc = null, Bc = 0, S = V = null;
    }
    function Fc(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function Gc(a, b, c) {
      if (R = W(), S = Dc(), T) {
        var d = S.queue;
        if (b = d.dispatch, V !== null && (c = V.get(d), c !== void 0)) {
          V.delete(d), d = S.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return S.memoizedState = d, [d, b];
        }
        return [S.memoizedState, b];
      }
      return a = a === Fc ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, S.memoizedState = a, a = S.queue = { last: null, dispatch: null }, a = a.dispatch = Hc.bind(null, R, a), [S.memoizedState, a];
    }
    function Ic(a, b) {
      if (R = W(), S = Dc(), b = b === void 0 ? null : b, S !== null) {
        var c = S.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f = 0; f < d.length && f < b.length; f++)
                if (!xc(b[f], d[f])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), S.memoizedState = [a, b], a;
    }
    function Hc(a, b, c) {
      if (25 <= Bc)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === R)
        if (Ac = !0, a = { action: c, next: null }, V === null && (V = /* @__PURE__ */ new Map()), c = V.get(b), c === void 0)
          V.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function Jc() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Kc() {
    }
    var Mc = { readContext: function(a) {
      return a._currentValue;
    }, useContext: function(a) {
      return W(), a._currentValue;
    }, useMemo: Ic, useReducer: Gc, useRef: function(a) {
      R = W(), S = Dc();
      var b = S.memoizedState;
      return b === null ? (a = { current: a }, S.memoizedState = a) : b;
    }, useState: function(a) {
      return Gc(Fc, a);
    }, useInsertionEffect: Kc, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return Ic(function() {
        return a;
      }, b);
    }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a) {
      return W(), a;
    }, useTransition: function() {
      return W(), [!1, Jc];
    }, useId: function() {
      var a = yc.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - sc(a) - 1)).toString(32) + b;
      var c = Lc;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = U++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return W(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, Lc = null, Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Oc(a) {
      return console.error(a), null;
    }
    function X() {
    }
    function Pc(a, b) {
      var c = a.pingedTasks;
      c.push(b), c.length === 1 && setImmediate(function() {
        return Qc(a);
      });
    }
    function Rc(a, b, c, d, f, e, g, h) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var m = { node: b, ping: function() {
        return Pc(a, m);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
      return f.add(m), m;
    }
    function Sc(a, b, c, d, f, e) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
    }
    function Y(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function Tc(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Uc(a, b, c, d, f) {
      for (R = {}, yc = b, U = 0, a = c(d, f); Ac; )
        Ac = !1, U = 0, Bc += 1, S = null, a = c(d, f);
      return Ec(), a;
    }
    function Vc(a, b, c, d) {
      var f = c.render(), e = d.childContextTypes;
      if (e != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h in c)
            if (!(h in e))
              throw Error((gc(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
          d = O({}, g, c);
        }
        b.legacyContext = d, Z(a, b, f), b.legacyContext = g;
      } else
        Z(a, b, f);
    }
    function Wc(a, b) {
      if (a && a.defaultProps) {
        b = O({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Xc(a, b, c, d, f) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f = ic(c, b.legacyContext);
          var e = c.contextType;
          e = new c(d, typeof e == "object" && e !== null ? e._currentValue : f), pc(e, c, d, f), Vc(a, b, e, c);
        } else {
          e = ic(c, b.legacyContext), f = Uc(a, b, c, d, e);
          var g = U !== 0;
          if (typeof f == "object" && f !== null && typeof f.render == "function" && f.$$typeof === void 0)
            pc(f, c, d, e), Vc(a, b, f, c);
          else if (g) {
            d = b.treeContext, b.treeContext = rc(d, 1, 0);
            try {
              Z(a, b, f);
            } finally {
              b.treeContext = d;
            }
          } else
            Z(a, b, f);
        }
      else if (typeof c == "string") {
        switch (f = b.blockedSegment, e = Pa(f.chunks, c, d, a.responseState, f.formatContext), f.lastPushedText = !1, g = f.formatContext, f.formatContext = ya(g, c, d), Yc(a, b, e), f.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f.chunks.push(Qa, c, Ra);
        }
        f.lastPushedText = !1;
      } else {
        switch (c) {
          case dc:
          case cc:
          case Tb:
          case Ub:
          case Sb:
            Z(a, b, d.children);
            return;
          case Zb:
            Z(
              a,
              b,
              d.children
            );
            return;
          case bc:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Yb:
            a: {
              c = b.blockedBoundary, f = b.blockedSegment, e = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, m = Sc(a, f.chunks.length, h, f.formatContext, !1, !1);
              f.children.push(m), f.lastPushedText = !1;
              var n = Sc(a, 0, null, f.formatContext, !1, !1);
              n.parentFlushed = !0, b.blockedBoundary = h, b.blockedSegment = n;
              try {
                if (Yc(a, b, d), n.lastPushedText && n.textEmbedded && n.chunks.push(za), n.status = 1, Zc(h, n), h.pendingTasks === 0)
                  break a;
              } catch (p) {
                n.status = 4, h.forceClientRender = !0, h.errorDigest = Y(a, p);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f;
              }
              b = Rc(a, e, c, m, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Xb:
              if (d = Uc(a, b, c.render, d, f), U !== 0) {
                c = b.treeContext, b.treeContext = rc(c, 1, 0);
                try {
                  Z(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                Z(
                  a,
                  b,
                  d
                );
              return;
            case $b:
              c = c.type, d = Wc(c, d), Xc(a, b, c, d, f);
              return;
            case Vb:
              if (f = d.children, c = c._context, d = d.value, e = c._currentValue, c._currentValue = d, g = P, P = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e, value: d }, b.context = d, Z(a, b, f), a = P, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue = d === ec ? a.context._defaultValue : d, a = P = a.parent, b.context = a;
              return;
            case Wb:
              d = d.children, d = d(c._currentValue), Z(a, b, d);
              return;
            case ac:
              f = c._init, c = f(c._payload), d = Wc(c, d), Xc(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function Z(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Qb:
            Xc(a, b, c.type, c.props, c.ref);
            return;
          case Rb:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case ac:
            var d = c._init;
            c = d(c._payload), Z(a, b, c);
            return;
        }
        if (qa(c)) {
          $c(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = fc && c[fc] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f = [];
            do
              f.push(c.value), c = d.next();
            while (!c.done);
            $c(a, b, f);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Aa(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Aa(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function $c(a, b, c) {
      for (var d = c.length, f = 0; f < d; f++) {
        var e = b.treeContext;
        b.treeContext = rc(e, d, f);
        try {
          Yc(a, b, c[f]);
        } finally {
          b.treeContext = e;
        }
      }
    }
    function Yc(a, b, c) {
      var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
      try {
        return Z(a, b, c);
      } catch (m) {
        if (Ec(), typeof m == "object" && m !== null && typeof m.then == "function") {
          c = m;
          var g = b.blockedSegment, h = Sc(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h), g.lastPushedText = !1, a = Rc(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, nc(e);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, nc(e), m;
      }
    }
    function ad(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, bd(this, b, a);
    }
    function cd(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.end())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return cd(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function Zc(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && Zc(a, c);
      } else
        a.completedSegments.push(b);
    }
    function bd(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = X, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && Zc(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(ad, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (Zc(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Qc(a) {
      if (a.status !== 2) {
        var b = P, c = Nc.current;
        Nc.current = Mc;
        var d = Lc;
        Lc = a.responseState;
        try {
          var f = a.pingedTasks, e;
          for (e = 0; e < f.length; e++) {
            var g = f[e], h = a, m = g.blockedSegment;
            if (m.status === 0) {
              nc(g.context);
              try {
                Z(h, g, g.node), m.lastPushedText && m.textEmbedded && m.chunks.push(za), g.abortSet.delete(g), m.status = 1, bd(h, g.blockedBoundary, m);
              } catch (E) {
                if (Ec(), typeof E == "object" && E !== null && typeof E.then == "function") {
                  var n = g.ping;
                  E.then(n, n);
                } else {
                  g.abortSet.delete(g), m.status = 4;
                  var p = g.blockedBoundary, v = E, C = Y(h, v);
                  if (p === null ? Tc(h, v) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = !0, p.errorDigest = C, p.parentFlushed && h.clientRenderedBoundaries.push(p))), h.allPendingTasks--, h.allPendingTasks === 0) {
                    var D = h.onAllReady;
                    D();
                  }
                }
              } finally {
              }
            }
          }
          f.splice(0, e), a.destination !== null && dd(a, a.destination);
        } catch (E) {
          Y(a, E), Tc(a, E);
        } finally {
          Lc = d, Nc.current = c, c === Mc && nc(b);
        }
      }
    }
    function ed(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, r(b, Sa), r(b, a.placeholderPrefix), a = d.toString(16), r(b, a), w(b, Ta);
        case 1:
          c.status = 2;
          var f = !0;
          d = c.chunks;
          var e = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f = c[g]; e < f.index; e++)
              r(b, d[e]);
            f = fd(a, b, f);
          }
          for (; e < d.length - 1; e++)
            r(b, d[e]);
          return e < d.length && (f = w(b, d[e])), f;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function fd(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return ed(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        d = d.errorDigest, w(b, Xa), r(b, Za), d && (r(b, ab), r(b, F(d)), r(b, $a)), w(b, bb), ed(a, b, c);
      else if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f = a.responseState, e = f.nextSuspenseID++;
        f = x(f.boundaryPrefix + e.toString(16)), d = d.id = f, cb(b, a.responseState, d), ed(a, b, c);
      } else if (d.byteSize > a.progressiveChunkSize)
        d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), cb(b, a.responseState, d.id), ed(a, b, c);
      else {
        if (w(b, Ua), c = d.completedSegments, c.length !== 1)
          throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        fd(a, b, c[0]);
      }
      return w(b, Ya);
    }
    function gd(a, b, c) {
      return yb(b, a.responseState, c.formatContext, c.id), fd(a, b, c), zb(b, c.formatContext);
    }
    function hd(a, b, c) {
      for (var d = c.completedSegments, f = 0; f < d.length; f++)
        id(a, b, c, d[f]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, r(b, a.startInlineScript), a.sentCompleteBoundaryFunction ? r(b, Gb) : (a.sentCompleteBoundaryFunction = !0, r(b, Fb)), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), r(b, d), r(b, Hb), r(b, a.segmentPrefix), r(b, c), w(b, Ib);
    }
    function id(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f = d.id;
      if (f === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return gd(a, b, d);
      }
      return gd(a, b, d), a = a.responseState, r(b, a.startInlineScript), a.sentCompleteSegmentFunction ? r(b, Bb) : (a.sentCompleteSegmentFunction = !0, r(b, Ab)), r(b, a.segmentPrefix), f = f.toString(16), r(b, f), r(b, Cb), r(b, a.placeholderPrefix), r(b, f), w(b, Db);
    }
    function dd(a, b) {
      k = new Uint8Array(2048), l = 0, q = !0;
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          fd(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            r(b, d[c]);
          c < d.length && w(b, d[c]);
        }
        var f = a.clientRenderedBoundaries, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          d = b;
          var h = a.responseState, m = g.id, n = g.errorDigest, p = g.errorMessage, v = g.errorComponentStack;
          if (r(d, h.startInlineScript), h.sentClientRenderFunction ? r(d, Kb) : (h.sentClientRenderFunction = !0, r(d, Jb)), m === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (r(d, m), r(d, Lb), (n || p || v) && (r(d, Nb), r(d, Pb(n || ""))), (p || v) && (r(d, Nb), r(d, Pb(p || ""))), v && (r(d, Nb), r(d, Pb(v))), !w(d, Mb)) {
            a.destination = null, e++, f.splice(0, e);
            return;
          }
        }
        f.splice(0, e);
        var C = a.completedBoundaries;
        for (e = 0; e < C.length; e++)
          if (!hd(a, b, C[e])) {
            a.destination = null, e++, C.splice(0, e);
            return;
          }
        C.splice(0, e), ca(b), k = new Uint8Array(2048), l = 0, q = !0;
        var D = a.partialBoundaries;
        for (e = 0; e < D.length; e++) {
          var E = D[e];
          a: {
            f = a, g = b;
            var na = E.completedSegments;
            for (h = 0; h < na.length; h++)
              if (!id(f, g, E, na[h])) {
                h++, na.splice(0, h);
                var Eb = !1;
                break a;
              }
            na.splice(0, h), Eb = !0;
          }
          if (!Eb) {
            a.destination = null, e++, D.splice(0, e);
            return;
          }
        }
        D.splice(0, e);
        var oa = a.completedBoundaries;
        for (e = 0; e < oa.length; e++)
          if (!hd(a, b, oa[e])) {
            a.destination = null, e++, oa.splice(0, e);
            return;
          }
        oa.splice(0, e);
      } finally {
        ca(b), typeof b.flush == "function" && b.flush(), a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.end();
      }
    }
    function jd(a) {
      setImmediate(function() {
        return Qc(a);
      });
    }
    function kd(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          dd(a, b);
        } catch (c) {
          Y(a, c), Tc(a, c);
        }
      }
    }
    function ld(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return cd(c2, a, b);
        }), c.clear(), a.destination !== null && dd(a, a.destination);
      } catch (d) {
        Y(a, d), Tc(a, d);
      }
    }
    function md(a, b) {
      return function() {
        return kd(b, a);
      };
    }
    function nd(a, b) {
      return function() {
        return ld(a, b);
      };
    }
    function od(a, b) {
      var c = b ? b.identifierPrefix : void 0, d = b ? b.nonce : void 0, f = b ? b.bootstrapScriptContent : void 0, e = b ? b.bootstrapScripts : void 0, g = b ? b.bootstrapModules : void 0;
      c = c === void 0 ? "" : c, d = d === void 0 ? ra : x('<script nonce="' + F(d) + '">');
      var h = [];
      if (f !== void 0 && h.push(d, ("" + f).replace(wa, xa), sa), e !== void 0)
        for (f = 0; f < e.length; f++)
          h.push(ta, F(e[f]), va);
      if (g !== void 0)
        for (e = 0; e < g.length; e++)
          h.push(ua, F(g[e]), va);
      g = {
        bootstrapChunks: h,
        startInlineScript: d,
        placeholderPrefix: x(c + "P:"),
        segmentPrefix: x(c + "S:"),
        boundaryPrefix: c + "B:",
        idPrefix: c,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      }, e = b ? b.namespaceURI : void 0, e = G(e === "http://www.w3.org/2000/svg" ? 2 : e === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null), f = b ? b.progressiveChunkSize : void 0, d = b ? b.onError : void 0, h = b ? b.onAllReady : void 0;
      var m = b ? b.onShellReady : void 0, n = b ? b.onShellError : void 0;
      return b = [], c = /* @__PURE__ */ new Set(), g = {
        destination: null,
        responseState: g,
        progressiveChunkSize: f === void 0 ? 12800 : f,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: c,
        pingedTasks: b,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: d === void 0 ? Oc : d,
        onAllReady: h === void 0 ? X : h,
        onShellReady: m === void 0 ? X : m,
        onShellError: n === void 0 ? X : n,
        onFatalError: X
      }, e = Sc(g, 0, null, e, !1, !1), e.parentFlushed = !0, a = Rc(g, a, null, e, c, hc, null, qc), b.push(a), g;
    }
    exports.renderToPipeableStream = function(a, b) {
      var c = od(a, b), d = !1;
      return jd(c), { pipe: function(a2) {
        if (d)
          throw Error("React currently only supports piping to one writable stream.");
        return d = !0, kd(c, a2), a2.on("drain", md(a2, c)), a2.on("error", nd(c, Error("The destination stream errored while writing data."))), a2.on("close", nd(c, Error("The destination stream closed early."))), a2;
      }, abort: function(a2) {
        ld(c, a2);
      } };
    };
    exports.version = "18.3.1";
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports) {
    "use strict";
    var l, s;
    l = require_react_dom_server_legacy_node_production_min(), s = require_react_dom_server_node_production_min();
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToPipeableStream = s.renderToPipeableStream;
  }
});

// app/utils/db.ts
import { PrismaClient } from "@prisma/client";
var db, init_db = __esm({
  "app/utils/db.ts"() {
    "use strict";
    db = new PrismaClient({
      log: ["error", "warn"],
      errorFormat: "minimal"
    });
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
    "use strict";
    var f = require_react(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      g !== void 0 && (e = "" + g), a.key !== void 0 && (e = "" + a.key), a.ref !== void 0 && (h = a.ref);
      for (b in a)
        m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          d[b] === void 0 && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    exports.Fragment = l;
    exports.jsx = q;
    exports.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    module.exports = require_react_jsx_runtime_production_min();
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
    function equal(a, b) {
      if (a === b)
        return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length)
            return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return !1;
          return !0;
        }
        var it;
        if (hasMap && a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return !1;
          for (it = a.entries(); !(i = it.next()).done; )
            if (!b.has(i.value[0]))
              return !1;
          for (it = a.entries(); !(i = it.next()).done; )
            if (!equal(i.value[1], b.get(i.value[0])))
              return !1;
          return !0;
        }
        if (hasSet && a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return !1;
          for (it = a.entries(); !(i = it.next()).done; )
            if (!b.has(i.value[0]))
              return !1;
          return !0;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          if (length = a.length, length != b.length)
            return !1;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return !1;
          return !0;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf == "function" && typeof b.valueOf == "function")
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString == "function" && typeof b.toString == "function")
          return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length)
          return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return !1;
        if (hasElementType && a instanceof Element)
          return !1;
        for (i = length; i-- !== 0; )
          if (!((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) && !equal(a[keys[i]], b[keys[i]]))
            return !1;
        return !0;
      }
      return a !== a && b !== b;
    }
    module.exports = function(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i))
          return console.warn("react-fast-compare cannot handle circular refs"), !1;
        throw error;
      }
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/headers.mjs
function canonicalizeHeaderName(hdr) {
  return hdr.replace(/(^|-)(\w+)/g, (_fullMatch, start, letters) => start + letters.slice(0, 1).toUpperCase() + letters.slice(1).toLowerCase());
}
function getHeaders(headers, needle_) {
  let result = [];
  if (!headers)
    return result;
  let needle = canonicalizeHeaderName(needle_);
  for (let [key, values2] of Object.entries(headers))
    canonicalizeHeaderName(key) === needle && (Array.isArray(values2) ? result.push(...values2) : result.push(values2));
  return result;
}
function getHeader(headers, needle) {
  if (headers)
    return getHeaders(headers, needle)?.[0];
}
function addHeader(headers, key, value) {
  canonicalizeHeaders(headers);
  let canonKey = canonicalizeHeaderName(key), list = headers[canonKey];
  list ? Array.isArray(list) || (list = [list]) : list = [], headers[canonKey] = list, list.push(value);
}
function canonicalizeValue(value) {
  return typeof value == "number" ? value.toString() : value;
}
function canonicalizeHeaders(hdr) {
  for (let [key, values2] of Object.entries(hdr)) {
    let canonKey = canonicalizeHeaderName(key);
    hdr[canonKey] || (hdr[canonKey] = []), Array.isArray(hdr[canonKey]) || (hdr[canonKey] = [canonicalizeValue(hdr[canonKey])]), key !== canonKey && (delete hdr[key], hdr[canonKey].push(...[values2].flat().map((value) => canonicalizeValue(value))));
  }
  return hdr;
}
function removeHeader(headers, needle) {
  canonicalizeHeaders(headers);
  let canonKey = canonicalizeHeaderName(needle);
  delete headers[canonKey];
}
function flatHeaders(headers) {
  return headers ? Object.entries(headers).flatMap(([header, values2]) => Array.isArray(values2) ? values2.map((value) => [header, value]) : [[header, values2]]) : [];
}
var init_headers2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/http/headers.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/adapters/web-api/adapter.mjs
async function webApiConvertRequest(adapterArgs) {
  let request2 = adapterArgs.rawRequest, headers = {};
  for (let [key, value] of request2.headers.entries())
    addHeader(headers, key, value);
  return {
    headers,
    method: request2.method ?? "GET",
    url: new URL(request2.url).toString()
  };
}
async function webApiConvertHeaders(headers, _adapterArgs) {
  let remixHeaders = new Headers();
  return flatHeaders(headers ?? {}).forEach(([key, value]) => remixHeaders.append(key, value)), Promise.resolve(remixHeaders);
}
async function webApiConvertResponse(resp, adapterArgs) {
  return new Response(resp.body, {
    status: resp.statusCode,
    statusText: resp.statusText,
    headers: await webApiConvertHeaders(resp.headers ?? {})
  });
}
function webApiRuntimeString() {
  return "Web API";
}
var init_adapter = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/adapters/web-api/adapter.mjs"() {
    init_headers2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/crypto/types.mjs
var HashFormat, init_types = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/crypto/types.mjs"() {
    (function(HashFormat2) {
      HashFormat2.Base64 = "base64", HashFormat2.Hex = "hex";
    })(HashFormat || (HashFormat = {}));
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/index.mjs
function isOK(resp) {
  return resp.statusCode >= 200 && resp.statusCode <= 299;
}
function setAbstractFetchFunc(func) {
  abstractFetch = func;
}
function setAbstractConvertRequestFunc(func) {
  abstractConvertRequest = func;
}
function setAbstractConvertResponseFunc(func) {
  abstractConvertResponse = func;
}
function setAbstractConvertHeadersFunc(func) {
  abstractConvertHeaders = func;
}
var abstractFetch, abstractConvertRequest, abstractConvertIncomingResponse, abstractConvertResponse, abstractConvertHeaders, init_http = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/http/index.mjs"() {
    abstractFetch = () => {
      throw new Error("Missing adapter implementation for 'abstractFetch' - make sure to import the appropriate adapter for your platform");
    };
    abstractConvertRequest = () => {
      throw new Error("Missing adapter implementation for 'abstractConvertRequest' - make sure to import the appropriate adapter for your platform");
    };
    abstractConvertIncomingResponse = () => Promise.resolve({}), abstractConvertResponse = () => {
      throw new Error("Missing adapter implementation for 'abstractConvertResponse' - make sure to import the appropriate adapter for your platform");
    };
    abstractConvertHeaders = () => {
      throw new Error("Missing adapter implementation for 'abstractConvertHeaders' - make sure to import the appropriate adapter for your platform");
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/platform/runtime-string.mjs
function setAbstractRuntimeString(func) {
  abstractRuntimeString = func;
}
var abstractRuntimeString, init_runtime_string = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/platform/runtime-string.mjs"() {
    abstractRuntimeString = () => {
      throw new Error("Missing adapter implementation for 'abstractRuntimeString' - make sure to import the appropriate adapter for your platform");
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/adapters/web-api/index.mjs
var init_web_api = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/adapters/web-api/index.mjs"() {
    init_adapter();
    init_http();
    init_runtime_string();
    setAbstractFetchFunc(fetch);
    setAbstractConvertRequestFunc(webApiConvertRequest);
    setAbstractConvertResponseFunc(webApiConvertResponse);
    setAbstractConvertHeadersFunc(webApiConvertHeaders);
    setAbstractRuntimeString(webApiRuntimeString);
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/error.mjs
var ShopifyError, InvalidHmacError, InvalidShopError, InvalidHostError, InvalidJwtError, MissingJwtTokenError, InvalidDeliveryMethodError, SafeCompareError, PrivateAppError, HttpRequestError, HttpMaxRetriesError, HttpResponseError, HttpRetriableError, HttpInternalError, HttpThrottlingError, GraphqlQueryError, InvalidOAuthError, BotActivityDetected, CookieNotFound, InvalidSession, InvalidWebhookError, MissingWebhookCallbackError, MissingRequiredArgument, InvalidRequestError, BillingError, FeatureDeprecatedError, init_error = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/error.mjs"() {
    ShopifyError = class extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, new.target.prototype);
      }
    }, InvalidHmacError = class extends ShopifyError {
    }, InvalidShopError = class extends ShopifyError {
    }, InvalidHostError = class extends ShopifyError {
    }, InvalidJwtError = class extends ShopifyError {
    }, MissingJwtTokenError = class extends ShopifyError {
    }, InvalidDeliveryMethodError = class extends ShopifyError {
    }, SafeCompareError = class extends ShopifyError {
    }, PrivateAppError = class extends ShopifyError {
    }, HttpRequestError = class extends ShopifyError {
    }, HttpMaxRetriesError = class extends ShopifyError {
    }, HttpResponseError = class extends ShopifyError {
      response;
      constructor({ message, code, statusText, body, headers }) {
        super(message), this.response = {
          code,
          statusText,
          body,
          headers
        };
      }
    }, HttpRetriableError = class extends HttpResponseError {
    }, HttpInternalError = class extends HttpRetriableError {
    }, HttpThrottlingError = class extends HttpRetriableError {
      constructor({ retryAfter, ...params }) {
        super(params), this.response.retryAfter = retryAfter;
      }
    }, GraphqlQueryError = class extends ShopifyError {
      response;
      headers;
      body;
      constructor({ message, response, headers, body }) {
        super(message), this.response = response, this.headers = headers, this.body = body;
      }
    }, InvalidOAuthError = class extends ShopifyError {
    }, BotActivityDetected = class extends ShopifyError {
    }, CookieNotFound = class extends ShopifyError {
    }, InvalidSession = class extends ShopifyError {
    }, InvalidWebhookError = class extends ShopifyError {
      response;
      constructor({ message, response }) {
        super(message), this.response = response;
      }
    }, MissingWebhookCallbackError = class extends InvalidWebhookError {
    }, MissingRequiredArgument = class extends ShopifyError {
    }, InvalidRequestError = class extends ShopifyError {
    }, BillingError = class extends ShopifyError {
      errorData;
      constructor({ message, errorData }) {
        super(message), this.errorData = errorData;
      }
    }, FeatureDeprecatedError = class extends ShopifyError {
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/crypto/utils.mjs
async function createSHA256HMAC(secret, payload, returnFormat = HashFormat.Base64) {
  let cryptoLib = typeof crypto?.webcrypto > "u" ? crypto : crypto.webcrypto, enc = new TextEncoder(), key = await cryptoLib.subtle.importKey("raw", enc.encode(secret), {
    name: "HMAC",
    hash: { name: "SHA-256" }
  }, !1, ["sign"]), signature = await cryptoLib.subtle.sign("HMAC", key, enc.encode(payload));
  return returnFormat === HashFormat.Base64 ? asBase64(signature) : asHex(signature);
}
function asHex(buffer) {
  return [...new Uint8Array(buffer)].map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
function asBase64(buffer) {
  let output = "", input = new Uint8Array(buffer);
  for (let i = 0; i < input.length; ) {
    let byte1 = input[i++], byte2 = input[i++], byte3 = input[i++], enc1 = byte1 >> 2, enc2 = (byte1 & 3) << 4 | byte2 >> 4, enc3 = (byte2 & 15) << 2 | byte3 >> 6, enc4 = byte3 & 63;
    isNaN(byte2) && (enc3 = 64), isNaN(byte3) && (enc4 = 64), output += LookupTable[enc1] + LookupTable[enc2] + LookupTable[enc3] + LookupTable[enc4];
  }
  return output;
}
function hashString(str, returnFormat) {
  let buffer = new TextEncoder().encode(str);
  switch (returnFormat) {
    case HashFormat.Base64:
      return asBase64(buffer);
    case HashFormat.Hex:
      return asHex(buffer);
    default:
      throw new ShopifyError(`Unrecognized hash format '${returnFormat}'`);
  }
}
var LookupTable, init_utils = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/crypto/utils.mjs"() {
    init_error();
    init_types();
    LookupTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/utils.mjs
function splitN(str, sep, maxNumParts) {
  let parts = str.split(sep), maxParts = Math.min(Math.abs(maxNumParts), parts.length);
  return [...parts.slice(0, maxParts - 1), parts.slice(maxParts - 1).join(sep)];
}
var init_utils2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/http/utils.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/cookies.mjs
var Cookies, init_cookies2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/http/cookies.mjs"() {
    init_utils();
    init_utils2();
    init_headers2();
    Cookies = class {
      response;
      static parseCookies(hdrs) {
        let entries = hdrs.filter((hdr) => hdr.trim().length > 0).map((cookieDef) => {
          let [keyval, ...opts] = cookieDef.split(";"), [name, value] = splitN(keyval, "=", 2).map((value2) => value2.trim());
          return [
            name,
            {
              name,
              value,
              ...Object.fromEntries(opts.map((opt) => splitN(opt, "=", 2).map((value2) => value2.trim())))
            }
          ];
        }), jar = Object.fromEntries(entries);
        for (let cookie of Object.values(jar))
          typeof cookie.expires == "string" && (cookie.expires = new Date(cookie.expires));
        return jar;
      }
      static encodeCookie(data3) {
        let result = "";
        return result += `${data3.name}=${data3.value};`, result += Object.entries(data3).filter(([key]) => !["name", "value", "expires"].includes(key)).map(([key, value]) => `${key}=${value}`).join("; "), data3.expires && (result += ";", result += `expires=${data3.expires.toUTCString()}`), result;
      }
      receivedCookieJar = {};
      outgoingCookieJar = {};
      keys = [];
      constructor(request2, response, { keys = [] } = {}) {
        this.response = response, keys && (this.keys = keys);
        let cookieReqHdr = getHeader(request2.headers, "Cookie") ?? "";
        this.receivedCookieJar = Cookies.parseCookies(cookieReqHdr.split(";"));
        let cookieResHdr = getHeaders(response.headers, "Set-Cookie") ?? [];
        this.outgoingCookieJar = Cookies.parseCookies(cookieResHdr);
      }
      toHeaders() {
        return Object.values(this.outgoingCookieJar).map((cookie) => Cookies.encodeCookie(cookie));
      }
      updateHeader() {
        this.response.headers || (this.response.headers = {}), removeHeader(this.response.headers, "Set-Cookie"), this.toHeaders().map((hdr) => addHeader(this.response.headers, "Set-Cookie", hdr));
      }
      get(name) {
        return this.receivedCookieJar[name]?.value;
      }
      deleteCookie(name) {
        this.set(name, "", {
          path: "/",
          expires: /* @__PURE__ */ new Date(0)
        });
      }
      async getAndVerify(name) {
        let value = this.get(name);
        if (value && await this.isSignedCookieValid(name))
          return value;
      }
      get canSign() {
        return this.keys?.length > 0;
      }
      set(name, value, opts = {}) {
        this.outgoingCookieJar[name] = {
          ...opts,
          name,
          value
        }, this.updateHeader();
      }
      async setAndSign(name, value, opts = {}) {
        if (!this.canSign)
          throw Error("No keys provided for signing.");
        this.set(name, value, opts);
        let sigName = `${name}.sig`, signature = await createSHA256HMAC(this.keys[0], value);
        this.set(sigName, signature, opts), this.updateHeader();
      }
      async isSignedCookieValid(cookieName) {
        let signedCookieName = `${cookieName}.sig`;
        if (!this.cookieExists(cookieName) || !this.cookieExists(signedCookieName))
          return this.deleteInvalidCookies(cookieName, signedCookieName), !1;
        let cookieValue = this.get(cookieName), signature = this.get(signedCookieName);
        return !cookieValue || !signature ? (this.deleteInvalidCookies(cookieName, signedCookieName), !1) : (await Promise.all(this.keys.map((key) => createSHA256HMAC(key, cookieValue)))).includes(signature) ? !0 : (this.deleteInvalidCookies(cookieName, signedCookieName), !1);
      }
      cookieExists(cookieName) {
        return Boolean(this.get(cookieName));
      }
      deleteInvalidCookies(...cookieNames) {
        cookieNames.forEach((cookieName) => this.deleteCookie(cookieName));
      }
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/runtime/index.mjs
var init_runtime = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/runtime/index.mjs"() {
    init_runtime_string();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/types.mjs
var LogSeverity, ApiVersion, LIBRARY_NAME, ShopifyHeader, ClientType, privacyTopics, BillingInterval, BillingReplacementBehavior, StatusCode, Method, init_types2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/types.mjs"() {
    (function(LogSeverity2) {
      LogSeverity2[LogSeverity2.Error = 0] = "Error", LogSeverity2[LogSeverity2.Warning = 1] = "Warning", LogSeverity2[LogSeverity2.Info = 2] = "Info", LogSeverity2[LogSeverity2.Debug = 3] = "Debug";
    })(LogSeverity || (LogSeverity = {}));
    (function(ApiVersion2) {
      ApiVersion2.October22 = "2022-10", ApiVersion2.January23 = "2023-01", ApiVersion2.April23 = "2023-04", ApiVersion2.July23 = "2023-07", ApiVersion2.October23 = "2023-10", ApiVersion2.January24 = "2024-01", ApiVersion2.April24 = "2024-04", ApiVersion2.July24 = "2024-07", ApiVersion2.October24 = "2024-10", ApiVersion2.January25 = "2025-01", ApiVersion2.April25 = "2025-04", ApiVersion2.July25 = "2025-07", ApiVersion2.October25 = "2025-10", ApiVersion2.Unstable = "unstable";
    })(ApiVersion || (ApiVersion = {}));
    LIBRARY_NAME = "Shopify API Library";
    (function(ShopifyHeader2) {
      ShopifyHeader2.AccessToken = "X-Shopify-Access-Token", ShopifyHeader2.ApiVersion = "X-Shopify-API-Version", ShopifyHeader2.Domain = "X-Shopify-Shop-Domain", ShopifyHeader2.Hmac = "X-Shopify-Hmac-Sha256", ShopifyHeader2.Topic = "X-Shopify-Topic", ShopifyHeader2.SubTopic = "X-Shopify-Sub-Topic", ShopifyHeader2.WebhookId = "X-Shopify-Webhook-Id", ShopifyHeader2.StorefrontPrivateToken = "Shopify-Storefront-Private-Token", ShopifyHeader2.StorefrontSDKVariant = "X-SDK-Variant", ShopifyHeader2.StorefrontSDKVersion = "X-SDK-Version";
    })(ShopifyHeader || (ShopifyHeader = {}));
    (function(ClientType2) {
      ClientType2.Rest = "rest", ClientType2.Graphql = "graphql";
    })(ClientType || (ClientType = {}));
    privacyTopics = [
      "CUSTOMERS_DATA_REQUEST",
      "CUSTOMERS_REDACT",
      "SHOP_REDACT"
    ];
    (function(BillingInterval2) {
      BillingInterval2.OneTime = "ONE_TIME", BillingInterval2.Every30Days = "EVERY_30_DAYS", BillingInterval2.Annual = "ANNUAL", BillingInterval2.Usage = "USAGE";
    })(BillingInterval || (BillingInterval = {}));
    (function(BillingReplacementBehavior2) {
      BillingReplacementBehavior2.ApplyImmediately = "APPLY_IMMEDIATELY", BillingReplacementBehavior2.ApplyOnNextBillingCycle = "APPLY_ON_NEXT_BILLING_CYCLE", BillingReplacementBehavior2.Standard = "STANDARD";
    })(BillingReplacementBehavior || (BillingReplacementBehavior = {}));
    (function(StatusCode2) {
      StatusCode2[StatusCode2.Continue = 100] = "Continue", StatusCode2[StatusCode2.SwitchingProtocols = 101] = "SwitchingProtocols", StatusCode2[StatusCode2.Ok = 200] = "Ok", StatusCode2[StatusCode2.Created = 201] = "Created", StatusCode2[StatusCode2.Accepted = 202] = "Accepted", StatusCode2[StatusCode2.NonAuthoritativeInformation = 203] = "NonAuthoritativeInformation", StatusCode2[StatusCode2.NoContent = 204] = "NoContent", StatusCode2[StatusCode2.ResetContent = 205] = "ResetContent", StatusCode2[StatusCode2.PartialContent = 206] = "PartialContent", StatusCode2[StatusCode2.MultipleChoices = 300] = "MultipleChoices", StatusCode2[StatusCode2.MovedPermanently = 301] = "MovedPermanently", StatusCode2[StatusCode2.Found = 302] = "Found", StatusCode2[StatusCode2.SeeOther = 303] = "SeeOther", StatusCode2[StatusCode2.NotModified = 304] = "NotModified", StatusCode2[StatusCode2.UseProxy = 305] = "UseProxy", StatusCode2[StatusCode2.TemporaryRedirect = 307] = "TemporaryRedirect", StatusCode2[StatusCode2.BadRequest = 400] = "BadRequest", StatusCode2[StatusCode2.Unauthorized = 401] = "Unauthorized", StatusCode2[StatusCode2.PaymentRequired = 402] = "PaymentRequired", StatusCode2[StatusCode2.Forbidden = 403] = "Forbidden", StatusCode2[StatusCode2.NotFound = 404] = "NotFound", StatusCode2[StatusCode2.MethodNotAllowed = 405] = "MethodNotAllowed", StatusCode2[StatusCode2.NotAcceptable = 406] = "NotAcceptable", StatusCode2[StatusCode2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", StatusCode2[StatusCode2.RequestTimeout = 408] = "RequestTimeout", StatusCode2[StatusCode2.Conflict = 409] = "Conflict", StatusCode2[StatusCode2.Gone = 410] = "Gone", StatusCode2[StatusCode2.LengthRequired = 411] = "LengthRequired", StatusCode2[StatusCode2.PreconditionFailed = 412] = "PreconditionFailed", StatusCode2[StatusCode2.RequestEntityTooLarge = 413] = "RequestEntityTooLarge", StatusCode2[StatusCode2.RequestUriTooLong = 414] = "RequestUriTooLong", StatusCode2[StatusCode2.UnsupportedMediaType = 415] = "UnsupportedMediaType", StatusCode2[StatusCode2.RequestedRangeNotSatisfiable = 416] = "RequestedRangeNotSatisfiable", StatusCode2[StatusCode2.ExpectationFailed = 417] = "ExpectationFailed", StatusCode2[StatusCode2.ImATeapot = 418] = "ImATeapot", StatusCode2[StatusCode2.UnprocessableEntity = 422] = "UnprocessableEntity", StatusCode2[StatusCode2.TooManyRequests = 429] = "TooManyRequests", StatusCode2[StatusCode2.InternalServerError = 500] = "InternalServerError", StatusCode2[StatusCode2.NotImplemented = 501] = "NotImplemented", StatusCode2[StatusCode2.BadGateway = 502] = "BadGateway", StatusCode2[StatusCode2.ServiceUnavailable = 503] = "ServiceUnavailable", StatusCode2[StatusCode2.GatewayTimeout = 504] = "GatewayTimeout", StatusCode2[StatusCode2.HttpVersionNotSupported = 505] = "HttpVersionNotSupported";
    })(StatusCode || (StatusCode = {}));
    (function(Method3) {
      Method3.Get = "GET", Method3.Post = "POST", Method3.Put = "PUT", Method3.Patch = "PATCH", Method3.Delete = "DELETE", Method3.Head = "HEAD", Method3.Options = "OPTIONS", Method3.Connect = "CONNECT";
    })(Method || (Method = {}));
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/version.mjs
var SHOPIFY_API_LIBRARY_VERSION, init_version = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/version.mjs"() {
    SHOPIFY_API_LIBRARY_VERSION = "12.0.0";
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/logger/log.mjs
function log(config) {
  return function(severity, message, context = {}) {
    if (severity > config.logger.level)
      return;
    let prefix = [];
    config.logger.timestamps && prefix.push(`${(/* @__PURE__ */ new Date()).toISOString().slice(0, -5)}Z`);
    let packageString = context.package || "shopify-api";
    switch (delete context.package, severity) {
      case LogSeverity.Debug:
        packageString = `${packageString}/DEBUG`;
        break;
      case LogSeverity.Info:
        packageString = `${packageString}/INFO`;
        break;
      case LogSeverity.Warning:
        packageString = `${packageString}/WARNING`;
        break;
      case LogSeverity.Error:
        packageString = `${packageString}/ERROR`;
        break;
    }
    prefix.push(packageString);
    let contextParts = [];
    Object.entries(context).forEach(([key, value]) => {
      contextParts.push(`${key}: ${value}`);
    });
    let suffix = "";
    contextParts.length > 0 && (suffix = ` | {${contextParts.join(", ")}}`), config.logger.log(severity, `[${prefix.join("] [")}] ${message}${suffix}`);
  };
}
var init_log = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/logger/log.mjs"() {
    init_types2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/logger/index.mjs
import { compare } from "compare-versions";
function logger(config) {
  let logFunction = log(config);
  return {
    log: logFunction,
    debug: async (message, context = {}) => logFunction(LogSeverity.Debug, message, context),
    info: async (message, context = {}) => logFunction(LogSeverity.Info, message, context),
    warning: async (message, context = {}) => logFunction(LogSeverity.Warning, message, context),
    error: async (message, context = {}) => logFunction(LogSeverity.Error, message, context),
    deprecated: deprecated(logFunction)
  };
}
function deprecated(logFunction) {
  return function(version, message) {
    if (compare(SHOPIFY_API_LIBRARY_VERSION, version, ">="))
      throw new FeatureDeprecatedError(`Feature was deprecated in version ${version}`);
    return logFunction(LogSeverity.Warning, `[Deprecated | ${version}] ${message}`);
  };
}
var init_logger = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/logger/index.mjs"() {
    init_types2();
    init_error();
    init_version();
    init_log();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/rest/load-rest-resources.mjs
function loadRestResources({ resources, config, RestClient: RestClient2 }) {
  let firstResource = Object.keys(resources)[0];
  return config.apiVersion !== resources[firstResource].apiVersion && logger(config).warning(`Loading REST resources for API version ${resources[firstResource].apiVersion}, which doesn't match the default ${config.apiVersion}`), Object.fromEntries(Object.entries(resources).map(([name, resource]) => {
    class NewResource extends resource {
    }
    return NewResource.setClassProperties({
      Client: RestClient2,
      config
    }), Object.entries(NewResource.hasOne).map(([_attribute, klass]) => {
      klass.setClassProperties({
        Client: RestClient2,
        config
      });
    }), Object.entries(NewResource.hasMany).map(([_attribute, klass]) => {
      klass.setClassProperties({
        Client: RestClient2,
        config
      });
    }), Reflect.defineProperty(NewResource, "name", {
      value: name
    }), [name, NewResource];
  }));
}
var init_load_rest_resources = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/rest/load-rest-resources.mjs"() {
    init_logger();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/future/flags.mjs
function logDisabledFutureFlags(config, logger2) {
  if (!config._logDisabledFutureFlags)
    return;
  let logFlag = (flag, message) => logger2.info(`Future flag ${flag} is disabled.

  ${message}
`);
  config.future?.customerAddressDefaultFix || logFlag("customerAddressDefaultFix", "Enable this flag to change the CustomerAddress classes to expose a 'is_default' property instead of 'default' when fetching data."), config.future?.unstable_managedPricingSupport || logFlag("unstable_managedPricingSupport", "Enable this flag to support managed pricing, so apps can check for payments without needing a billing config. Learn more at https://shopify.dev/docs/apps/launch/billing/managed-pricing");
}
var init_flags = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/future/flags.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/scopes/index.mjs
var _AuthScopes, AuthScopes, init_scopes = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/scopes/index.mjs"() {
    _AuthScopes = class {
      compressedScopes;
      expandedScopes;
      originalScopes;
      constructor(scopes) {
        let scopesArray = [];
        typeof scopes == "string" ? scopesArray = scopes.split(new RegExp(`${_AuthScopes.SCOPE_DELIMITER}\\s*`)) : Array.isArray(scopes) ? scopesArray = scopes : scopes && (scopesArray = Array.from(scopes.expandedScopes)), scopesArray = scopesArray.map((scope) => scope.trim()).filter((scope) => scope.length);
        let impliedScopes = this.getImpliedScopes(scopesArray), scopeSet = new Set(scopesArray), impliedSet = new Set(impliedScopes);
        this.compressedScopes = new Set([...scopeSet].filter((x) => !impliedSet.has(x))), this.expandedScopes = /* @__PURE__ */ new Set([...scopeSet, ...impliedSet]), this.originalScopes = scopeSet;
      }
      /**
       * Checks whether the current set of scopes includes the given one.
       */
      has(scope) {
        let other;
        return scope instanceof _AuthScopes ? other = scope : other = new _AuthScopes(scope), other.toArray().filter((x) => !this.expandedScopes.has(x)).length === 0;
      }
      /**
       * Checks whether the current set of scopes equals the given one.
       */
      equals(otherScopes) {
        let other;
        return otherScopes instanceof _AuthScopes ? other = otherScopes : other = new _AuthScopes(otherScopes), this.compressedScopes.size === other.compressedScopes.size && this.toArray().filter((x) => !other.has(x)).length === 0;
      }
      /**
       * Returns a comma-separated string with the current set of scopes.
       */
      toString() {
        return this.toArray().join(_AuthScopes.SCOPE_DELIMITER);
      }
      /**
       * Returns an array with the current set of scopes.
       */
      toArray(returnOriginalScopes = !1) {
        return returnOriginalScopes ? [...this.originalScopes] : [...this.compressedScopes];
      }
      getImpliedScopes(scopesArray) {
        return scopesArray.reduce((array, current) => {
          let matches2 = current.match(/^(unauthenticated_)?write_(.*)$/);
          return matches2 && array.push(`${matches2[1] ? matches2[1] : ""}read_${matches2[2]}`), array;
        }, []);
      }
    }, AuthScopes = _AuthScopes;
    __publicField(AuthScopes, "SCOPE_DELIMITER", ",");
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/config.mjs
function validateConfig(params) {
  let config = {
    apiKey: "",
    apiSecretKey: "",
    hostName: "",
    hostScheme: "https",
    isEmbeddedApp: !0,
    isCustomStoreApp: !1,
    logger: {
      log: defaultLogFunction,
      level: LogSeverity.Info,
      httpRequests: !1,
      timestamps: !1
    },
    future: {},
    _logDisabledFutureFlags: !0
  }, mandatory = [
    "apiSecretKey",
    "hostName",
    "apiVersion"
  ];
  (!("isCustomStoreApp" in params) || !params.isCustomStoreApp) && mandatory.push("apiKey"), "isCustomStoreApp" in params && params.isCustomStoreApp && (!("adminApiAccessToken" in params) || params.adminApiAccessToken?.length === 0) && mandatory.push("adminApiAccessToken");
  let missing = [];
  if (mandatory.forEach((key) => {
    notEmpty(params[key]) || missing.push(key);
  }), missing.length)
    throw new ShopifyError(`Cannot initialize Shopify API Library. Missing values for: ${missing.join(", ")}. For apiVersion, please specify an explicit API version (e.g., ApiVersion.July25). See https://shopify.dev/docs/api/usage/versioning for more information.`);
  let { hostScheme, isCustomStoreApp, adminApiAccessToken, userAgentPrefix, logger: logger$1, privateAppStorefrontAccessToken, customShopDomains, billing, future: future2, ...mandatoryParams } = params, scopes;
  return params.scopes === void 0 ? scopes = void 0 : params.scopes instanceof AuthScopes ? scopes = params.scopes : scopes = new AuthScopes(params.scopes), Object.assign(config, mandatoryParams, {
    hostName: params.hostName.replace(/\/$/, ""),
    scopes,
    hostScheme: hostScheme ?? config.hostScheme,
    isCustomStoreApp: isCustomStoreApp ?? config.isCustomStoreApp,
    adminApiAccessToken: adminApiAccessToken ?? config.adminApiAccessToken,
    userAgentPrefix: userAgentPrefix ?? config.userAgentPrefix,
    logger: { ...config.logger, ...logger$1 || {} },
    privateAppStorefrontAccessToken: privateAppStorefrontAccessToken ?? config.privateAppStorefrontAccessToken,
    customShopDomains: customShopDomains ?? config.customShopDomains,
    billing: billing ?? config.billing,
    future: future2 ?? config.future
  }), config.isCustomStoreApp && params.adminApiAccessToken === params.apiSecretKey && logger(config).warning("adminApiAccessToken is set to the same value as apiSecretKey. adminApiAccessToken should be set to the Admin API access token for custom store apps; apiSecretKey should be set to the custom store app's API secret key."), config;
}
function notEmpty(value) {
  return value == null ? !1 : typeof value == "string" || Array.isArray(value) ? value.length > 0 : !0;
}
function defaultLogFunction(severity, message) {
  switch (severity) {
    case LogSeverity.Debug:
      console.debug(message);
      break;
    case LogSeverity.Info:
      console.log(message);
      break;
    case LogSeverity.Warning:
      console.warn(message);
      break;
    case LogSeverity.Error:
      console.error(message);
      break;
  }
}
var init_config = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/config.mjs"() {
    init_error();
    init_types2();
    init_scopes();
    init_logger();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/constants.mjs
var CLIENT, GQL_API_ERROR, UNEXPECTED_CONTENT_TYPE_ERROR, NO_DATA_OR_ERRORS_ERROR, CONTENT_TYPES, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES, DEFER_OPERATION_REGEX, NEWLINE_SEPARATOR, BOUNDARY_HEADER_REGEX, HEADER_SEPARATOR, init_constants = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/constants.mjs"() {
    CLIENT = "GraphQL Client", GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.", UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:", NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.", CONTENT_TYPES = {
      json: "application/json",
      multipart: "multipart/mixed"
    }, SDK_VARIANT_HEADER = "X-SDK-Variant", SDK_VERSION_HEADER = "X-SDK-Version", DEFAULT_SDK_VARIANT = "shopify-graphql-client", DEFAULT_CLIENT_VERSION = "1.4.1", RETRY_WAIT_TIME = 1e3, RETRIABLE_STATUS_CODES = [429, 503], DEFER_OPERATION_REGEX = /@(defer)\b/i, NEWLINE_SEPARATOR = `\r
`, BOUNDARY_HEADER_REGEX = /boundary="?([^=";]+)"?/i, HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/utilities.mjs
function formatErrorMessage(message, client = CLIENT) {
  return message.startsWith(`${client}`) ? message : `${client}: ${message}`;
}
function getErrorMessage(error) {
  return error instanceof Error ? error.message : JSON.stringify(error);
}
function getErrorCause(error) {
  return error instanceof Error && error.cause ? error.cause : void 0;
}
function combineErrors(dataArray) {
  return dataArray.flatMap(({ errors }) => errors ?? []);
}
function validateRetries({ client, retries }) {
  if (retries !== void 0 && (typeof retries != "number" || retries < 0 || retries > 3))
    throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${0} or greater than ${3}`);
}
function getKeyValueIfValid(key, value) {
  return value && (typeof value != "object" || Array.isArray(value) || typeof value == "object" && Object.keys(value).length > 0) ? { [key]: value } : {};
}
function buildDataObjectByPath(path, data3) {
  if (path.length === 0)
    return data3;
  let newData = {
    [path.pop()]: data3
  };
  return path.length === 0 ? newData : buildDataObjectByPath(path, newData);
}
function combineObjects(baseObject, newObject) {
  return Object.keys(newObject || {}).reduce((acc, key) => (typeof newObject[key] == "object" || Array.isArray(newObject[key])) && baseObject[key] ? (acc[key] = combineObjects(baseObject[key], newObject[key]), acc) : (acc[key] = newObject[key], acc), Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });
}
function buildCombinedDataObject([initialDatum, ...remainingData]) {
  return remainingData.reduce(combineObjects, { ...initialDatum });
}
var init_utilities = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/utilities.mjs"() {
    init_constants();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/http-fetch.mjs
function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES }) {
  let httpFetch = async (requestParams, count, maxRetries) => {
    let nextCount = count + 1, maxTries = maxRetries + 1, response;
    try {
      if (response = await customFetchApi(...requestParams), clientLogger({
        type: "HTTP-Response",
        content: {
          requestParams,
          response
        }
      }), !response.ok && retriableCodes.includes(response.status) && nextCount <= maxTries)
        throw new Error();
      let deprecationNotice = response?.headers.get("X-Shopify-API-Deprecated-Reason") || "";
      return deprecationNotice && clientLogger({
        type: "HTTP-Response-GraphQL-Deprecation-Notice",
        content: {
          requestParams,
          deprecationNotice
        }
      }), response;
    } catch (error) {
      if (nextCount <= maxTries) {
        let retryAfter = response?.headers.get("Retry-After");
        return await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime), clientLogger({
          type: "HTTP-Retry",
          content: {
            requestParams,
            lastResponse: response,
            retryAttempt: count,
            maxRetries
          }
        }), httpFetch(requestParams, nextCount, maxRetries);
      }
      throw new Error(formatErrorMessage(`${maxRetries > 0 ? `Attempted maximum number of ${maxRetries} network retries. Last message - ` : ""}${getErrorMessage(error)}`, client));
    }
  };
  return httpFetch;
}
async function sleep(waitTime) {
  return new Promise((resolve) => setTimeout(resolve, waitTime));
}
var init_http_fetch = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/http-fetch.mjs"() {
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/graphql-client/dist/graphql-client/graphql-client.mjs
function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger: logger2 }) {
  validateRetries({ client: CLIENT, retries });
  let config = {
    headers,
    url,
    retries
  }, clientLogger = generateClientLogger(logger2), httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: RETRY_WAIT_TIME
  }), fetchFn = generateFetch(httpFetch, config), request2 = generateRequest(fetchFn), requestStream = generateRequestStream(fetchFn);
  return {
    config,
    fetch: fetchFn,
    request: request2,
    requestStream
  };
}
function generateClientLogger(logger2) {
  return (logContent) => {
    logger2 && logger2(logContent);
  };
}
async function processJSONResponse(response) {
  let { errors, data: data3, extensions } = await response.json();
  return {
    ...getKeyValueIfValid("data", data3),
    ...getKeyValueIfValid("extensions", extensions),
    headers: response.headers,
    ...errors || !data3 ? {
      errors: {
        networkStatusCode: response.status,
        message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
        ...getKeyValueIfValid("graphQLErrors", errors),
        response
      }
    } : {}
  };
}
function generateFetch(httpFetch, { url, headers, retries }) {
  return async (operation, options = {}) => {
    let { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, keepalive, signal } = options, body = JSON.stringify({
      query: operation,
      variables
    });
    validateRetries({ client: CLIENT, retries: overrideRetries });
    let flatHeaders2 = Object.entries({
      ...headers,
      ...overrideHeaders
    }).reduce((headers2, [key, value]) => (headers2[key] = Array.isArray(value) ? value.join(", ") : value.toString(), headers2), {});
    return !flatHeaders2[SDK_VARIANT_HEADER] && !flatHeaders2[SDK_VERSION_HEADER] && (flatHeaders2[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT, flatHeaders2[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION), httpFetch([
      overrideUrl ?? url,
      {
        method: "POST",
        headers: flatHeaders2,
        body,
        signal,
        keepalive
      }
    ], 1, overrideRetries ?? retries);
  };
}
function generateRequest(fetchFn) {
  return async (...props) => {
    if (DEFER_OPERATION_REGEX.test(props[0]))
      throw new Error(formatErrorMessage("This operation will result in a streamable response - use requestStream() instead."));
    let response = null;
    try {
      response = await fetchFn(...props);
      let { status, statusText } = response, contentType = response.headers.get("content-type") || "";
      return response.ok ? contentType.includes(CONTENT_TYPES.json) ? await processJSONResponse(response) : {
        errors: {
          networkStatusCode: status,
          message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
          response
        }
      } : {
        errors: {
          networkStatusCode: status,
          message: formatErrorMessage(statusText),
          response
        }
      };
    } catch (error) {
      return {
        errors: {
          message: getErrorMessage(error),
          ...response == null ? {} : {
            networkStatusCode: response.status,
            response
          }
        }
      };
    }
  };
}
async function* getStreamBodyIterator(response) {
  let decoder = new TextDecoder();
  if (response.body[Symbol.asyncIterator])
    for await (let chunk of response.body)
      yield decoder.decode(chunk);
  else {
    let reader = response.body.getReader(), readResult;
    try {
      for (; !(readResult = await reader.read()).done; )
        yield decoder.decode(readResult.value);
    } finally {
      reader.cancel();
    }
  }
}
function readStreamChunk(streamBodyIterator, boundary2) {
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let buffer = "";
        for await (let textChunk of streamBodyIterator)
          if (buffer += textChunk, buffer.indexOf(boundary2) > -1) {
            let lastBoundaryIndex = buffer.lastIndexOf(boundary2), chunkBodies = buffer.slice(0, lastBoundaryIndex).split(boundary2).filter((chunk) => chunk.trim().length > 0).map((chunk) => chunk.slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length).trim());
            chunkBodies.length > 0 && (yield chunkBodies), buffer = buffer.slice(lastBoundaryIndex + boundary2.length), buffer.trim() === "--" && (buffer = "");
          }
      } catch (error) {
        throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);
      }
    }
  };
}
function createJsonResponseAsyncIterator(response) {
  return {
    async *[Symbol.asyncIterator]() {
      yield {
        ...await processJSONResponse(response),
        hasNext: !1
      };
    }
  };
}
function getResponseDataFromChunkBodies(chunkBodies) {
  return chunkBodies.map((value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);
    }
  }).map((payload) => {
    let { data: data3, incremental, hasNext, extensions, errors } = payload;
    if (!incremental)
      return {
        data: data3 || {},
        ...getKeyValueIfValid("errors", errors),
        ...getKeyValueIfValid("extensions", extensions),
        hasNext
      };
    let incrementalArray = incremental.map(({ data: data4, path, errors: errors2 }) => ({
      data: data4 && path ? buildDataObjectByPath(path, data4) : {},
      ...getKeyValueIfValid("errors", errors2)
    }));
    return {
      data: incrementalArray.length === 1 ? incrementalArray[0].data : buildCombinedDataObject([
        ...incrementalArray.map(({ data: data4 }) => data4)
      ]),
      ...getKeyValueIfValid("errors", combineErrors(incrementalArray)),
      hasNext
    };
  });
}
function validateResponseData(responseErrors, combinedData) {
  if (responseErrors.length > 0)
    throw new Error(GQL_API_ERROR, {
      cause: {
        graphQLErrors: responseErrors
      }
    });
  if (Object.keys(combinedData).length === 0)
    throw new Error(NO_DATA_OR_ERRORS_ERROR);
}
function createMultipartResponseAsyncInterator(response, responseContentType) {
  let boundaryHeader = (responseContentType ?? "").match(BOUNDARY_HEADER_REGEX), boundary2 = `--${boundaryHeader ? boundaryHeader[1] : "-"}`;
  if (!response.body?.getReader && !response.body?.[Symbol.asyncIterator])
    throw new Error("API multipart response did not return an iterable body", {
      cause: response
    });
  let streamBodyIterator = getStreamBodyIterator(response), combinedData = {}, responseExtensions;
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let streamHasNext = !0;
        for await (let chunkBodies of readStreamChunk(streamBodyIterator, boundary2)) {
          let responseData = getResponseDataFromChunkBodies(chunkBodies);
          responseExtensions = responseData.find((datum) => datum.extensions)?.extensions ?? responseExtensions;
          let responseErrors = combineErrors(responseData);
          combinedData = buildCombinedDataObject([
            combinedData,
            ...responseData.map(({ data: data3 }) => data3)
          ]), streamHasNext = responseData.slice(-1)[0].hasNext, validateResponseData(responseErrors, combinedData), yield {
            ...getKeyValueIfValid("data", combinedData),
            ...getKeyValueIfValid("extensions", responseExtensions),
            hasNext: streamHasNext
          };
        }
        if (streamHasNext)
          throw new Error("Response stream terminated unexpectedly");
      } catch (error) {
        let cause = getErrorCause(error);
        yield {
          ...getKeyValueIfValid("data", combinedData),
          ...getKeyValueIfValid("extensions", responseExtensions),
          errors: {
            message: formatErrorMessage(getErrorMessage(error)),
            networkStatusCode: response.status,
            ...getKeyValueIfValid("graphQLErrors", cause?.graphQLErrors),
            response
          },
          hasNext: !1
        };
      }
    }
  };
}
function generateRequestStream(fetchFn) {
  return async (...props) => {
    if (!DEFER_OPERATION_REGEX.test(props[0]))
      throw new Error(formatErrorMessage("This operation does not result in a streamable response - use request() instead."));
    try {
      let response = await fetchFn(...props), { statusText } = response;
      if (!response.ok)
        throw new Error(statusText, { cause: response });
      let responseContentType = response.headers.get("content-type") || "";
      switch (!0) {
        case responseContentType.includes(CONTENT_TYPES.json):
          return createJsonResponseAsyncIterator(response);
        case responseContentType.includes(CONTENT_TYPES.multipart):
          return createMultipartResponseAsyncInterator(response, responseContentType);
        default:
          throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });
      }
    } catch (error) {
      return {
        async *[Symbol.asyncIterator]() {
          let response = getErrorCause(error);
          yield {
            errors: {
              message: formatErrorMessage(getErrorMessage(error)),
              ...getKeyValueIfValid("networkStatusCode", response?.status),
              ...getKeyValueIfValid("response", response)
            },
            hasNext: !1
          };
        }
      };
    }
  };
}
var init_graphql_client = __esm({
  "node_modules/@shopify/graphql-client/dist/graphql-client/graphql-client.mjs"() {
    init_http_fetch();
    init_constants();
    init_utilities();
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/validations.mjs
function validateDomainAndGetStoreUrl({ client, storeDomain }) {
  try {
    if (!storeDomain || typeof storeDomain != "string")
      throw new Error();
    let trimmedDomain = storeDomain.trim(), protocolUrl = trimmedDomain.match(/^https?:/) ? trimmedDomain : `https://${trimmedDomain}`, url = new URL(protocolUrl);
    return url.protocol = "https", url.origin;
  } catch (error) {
    throw new Error(`${client}: a valid store domain ("${storeDomain}") must be provided`, { cause: error });
  }
}
function validateApiVersion({ client, currentSupportedApiVersions, apiVersion: apiVersion2, logger: logger2 }) {
  let versionError = `${client}: the provided apiVersion ("${apiVersion2}")`, supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(", ")}`;
  if (!apiVersion2 || typeof apiVersion2 != "string")
    throw new Error(`${versionError} is invalid. ${supportedVersion}`);
  let trimmedApiVersion = apiVersion2.trim();
  currentSupportedApiVersions.includes(trimmedApiVersion) || (logger2 ? logger2({
    type: "Unsupported_Api_Version",
    content: {
      apiVersion: apiVersion2,
      supportedApiVersions: currentSupportedApiVersions
    }
  }) : console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`));
}
var init_validations = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/validations.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/api-versions.mjs
function getQuarterMonth(quarter) {
  let month = quarter * 3 - 2;
  return month === 10 ? month : `0${month}`;
}
function getPrevousVersion(year, quarter, nQuarter) {
  let versionQuarter = quarter - nQuarter;
  return versionQuarter <= 0 ? `${year - 1}-${getQuarterMonth(versionQuarter + 4)}` : `${year}-${getQuarterMonth(versionQuarter)}`;
}
function getCurrentApiVersion() {
  let date = /* @__PURE__ */ new Date(), month = date.getUTCMonth(), year = date.getUTCFullYear(), quarter = Math.floor(month / 3 + 1);
  return {
    year,
    quarter,
    version: `${year}-${getQuarterMonth(quarter)}`
  };
}
function getCurrentSupportedApiVersions() {
  let { year, quarter, version: currentVersion } = getCurrentApiVersion(), nextVersion = quarter === 4 ? `${year + 1}-01` : `${year}-${getQuarterMonth(quarter + 1)}`;
  return [
    getPrevousVersion(year, quarter, 3),
    getPrevousVersion(year, quarter, 2),
    getPrevousVersion(year, quarter, 1),
    currentVersion,
    nextVersion,
    "unstable"
  ];
}
var init_api_versions = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/api-versions.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/api-client-utilities/utilities.mjs
function generateGetHeaders(config) {
  return (customHeaders) => ({ ...customHeaders ?? {}, ...config.headers });
}
function generateGetGQLClientParams({ getHeaders: getHeaders2, getApiUrl }) {
  return (operation, options) => {
    let props = [operation];
    if (options && Object.keys(options).length > 0) {
      let { variables, apiVersion: propApiVersion, headers, retries, signal } = options;
      props.push({
        ...variables ? { variables } : {},
        ...headers ? { headers: getHeaders2(headers) } : {},
        ...propApiVersion ? { url: getApiUrl(propApiVersion) } : {},
        ...retries ? { retries } : {},
        ...signal ? { signal } : {}
      });
    }
    return props;
  };
}
var init_utilities2 = __esm({
  "node_modules/@shopify/graphql-client/dist/api-client-utilities/utilities.mjs"() {
  }
});

// node_modules/@shopify/graphql-client/dist/index.mjs
var init_dist3 = __esm({
  "node_modules/@shopify/graphql-client/dist/index.mjs"() {
    init_graphql_client();
    init_utilities();
    init_validations();
    init_api_versions();
    init_http_fetch();
    init_utilities2();
  }
});

// node_modules/@shopify/admin-api-client/dist/constants.mjs
var DEFAULT_CONTENT_TYPE, DEFAULT_CLIENT_VERSION2, ACCESS_TOKEN_HEADER, CLIENT2, RETRIABLE_STATUS_CODES2, DEFAULT_RETRY_WAIT_TIME, init_constants2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/constants.mjs"() {
    DEFAULT_CONTENT_TYPE = "application/json", DEFAULT_CLIENT_VERSION2 = "1.1.1", ACCESS_TOKEN_HEADER = "X-Shopify-Access-Token", CLIENT2 = "Admin API Client", RETRIABLE_STATUS_CODES2 = [429, 500, 503], DEFAULT_RETRY_WAIT_TIME = 1e3;
  }
});

// node_modules/@shopify/admin-api-client/dist/validations.mjs
function validateRequiredAccessToken(accessToken) {
  if (!accessToken)
    throw new Error(`${CLIENT2}: an access token must be provided`);
}
function validateServerSideUsage(isTesting = !1) {
  if (typeof window < "u" && !isTesting)
    throw new Error(`${CLIENT2}: this client should not be used in the browser`);
}
var init_validations2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/validations.mjs"() {
    init_constants2();
  }
});

// node_modules/@shopify/admin-api-client/dist/graphql/client.mjs
function createAdminApiClient({ storeDomain, apiVersion: apiVersion2, accessToken, userAgentPrefix, retries = 0, customFetchApi, logger: logger2, isTesting }) {
  let currentSupportedApiVersions = getCurrentSupportedApiVersions(), storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  }), baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger: logger2
  };
  validateServerSideUsage(isTesting), validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion: apiVersion2,
    logger: logger2
  }), validateRequiredAccessToken(accessToken);
  let apiUrlFormatter = generateApiUrlFormatter(storeUrl, apiVersion2, baseApiVersionValidationParams), config = {
    storeDomain: storeUrl,
    apiVersion: apiVersion2,
    accessToken,
    headers: {
      "Content-Type": DEFAULT_CONTENT_TYPE,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": `${userAgentPrefix ? `${userAgentPrefix} | ` : ""}${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    },
    apiUrl: apiUrlFormatter(),
    userAgentPrefix
  }, graphqlClient = createGraphQLClient({
    headers: config.headers,
    url: config.apiUrl,
    retries,
    customFetchApi,
    logger: logger2
  }), getHeaders2 = generateGetHeaders(config), getApiUrl = generateGetApiUrl(config, apiUrlFormatter), getGQLClientParams = generateGetGQLClientParams({
    getHeaders: getHeaders2,
    getApiUrl
  });
  return Object.freeze({
    config,
    getHeaders: getHeaders2,
    getApiUrl,
    fetch: (...props) => graphqlClient.fetch(...getGQLClientParams(...props)),
    request: (...props) => graphqlClient.request(...getGQLClientParams(...props))
  });
}
function generateApiUrlFormatter(storeUrl, defaultApiVersion, baseApiVersionValidationParams) {
  return (apiVersion2) => {
    apiVersion2 && validateApiVersion({
      ...baseApiVersionValidationParams,
      apiVersion: apiVersion2
    });
    let urlApiVersion = (apiVersion2 ?? defaultApiVersion).trim();
    return `${storeUrl}/admin/api/${urlApiVersion}/graphql.json`;
  };
}
function generateGetApiUrl(config, apiUrlFormatter) {
  return (propApiVersion) => propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;
}
var init_client = __esm({
  "node_modules/@shopify/admin-api-client/dist/graphql/client.mjs"() {
    init_dist3();
    init_constants2();
    init_validations2();
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/types.mjs
var Method2, init_types3 = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/types.mjs"() {
    (function(Method3) {
      Method3.Get = "GET", Method3.Post = "POST", Method3.Put = "PUT", Method3.Delete = "DELETE";
    })(Method2 || (Method2 = {}));
  }
});

// node_modules/@shopify/admin-api-client/dist/rest/client.mjs
function createAdminRestApiClient({ storeDomain, apiVersion: apiVersion2, accessToken, userAgentPrefix, logger: logger2, customFetchApi = fetch, retries: clientRetries = 0, scheme = "https", defaultRetryTime = DEFAULT_RETRY_WAIT_TIME, formatPaths = !0, isTesting }) {
  let currentSupportedApiVersions = getCurrentSupportedApiVersions(), storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT2,
    storeDomain
  }).replace("https://", `${scheme}://`), baseApiVersionValidationParams = {
    client: CLIENT2,
    currentSupportedApiVersions,
    logger: logger2
  };
  validateServerSideUsage(isTesting), validateApiVersion({
    client: CLIENT2,
    currentSupportedApiVersions,
    apiVersion: apiVersion2,
    logger: logger2
  }), validateRequiredAccessToken(accessToken), validateRetries({ client: CLIENT2, retries: clientRetries });
  let apiUrlFormatter = generateApiUrlFormatter2(storeUrl, apiVersion2, baseApiVersionValidationParams, formatPaths), clientLogger = generateClientLogger2(logger2), httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: defaultRetryTime,
    client: CLIENT2,
    retriableCodes: RETRIABLE_STATUS_CODES2
  }), request2 = async (path, { method, data: data3, headers: requestHeadersObj, searchParams, retries = 0, apiVersion: apiVersion3 }) => {
    validateRetries({ client: CLIENT2, retries });
    let url = apiUrlFormatter(path, searchParams ?? {}, apiVersion3), requestHeaders = normalizedHeaders(requestHeadersObj ?? {}), userAgent = [
      ...requestHeaders["user-agent"] ? [requestHeaders["user-agent"]] : [],
      ...userAgentPrefix ? [userAgentPrefix] : [],
      `${CLIENT2} v${DEFAULT_CLIENT_VERSION2}`
    ].join(" | "), headers = normalizedHeaders({
      "Content-Type": DEFAULT_CONTENT_TYPE,
      ...requestHeaders,
      Accept: DEFAULT_CONTENT_TYPE,
      [ACCESS_TOKEN_HEADER]: accessToken,
      "User-Agent": userAgent
    }), body = data3 && typeof data3 != "string" ? JSON.stringify(data3) : data3;
    return httpFetch([url, { method, headers, ...body ? { body } : void 0 }], 1, retries ?? clientRetries);
  };
  return {
    get: (path, options) => request2(path, { method: Method2.Get, ...options }),
    put: (path, options) => request2(path, { method: Method2.Put, ...options }),
    post: (path, options) => request2(path, { method: Method2.Post, ...options }),
    delete: (path, options) => request2(path, { method: Method2.Delete, ...options })
  };
}
function generateApiUrlFormatter2(storeUrl, defaultApiVersion, baseApiVersionValidationParams, formatPaths = !0) {
  return (path, searchParams, apiVersion2) => {
    apiVersion2 && validateApiVersion({
      ...baseApiVersionValidationParams,
      apiVersion: apiVersion2
    });
    function convertValue(params2, key, value) {
      if (Array.isArray(value)) {
        value.forEach((arrayValue) => convertValue(params2, `${key}[]`, arrayValue));
        return;
      } else if (typeof value == "object") {
        Object.entries(value).forEach(([objKey, objValue]) => convertValue(params2, `${key}[${objKey}]`, objValue));
        return;
      }
      params2.append(key, String(value));
    }
    let urlApiVersion = (apiVersion2 ?? defaultApiVersion).trim(), cleanPath = path.replace(/^\//, "");
    formatPaths && (cleanPath.startsWith("admin") || (cleanPath = `admin/api/${urlApiVersion}/${cleanPath}`), cleanPath.endsWith(".json") || (cleanPath = `${cleanPath}.json`));
    let params = new URLSearchParams();
    if (searchParams)
      for (let [key, value] of Object.entries(searchParams))
        convertValue(params, key, value);
    let queryString = params.toString() ? `?${params.toString()}` : "";
    return `${storeUrl}/${cleanPath}${queryString}`;
  };
}
function generateClientLogger2(logger2) {
  return (logContent) => {
    logger2 && logger2(logContent);
  };
}
function normalizedHeaders(headersObj) {
  let normalizedHeaders2 = {};
  for (let [key, value] of Object.entries(headersObj))
    normalizedHeaders2[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
  return normalizedHeaders2;
}
var init_client2 = __esm({
  "node_modules/@shopify/admin-api-client/dist/rest/client.mjs"() {
    init_dist3();
    init_validations2();
    init_constants2();
    init_types3();
  }
});

// node_modules/@shopify/admin-api-client/dist/index.mjs
var init_dist4 = __esm({
  "node_modules/@shopify/admin-api-client/dist/index.mjs"() {
    init_client();
    init_client2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/common.mjs
function getUserAgent(config) {
  let userAgentPrefix = `${LIBRARY_NAME} v${SHOPIFY_API_LIBRARY_VERSION} | ${abstractRuntimeString()}`;
  return config.userAgentPrefix && (userAgentPrefix = `${config.userAgentPrefix} | ${userAgentPrefix}`), userAgentPrefix;
}
function serializeResponse(response) {
  if (!response)
    return { error: "No response object provided" };
  try {
    let { status, statusText, ok, redirected, type, url, headers } = response, serialized = {
      status,
      statusText,
      ok,
      redirected,
      type,
      url
    };
    return headers?.entries ? serialized.headers = Object.fromEntries(headers.entries()) : headers && (serialized.headers = headers), serialized;
  } catch {
    return response;
  }
}
function clientLoggerFactory(config) {
  return (logContent) => {
    if (config.logger.httpRequests)
      switch (logContent.type) {
        case "HTTP-Response": {
          let responseLog = logContent.content;
          logger(config).debug("Received response for HTTP request", {
            requestParams: JSON.stringify(responseLog.requestParams),
            response: JSON.stringify(serializeResponse(responseLog.response))
          });
          break;
        }
        case "HTTP-Retry": {
          let responseLog = logContent.content;
          logger(config).debug("Retrying HTTP request", {
            requestParams: JSON.stringify(responseLog.requestParams),
            retryAttempt: responseLog.retryAttempt,
            maxRetries: responseLog.maxRetries,
            response: responseLog.lastResponse ? JSON.stringify(serializeResponse(responseLog.lastResponse)) : "undefined"
          });
          break;
        }
        case "HTTP-Response-GraphQL-Deprecation-Notice": {
          let responseLog = logContent.content;
          logger(config).debug("Received response containing Deprecated GraphQL Notice", {
            requestParams: JSON.stringify(responseLog.requestParams),
            deprecationNotice: responseLog.deprecationNotice
          });
          break;
        }
        default: {
          logger(config).debug(`HTTP request event: ${logContent.content}`);
          break;
        }
      }
  };
}
function throwFailedRequest(body, atMaxRetries, response) {
  if (typeof response > "u") {
    let message = body?.errors?.message ?? "";
    throw new HttpRequestError(`Http request error, no response available: ${message}`);
  }
  let responseHeaders = canonicalizeHeaders(Object.fromEntries(response.headers.entries() ?? []));
  if (response.status === StatusCode.Ok && body.errors.graphQLErrors)
    throw new GraphqlQueryError({
      message: body.errors.graphQLErrors?.[0].message ?? "GraphQL operation failed",
      response,
      headers: responseHeaders,
      body
    });
  let errorMessages = [];
  body.errors && errorMessages.push(JSON.stringify(body.errors, null, 2));
  let xRequestId = getHeader(responseHeaders, "x-request-id");
  xRequestId && errorMessages.push(`If you report this error, please include this id: ${xRequestId}`);
  let errorMessage = errorMessages.length ? `:
${errorMessages.join(`
`)}` : "", code = response.status, statusText = response.statusText;
  switch (!0) {
    case response.status === StatusCode.TooManyRequests: {
      if (atMaxRetries)
        throw new HttpMaxRetriesError("Attempted the maximum number of retries for HTTP request.");
      {
        let retryAfter = getHeader(responseHeaders, "Retry-After");
        throw new HttpThrottlingError({
          message: `Shopify is throttling requests ${errorMessage}`,
          code,
          statusText,
          body,
          headers: responseHeaders,
          retryAfter: retryAfter ? parseFloat(retryAfter) : void 0
        });
      }
    }
    case response.status >= StatusCode.InternalServerError:
      throw atMaxRetries ? new HttpMaxRetriesError("Attempted the maximum number of retries for HTTP request.") : new HttpInternalError({
        message: `Shopify internal error${errorMessage}`,
        code,
        statusText,
        body,
        headers: responseHeaders
      });
    default:
      throw new HttpResponseError({
        message: `Received an error response (${response.status} ${response.statusText}) from Shopify${errorMessage}`,
        code,
        statusText,
        body,
        headers: responseHeaders
      });
  }
}
var init_common = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/common.mjs"() {
    init_error();
    init_types2();
    init_version();
    init_logger();
    init_runtime_string();
    init_headers2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/admin/graphql/client.mjs
function graphqlClientClass({ config }) {
  class NewGraphqlClient extends GraphqlClient {
    static config = config;
  }
  return Reflect.defineProperty(NewGraphqlClient, "name", {
    value: "GraphqlClient"
  }), NewGraphqlClient;
}
var GraphqlClient, init_client3 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/admin/graphql/client.mjs"() {
    init_dist4();
    init_logger();
    init_error();
    init_common();
    init_http();
    init_headers2();
    GraphqlClient = class {
      session;
      client;
      apiVersion;
      constructor(params) {
        let config = this.graphqlClass().config;
        if (!config.isCustomStoreApp && !params.session.accessToken)
          throw new MissingRequiredArgument("Missing access token when creating GraphQL client");
        if (params.apiVersion) {
          let message = params.apiVersion === config.apiVersion ? `Admin client has a redundant API version override to the default ${params.apiVersion}` : `Admin client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;
          logger(config).debug(message);
        }
        this.session = params.session, this.apiVersion = params.apiVersion, this.client = createAdminApiClient({
          accessToken: config.adminApiAccessToken ?? this.session.accessToken,
          apiVersion: this.apiVersion ?? config.apiVersion,
          storeDomain: this.session.shop,
          customFetchApi: abstractFetch,
          logger: clientLoggerFactory(config),
          userAgentPrefix: getUserAgent(config),
          isTesting: config.isTesting
        });
      }
      async query(params) {
        if (logger(this.graphqlClass().config).deprecated("12.0.0", `The query method is deprecated, and was replaced with the request method.
See the migration guide: https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.`), typeof params.data == "string" && params.data.length === 0 || Object.entries(params.data).length === 0)
          throw new MissingRequiredArgument("Query missing.");
        let operation, variables;
        typeof params.data == "string" ? operation = params.data : (operation = params.data.query, variables = params.data.variables);
        let headers = Object.fromEntries(Object.entries(params?.extraHeaders ?? {}).map(([key, value]) => [
          key,
          Array.isArray(value) ? value.join(", ") : value.toString()
        ]));
        return { body: await this.request(operation, {
          headers,
          retries: params.tries ? params.tries - 1 : void 0,
          variables
        }), headers: {} };
      }
      async request(operation, options) {
        let response = await this.client.request(operation, {
          apiVersion: this.apiVersion || this.graphqlClass().config.apiVersion,
          ...options
        });
        if (response.errors) {
          let fetchResponse = response.errors.response;
          throwFailedRequest(response, (options?.retries ?? 0) > 0, fetchResponse);
        }
        let headerObject = Object.fromEntries(response.headers ? response.headers.entries() : []);
        return {
          ...response,
          headers: canonicalizeHeaders(headerObject ?? {})
        };
      }
      graphqlClass() {
        return this.constructor;
      }
    };
    __publicField(GraphqlClient, "config");
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/admin/rest/client.mjs
import * as LosslessJSON from "lossless-json";
function restClientClass(params) {
  let { config, formatPaths } = params;
  class NewRestClient extends RestClient {
    static config = config;
    static formatPaths = formatPaths === void 0 ? !0 : formatPaths;
  }
  return Reflect.defineProperty(NewRestClient, "name", {
    value: "RestClient"
  }), NewRestClient;
}
var _RestClient, RestClient, init_client4 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/admin/rest/client.mjs"() {
    init_dist4();
    init_common();
    init_error();
    init_logger();
    init_types2();
    init_utils();
    init_types();
    init_http();
    init_headers2();
    _RestClient = class {
      loggedDeprecations = {};
      client;
      session;
      apiVersion;
      constructor({ session, apiVersion: apiVersion2 }) {
        let config = this.restClass().config;
        if (!config.isCustomStoreApp && !session.accessToken)
          throw new MissingRequiredArgument("Missing access token when creating REST client");
        if (apiVersion2) {
          let message = apiVersion2 === config.apiVersion ? `REST client has a redundant API version override to the default ${apiVersion2}` : `REST client overriding default API version ${config.apiVersion} with ${apiVersion2}`;
          logger(config).debug(message);
        }
        let customStoreAppAccessToken = config.adminApiAccessToken ?? config.apiSecretKey;
        this.session = session, this.apiVersion = apiVersion2 ?? config.apiVersion, this.client = createAdminRestApiClient({
          scheme: config.hostScheme,
          storeDomain: session.shop,
          apiVersion: apiVersion2 ?? config.apiVersion,
          accessToken: config.isCustomStoreApp ? customStoreAppAccessToken : session.accessToken,
          customFetchApi: abstractFetch,
          logger: clientLoggerFactory(config),
          userAgentPrefix: getUserAgent(config),
          defaultRetryTime: this.restClass().RETRY_WAIT_TIME,
          formatPaths: this.restClass().formatPaths,
          isTesting: config.isTesting
        });
      }
      /**
       * Performs a GET request on the given path.
       */
      async get(params) {
        return this.request({ method: Method.Get, ...params });
      }
      /**
       * Performs a POST request on the given path.
       */
      async post(params) {
        return this.request({ method: Method.Post, ...params });
      }
      /**
       * Performs a PUT request on the given path.
       */
      async put(params) {
        return this.request({ method: Method.Put, ...params });
      }
      /**
       * Performs a DELETE request on the given path.
       */
      async delete(params) {
        return this.request({ method: Method.Delete, ...params });
      }
      async request(params) {
        let requestParams = {
          headers: {
            ...params.extraHeaders,
            ...params.type ? { "Content-Type": params.type.toString() } : {}
          },
          retries: params.tries ? params.tries - 1 : void 0,
          searchParams: params.query
        }, response;
        switch (params.method) {
          case Method.Get:
            response = await this.client.get(params.path, requestParams);
            break;
          case Method.Put:
            response = await this.client.put(params.path, {
              ...requestParams,
              data: params.data
            });
            break;
          case Method.Post:
            response = await this.client.post(params.path, {
              ...requestParams,
              data: params.data
            });
            break;
          case Method.Delete:
            response = await this.client.delete(params.path, requestParams);
            break;
          default:
            throw new InvalidRequestError(`Unsupported request method '${params.method}'`);
        }
        let bodyString = await response.text(), body = params.method === Method.Delete && bodyString === "" ? {} : this.parseJsonWithLosslessNumbers(bodyString), responseHeaders = canonicalizeHeaders(Object.fromEntries(response.headers.entries()));
        response.ok || throwFailedRequest(body, (params.tries ?? 1) > 1, response);
        let requestReturn = {
          body,
          headers: responseHeaders
        };
        await this.logDeprecations({
          method: params.method,
          url: params.path,
          headers: requestParams.headers,
          body: params.data ? JSON.stringify(params.data) : void 0
        }, requestReturn);
        let link = response.headers.get("Link");
        if (link !== void 0) {
          let pageInfo = {
            limit: params.query?.limit ? params.query?.limit.toString() : _RestClient.DEFAULT_LIMIT
          };
          if (link) {
            let links2 = link.split(", ");
            for (let link2 of links2) {
              let parsedLink = link2.match(_RestClient.LINK_HEADER_REGEXP);
              if (!parsedLink)
                continue;
              let linkRel = parsedLink[2], linkUrl = new URL(parsedLink[1]), linkFields = linkUrl.searchParams.get("fields"), linkPageToken = linkUrl.searchParams.get("page_info");
              if (!pageInfo.fields && linkFields && (pageInfo.fields = linkFields.split(",")), linkPageToken)
                switch (linkRel) {
                  case "previous":
                    pageInfo.previousPageUrl = parsedLink[1], pageInfo.prevPage = this.buildRequestParams(parsedLink[1]);
                    break;
                  case "next":
                    pageInfo.nextPageUrl = parsedLink[1], pageInfo.nextPage = this.buildRequestParams(parsedLink[1]);
                    break;
                }
            }
          }
          requestReturn.pageInfo = pageInfo;
        }
        return requestReturn;
      }
      restClass() {
        return this.constructor;
      }
      /**
       * Parse JSON with lossless-json to preserve numeric precision.
       * Converts all ID fields (ending with _id, _ids, or named 'id') to strings.
       */
      parseJsonWithLosslessNumbers(jsonString) {
        let parsed = LosslessJSON.parse(jsonString), processValue = (value, key) => {
          if (value == null)
            return value;
          if (value && value.isLosslessNumber === !0) {
            let keyLower = (key || "").toLowerCase();
            return keyLower === "id" || keyLower.endsWith("_id") ? value.toString() : Number(value.value);
          }
          if (Array.isArray(value)) {
            let isIdsArray = key && key.toLowerCase().endsWith("_ids");
            return value.map((item) => isIdsArray && item && item.isLosslessNumber === !0 ? item.toString() : processValue(item));
          }
          if (typeof value == "object") {
            let result = {};
            for (let objKey in value)
              Object.prototype.hasOwnProperty.call(value, objKey) && (result[objKey] = processValue(value[objKey], objKey));
            return result;
          }
          return value;
        };
        return processValue(parsed);
      }
      buildRequestParams(newPageUrl) {
        let pattern = "^/admin/api/[^/]+/(.*).json$", url = new URL(newPageUrl);
        return {
          path: url.pathname.replace(new RegExp(pattern), "$1"),
          query: Object.fromEntries(url.searchParams.entries())
        };
      }
      async logDeprecations(request2, response) {
        let config = this.restClass().config, deprecationReason = getHeader(response.headers, "X-Shopify-API-Deprecated-Reason");
        if (deprecationReason) {
          let deprecation = {
            message: deprecationReason,
            path: request2.url
          };
          request2.body && (deprecation.body = `${request2.body.substring(0, 100)}...`);
          let depHash = await createSHA256HMAC(config.apiSecretKey, JSON.stringify(deprecation), HashFormat.Hex);
          if (!Object.keys(this.loggedDeprecations).includes(depHash) || Date.now() - this.loggedDeprecations[depHash] >= _RestClient.DEPRECATION_ALERT_DELAY) {
            this.loggedDeprecations[depHash] = Date.now();
            let stack = new Error().stack, message = `API Deprecation Notice ${(/* @__PURE__ */ new Date()).toLocaleString()} : ${JSON.stringify(deprecation)}  -  Stack Trace: ${stack}`;
            await logger(config).warning(message);
          }
        }
      }
    }, RestClient = _RestClient;
    __publicField(RestClient, "config"), __publicField(RestClient, "formatPaths"), __publicField(RestClient, "LINK_HEADER_REGEXP", /<([^<]+)>; rel="([^"]+)"/), __publicField(RestClient, "DEFAULT_LIMIT", "50"), __publicField(RestClient, "RETRY_WAIT_TIME", 1e3), __publicField(RestClient, "DEPRECATION_ALERT_DELAY", 3e5);
  }
});

// node_modules/@shopify/storefront-api-client/dist/constants.mjs
var DEFAULT_CONTENT_TYPE2, DEFAULT_SDK_VARIANT2, DEFAULT_CLIENT_VERSION3, PUBLIC_ACCESS_TOKEN_HEADER, PRIVATE_ACCESS_TOKEN_HEADER, SDK_VARIANT_HEADER2, SDK_VERSION_HEADER2, SDK_VARIANT_SOURCE_HEADER, CLIENT3, init_constants3 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/constants.mjs"() {
    DEFAULT_CONTENT_TYPE2 = "application/json", DEFAULT_SDK_VARIANT2 = "storefront-api-client", DEFAULT_CLIENT_VERSION3 = "1.0.9", PUBLIC_ACCESS_TOKEN_HEADER = "X-Shopify-Storefront-Access-Token", PRIVATE_ACCESS_TOKEN_HEADER = "Shopify-Storefront-Private-Token", SDK_VARIANT_HEADER2 = "X-SDK-Variant", SDK_VERSION_HEADER2 = "X-SDK-Version", SDK_VARIANT_SOURCE_HEADER = "X-SDK-Variant-Source", CLIENT3 = "Storefront API Client";
  }
});

// node_modules/@shopify/storefront-api-client/dist/validations.mjs
function validatePrivateAccessTokenUsage(privateAccessToken) {
  if (privateAccessToken && typeof window < "u")
    throw new Error(`${CLIENT3}: private access tokens and headers should only be used in a server-to-server implementation. Use the public API access token in nonserver environments.`);
}
function validateRequiredAccessTokens(publicAccessToken, privateAccessToken) {
  if (!publicAccessToken && !privateAccessToken)
    throw new Error(`${CLIENT3}: a public or private access token must be provided`);
  if (publicAccessToken && privateAccessToken)
    throw new Error(`${CLIENT3}: only provide either a public or private access token`);
}
var init_validations3 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/validations.mjs"() {
    init_constants3();
  }
});

// node_modules/@shopify/storefront-api-client/dist/storefront-api-client.mjs
function createStorefrontApiClient({ storeDomain, apiVersion: apiVersion2, publicAccessToken, privateAccessToken, clientName, retries = 0, customFetchApi, logger: logger2 }) {
  let currentSupportedApiVersions = getCurrentSupportedApiVersions(), storeUrl = validateDomainAndGetStoreUrl({
    client: CLIENT3,
    storeDomain
  }), baseApiVersionValidationParams = {
    client: CLIENT3,
    currentSupportedApiVersions,
    logger: logger2
  };
  validateApiVersion({ ...baseApiVersionValidationParams, apiVersion: apiVersion2 }), validateRequiredAccessTokens(publicAccessToken, privateAccessToken), validatePrivateAccessTokenUsage(privateAccessToken);
  let apiUrlFormatter = generateApiUrlFormatter3(storeUrl, apiVersion2, baseApiVersionValidationParams), config = {
    storeDomain: storeUrl,
    apiVersion: apiVersion2,
    ...publicAccessToken ? { publicAccessToken } : {
      privateAccessToken
    },
    headers: {
      "Content-Type": DEFAULT_CONTENT_TYPE2,
      Accept: DEFAULT_CONTENT_TYPE2,
      [SDK_VARIANT_HEADER2]: DEFAULT_SDK_VARIANT2,
      [SDK_VERSION_HEADER2]: DEFAULT_CLIENT_VERSION3,
      ...clientName ? { [SDK_VARIANT_SOURCE_HEADER]: clientName } : {},
      ...publicAccessToken ? { [PUBLIC_ACCESS_TOKEN_HEADER]: publicAccessToken } : { [PRIVATE_ACCESS_TOKEN_HEADER]: privateAccessToken }
    },
    apiUrl: apiUrlFormatter(),
    clientName
  }, graphqlClient = createGraphQLClient({
    headers: config.headers,
    url: config.apiUrl,
    retries,
    customFetchApi,
    logger: logger2
  }), getHeaders2 = generateGetHeaders(config), getApiUrl = generateGetApiUrl2(config, apiUrlFormatter), getGQLClientParams = generateGetGQLClientParams({
    getHeaders: getHeaders2,
    getApiUrl
  });
  return Object.freeze({
    config,
    getHeaders: getHeaders2,
    getApiUrl,
    fetch: (...props) => graphqlClient.fetch(...getGQLClientParams(...props)),
    request: (...props) => graphqlClient.request(...getGQLClientParams(...props)),
    requestStream: (...props) => graphqlClient.requestStream(...getGQLClientParams(...props))
  });
}
function generateApiUrlFormatter3(storeUrl, defaultApiVersion, baseApiVersionValidationParams) {
  return (apiVersion2) => {
    apiVersion2 && validateApiVersion({
      ...baseApiVersionValidationParams,
      apiVersion: apiVersion2
    });
    let urlApiVersion = (apiVersion2 ?? defaultApiVersion).trim();
    return `${storeUrl}/api/${urlApiVersion}/graphql.json`;
  };
}
function generateGetApiUrl2(config, apiUrlFormatter) {
  return (propApiVersion) => propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;
}
var init_storefront_api_client = __esm({
  "node_modules/@shopify/storefront-api-client/dist/storefront-api-client.mjs"() {
    init_dist3();
    init_constants3();
    init_validations3();
  }
});

// node_modules/@shopify/storefront-api-client/dist/index.mjs
var init_dist5 = __esm({
  "node_modules/@shopify/storefront-api-client/dist/index.mjs"() {
    init_storefront_api_client();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/storefront/client.mjs
function storefrontClientClass(params) {
  let { config } = params;
  class NewStorefrontClient extends StorefrontClient {
    static config = config;
  }
  return Reflect.defineProperty(NewStorefrontClient, "name", {
    value: "StorefrontClient"
  }), NewStorefrontClient;
}
var StorefrontClient, init_client5 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/storefront/client.mjs"() {
    init_dist5();
    init_logger();
    init_error();
    init_common();
    init_http();
    StorefrontClient = class {
      session;
      client;
      apiVersion;
      constructor(params) {
        let config = this.storefrontClass().config;
        if (!config.isCustomStoreApp && !params.session.accessToken)
          throw new MissingRequiredArgument("Missing access token when creating GraphQL client");
        if (params.apiVersion) {
          let message = params.apiVersion === config.apiVersion ? `Storefront client has a redundant API version override to the default ${params.apiVersion}` : `Storefront client overriding default API version ${config.apiVersion} with ${params.apiVersion}`;
          logger(config).debug(message);
        }
        let accessToken;
        if (config.isCustomStoreApp) {
          if (accessToken = config.privateAppStorefrontAccessToken, !accessToken)
            throw new MissingRequiredArgument("Custom store apps must set the privateAppStorefrontAccessToken property to call the Storefront API.");
        } else if (accessToken = params.session.accessToken, !accessToken)
          throw new MissingRequiredArgument("Session missing access token.");
        this.session = params.session, this.apiVersion = params.apiVersion, this.client = createStorefrontApiClient({
          privateAccessToken: accessToken,
          apiVersion: this.apiVersion ?? config.apiVersion,
          storeDomain: this.session.shop,
          customFetchApi: abstractFetch,
          logger: clientLoggerFactory(config),
          clientName: getUserAgent(config)
        });
      }
      async query(params) {
        if (logger(this.storefrontClass().config).deprecated("12.0.0", `The query method is deprecated, and was replaced with the request method.
See the migration guide: https://github.com/Shopify/shopify-app-js/blob/main/packages/apps/shopify-api/docs/migrating-to-v9.md#using-the-new-clients.`), typeof params.data == "string" && params.data.length === 0 || Object.entries(params.data).length === 0)
          throw new MissingRequiredArgument("Query missing.");
        let operation, variables;
        typeof params.data == "string" ? operation = params.data : (operation = params.data.query, variables = params.data.variables);
        let headers = Object.fromEntries(Object.entries(params?.extraHeaders ?? {}).map(([key, value]) => [
          key,
          Array.isArray(value) ? value.join(", ") : value.toString()
        ]));
        return { body: await this.request(operation, {
          headers,
          retries: params.tries ? params.tries - 1 : void 0,
          variables
        }), headers: {} };
      }
      async request(operation, options) {
        let response = await this.client.request(operation, {
          apiVersion: this.apiVersion || this.storefrontClass().config.apiVersion,
          ...options
        });
        if (response.errors) {
          let fetchResponse = response.errors.response;
          throwFailedRequest(response, (options?.retries ?? 0) > 0, fetchResponse);
        }
        return response;
      }
      storefrontClass() {
        return this.constructor;
      }
    };
    __publicField(StorefrontClient, "config");
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/graphql_proxy/graphql_proxy.mjs
import "lossless-json";
import "compare-versions";
function graphqlProxy(config) {
  return async ({ session, rawBody }) => {
    if (!session.accessToken)
      throw new InvalidSession("Cannot proxy query. Session not authenticated.");
    let GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session }), query, variables;
    if (typeof rawBody == "string" ? query = rawBody : (query = rawBody.query, variables = rawBody.variables), !query)
      throw new MissingRequiredArgument("Query missing.");
    return { body: await client.request(query, { variables }), headers: {} };
  };
}
var init_graphql_proxy = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/graphql_proxy/graphql_proxy.mjs"() {
    init_error();
    init_client3();
    init_dist4();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/index.mjs
function clientClasses(config) {
  return {
    // We don't pass in the HttpClient because the RestClient inherits from it, and goes through the same setup process
    Rest: restClientClass({ config }),
    Graphql: graphqlClientClass({ config }),
    Storefront: storefrontClientClass({ config }),
    graphqlProxy: graphqlProxy(config)
  };
}
var init_clients = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/index.mjs"() {
    init_client3();
    init_client4();
    init_client5();
    init_graphql_proxy();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/processed-query.mjs
var ProcessedQuery, init_processed_query = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/processed-query.mjs"() {
    ProcessedQuery = class {
      static stringify(keyValuePairs) {
        return !keyValuePairs || Object.keys(keyValuePairs).length === 0 ? "" : new ProcessedQuery().putAll(keyValuePairs).stringify();
      }
      processedQuery;
      constructor() {
        this.processedQuery = new URLSearchParams();
      }
      putAll(keyValuePairs) {
        return Object.entries(keyValuePairs).forEach(([key, value]) => this.put(key, value)), this;
      }
      put(key, value) {
        Array.isArray(value) ? this.putArray(key, value) : value?.constructor === Object ? this.putObject(key, value) : this.putSimple(key, value);
      }
      putArray(key, value) {
        value.forEach((arrayValue) => this.processedQuery.append(`${key}[]`, `${arrayValue}`));
      }
      putObject(key, value) {
        Object.entries(value).forEach(([entry2, entryValue]) => {
          this.processedQuery.append(`${key}[${entry2}]`, `${entryValue}`);
        });
      }
      putSimple(key, value) {
        this.processedQuery.append(key, `${value}`);
      }
      stringify(omitQuestionMark = !1) {
        let queryString = this.processedQuery.toString();
        return omitQuestionMark ? queryString : `?${queryString}`;
      }
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/safe-compare.mjs
function timingSafeEqual(bufA, bufB) {
  let viewA = new Uint8Array(bufA), viewB = new Uint8Array(bufB), out = 0;
  for (let i = 0; i < viewA.length; i++)
    out |= viewA[i] ^ viewB[i];
  return out === 0;
}
var safeCompare, init_safe_compare = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/safe-compare.mjs"() {
    init_error();
    safeCompare = (strA, strB) => {
      if (typeof strA == typeof strB) {
        let enc = new TextEncoder(), buffA = enc.encode(JSON.stringify(strA)), buffB = enc.encode(JSON.stringify(strB));
        if (buffA.length === buffB.length)
          return timingSafeEqual(buffA, buffB);
      } else
        throw new SafeCompareError(`Mismatched data types provided: ${typeof strA} and ${typeof strB}`);
      return !1;
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/types.mjs
var HmacValidationType, ValidationErrorReason, init_types4 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/types.mjs"() {
    (function(HmacValidationType2) {
      HmacValidationType2.Flow = "flow", HmacValidationType2.Webhook = "webhook", HmacValidationType2.FulfillmentService = "fulfillment_service";
    })(HmacValidationType || (HmacValidationType = {}));
    ValidationErrorReason = {
      MissingBody: "missing_body",
      InvalidHmac: "invalid_hmac",
      MissingHmac: "missing_hmac"
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/hmac-validator.mjs
function stringifyQueryForAdmin(query) {
  let processedQuery = new ProcessedQuery();
  return Object.keys(query).sort((val1, val2) => val1.localeCompare(val2)).forEach((key) => processedQuery.put(key, query[key])), processedQuery.stringify(!0);
}
function stringifyQueryForAppProxy(query) {
  return Object.entries(query).sort(([val1], [val2]) => val1.localeCompare(val2)).reduce((acc, [key, value]) => `${acc}${key}=${Array.isArray(value) ? value.join(",") : value}`, "");
}
function generateLocalHmac(config) {
  return async (params, signator = "admin") => {
    let { hmac, signature, ...query } = params, queryString = signator === "admin" ? stringifyQueryForAdmin(query) : stringifyQueryForAppProxy(query);
    return createSHA256HMAC(config.apiSecretKey, queryString, HashFormat.Hex);
  };
}
function validateHmac(config) {
  return async (query, { signator } = { signator: "admin" }) => {
    if (signator === "admin" && !query.hmac)
      throw new InvalidHmacError("Query does not contain an HMAC value.");
    if (signator === "appProxy" && !query.signature)
      throw new InvalidHmacError("Query does not contain a signature value.");
    validateHmacTimestamp(query);
    let hmac = signator === "appProxy" ? query.signature : query.hmac, localHmac = await generateLocalHmac(config)(query, signator);
    return safeCompare(hmac, localHmac);
  };
}
async function validateHmacString(config, data3, hmac, format) {
  let localHmac = await createSHA256HMAC(config.apiSecretKey, data3, format);
  return safeCompare(hmac, localHmac);
}
function getCurrentTimeInSec() {
  return Math.trunc(Date.now() / 1e3);
}
function validateHmacFromRequestFactory(config) {
  return async function({ type, rawBody, ...adapterArgs }) {
    let request2 = await abstractConvertRequest(adapterArgs);
    if (!rawBody.length)
      return fail(ValidationErrorReason.MissingBody, type, config);
    let hmac = getHeader(request2.headers, ShopifyHeader.Hmac);
    return hmac ? await validateHmacString(config, rawBody, hmac, HashFormat.Base64) ? succeed(type, config) : fail(ValidationErrorReason.InvalidHmac, type, config) : fail(ValidationErrorReason.MissingHmac, type, config);
  };
}
function validateHmacTimestamp(query) {
  if (Math.abs(getCurrentTimeInSec() - Number(query.timestamp)) > HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC)
    throw new InvalidHmacError("HMAC timestamp is outside of the tolerance range");
}
async function fail(reason, type, config) {
  return await logger(config).debug(`${type} request is not valid`, { reason }), {
    valid: !1,
    reason
  };
}
async function succeed(type, config) {
  return await logger(config).debug(`${type} request is valid`), {
    valid: !0
  };
}
var HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC, init_hmac_validator = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/hmac-validator.mjs"() {
    init_logger();
    init_types2();
    init_http();
    init_types();
    init_utils();
    init_error();
    init_safe_compare();
    init_processed_query();
    init_types4();
    init_headers2();
    HMAC_TIMESTAMP_PERMITTED_CLOCK_TOLERANCE_SEC = 90;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/decode-host.mjs
function decodeHost(host) {
  return atob(host);
}
var init_decode_host = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/decode-host.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/shop-admin-url-helper.mjs
function shopAdminUrlToLegacyUrl(shopAdminUrl) {
  let shopUrl = removeProtocol(shopAdminUrl);
  if (!(shopUrl.split(".")[0] === "admin"))
    return null;
  let regex = new RegExp("admin\\..+/store/([^/]+)"), matches2 = shopUrl.match(regex);
  if (matches2 && matches2.length === 2) {
    let shopName = matches2[1], isSpinUrl = shopUrl.includes("spin.dev/store/"), isLocalUrl = shopUrl.includes("shop.dev/store/");
    return isSpinUrl ? spinAdminUrlToLegacyUrl(shopUrl) : isLocalUrl ? localAdminUrlToLegacyUrl(shopUrl) : `${shopName}.myshopify.com`;
  } else
    return null;
}
function legacyUrlToShopAdminUrl(legacyAdminUrl) {
  let shopUrl = removeProtocol(legacyAdminUrl), regex = new RegExp("(.+)\\.myshopify\\.com$"), matches2 = shopUrl.match(regex);
  if (matches2 && matches2.length === 2)
    return `admin.shopify.com/store/${matches2[1]}`;
  {
    let isSpinUrl = shopUrl.endsWith("spin.dev"), isLocalUrl = shopUrl.endsWith("shop.dev");
    return isSpinUrl ? spinLegacyUrlToAdminUrl(shopUrl) : isLocalUrl ? localLegacyUrlToAdminUrl(shopUrl) : null;
  }
}
function spinAdminUrlToLegacyUrl(shopAdminUrl) {
  let spinRegex = new RegExp("admin\\.web\\.(.+\\.spin\\.dev)/store/(.+)"), spinMatches = shopAdminUrl.match(spinRegex);
  if (spinMatches && spinMatches.length === 3) {
    let spinUrl = spinMatches[1];
    return `${spinMatches[2]}.shopify.${spinUrl}`;
  } else
    return null;
}
function localAdminUrlToLegacyUrl(shopAdminUrl) {
  let localRegex = new RegExp("admin\\.shop\\.dev/store/(.+)"), localMatches = shopAdminUrl.match(localRegex);
  return localMatches && localMatches.length === 2 ? `${localMatches[1]}.shop.dev` : null;
}
function spinLegacyUrlToAdminUrl(legacyAdminUrl) {
  let spinRegex = new RegExp("(.+)\\.shopify\\.(.+\\.spin\\.dev)"), spinMatches = legacyAdminUrl.match(spinRegex);
  if (spinMatches && spinMatches.length === 3) {
    let shopName = spinMatches[1];
    return `admin.web.${spinMatches[2]}/store/${shopName}`;
  } else
    return null;
}
function localLegacyUrlToAdminUrl(legacyAdminUrl) {
  let localRegex = new RegExp("(.+)\\.shop\\.dev$"), localMatches = legacyAdminUrl.match(localRegex);
  return localMatches && localMatches.length === 2 ? `admin.shop.dev/store/${localMatches[1]}` : null;
}
function removeProtocol(url) {
  return url.replace(/^https?:\/\//, "").replace(/\/$/, "");
}
var init_shop_admin_url_helper = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/shop-admin-url-helper.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/shop-validator.mjs
function sanitizeShop(config) {
  return (shop, throwOnInvalid = !1) => {
    let shopUrl = shop, domainsRegex = [
      "myshopify\\.com",
      "shopify\\.com",
      "myshopify\\.io",
      "shop\\.dev"
    ];
    config.customShopDomains && domainsRegex.push(...config.customShopDomains.map((regex) => typeof regex == "string" ? regex : regex.source));
    let shopUrlRegex = new RegExp(`^[a-zA-Z0-9][a-zA-Z0-9-_]*\\.(${domainsRegex.join("|")})[/]*$`);
    new RegExp(`^admin\\.(${domainsRegex.join("|")})/store/([a-zA-Z0-9][a-zA-Z0-9-_]*)$`).test(shopUrl) && (shopUrl = shopAdminUrlToLegacyUrl(shopUrl) || "");
    let sanitizedShop = shopUrlRegex.test(shopUrl) ? shopUrl : null;
    if (!sanitizedShop && throwOnInvalid)
      throw new InvalidShopError("Received invalid shop argument");
    return sanitizedShop;
  };
}
function sanitizeHost() {
  return (host, throwOnInvalid = !1) => {
    let sanitizedHost = /^[0-9a-zA-Z+/]+={0,2}$/.test(host) ? host : null;
    if (sanitizedHost) {
      let { hostname } = new URL(`https://${decodeHost(sanitizedHost)}`), originsRegex = [
        "myshopify\\.com",
        "shopify\\.com",
        "myshopify\\.io",
        "spin\\.dev",
        "shop\\.dev"
      ];
      new RegExp(`\\.(${originsRegex.join("|")})$`).test(hostname) || (sanitizedHost = null);
    }
    if (!sanitizedHost && throwOnInvalid)
      throw new InvalidHostError("Received invalid host argument");
    return sanitizedHost;
  };
}
var init_shop_validator = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/shop-validator.mjs"() {
    init_error();
    init_decode_host();
    init_shop_admin_url_helper();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/clients/types.mjs
import "compare-versions";
import "lossless-json";
var DataType, init_types5 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/clients/types.mjs"() {
    init_dist4();
    (function(DataType2) {
      DataType2.JSON = "application/json", DataType2.GraphQL = "application/graphql", DataType2.URLEncoded = "application/x-www-form-urlencoded";
    })(DataType || (DataType = {}));
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/fetch-request.mjs
function fetchRequestFactory(config) {
  return async function(url, options) {
    let log2 = logger(config), doLog = config.logger.httpRequests && config.logger.level === LogSeverity.Debug;
    doLog && log2.debug("Making HTTP request", {
      method: options?.method || "GET",
      url,
      ...options?.body && { body: options?.body }
    });
    let response = await abstractFetch(url, options);
    return doLog && log2.debug("HTTP request completed", {
      method: options?.method || "GET",
      url,
      status: response.status
    }), response;
  };
}
var init_fetch_request = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/fetch-request.mjs"() {
    init_logger();
    init_types2();
    init_http();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/types.mjs
var SESSION_COOKIE_NAME, STATE_COOKIE_NAME, init_types6 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/types.mjs"() {
    SESSION_COOKIE_NAME = "shopify_app_session", STATE_COOKIE_NAME = "shopify_app_state";
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/nonce.mjs
function nonce() {
  return crypto.getRandomValues(new Uint8Array(15)).map((byte) => byte % 10).join("");
}
var init_nonce = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/nonce.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/session/session.mjs
var propertiesToSave, Session, init_session = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/session/session.mjs"() {
    init_error();
    init_scopes();
    propertiesToSave = [
      "id",
      "shop",
      "state",
      "isOnline",
      "scope",
      "accessToken",
      "expires",
      "onlineAccessInfo"
    ], Session = class {
      static fromPropertyArray(entries, returnUserData = !1) {
        if (!Array.isArray(entries))
          throw new InvalidSession("The parameter is not an array: a Session cannot be created from this object.");
        let obj = Object.fromEntries(entries.filter(([_key, value]) => value != null).map(([key, value]) => {
          switch (key.toLowerCase()) {
            case "isonline":
              return ["isOnline", value];
            case "accesstoken":
              return ["accessToken", value];
            case "onlineaccessinfo":
              return ["onlineAccessInfo", value];
            case "userid":
              return ["userId", value];
            case "firstname":
              return ["firstName", value];
            case "lastname":
              return ["lastName", value];
            case "accountowner":
              return ["accountOwner", value];
            case "emailverified":
              return ["emailVerified", value];
            default:
              return [key.toLowerCase(), value];
          }
        })), sessionData = {}, onlineAccessInfo = {
          associated_user: {}
        };
        return Object.entries(obj).forEach(([key, value]) => {
          switch (key) {
            case "isOnline":
              typeof value == "string" ? sessionData[key] = value.toString().toLowerCase() === "true" : typeof value == "number" ? sessionData[key] = Boolean(value) : sessionData[key] = value;
              break;
            case "scope":
              sessionData[key] = value.toString();
              break;
            case "expires":
              sessionData[key] = value ? new Date(Number(value)) : void 0;
              break;
            case "onlineAccessInfo":
              onlineAccessInfo.associated_user.id = Number(value);
              break;
            case "userId":
              if (returnUserData) {
                onlineAccessInfo.associated_user.id = Number(value);
                break;
              }
            case "firstName":
              if (returnUserData) {
                onlineAccessInfo.associated_user.first_name = String(value);
                break;
              }
            case "lastName":
              if (returnUserData) {
                onlineAccessInfo.associated_user.last_name = String(value);
                break;
              }
            case "email":
              if (returnUserData) {
                onlineAccessInfo.associated_user.email = String(value);
                break;
              }
            case "accountOwner":
              if (returnUserData) {
                onlineAccessInfo.associated_user.account_owner = Boolean(value);
                break;
              }
            case "locale":
              if (returnUserData) {
                onlineAccessInfo.associated_user.locale = String(value);
                break;
              }
            case "collaborator":
              if (returnUserData) {
                onlineAccessInfo.associated_user.collaborator = Boolean(value);
                break;
              }
            case "emailVerified":
              if (returnUserData) {
                onlineAccessInfo.associated_user.email_verified = Boolean(value);
                break;
              }
            default:
              sessionData[key] = value;
          }
        }), sessionData.isOnline && (sessionData.onlineAccessInfo = onlineAccessInfo), new Session(sessionData);
      }
      /**
       * The unique identifier for the session.
       */
      id;
      /**
       * The Shopify shop domain, such as `example.myshopify.com`.
       */
      shop;
      /**
       * The state of the session. Used for the OAuth authentication code flow.
       */
      state;
      /**
       * Whether the access token in the session is online or offline.
       */
      isOnline;
      /**
       * The desired scopes for the access token, at the time the session was created.
       */
      scope;
      /**
       * The date the access token expires.
       */
      expires;
      /**
       * The access token for the session.
       */
      accessToken;
      /**
       * Information on the user for the session. Only present for online sessions.
       */
      onlineAccessInfo;
      constructor(params) {
        Object.assign(this, params);
      }
      /**
       * Whether the session is active. Active sessions have an access token that is not expired, and has has the given
       * scopes if scopes is equal to a truthy value.
       */
      isActive(scopes, withinMillisecondsOfExpiry = 500) {
        let hasAccessToken = Boolean(this.accessToken), isTokenNotExpired = !this.isExpired(withinMillisecondsOfExpiry);
        return !this.isScopeChanged(scopes) && hasAccessToken && isTokenNotExpired;
      }
      /**
       * Whether the access token includes the given scopes if they are provided.
       */
      isScopeChanged(scopes) {
        return typeof scopes > "u" ? !1 : !this.isScopeIncluded(scopes);
      }
      /**
       * Whether the access token includes the given scopes.
       */
      isScopeIncluded(scopes) {
        let requiredScopes = scopes instanceof AuthScopes ? scopes : new AuthScopes(scopes);
        return new AuthScopes(this.scope).has(requiredScopes);
      }
      /**
       * Whether the access token is expired.
       */
      isExpired(withinMillisecondsOfExpiry = 0) {
        return Boolean(this.expires && this.expires.getTime() - withinMillisecondsOfExpiry < Date.now());
      }
      /**
       * Converts an object with data into a Session.
       */
      toObject() {
        let object = {
          id: this.id,
          shop: this.shop,
          state: this.state,
          isOnline: this.isOnline
        };
        return this.scope && (object.scope = this.scope), this.expires && (object.expires = this.expires), this.accessToken && (object.accessToken = this.accessToken), this.onlineAccessInfo && (object.onlineAccessInfo = this.onlineAccessInfo), object;
      }
      /**
       * Checks whether the given session is equal to this session.
       */
      equals(other) {
        if (!other || !(this.id === other.id && this.shop === other.shop && this.state === other.state && this.isOnline === other.isOnline))
          return !1;
        let copyA = this.toPropertyArray(!0);
        copyA.sort(([k1], [k2]) => k1 < k2 ? -1 : 1);
        let copyB = other.toPropertyArray(!0);
        return copyB.sort(([k1], [k2]) => k1 < k2 ? -1 : 1), JSON.stringify(copyA) === JSON.stringify(copyB);
      }
      /**
       * Converts the session into an array of key-value pairs.
       */
      toPropertyArray(returnUserData = !1) {
        return Object.entries(this).filter(([key, value]) => propertiesToSave.includes(key) && value !== void 0 && value !== null).flatMap(([key, value]) => {
          switch (key) {
            case "expires":
              return [[key, value ? value.getTime() : void 0]];
            case "onlineAccessInfo":
              return returnUserData ? [
                ["userId", value?.associated_user?.id],
                ["firstName", value?.associated_user?.first_name],
                ["lastName", value?.associated_user?.last_name],
                ["email", value?.associated_user?.email],
                ["locale", value?.associated_user?.locale],
                ["emailVerified", value?.associated_user?.email_verified],
                ["accountOwner", value?.associated_user?.account_owner],
                ["collaborator", value?.associated_user?.collaborator]
              ] : [[key, value.associated_user.id]];
            default:
              return [[key, value]];
          }
        }).filter(([_key, value]) => value !== void 0);
      }
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/get-hmac-key.mjs
function getHMACKey(key) {
  let arrayBuffer = new Uint8Array(key.length);
  for (let i = 0, keyLen = key.length; i < keyLen; i++)
    arrayBuffer[i] = key.charCodeAt(i);
  return arrayBuffer;
}
var init_get_hmac_key = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/get-hmac-key.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/session/decode-session-token.mjs
import * as jose from "jose";
function decodeSessionToken(config) {
  return async (token, { checkAudience = !0 } = {}) => {
    let payload;
    try {
      payload = (await jose.jwtVerify(token, getHMACKey(config.apiSecretKey), {
        algorithms: ["HS256"],
        clockTolerance: JWT_PERMITTED_CLOCK_TOLERANCE
      })).payload;
    } catch (error) {
      throw new InvalidJwtError(`Failed to parse session token '${token}': ${error.message}`);
    }
    if (checkAudience && payload.aud !== config.apiKey)
      throw new InvalidJwtError("Session token had invalid API key");
    return payload;
  };
}
var JWT_PERMITTED_CLOCK_TOLERANCE, init_decode_session_token = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/session/decode-session-token.mjs"() {
    init_error();
    init_get_hmac_key();
    JWT_PERMITTED_CLOCK_TOLERANCE = 10;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/session/session-utils.mjs
function getJwtSessionId(config) {
  return (shop, userId) => `${sanitizeShop(config)(shop, !0)}_${userId}`;
}
function getOfflineId(config) {
  return (shop) => `offline_${sanitizeShop(config)(shop, !0)}`;
}
function getCurrentSessionId(config) {
  return async function({ isOnline, ...adapterArgs }) {
    let request2 = await abstractConvertRequest(adapterArgs), log2 = logger(config);
    if (config.isEmbeddedApp) {
      log2.debug("App is embedded, looking for session id in JWT payload", {
        isOnline
      });
      let authHeader = request2.headers.Authorization;
      if (authHeader) {
        let matches2 = (typeof authHeader == "string" ? authHeader : authHeader[0]).match(/^Bearer (.+)$/);
        if (!matches2)
          throw log2.error("Missing Bearer token in authorization header", { isOnline }), new MissingJwtTokenError("Missing Bearer token in authorization header");
        let jwtPayload = await decodeSessionToken(config)(matches2[1]), shop = jwtPayload.dest.replace(/^https:\/\//, "");
        return log2.debug("Found valid JWT payload", { shop, isOnline }), isOnline ? getJwtSessionId(config)(shop, jwtPayload.sub) : getOfflineId(config)(shop);
      } else
        log2.error("Missing Authorization header review App Bridge configuration", { isOnline });
    } else
      return log2.debug("App is not embedded, looking for session id in cookies", {
        isOnline
      }), new Cookies(request2, {}, {
        keys: [config.apiSecretKey]
      }).getAndVerify(SESSION_COOKIE_NAME);
  };
}
function customAppSession(config) {
  return (shop) => new Session({
    id: "",
    shop: `${sanitizeShop(config)(shop, !0)}`,
    state: "",
    isOnline: !1
  });
}
var init_session_utils = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/session/session-utils.mjs"() {
    init_types6();
    init_http();
    init_shop_validator();
    init_logger();
    init_error();
    init_decode_session_token();
    init_session();
    init_cookies2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/create-session.mjs
function createSession2({ config, accessTokenResponse, shop, state }) {
  let associatedUser = accessTokenResponse.associated_user, isOnline = Boolean(associatedUser);
  logger(config).info("Creating new session", { shop, isOnline });
  let getSessionExpiration = (expires_in) => new Date(Date.now() + expires_in * 1e3), getOnlineSessionProperties = (responseBody) => {
    let { access_token, scope, ...rest } = responseBody;
    return {
      id: config.isEmbeddedApp ? getJwtSessionId(config)(shop, `${rest.associated_user.id}`) : crypto.randomUUID(),
      onlineAccessInfo: rest,
      expires: getSessionExpiration(rest.expires_in)
    };
  }, getOfflineSessionProperties = (responseBody) => {
    let { expires_in } = responseBody;
    return {
      id: getOfflineId(config)(shop),
      ...expires_in && { expires: getSessionExpiration(expires_in) }
    };
  };
  return new Session({
    shop,
    state,
    isOnline,
    accessToken: accessTokenResponse.access_token,
    scope: accessTokenResponse.scope,
    ...isOnline ? getOnlineSessionProperties(accessTokenResponse) : getOfflineSessionProperties(accessTokenResponse)
  });
}
var init_create_session = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/create-session.mjs"() {
    init_session();
    init_logger();
    init_session_utils();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/oauth.mjs
import { isbot as isbot2 } from "isbot";
function begin(config) {
  return async ({ shop, callbackPath, isOnline, ...adapterArgs }) => {
    throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
    let log2 = logger(config);
    log2.info("Beginning OAuth", { shop, isOnline, callbackPath });
    let request2 = await abstractConvertRequest(adapterArgs), response = await abstractConvertIncomingResponse(adapterArgs), userAgent = request2.headers["User-Agent"];
    if (Array.isArray(userAgent) && (userAgent = userAgent[0]), isbot2(userAgent))
      return logForBot({ request: request2, log: log2, func: "begin" }), response.statusCode = 410, abstractConvertResponse(response, adapterArgs);
    let cookies = new Cookies(request2, response, {
      keys: [config.apiSecretKey],
      secure: !0
    }), state = nonce();
    await cookies.setAndSign(STATE_COOKIE_NAME, state, {
      expires: new Date(Date.now() + 6e4),
      sameSite: "lax",
      secure: !0,
      path: callbackPath
    });
    let scopes = config.scopes ? config.scopes.toString() : "", query = {
      client_id: config.apiKey,
      scope: scopes,
      redirect_uri: `${config.hostScheme}://${config.hostName}${callbackPath}`,
      state,
      "grant_options[]": isOnline ? "per-user" : ""
    }, processedQuery = new ProcessedQuery();
    processedQuery.putAll(query);
    let redirectUrl = `https://${sanitizeShop(config)(shop, !0)}/admin/oauth/authorize${processedQuery.stringify()}`;
    return response.statusCode = 302, response.statusText = "Found", response.headers = {
      ...response.headers,
      ...cookies.response.headers,
      Location: redirectUrl
    }, log2.debug(`OAuth started, redirecting to ${redirectUrl}`, { shop, isOnline }), abstractConvertResponse(response, adapterArgs);
  };
}
function callback(config) {
  return async function({ ...adapterArgs }) {
    throwIfCustomStoreApp(config.isCustomStoreApp, "Cannot perform OAuth for private apps");
    let log2 = logger(config), request2 = await abstractConvertRequest(adapterArgs), query = new URL(request2.url, `${config.hostScheme}://${config.hostName}`).searchParams, shop = query.get("shop"), response = {}, userAgent = request2.headers["User-Agent"];
    if (Array.isArray(userAgent) && (userAgent = userAgent[0]), isbot2(userAgent))
      throw logForBot({ request: request2, log: log2, func: "callback" }), new BotActivityDetected("Invalid OAuth callback initiated by bot");
    log2.info("Completing OAuth", { shop });
    let cookies = new Cookies(request2, response, {
      keys: [config.apiSecretKey],
      secure: !0
    }), stateFromCookie = await cookies.getAndVerify(STATE_COOKIE_NAME);
    if (cookies.deleteCookie(STATE_COOKIE_NAME), !stateFromCookie)
      throw log2.error("Could not find OAuth cookie", { shop }), new CookieNotFound(`Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ${shop}`);
    let authQuery = Object.fromEntries(query.entries());
    if (!await validQuery({ config, query: authQuery, stateFromCookie }))
      throw log2.error("Invalid OAuth callback", { shop, stateFromCookie }), new InvalidOAuthError("Invalid OAuth callback.");
    log2.debug("OAuth request is valid, requesting access token", { shop });
    let body = {
      client_id: config.apiKey,
      client_secret: config.apiSecretKey,
      code: query.get("code")
    }, cleanShop = sanitizeShop(config)(query.get("shop"), !0), postResponse = await fetchRequestFactory(config)(`https://${cleanShop}/admin/oauth/access_token`, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": DataType.JSON,
        Accept: DataType.JSON
      }
    });
    postResponse.ok || throwFailedRequest(await postResponse.json(), !1, postResponse);
    let session = createSession2({
      accessTokenResponse: await postResponse.json(),
      shop: cleanShop,
      state: stateFromCookie,
      config
    });
    return config.isEmbeddedApp || await cookies.setAndSign(SESSION_COOKIE_NAME, session.id, {
      expires: session.expires,
      sameSite: "lax",
      secure: !0,
      path: "/"
    }), {
      headers: await abstractConvertHeaders(cookies.response.headers, adapterArgs),
      session
    };
  };
}
async function validQuery({ config, query, stateFromCookie }) {
  return await validateHmac(config)(query) && safeCompare(query.state, stateFromCookie);
}
function throwIfCustomStoreApp(isCustomStoreApp, message) {
  if (isCustomStoreApp)
    throw new PrivateAppError(message);
}
var logForBot, init_oauth = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/oauth.mjs"() {
    init_common();
    init_processed_query();
    init_error();
    init_hmac_validator();
    init_shop_validator();
    init_http();
    init_logger();
    init_types5();
    init_fetch_request();
    init_types6();
    init_nonce();
    init_safe_compare();
    init_create_session();
    init_cookies2();
    logForBot = ({ request: request2, log: log2, func }) => {
      log2.debug(`Possible bot request to auth ${func}: `, {
        userAgent: request2.headers["User-Agent"]
      });
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/get-embedded-app-url.mjs
function getEmbeddedAppUrl(config) {
  return async ({ ...adapterArgs }) => {
    let request2 = await abstractConvertRequest(adapterArgs);
    if (!request2)
      throw new MissingRequiredArgument("getEmbeddedAppUrl requires a request object argument");
    if (!request2.url)
      throw new InvalidRequestError("Request does not contain a URL");
    let host = new URL(request2.url, `https://${request2.headers.host}`).searchParams.get("host");
    if (typeof host != "string")
      throw new InvalidRequestError("Request does not contain a host query parameter");
    return buildEmbeddedAppUrl(config)(host);
  };
}
function buildEmbeddedAppUrl(config) {
  return (host) => (sanitizeHost()(host, !0), `https://${decodeHost(host)}/apps/${config.apiKey}`);
}
var init_get_embedded_app_url = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/get-embedded-app-url.mjs"() {
    init_error();
    init_http();
    init_shop_validator();
    init_decode_host();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/token-exchange.mjs
function tokenExchange(config) {
  return async ({ shop, sessionToken, requestedTokenType }) => {
    await decodeSessionToken(config)(sessionToken);
    let body = {
      client_id: config.apiKey,
      client_secret: config.apiSecretKey,
      grant_type: TokenExchangeGrantType,
      subject_token: sessionToken,
      subject_token_type: IdTokenType,
      requested_token_type: requestedTokenType
    }, cleanShop = sanitizeShop(config)(shop, !0), postResponse = await fetchRequestFactory(config)(`https://${cleanShop}/admin/oauth/access_token`, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": DataType.JSON,
        Accept: DataType.JSON
      }
    });
    return postResponse.ok || throwFailedRequest(await postResponse.json(), !1, postResponse), {
      session: createSession2({
        accessTokenResponse: await postResponse.json(),
        shop: cleanShop,
        // We need to keep this as an empty string as our template DB schemas have this required
        state: "",
        config
      })
    };
  };
}
var RequestedTokenType, TokenExchangeGrantType, IdTokenType, init_token_exchange = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/token-exchange.mjs"() {
    init_common();
    init_decode_session_token();
    init_shop_validator();
    init_types5();
    init_fetch_request();
    init_create_session();
    (function(RequestedTokenType2) {
      RequestedTokenType2.OnlineAccessToken = "urn:shopify:params:oauth:token-type:online-access-token", RequestedTokenType2.OfflineAccessToken = "urn:shopify:params:oauth:token-type:offline-access-token";
    })(RequestedTokenType || (RequestedTokenType = {}));
    TokenExchangeGrantType = "urn:ietf:params:oauth:grant-type:token-exchange", IdTokenType = "urn:ietf:params:oauth:token-type:id_token";
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/client-credentials.mjs
function clientCredentials(config) {
  return async ({ shop }) => {
    let cleanShop = sanitizeShop(config)(shop, !0), requestConfig = {
      method: "POST",
      body: JSON.stringify({
        client_id: config.apiKey,
        client_secret: config.apiSecretKey,
        grant_type: ClientCredentialsGrantType
      }),
      headers: {
        "Content-Type": DataType.JSON,
        Accept: DataType.JSON
      }
    }, postResponse = await fetchRequestFactory(config)(`https://${cleanShop}/admin/oauth/access_token`, requestConfig), responseData = await postResponse.json();
    return postResponse.ok || throwFailedRequest(responseData, !1, postResponse), {
      session: createSession2({
        accessTokenResponse: responseData,
        shop: cleanShop,
        // We need to keep this as an empty string as our template DB schemas have this required
        state: "",
        config
      })
    };
  };
}
var ClientCredentialsGrantType, init_client_credentials = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/oauth/client-credentials.mjs"() {
    init_common();
    init_types5();
    init_fetch_request();
    init_shop_validator();
    init_create_session();
    ClientCredentialsGrantType = "client_credentials";
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/auth/index.mjs
function shopifyAuth(config) {
  return {
    begin: begin(config),
    callback: callback(config),
    nonce,
    safeCompare,
    getEmbeddedAppUrl: getEmbeddedAppUrl(config),
    buildEmbeddedAppUrl: buildEmbeddedAppUrl(config),
    tokenExchange: tokenExchange(config),
    clientCredentials: clientCredentials(config)
  };
}
var init_auth = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/auth/index.mjs"() {
    init_oauth();
    init_nonce();
    init_safe_compare();
    init_get_embedded_app_url();
    init_token_exchange();
    init_client_credentials();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/session/index.mjs
function shopifySession(config) {
  return {
    customAppSession: customAppSession(config),
    getCurrentId: getCurrentSessionId(config),
    getOfflineId: getOfflineId(config),
    getJwtSessionId: getJwtSessionId(config),
    decodeSessionToken: decodeSessionToken(config)
  };
}
var init_session2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/session/index.mjs"() {
    init_decode_session_token();
    init_session_utils();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/version-compatible.mjs
function versionCompatible(config) {
  return (referenceVersion, currentVersion = config.apiVersion) => {
    if (currentVersion === ApiVersion.Unstable)
      return !0;
    let numericVersion = (version) => parseInt(version.replace("-", ""), 10), current = numericVersion(currentVersion), reference = numericVersion(referenceVersion);
    return current >= reference;
  };
}
function versionPriorTo(config) {
  return (referenceVersion, currentVersion = config.apiVersion) => !versionCompatible(config)(referenceVersion, currentVersion);
}
var init_version_compatible = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/version-compatible.mjs"() {
    init_types2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/utils/index.mjs
function shopifyUtils(config) {
  return {
    sanitizeShop: sanitizeShop(config),
    sanitizeHost: sanitizeHost(),
    validateHmac: validateHmac(config),
    versionCompatible: versionCompatible(config),
    versionPriorTo: versionPriorTo(config),
    shopAdminUrlToLegacyUrl,
    legacyUrlToShopAdminUrl
  };
}
var init_utils3 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/utils/index.mjs"() {
    init_shop_validator();
    init_hmac_validator();
    init_version_compatible();
    init_shop_admin_url_helper();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/types.mjs
var DeliveryMethod, WebhookOperation, WebhookValidationErrorReason, init_types7 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/types.mjs"() {
    init_types4();
    (function(DeliveryMethod2) {
      DeliveryMethod2.Http = "http", DeliveryMethod2.EventBridge = "eventbridge", DeliveryMethod2.PubSub = "pubsub";
    })(DeliveryMethod || (DeliveryMethod = {}));
    (function(WebhookOperation2) {
      WebhookOperation2.Create = "create", WebhookOperation2.Update = "update", WebhookOperation2.Delete = "delete";
    })(WebhookOperation || (WebhookOperation = {}));
    WebhookValidationErrorReason = {
      ...ValidationErrorReason,
      MissingHeaders: "missing_headers"
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/registry.mjs
function registry() {
  return {};
}
function topicForStorage(topic) {
  return topic.toUpperCase().replace(/\/|\./g, "_");
}
function addHandlers(config, webhookRegistry) {
  return function(handlersToAdd) {
    for (let [topic, handlers] of Object.entries(handlersToAdd)) {
      let topicKey = topicForStorage(topic);
      if (Array.isArray(handlers))
        for (let handler of handlers)
          mergeOrAddHandler(config, webhookRegistry, topicKey, handler);
      else
        mergeOrAddHandler(config, webhookRegistry, topicKey, handlers);
    }
  };
}
function getTopicsAdded(webhookRegistry) {
  return function() {
    return Object.keys(webhookRegistry);
  };
}
function getHandlers(webhookRegistry) {
  return function(topic) {
    return webhookRegistry[topicForStorage(topic)] || [];
  };
}
function handlerIdentifier(config, handler) {
  let prefix = handler.deliveryMethod;
  switch (handler.deliveryMethod) {
    case DeliveryMethod.Http:
      return `${prefix}_${addHostToCallbackUrl(config, handler.callbackUrl)}`;
    case DeliveryMethod.EventBridge:
      return `${prefix}_${handler.arn}`;
    case DeliveryMethod.PubSub:
      return `${prefix}_${handler.pubSubProject}:${handler.pubSubTopic}`;
    default:
      throw new InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
  }
}
function addHostToCallbackUrl(config, callbackUrl) {
  return callbackUrl.startsWith("/") ? `${config.hostScheme}://${config.hostName}${callbackUrl}` : callbackUrl;
}
function mergeOrAddHandler(config, webhookRegistry, topic, handler) {
  let log2 = logger(config);
  if (handler.includeFields?.sort(), handler.metafieldNamespaces?.sort(), !(topic in webhookRegistry)) {
    webhookRegistry[topic] = [handler];
    return;
  }
  let identifier = handlerIdentifier(config, handler);
  for (let index in webhookRegistry[topic]) {
    if (!Object.prototype.hasOwnProperty.call(webhookRegistry[topic], index))
      continue;
    let existingHandler = webhookRegistry[topic][index], existingIdentifier = handlerIdentifier(config, existingHandler);
    if (identifier === existingIdentifier)
      if (handler.deliveryMethod === DeliveryMethod.Http) {
        log2.info(`Detected multiple handlers for '${topic}', webhooks.process will call them sequentially`);
        break;
      } else
        throw new InvalidDeliveryMethodError(`Can only add multiple handlers for a topic when deliveryMethod is Http. Please be sure that you used addHandler method once after creating ShopifyApi instance in your app.  Invalid handler: ${JSON.stringify(handler)}`);
  }
  webhookRegistry[topic].push(handler);
}
var init_registry = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/registry.mjs"() {
    init_error();
    init_logger();
    init_types7();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/query-template.mjs
function queryTemplate(template, params) {
  let query = template;
  return Object.entries(params).forEach(([key, value]) => {
    query = query.replace(`{{${key}}}`, value);
  }), query;
}
var init_query_template = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/query-template.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/register.mjs
import "lossless-json";
function register(config, webhookRegistry) {
  return async function({ session }) {
    let log2 = logger(config);
    log2.info("Registering webhooks", { shop: session.shop });
    let registerReturn = Object.keys(webhookRegistry).reduce((acc, topic) => (acc[topic] = [], acc), {}), existingHandlers = await getExistingHandlers(config, session);
    log2.debug(`Existing topics: [${Object.keys(existingHandlers).join(", ")}]`, { shop: session.shop });
    for (let topic in webhookRegistry)
      Object.prototype.hasOwnProperty.call(webhookRegistry, topic) && (privacyTopics.includes(topic) || (registerReturn[topic] = await registerTopic({
        config,
        session,
        topic,
        existingHandlers: existingHandlers[topic] || [],
        handlers: getHandlers(webhookRegistry)(topic)
      }), delete existingHandlers[topic]));
    for (let topic in existingHandlers) {
      if (!Object.prototype.hasOwnProperty.call(existingHandlers, topic))
        continue;
      let GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session });
      registerReturn[topic] = await runMutations({
        config,
        client,
        topic,
        handlers: existingHandlers[topic],
        operation: WebhookOperation.Delete
      });
    }
    return registerReturn;
  };
}
async function getExistingHandlers(config, session) {
  let GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session }), existingHandlers = {}, hasNextPage, endCursor = null;
  do {
    let query = buildCheckQuery(endCursor), response = await client.request(query);
    response.data?.webhookSubscriptions?.edges.forEach((edge) => {
      let handler = buildHandlerFromNode(edge);
      existingHandlers[edge.node.topic] || (existingHandlers[edge.node.topic] = []), existingHandlers[edge.node.topic].push(handler);
    }), endCursor = response.data?.webhookSubscriptions?.pageInfo.endCursor, hasNextPage = response.data?.webhookSubscriptions?.pageInfo.hasNextPage;
  } while (hasNextPage);
  return existingHandlers;
}
function buildCheckQuery(endCursor) {
  return queryTemplate(TEMPLATE_GET_HANDLERS, {
    END_CURSOR: JSON.stringify(endCursor)
  });
}
function buildHandlerFromNode(edge) {
  let endpoint = edge.node.endpoint, handler;
  switch (endpoint.__typename) {
    case "WebhookHttpEndpoint":
      handler = {
        deliveryMethod: DeliveryMethod.Http,
        callbackUrl: endpoint.callbackUrl,
        // This is a dummy for now because we don't really care about it
        callback: async () => {
        }
      };
      break;
    case "WebhookEventBridgeEndpoint":
      handler = {
        deliveryMethod: DeliveryMethod.EventBridge,
        arn: endpoint.arn
      };
      break;
    case "WebhookPubSubEndpoint":
      handler = {
        deliveryMethod: DeliveryMethod.PubSub,
        pubSubProject: endpoint.pubSubProject,
        pubSubTopic: endpoint.pubSubTopic
      };
      break;
  }
  return handler.id = edge.node.id, handler.includeFields = edge.node.includeFields, handler.metafieldNamespaces = edge.node.metafieldNamespaces, handler.includeFields?.sort(), handler.metafieldNamespaces?.sort(), handler;
}
async function registerTopic({ config, session, topic, existingHandlers, handlers }) {
  let registerResults = [], { toCreate, toUpdate, toDelete } = categorizeHandlers(config, existingHandlers, handlers), GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session }), operation = WebhookOperation.Create;
  return registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toCreate })), operation = WebhookOperation.Update, registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toUpdate })), operation = WebhookOperation.Delete, registerResults = registerResults.concat(await runMutations({ config, client, topic, operation, handlers: toDelete })), registerResults;
}
function categorizeHandlers(config, existingHandlers, handlers) {
  let handlersByKey = handlers.reduce((acc, value) => (acc[handlerIdentifier(config, value)] = value, acc), {}), existingHandlersByKey = existingHandlers.reduce((acc, value) => (acc[handlerIdentifier(config, value)] = value, acc), {}), toCreate = { ...handlersByKey }, toUpdate = {}, toDelete = {};
  for (let existingKey in existingHandlersByKey) {
    if (!Object.prototype.hasOwnProperty.call(existingHandlersByKey, existingKey))
      continue;
    let existingHandler = existingHandlersByKey[existingKey], handler = handlersByKey[existingKey];
    existingKey in handlersByKey ? (delete toCreate[existingKey], areHandlerFieldsEqual(existingHandler, handler) || (toUpdate[existingKey] = handler, toUpdate[existingKey].id = existingHandler.id)) : toDelete[existingKey] = existingHandler;
  }
  return {
    toCreate: Object.values(toCreate),
    toUpdate: Object.values(toUpdate),
    toDelete: Object.values(toDelete)
  };
}
function areHandlerFieldsEqual(arr1, arr2) {
  let includeFieldsEqual = arraysEqual(arr1.includeFields || [], arr2.includeFields || []), metafieldNamespacesEqual = arraysEqual(arr1.metafieldNamespaces || [], arr2.metafieldNamespaces || []);
  return includeFieldsEqual && metafieldNamespacesEqual;
}
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return !1;
  for (let i = 0; i < arr1.length; i++)
    if (arr1[i] !== arr2[i])
      return !1;
  return !0;
}
async function runMutations({ config, client, topic, handlers, operation }) {
  let registerResults = [];
  for (let handler of handlers)
    registerResults.push(await runMutation({ config, client, topic, handler, operation }));
  return registerResults;
}
async function runMutation({ config, client, topic, handler, operation }) {
  let registerResult;
  logger(config).debug("Running webhook mutation", { topic, operation });
  try {
    let query = buildMutation(config, topic, handler, operation), result = await client.request(query);
    registerResult = {
      deliveryMethod: handler.deliveryMethod,
      success: isSuccess(result, handler, operation),
      result,
      operation
    };
  } catch (error) {
    if (error instanceof InvalidDeliveryMethodError)
      registerResult = {
        deliveryMethod: handler.deliveryMethod,
        success: !1,
        result: { message: error.message },
        operation
      };
    else
      throw error;
  }
  return registerResult;
}
function buildMutation(config, topic, handler, operation) {
  let params = {}, identifier;
  handler.id ? identifier = `id: "${handler.id}"` : identifier = `topic: ${topic}`;
  let mutationArguments = {
    MUTATION_NAME: getMutationName(handler, operation),
    IDENTIFIER: identifier,
    MUTATION_PARAMS: ""
  };
  if (operation !== WebhookOperation.Delete) {
    switch (handler.deliveryMethod) {
      case DeliveryMethod.Http:
        params.callbackUrl = `"${addHostToCallbackUrl(config, handler.callbackUrl)}"`;
        break;
      case DeliveryMethod.EventBridge:
        params.arn = `"${handler.arn}"`;
        break;
      case DeliveryMethod.PubSub:
        params.pubSubProject = `"${handler.pubSubProject}"`, params.pubSubTopic = `"${handler.pubSubTopic}"`;
        break;
      default:
        throw new InvalidDeliveryMethodError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
    }
    if (handler.includeFields && (params.includeFields = JSON.stringify(handler.includeFields)), handler.metafieldNamespaces && (params.metafieldNamespaces = JSON.stringify(handler.metafieldNamespaces)), handler.subTopic) {
      let subTopicString = `subTopic: "${handler.subTopic}",`;
      mutationArguments.MUTATION_PARAMS = subTopicString;
    }
    let paramsString = Object.entries(params).map(([key, value]) => `${key}: ${value}`).join(", ");
    mutationArguments.MUTATION_PARAMS += `webhookSubscription: {${paramsString}}`;
  }
  return queryTemplate(TEMPLATE_MUTATION, mutationArguments);
}
function getMutationName(handler, operation) {
  switch (operation) {
    case WebhookOperation.Create:
      return `${getEndpoint(handler)}Create`;
    case WebhookOperation.Update:
      return `${getEndpoint(handler)}Update`;
    case WebhookOperation.Delete:
      return "webhookSubscriptionDelete";
    default:
      throw new ShopifyError(`Unrecognized operation '${operation}'`);
  }
}
function getEndpoint(handler) {
  switch (handler.deliveryMethod) {
    case DeliveryMethod.Http:
      return "webhookSubscription";
    case DeliveryMethod.EventBridge:
      return "eventBridgeWebhookSubscription";
    case DeliveryMethod.PubSub:
      return "pubSubWebhookSubscription";
    default:
      throw new ShopifyError(`Unrecognized delivery method '${handler.deliveryMethod}'`);
  }
}
function isSuccess(result, handler, operation) {
  let mutationName = getMutationName(handler, operation);
  return Boolean(result.data && result.data[mutationName] && result.data[mutationName].userErrors.length === 0);
}
var TEMPLATE_GET_HANDLERS, TEMPLATE_MUTATION, init_register = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/register.mjs"() {
    init_client3();
    init_dist4();
    init_error();
    init_types2();
    init_logger();
    init_registry();
    init_query_template();
    init_types7();
    TEMPLATE_GET_HANDLERS = `query shopifyApiReadWebhookSubscriptions {
  webhookSubscriptions(
    first: 250,
    after: {{END_CURSOR}},
  ) {
    edges {
      node {
        id
        topic
        includeFields
        metafieldNamespaces
        endpoint {
          __typename
          ... on WebhookHttpEndpoint {
            callbackUrl
          }
          ... on WebhookEventBridgeEndpoint {
            arn
          }
          ... on WebhookPubSubEndpoint {
            pubSubProject
            pubSubTopic
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}`, TEMPLATE_MUTATION = `
  mutation shopifyApiCreateWebhookSubscription {
    {{MUTATION_NAME}}(
      {{IDENTIFIER}},
      {{MUTATION_PARAMS}}
    ) {
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/validate.mjs
function validateFactory(config) {
  return async function({ rawBody, ...adapterArgs }) {
    let request2 = await abstractConvertRequest(adapterArgs), validHmacResult = await validateHmacFromRequestFactory(config)({
      type: HmacValidationType.Webhook,
      rawBody,
      ...adapterArgs
    });
    return validHmacResult.valid ? checkWebhookHeaders(request2.headers) : (validHmacResult.reason === ValidationErrorReason.InvalidHmac && await logger(config).debug("Webhook HMAC validation failed. Please note that events manually triggered from a store's Notifications settings will fail this validation. To test this, please use the CLI or trigger the actual event in a development store."), validHmacResult);
  };
}
function checkWebhookHeaders(headers) {
  let missingHeaders = [], headerValues = Object.entries(HANDLER_PROPERTIES).reduce((acc, [property, headerName]) => {
    let headerValue = getHeader(headers, headerName);
    return headerValue ? acc[property] = headerValue : property in OPTIONAL_HANDLER_PROPERTIES || missingHeaders.push(headerName), acc;
  }, {});
  return missingHeaders.length ? {
    valid: !1,
    reason: WebhookValidationErrorReason.MissingHeaders,
    missingHeaders
  } : {
    valid: !0,
    ...headerValues,
    ...headerValues.subTopic ? { subTopic: headerValues.subTopic } : {},
    topic: topicForStorage(headerValues.topic)
  };
}
var OPTIONAL_HANDLER_PROPERTIES, HANDLER_PROPERTIES, init_validate = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/validate.mjs"() {
    init_logger();
    init_hmac_validator();
    init_types4();
    init_http();
    init_types2();
    init_types7();
    init_registry();
    init_headers2();
    OPTIONAL_HANDLER_PROPERTIES = {
      subTopic: ShopifyHeader.SubTopic
    }, HANDLER_PROPERTIES = {
      apiVersion: ShopifyHeader.ApiVersion,
      domain: ShopifyHeader.Domain,
      hmac: ShopifyHeader.Hmac,
      topic: ShopifyHeader.Topic,
      webhookId: ShopifyHeader.WebhookId,
      ...OPTIONAL_HANDLER_PROPERTIES
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/process.mjs
function process2(config, webhookRegistry) {
  return async function({ context, rawBody, ...adapterArgs }) {
    let response = {
      statusCode: StatusCode.Ok,
      statusText: STATUS_TEXT_LOOKUP[StatusCode.Ok],
      headers: {}
    };
    await logger(config).info("Receiving webhook request");
    let webhookCheck = await validateFactory(config)({
      rawBody,
      ...adapterArgs
    }), errorMessage = "Unknown error while handling webhook";
    if (webhookCheck.valid) {
      let handlerResult = await callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody, context);
      response.statusCode = handlerResult.statusCode, isOK(response) || (errorMessage = handlerResult.errorMessage || errorMessage);
    } else {
      let errorResult = await handleInvalidWebhook(config, webhookCheck);
      response.statusCode = errorResult.statusCode, response.statusText = STATUS_TEXT_LOOKUP[response.statusCode], errorMessage = errorResult.errorMessage;
    }
    let returnResponse = await abstractConvertResponse(response, adapterArgs);
    if (!isOK(response))
      throw new InvalidWebhookError({
        message: errorMessage,
        response: returnResponse
      });
    return Promise.resolve(returnResponse);
  };
}
async function callWebhookHandlers(config, webhookRegistry, webhookCheck, rawBody, context) {
  let log2 = logger(config), { hmac: _hmac, valid: _valid, ...loggingContext } = webhookCheck;
  await log2.debug("Webhook request is valid, looking for HTTP handlers to call", loggingContext);
  let handlers = webhookRegistry[webhookCheck.topic] || [], response = { statusCode: StatusCode.Ok }, found = !1;
  for (let handler of handlers)
    if (handler.deliveryMethod === DeliveryMethod.Http) {
      if (!handler.callback)
        throw response.statusCode = StatusCode.InternalServerError, response.errorMessage = "Cannot call webhooks.process with a webhook handler that doesn't have a callback", new MissingWebhookCallbackError({
          message: response.errorMessage,
          response
        });
      found = !0, await log2.debug("Found HTTP handler, triggering it", loggingContext);
      try {
        await handler.callback(webhookCheck.topic, webhookCheck.domain, rawBody, webhookCheck.webhookId, webhookCheck.apiVersion, ...webhookCheck?.subTopic ? webhookCheck.subTopic : "", context);
      } catch (error) {
        response.statusCode = StatusCode.InternalServerError, response.errorMessage = error.message;
      }
    }
  return found || (await log2.debug("No HTTP handlers found", loggingContext), response.statusCode = StatusCode.NotFound, response.errorMessage = `No HTTP webhooks registered for topic ${webhookCheck.topic}`), response;
}
async function handleInvalidWebhook(config, webhookCheck) {
  let response = {
    statusCode: StatusCode.InternalServerError,
    errorMessage: "Unknown error while handling webhook"
  };
  switch (webhookCheck.reason) {
    case WebhookValidationErrorReason.MissingHeaders:
      response.statusCode = StatusCode.BadRequest, response.errorMessage = `Missing one or more of the required HTTP headers to process webhooks: [${webhookCheck.missingHeaders.join(", ")}]`;
      break;
    case WebhookValidationErrorReason.MissingBody:
      response.statusCode = StatusCode.BadRequest, response.errorMessage = "No body was received when processing webhook";
      break;
    case WebhookValidationErrorReason.MissingHmac:
      response.statusCode = StatusCode.BadRequest, response.errorMessage = "Missing HMAC header in request";
      break;
    case WebhookValidationErrorReason.InvalidHmac:
      response.statusCode = StatusCode.Unauthorized, response.errorMessage = "Could not validate request HMAC";
      break;
  }
  return await logger(config).debug(`Webhook request is invalid, returning ${response.statusCode}: ${response.errorMessage}`), response;
}
var STATUS_TEXT_LOOKUP, init_process = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/process.mjs"() {
    init_types2();
    init_http();
    init_error();
    init_logger();
    init_types7();
    init_validate();
    STATUS_TEXT_LOOKUP = {
      [StatusCode.Ok]: "OK",
      [StatusCode.BadRequest]: "Bad Request",
      [StatusCode.Unauthorized]: "Unauthorized",
      [StatusCode.NotFound]: "Not Found",
      [StatusCode.InternalServerError]: "Internal Server Error"
    };
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/index.mjs
function shopifyWebhooks(config) {
  let webhookRegistry = registry();
  return {
    addHandlers: addHandlers(config, webhookRegistry),
    getTopicsAdded: getTopicsAdded(webhookRegistry),
    getHandlers: getHandlers(webhookRegistry),
    register: register(config, webhookRegistry),
    process: process2(config, webhookRegistry),
    validate: validateFactory(config)
  };
}
var init_webhooks = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/webhooks/index.mjs"() {
    init_registry();
    init_register();
    init_process();
    init_validate();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/types.mjs
var APP_SUBSCRIPTION_FRAGMENT, init_types8 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/types.mjs"() {
    APP_SUBSCRIPTION_FRAGMENT = `
  fragment AppSubscriptionFragment on AppSubscription {
    id
    name
    test
    status
    trialDays
    createdAt
    currentPeriodEnd
    returnUrl
    lineItems {
      id
      plan {
        pricingDetails {
          ... on AppRecurringPricing {
            price {
              amount
              currencyCode
            }
            interval
            discount {
              durationLimitInIntervals
              remainingDurationInIntervals
              priceAfterDiscount {
                amount
              }
              value {
                ... on AppSubscriptionDiscountAmount {
                  amount {
                    amount
                    currencyCode
                  }
                }
                ... on AppSubscriptionDiscountPercentage {
                  percentage
                }
              }
            }
          }
          ... on AppUsagePricing {
            balanceUsed {
              amount
              currencyCode
            }
            cappedAmount {
              amount
              currencyCode
            }
            terms
          }
        }
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/utils.mjs
function convertMoneyAmount(data3) {
  return data3 && (convertAppUsagePricingMoney(data3), convertAppRecurringPricingMoney(data3), convertAppDiscountMoney(data3), data3);
}
function convertAppRecurringPricingMoney(data3) {
  data3 && data3.price?.amount && typeof data3.price.amount == "string" && (data3.price.amount = parseFloat(data3.price.amount));
}
function convertAppDiscountMoney(data3) {
  data3 && (data3.discount?.priceAfterDiscount?.amount && typeof data3.discount.priceAfterDiscount.amount == "string" && (data3.discount.priceAfterDiscount.amount = parseFloat(data3.discount.priceAfterDiscount.amount)), data3.discount?.value?.amount?.amount && typeof data3.discount.value.amount.amount == "string" && (data3.discount.value.amount.amount = parseFloat(data3.discount.value.amount.amount)));
}
function convertAppUsagePricingMoney(data3) {
  data3 && (data3.balanceUsed?.amount && typeof data3.balanceUsed.amount == "string" && (data3.balanceUsed.amount = parseFloat(data3.balanceUsed.amount)), data3.cappedAmount?.amount && typeof data3.cappedAmount.amount == "string" && (data3.cappedAmount.amount = parseFloat(data3.cappedAmount.amount)));
}
function convertLineItems(lineItems) {
  return lineItems.map((item) => (item.plan?.pricingDetails && (item.plan.pricingDetails = convertMoneyAmount(item.plan.pricingDetails)), item));
}
var init_utils4 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/utils.mjs"() {
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/check.mjs
import "lossless-json";
import "compare-versions";
function check(config) {
  return async function(params) {
    if (!config.future?.unstable_managedPricingSupport && !config.billing)
      throw new BillingError({
        message: "Attempted to look for purchases without billing configs",
        errorData: []
      });
    let { session, isTest = !0, plans } = params, returnObject = params.returnObject ?? !1, GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session }), payments = await assessPayments({ client, isTest, plans });
    return config.future?.unstable_managedPricingSupport || returnObject ? payments : payments.hasActivePayment;
  };
}
async function assessPayments({ client, isTest, plans }) {
  let returnValue = {
    hasActivePayment: !1,
    oneTimePurchases: [],
    appSubscriptions: []
  }, installation, endCursor = null;
  do
    installation = (await client.request(HAS_PAYMENTS_QUERY, { variables: { endCursor } })).data?.currentAppInstallation, installation.activeSubscriptions.forEach((subscription) => {
      subscriptionMeetsCriteria({ subscription, isTest, plans }) && (returnValue.hasActivePayment = !0, subscription.lineItems && (subscription.lineItems = convertLineItems(subscription.lineItems)), returnValue.appSubscriptions.push(subscription));
    }), installation.oneTimePurchases.edges.forEach(({ node: purchase }) => {
      purchaseMeetsCriteria({ purchase, isTest, plans }) && (returnValue.hasActivePayment = !0, returnValue.oneTimePurchases.push(purchase));
    }), endCursor = installation.oneTimePurchases.pageInfo.endCursor;
  while (installation?.oneTimePurchases.pageInfo.hasNextPage);
  return returnValue;
}
function subscriptionMeetsCriteria({ subscription, isTest, plans }) {
  return (typeof plans > "u" || plans.includes(subscription.name)) && (isTest || !subscription.test);
}
function purchaseMeetsCriteria({ purchase, isTest, plans }) {
  return (typeof plans > "u" || plans.includes(purchase.name)) && (isTest || !purchase.test) && purchase.status === "ACTIVE";
}
var HAS_PAYMENTS_QUERY, init_check = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/check.mjs"() {
    init_client3();
    init_dist4();
    init_error();
    init_types8();
    init_utils4();
    HAS_PAYMENTS_QUERY = `
  ${APP_SUBSCRIPTION_FRAGMENT}
  query appSubscription($endCursor: String) {
    currentAppInstallation {
      activeSubscriptions {
        ...AppSubscriptionFragment
      }
      oneTimePurchases(first: 250, sortKey: CREATED_AT, after: $endCursor) {
        edges {
          node {
            id
            name
            test
            status
          }
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/request.mjs
import "lossless-json";
import "compare-versions";
function request(config) {
  return async function({ session, plan, isTest = !0, returnUrl: returnUrlParam, returnObject = !1, ...overrides }) {
    if (!config.billing || !config.billing[plan])
      throw new BillingError({
        message: `Could not find plan ${plan} in billing settings`,
        errorData: []
      });
    let billingConfig = {
      ...config.billing[plan]
    }, filteredOverrides = Object.fromEntries(Object.entries(overrides).filter(([_key, value]) => value !== void 0)), cleanShopName = session.shop.replace(".myshopify.com", ""), embeddedAppUrl = buildEmbeddedAppUrl(config)(hashString(`admin.shopify.com/store/${cleanShopName}`, HashFormat.Base64)), appUrl = `${config.hostScheme}://${config.hostName}?shop=${session.shop}`, returnUrl = returnUrlParam || (config.isEmbeddedApp ? embeddedAppUrl : appUrl), GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session });
    function isLineItemPlan(billingConfig2) {
      return "lineItems" in billingConfig2;
    }
    function isOneTimePlan(billingConfig2) {
      return billingConfig2.interval === BillingInterval.OneTime;
    }
    let data3;
    if (isLineItemPlan(billingConfig)) {
      let mergedBillingConfigs = mergeBillingConfigs(billingConfig, filteredOverrides);
      data3 = (await requestSubscriptionPayment({
        billingConfig: mergedBillingConfigs,
        plan,
        client,
        returnUrl,
        isTest
      })).appSubscriptionCreate;
    } else if (isOneTimePlan(billingConfig))
      data3 = (await requestSinglePayment({
        billingConfig: { ...billingConfig, ...filteredOverrides },
        plan,
        client,
        returnUrl,
        isTest
      })).appPurchaseOneTimeCreate;
    else
      throw new BillingError({
        message: `Invalid billing configuration for plan ${plan}. Must be either a one-time plan or a subscription plan with line items.`,
        errorData: []
      });
    if (data3.userErrors?.length)
      throw new BillingError({
        message: "Error while billing the store",
        errorData: data3.userErrors
      });
    return returnObject ? data3 : data3.confirmationUrl;
  };
}
async function requestSubscriptionPayment({ billingConfig, plan, client, returnUrl, isTest }) {
  let lineItems = billingConfig.lineItems.map((item) => {
    if (item.interval === BillingInterval.Every30Days || item.interval === BillingInterval.Annual) {
      let appRecurringPricingDetails = {
        interval: item.interval,
        price: {
          amount: item.amount,
          currencyCode: item.currencyCode
        }
      };
      return item.discount && (appRecurringPricingDetails.discount = {
        durationLimitInIntervals: item.discount.durationLimitInIntervals,
        value: {
          amount: item.discount.value.amount,
          percentage: item.discount.value.percentage
        }
      }), {
        plan: {
          appRecurringPricingDetails
        }
      };
    } else {
      if (item.interval === BillingInterval.Usage)
        return {
          plan: {
            appUsagePricingDetails: {
              terms: item.terms,
              cappedAmount: {
                amount: item.amount,
                currencyCode: item.currencyCode
              }
            }
          }
        };
      throw new BillingError({
        message: "Invalid interval provided",
        errorData: [item]
      });
    }
  }), mutationResponse = await client.request(RECURRING_PURCHASE_MUTATION, {
    variables: {
      name: plan,
      trialDays: billingConfig.trialDays,
      replacementBehavior: billingConfig.replacementBehavior,
      returnUrl,
      test: isTest,
      lineItems
    }
  });
  if (mutationResponse.errors)
    throw new BillingError({
      message: "Error while billing the store",
      errorData: mutationResponse.errors
    });
  return mutationResponse.data;
}
async function requestSinglePayment({ billingConfig, plan, client, returnUrl, isTest }) {
  let mutationResponse = await client.request(ONE_TIME_PURCHASE_MUTATION, {
    variables: {
      name: plan,
      returnUrl,
      test: isTest,
      price: {
        amount: billingConfig.amount,
        currencyCode: billingConfig.currencyCode
      }
    }
  });
  if (mutationResponse.errors)
    throw new BillingError({
      message: "Error while billing the store",
      errorData: mutationResponse.errors
    });
  return mutationResponse.data;
}
function mergeBillingConfigs(billingConfig, overrides) {
  let mergedConfig = { ...billingConfig, ...overrides }, mergedLineItems = [];
  if (billingConfig.lineItems && overrides.lineItems) {
    for (let i of billingConfig.lineItems) {
      let found = !1;
      for (let j of overrides.lineItems)
        if (i.interval === j.interval) {
          mergedLineItems.push({ ...i, ...j }), found = !0;
          break;
        }
      found || mergedLineItems.push(i);
    }
    mergedConfig.lineItems = mergedLineItems;
  }
  return mergedConfig;
}
var RECURRING_PURCHASE_MUTATION, ONE_TIME_PURCHASE_MUTATION, init_request = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/request.mjs"() {
    init_types2();
    init_error();
    init_get_embedded_app_url();
    init_client3();
    init_dist4();
    init_types();
    init_utils();
    init_types8();
    RECURRING_PURCHASE_MUTATION = `
  ${APP_SUBSCRIPTION_FRAGMENT}
  mutation AppSubscriptionCreate(
    $name: String!
    $returnUrl: URL!
    $test: Boolean
    $trialDays: Int
    $replacementBehavior: AppSubscriptionReplacementBehavior
    $lineItems: [AppSubscriptionLineItemInput!]!
  ) {
    appSubscriptionCreate(
      name: $name
      returnUrl: $returnUrl
      test: $test
      trialDays: $trialDays
      replacementBehavior: $replacementBehavior
      lineItems: $lineItems
    ) {
      appSubscription {
        ...AppSubscriptionFragment
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`, ONE_TIME_PURCHASE_MUTATION = `
  mutation test(
    $name: String!
    $price: MoneyInput!
    $returnUrl: URL!
    $test: Boolean
  ) {
    appPurchaseOneTimeCreate(
      name: $name
      price: $price
      returnUrl: $returnUrl
      test: $test
    ) {
      appPurchaseOneTime {
        id
        name
        test
      }
      confirmationUrl
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/cancel.mjs
import "lossless-json";
import "compare-versions";
function cancel(config) {
  return async function(subscriptionInfo) {
    let { session, subscriptionId, prorate = !0 } = subscriptionInfo, GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session });
    try {
      let response = await client.request(CANCEL_MUTATION, {
        variables: { id: subscriptionId, prorate }
      });
      if (response.data?.appSubscriptionCancel?.userErrors.length)
        throw new BillingError({
          message: "Error while canceling a subscription",
          errorData: response.data?.appSubscriptionCancel?.userErrors
        });
      return response.data?.appSubscriptionCancel?.appSubscription;
    } catch (error) {
      throw error instanceof GraphqlQueryError ? new BillingError({
        message: error.message,
        errorData: error.response?.errors
      }) : error;
    }
  };
}
var CANCEL_MUTATION, init_cancel = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/cancel.mjs"() {
    init_client3();
    init_dist4();
    init_error();
    init_types8();
    CANCEL_MUTATION = `
  ${APP_SUBSCRIPTION_FRAGMENT}
  mutation appSubscriptionCancel($id: ID!, $prorate: Boolean) {
    appSubscriptionCancel(id: $id, prorate: $prorate) {
      appSubscription {
        ...AppSubscriptionFragment
      }
      userErrors {
        field
        message
      }
    }
  }
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/subscriptions.mjs
import "lossless-json";
import "compare-versions";
function subscriptions(config) {
  return async function({ session }) {
    if (!config.future?.unstable_managedPricingSupport && !config.billing)
      throw new BillingError({
        message: "Attempted to look for purchases without billing configs",
        errorData: []
      });
    let GraphqlClient2 = graphqlClientClass({ config }), response = await new GraphqlClient2({ session }).request(SUBSCRIPTION_QUERY);
    if (!response.data?.currentAppInstallation?.activeSubscriptions)
      return { activeSubscriptions: [] };
    let activeSubscriptions = response.data.currentAppInstallation.activeSubscriptions;
    return activeSubscriptions.forEach((subscription) => {
      subscription.lineItems && (subscription.lineItems = convertLineItems(subscription.lineItems));
    }), {
      activeSubscriptions
    };
  };
}
var SUBSCRIPTION_QUERY, init_subscriptions = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/subscriptions.mjs"() {
    init_error();
    init_client3();
    init_dist4();
    init_types8();
    init_utils4();
    SUBSCRIPTION_QUERY = `
${APP_SUBSCRIPTION_FRAGMENT}
query appSubscription {
  currentAppInstallation {
    activeSubscriptions {
      ...AppSubscriptionFragment
    }
  }
}
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/create-usage-record.mjs
import "lossless-json";
import "compare-versions";
function createUsageRecord(config) {
  return async function(usageRecordInfo) {
    let { session, subscriptionLineItemId, description, price, idempotencyKey, isTest = !0 } = usageRecordInfo, GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session }), usageSubscriptionLineItemId = subscriptionLineItemId || await getUsageRecordSubscriptionLineItemId({ client, isTest }), variables = {
      description,
      price,
      subscriptionLineItemId: usageSubscriptionLineItemId
    };
    idempotencyKey && (variables.idempotencyKey = idempotencyKey);
    try {
      let response = await client.request(CREATE_USAGE_RECORD_MUTATION, {
        variables
      });
      if (response.data?.appUsageRecordCreate?.userErrors.length)
        throw new BillingError({
          message: "Error while creating a usage record",
          errorData: response.data?.appUsageRecordCreate?.userErrors
        });
      let appUsageRecord = response.data?.appUsageRecordCreate?.appUsageRecord;
      return convertAppRecurringPricingMoney(appUsageRecord.price), convertAppUsagePricingMoney(appUsageRecord.subscriptionLineItem.plan.pricingDetails), appUsageRecord;
    } catch (error) {
      throw error instanceof GraphqlQueryError ? new BillingError({
        message: error.message,
        errorData: error.response?.errors
      }) : error;
    }
  };
}
async function getUsageRecordSubscriptionLineItemId({ client, isTest }) {
  let payments = await assessPayments({ client, isTest });
  if (!payments.hasActivePayment)
    throw new BillingError({
      message: "No active payment found",
      errorData: []
    });
  if (!payments.appSubscriptions.length)
    throw new BillingError({
      message: "No active subscriptions found",
      errorData: []
    });
  if (payments.appSubscriptions)
    return getUsageLineItemId(payments.appSubscriptions);
  throw new BillingError({
    message: "Unable to find active subscription line item",
    errorData: []
  });
}
function getUsageLineItemId(subscriptions2) {
  for (let subscription of subscriptions2)
    if (subscription.status === "ACTIVE" && subscription.lineItems) {
      for (let lineItem of subscription.lineItems)
        if ("balanceUsed" in lineItem.plan.pricingDetails)
          return lineItem.id;
    }
  throw new BillingError({
    message: "No active usage subscription found",
    errorData: []
  });
}
var CREATE_USAGE_RECORD_MUTATION, init_create_usage_record = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/create-usage-record.mjs"() {
    init_error();
    init_client3();
    init_dist4();
    init_check();
    init_utils4();
    CREATE_USAGE_RECORD_MUTATION = `
mutation appUsageRecordCreate($description: String!, $price: MoneyInput!, $subscriptionLineItemId: ID!) {
  appUsageRecordCreate(description: $description, price: $price, subscriptionLineItemId: $subscriptionLineItemId) {
    userErrors {
      field
      message
    }
    appUsageRecord {
      id
      description
      idempotencyKey
      price {
        amount
        currencyCode
      }
      subscriptionLineItem {
        id
        plan {
          pricingDetails {
            ... on AppUsagePricing {
              balanceUsed {
                amount
                currencyCode
              }
              cappedAmount {
                amount
                currencyCode
              }
              terms
            }
          }
        }
      }
    }
  }
}
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/update-usage-subscription-capped-amount.mjs
import "lossless-json";
import "compare-versions";
function updateUsageCappedAmount(config) {
  return async function(params) {
    if (!config.billing)
      throw new BillingError({
        message: "Attempted to update line item without billing configs",
        errorData: []
      });
    let { session, subscriptionLineItemId, cappedAmount: { amount, currencyCode } } = params, GraphqlClient2 = graphqlClientClass({ config }), client = new GraphqlClient2({ session });
    try {
      let response = await client.request(UPDATE_USAGE_CAPPED_AMOUNT_MUTATION, {
        variables: {
          id: subscriptionLineItemId,
          cappedAmount: {
            amount,
            currencyCode
          }
        }
      });
      if (response.data?.appSubscriptionLineItemUpdate?.userErrors.length)
        throw new BillingError({
          message: "Error while updating usage subscription capped amount",
          errorData: response.data?.appSubscriptionLineItemUpdate?.userErrors
        });
      let appSubscription = response.data?.appSubscriptionLineItemUpdate?.appSubscription;
      return appSubscription && appSubscription.lineItems && (appSubscription.lineItems = convertLineItems(appSubscription.lineItems)), {
        confirmationUrl: response.data?.appSubscriptionLineItemUpdate?.confirmationUrl,
        appSubscription
      };
    } catch (error) {
      throw error instanceof GraphqlQueryError ? new BillingError({
        message: error.message,
        errorData: error.response?.errors
      }) : error;
    }
  };
}
var UPDATE_USAGE_CAPPED_AMOUNT_MUTATION, init_update_usage_subscription_capped_amount = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/update-usage-subscription-capped-amount.mjs"() {
    init_error();
    init_client3();
    init_dist4();
    init_types8();
    init_utils4();
    UPDATE_USAGE_CAPPED_AMOUNT_MUTATION = `
${APP_SUBSCRIPTION_FRAGMENT}
mutation appSubscriptionLineItemUpdate($cappedAmount: MoneyInput!, $id: ID!) {
  appSubscriptionLineItemUpdate(cappedAmount: $cappedAmount, id: $id) {
    userErrors {
      field
      message
    }
    confirmationUrl
    appSubscription {
      ...AppSubscriptionFragment
    }
  }
}
`;
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/billing/index.mjs
function shopifyBilling(config) {
  return {
    check: check(config),
    request: request(config),
    cancel: cancel(config),
    subscriptions: subscriptions(config),
    createUsageRecord: createUsageRecord(config),
    updateUsageCappedAmount: updateUsageCappedAmount(config)
  };
}
var init_billing = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/billing/index.mjs"() {
    init_check();
    init_request();
    init_cancel();
    init_subscriptions();
    init_create_usage_record();
    init_update_usage_subscription_capped_amount();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/flow/validate.mjs
function validateFactory2(config) {
  return async function({ rawBody, ...adapterArgs }) {
    return validateHmacFromRequestFactory(config)({
      type: HmacValidationType.Flow,
      rawBody,
      ...adapterArgs
    });
  };
}
var init_validate2 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/flow/validate.mjs"() {
    init_types4();
    init_hmac_validator();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/flow/index.mjs
function shopifyFlow(config) {
  return {
    validate: validateFactory2(config)
  };
}
var init_flow = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/flow/index.mjs"() {
    init_validate2();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/fulfillment-service/validate.mjs
function validateFactory3(config) {
  return async function({ rawBody, ...adapterArgs }) {
    return validateHmacFromRequestFactory(config)({
      type: HmacValidationType.FulfillmentService,
      rawBody,
      ...adapterArgs
    });
  };
}
var init_validate3 = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/fulfillment-service/validate.mjs"() {
    init_hmac_validator();
    init_types4();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/fulfillment-service/index.mjs
function fulfillmentService(config) {
  return {
    validate: validateFactory3(config)
  };
}
var init_fulfillment_service = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/fulfillment-service/index.mjs"() {
    init_validate3();
  }
});

// node_modules/@shopify/shopify-api/dist/esm/lib/index.mjs
function shopifyApi({ future: future2, restResources, ...config }) {
  let libConfig = { ...config, future: future2, restResources }, validatedConfig = validateConfig(libConfig), shopify2 = {
    config: validatedConfig,
    clients: clientClasses(validatedConfig),
    auth: shopifyAuth(validatedConfig),
    session: shopifySession(validatedConfig),
    utils: shopifyUtils(validatedConfig),
    webhooks: shopifyWebhooks(validatedConfig),
    billing: shopifyBilling(validatedConfig),
    flow: shopifyFlow(validatedConfig),
    fulfillmentService: fulfillmentService(validatedConfig),
    logger: logger(validatedConfig),
    rest: {}
  };
  return restResources && (shopify2.rest = loadRestResources({
    resources: restResources,
    config: validatedConfig,
    RestClient: restClientClass({ config: validatedConfig })
  })), shopify2.logger.info(`version ${SHOPIFY_API_LIBRARY_VERSION}, environment ${abstractRuntimeString()}`).catch((err) => console.log(err)), logDisabledFutureFlags(validatedConfig, shopify2.logger), shopify2;
}
var init_lib = __esm({
  "node_modules/@shopify/shopify-api/dist/esm/lib/index.mjs"() {
    init_load_rest_resources();
    init_runtime_string();
    init_flags();
    init_config();
    init_clients();
    init_auth();
    init_session2();
    init_utils3();
    init_webhooks();
    init_billing();
    init_logger();
    init_version();
    init_client4();
    init_flow();
    init_fulfillment_service();
    init_error();
    init_session();
    init_types2();
    init_scopes();
    init_token_exchange();
    init_types7();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/types.mjs
var AppDistribution, LoginErrorType, init_types9 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/types.mjs"() {
    (function(AppDistribution2) {
      AppDistribution2.AppStore = "app_store", AppDistribution2.SingleMerchant = "single_merchant", AppDistribution2.ShopifyAdmin = "shopify_admin";
    })(AppDistribution || (AppDistribution = {}));
    (function(LoginErrorType2) {
      LoginErrorType2.MissingShop = "MISSING_SHOP", LoginErrorType2.InvalidShop = "INVALID_SHOP";
    })(LoginErrorType || (LoginErrorType = {}));
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/headers.mjs
var init_headers3 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/headers.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/error.mjs
var import_jsx_runtime3, init_error2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/error.mjs"() {
    import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/index.mjs
var init_boundary = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/boundary/index.mjs"() {
    init_headers3();
    init_error2();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/version.mjs
var SHOPIFY_REMIX_LIBRARY_VERSION, init_version2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/version.mjs"() {
    SHOPIFY_REMIX_LIBRARY_VERSION = "4.0.2";
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/webhooks/register.mjs
function registerWebhooksFactory({ api, logger: logger2 }) {
  return async function({ session }) {
    return api.webhooks.register({ session }).then((response) => (Object.entries(response).forEach(([topic, topicResults]) => {
      topicResults.forEach(({ success, ...rest }) => {
        success ? logger2.debug("Registered webhook", {
          topic,
          shop: session.shop,
          operation: rest.operation
        }) : logger2.error("Failed to register webhook", {
          topic,
          shop: session.shop,
          result: JSON.stringify(rest.result)
        });
      });
    }), response)).catch((error) => {
      if ((error.body?.errors?.graphQLErrors || []).find(({ extensions: { code } }) => code === "THROTTLED"))
        logger2.error("Failed to register webhooks", {
          shop: session.shop,
          error: JSON.stringify(error)
        });
      else
        throw error;
    });
  };
}
var init_register2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/webhooks/register.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/const.mjs
var APP_BRIDGE_URL, REAUTH_URL_HEADER, RETRY_INVALID_SESSION_HEADER, init_const = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/const.mjs"() {
    APP_BRIDGE_URL = "https://cdn.shopify.com/shopifycloud/app-bridge.js", REAUTH_URL_HEADER = "X-Shopify-API-Request-Failure-Reauthorize-Url", RETRY_INVALID_SESSION_HEADER = {
      "X-Shopify-Retry-Invalid-Session-Request": "1"
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/ensure-cors-headers.mjs
function ensureCORSHeadersFactory(params, request2, corsHeaders = []) {
  let { logger: logger2, config } = params;
  return function(response) {
    let origin = request2.headers.get("Origin");
    if (origin && origin !== config.appUrl) {
      logger2.debug("Request comes from a different origin, adding CORS headers");
      let corsHeadersSet = /* @__PURE__ */ new Set([
        "Authorization",
        "Content-Type",
        ...corsHeaders
      ]);
      response.headers.set("Access-Control-Allow-Origin", "*"), response.headers.set("Access-Control-Allow-Headers", [...corsHeadersSet].join(", ")), response.headers.set("Access-Control-Expose-Headers", REAUTH_URL_HEADER);
    }
    return response;
  };
}
var init_ensure_cors_headers = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/ensure-cors-headers.mjs"() {
    init_const();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-bounce-page.mjs
var redirectToBouncePage, init_redirect_to_bounce_page = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-bounce-page.mjs"() {
    init_esm();
    redirectToBouncePage = (params, url) => {
      let { config } = params, searchParams = url.searchParams;
      throw searchParams.delete("id_token"), searchParams.set("shopify-reload", `${config.appUrl}${url.pathname}?${searchParams.toString()}`), redirect3(`${config.auth.patchSessionTokenPath}?${searchParams.toString()}`);
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/respond-to-invalid-session-token.mjs
function respondToInvalidSessionToken({ params, request: request2, retryRequest = !1 }) {
  let { api, logger: logger2, config } = params;
  if (!request2.headers.get("authorization"))
    return redirectToBouncePage({ config }, new URL(request2.url));
  throw new Response(void 0, {
    status: 401,
    statusText: "Unauthorized",
    headers: retryRequest ? RETRY_INVALID_SESSION_HEADER : {}
  });
}
var init_respond_to_invalid_session_token = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/respond-to-invalid-session-token.mjs"() {
    init_redirect_to_bounce_page();
    init_const();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/get-shop-from-request.mjs
function getShopFromRequest(request2) {
  return new URL(request2.url).searchParams.get("shop");
}
var init_get_shop_from_request = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/get-shop-from-request.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/validate-session-token.mjs
async function validateSessionToken(params, request2, token, { checkAudience = !0, retryRequest = !0 } = {}) {
  let { api, logger: logger2 } = params, shop = getShopFromRequest(request2);
  logger2.debug("Validating session token", { shop });
  try {
    let payload = await api.session.decodeSessionToken(token, {
      checkAudience
    });
    return logger2.debug("Session token is valid - validated", {
      shop,
      payload: JSON.stringify(payload)
    }), payload;
  } catch (error) {
    throw logger2.debug(`Failed to validate session token: ${error.message}`, {
      shop
    }), respondToInvalidSessionToken({ params, request: request2, retryRequest });
  }
}
var init_validate_session_token = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/validate-session-token.mjs"() {
    init_respond_to_invalid_session_token();
    init_get_shop_from_request();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/get-session-token-header.mjs
function getSessionTokenHeader(request2) {
  return request2.headers.get("authorization")?.replace("Bearer ", "");
}
function getSessionTokenFromUrlParam(request2) {
  return new URL(request2.url).searchParams.get(SESSION_TOKEN_PARAM);
}
var SESSION_TOKEN_PARAM, init_get_session_token_header = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/get-session-token-header.mjs"() {
    SESSION_TOKEN_PARAM = "id_token";
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/reject-bot-request.mjs
import { isbot as isbot3 } from "isbot";
function respondToBotRequest({ logger: logger2 }, request2) {
  let userAgent = request2.headers.get("User-Agent") ?? "";
  if (SHOPIFY_USER_AGENTS.some((agent) => agent.test(userAgent))) {
    logger2.debug("Request is from a Shopify agent, allow");
    return;
  }
  if (isbot3(userAgent))
    throw logger2.debug("Request is from a bot, skipping auth"), new Response(void 0, { status: 410, statusText: "Gone" });
}
var SHOPIFY_POS_USER_AGENT, SHOPIFY_MOBILE_USER_AGENT, SHOPIFY_USER_AGENTS, init_reject_bot_request = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/reject-bot-request.mjs"() {
    SHOPIFY_POS_USER_AGENT = /Shopify POS\//, SHOPIFY_MOBILE_USER_AGENT = /Shopify Mobile\//, SHOPIFY_USER_AGENTS = [SHOPIFY_POS_USER_AGENT, SHOPIFY_MOBILE_USER_AGENT];
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/respond-to-options-request.mjs
function respondToOptionsRequest(params, request2, corsHeaders) {
  if (request2.method === "OPTIONS")
    throw ensureCORSHeadersFactory(params, request2, corsHeaders)(new Response(null, {
      status: 204,
      headers: {
        "Access-Control-Max-Age": "7200"
      }
    }));
}
var init_respond_to_options_request = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/respond-to-options-request.mjs"() {
    init_ensure_cors_headers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/begin-auth.mjs
async function beginAuth(params, request2, isOnline, shop) {
  let { api, config } = params;
  throw await api.auth.begin({
    shop,
    callbackPath: config.auth.callbackPath,
    isOnline,
    rawRequest: request2
  });
}
var init_begin_auth = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/begin-auth.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-with-exitiframe.mjs
function redirectWithExitIframe(params, request2, shop) {
  let { api, config } = params, queryParams = new URL(request2.url).searchParams, host = api.utils.sanitizeHost(queryParams.get("host"));
  queryParams.set("shop", shop);
  let destination = `${config.auth.path}?shop=${shop}`;
  throw host && (queryParams.set("host", host), destination = `${destination}&host=${host}`), queryParams.set("exitIframe", destination), redirect3(`${config.auth.exitIframePath}?${queryParams.toString()}`);
}
var init_redirect_with_exitiframe = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-with-exitiframe.mjs"() {
    init_esm();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-with-app-bridge-headers.mjs
function redirectWithAppBridgeHeaders(redirectUri) {
  throw new Response(void 0, {
    status: 401,
    statusText: "Unauthorized",
    headers: getAppBridgeHeaders(redirectUri)
  });
}
function getAppBridgeHeaders(url) {
  return new Headers({ [REAUTH_URL_HEADER]: url });
}
var init_redirect_with_app_bridge_headers = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-with-app-bridge-headers.mjs"() {
    init_const();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-auth-page.mjs
async function redirectToAuthPage(params, request2, shop, isOnline = !1) {
  let { config } = params, isEmbeddedRequest2 = new URL(request2.url).searchParams.get("embedded") === "1";
  if (request2.headers.get("authorization")) {
    let redirectUri = new URL(config.auth.path, config.appUrl);
    redirectUri.searchParams.set("shop", shop), redirectWithAppBridgeHeaders(redirectUri.toString());
  } else if (isEmbeddedRequest2)
    redirectWithExitIframe(params, request2, shop);
  else
    throw await beginAuth(params, request2, isOnline, shop);
}
var init_redirect_to_auth_page = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-auth-page.mjs"() {
    init_begin_auth();
    init_redirect_with_exitiframe();
    init_redirect_with_app_bridge_headers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/invalidate-access-token.mjs
async function invalidateAccessToken(params, session) {
  let { logger: logger2, config } = params;
  logger2.debug(`Invalidating access token for session - ${session.id}`, {
    shop: session.shop
  }), session.accessToken = void 0, await config.sessionStorage.storeSession(session);
}
var init_invalidate_access_token = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/invalidate-access-token.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/cancel.mjs
import "isbot";
function cancelBillingFactory(params, request2, session) {
  return async function(options) {
    let { api, logger: logger2 } = params;
    logger2.debug("Cancelling billing", { shop: session.shop, ...options });
    try {
      return await api.billing.cancel({
        session,
        subscriptionId: options.subscriptionId,
        isTest: options.isTest,
        prorate: options.prorate
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", {
        shop: session.shop
      }), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
  };
}
var init_cancel2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/cancel.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/require.mjs
import "isbot";
function requireBillingFactory(params, request2, session) {
  let { api, logger: logger2 } = params;
  return async function(options) {
    let logContext = {
      shop: session.shop,
      plans: options.plans,
      isTest: options.isTest
    };
    logger2.debug("Checking billing for the shop", logContext);
    let data3;
    try {
      data3 = await api.billing.check({
        session,
        plans: options.plans,
        isTest: options.isTest,
        returnObject: !0
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", logContext), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
    if (!data3.hasActivePayment)
      throw logger2.debug("Billing check failed", logContext), await options.onFailure(new Error("Billing check failed"));
    return logger2.debug("Billing check succeeded", logContext), data3;
  };
}
var init_require = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/require.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/helpers.mjs
function redirectOutOfApp(params, request2, url, shop) {
  let { config, logger: logger2 } = params;
  logger2.debug("Redirecting out of app", { shop, url });
  let requestUrl = new URL(request2.url), isEmbeddedRequest2 = requestUrl.searchParams.get("embedded") === "1";
  if (request2.headers.get("authorization"))
    throw new Response(void 0, {
      status: 401,
      statusText: "Unauthorized",
      headers: getAppBridgeHeaders(url)
    });
  if (isEmbeddedRequest2) {
    let params2 = new URLSearchParams({
      shop,
      host: requestUrl.searchParams.get("host"),
      exitIframe: url
    });
    throw redirect3(`${config.auth.exitIframePath}?${params2.toString()}`);
  } else
    throw redirect3(url);
}
var init_helpers = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/helpers.mjs"() {
    init_esm();
    init_redirect_with_app_bridge_headers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/request.mjs
import "isbot";
function requestBillingFactory(params, request2, session) {
  return async function({ plan, isTest, returnUrl, ...overrides }) {
    let { api, logger: logger2 } = params;
    logger2.info("Requesting billing", {
      shop: session.shop,
      plan,
      isTest,
      returnUrl
    });
    let result;
    try {
      result = await api.billing.request({
        plan,
        session,
        isTest,
        returnUrl,
        returnObject: !0,
        ...overrides
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", {
        shop: session.shop
      }), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
    throw redirectOutOfApp(params, request2, result.confirmationUrl, session.shop);
  };
}
var init_request2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/request.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
    init_helpers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/check.mjs
import "isbot";
function checkBillingFactory(params, request2, session) {
  return async function(options = {}) {
    let { api, logger: logger2 } = params;
    logger2.debug("Checking billing plans", { shop: session.shop, ...options });
    try {
      return await api.billing.check({
        session,
        plans: options.plans,
        isTest: options.isTest,
        returnObject: !0
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", {
        shop: session.shop
      }), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
  };
}
var init_check2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/check.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/create-usage-record.mjs
import "isbot";
function createUsageRecordFactory(params, request2, session) {
  return async function(options) {
    let { api, logger: logger2 } = params;
    logger2.debug("Create usage record", { shop: session.shop, ...options });
    try {
      return await api.billing.createUsageRecord({
        ...options,
        session
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", {
        shop: session.shop
      }), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
  };
}
var init_create_usage_record2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/create-usage-record.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/update-usage-subscription-capped-amount.mjs
import "isbot";
function updateUsageCappedAmountFactory(params, request2, session) {
  return async function(options) {
    let { api, logger: logger2 } = params;
    logger2.debug("Updating usage subscription capped amount", {
      shop: session.shop,
      ...options
    });
    let result;
    try {
      result = await api.billing.updateUsageCappedAmount({
        session,
        subscriptionLineItemId: options.subscriptionLineItemId,
        cappedAmount: options.cappedAmount
      });
    } catch (error) {
      throw error instanceof HttpResponseError && error.response.code === 401 ? (logger2.debug("API token was invalid, redirecting to OAuth", {
        shop: session.shop
      }), await invalidateAccessToken(params, session), await redirectToAuthPage(params, request2, session.shop)) : error;
    }
    throw redirectOutOfApp(params, request2, result.confirmationUrl, session.shop);
  };
}
var init_update_usage_subscription_capped_amount2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/billing/update-usage-subscription-capped-amount.mjs"() {
    init_lib();
    init_redirect_to_auth_page();
    init_invalidate_access_token();
    init_types9();
    init_helpers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/admin/graphql.mjs
function graphqlClientFactory({ params, handleClientError, session }) {
  return async function(operation, options) {
    let client = new params.api.clients.Graphql({
      session,
      apiVersion: options?.apiVersion
    });
    try {
      let apiResponse = await client.request(operation, {
        variables: options?.variables,
        retries: options?.tries ? options.tries - 1 : 0,
        headers: options?.headers,
        signal: options?.signal
      });
      return new Response(JSON.stringify(apiResponse));
    } catch (error) {
      throw handleClientError ? await handleClientError({ error, params, session }) : error;
    }
  };
}
var init_graphql = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/admin/graphql.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/admin/factory.mjs
function adminClientFactory({ params, handleClientError, session }) {
  return {
    graphql: graphqlClientFactory({ params, session, handleClientError })
  };
}
var init_factory = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/admin/factory.mjs"() {
    init_graphql();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/create-admin-api-context.mjs
function createAdminApiContext(session, params, handleClientError) {
  return adminClientFactory({
    session,
    params,
    handleClientError
  });
}
var init_create_admin_api_context = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/create-admin-api-context.mjs"() {
    init_factory();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-shopify-or-app-root.mjs
async function redirectToShopifyOrAppRoot(request2, params, responseHeaders) {
  let { api } = params, url = new URL(request2.url), host = api.utils.sanitizeHost(url.searchParams.get("host")), shop = api.utils.sanitizeShop(url.searchParams.get("shop")), redirectUrl = api.config.isEmbeddedApp ? await api.auth.getEmbeddedAppUrl({ rawRequest: request2 }) : `/?shop=${shop}&host=${encodeURIComponent(host)}`;
  throw redirect3(redirectUrl, { headers: responseHeaders });
}
var init_redirect_to_shopify_or_app_root = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-shopify-or-app-root.mjs"() {
    init_esm();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/ensure-app-is-embedded-if-required.mjs
var ensureAppIsEmbeddedIfRequired, init_ensure_app_is_embedded_if_required = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/ensure-app-is-embedded-if-required.mjs"() {
    init_redirect_to_shopify_or_app_root();
    ensureAppIsEmbeddedIfRequired = async (params, request2) => {
      let { api, logger: logger2, config } = params, url = new URL(request2.url), shop = url.searchParams.get("shop");
      api.config.isEmbeddedApp && url.searchParams.get("embedded") !== "1" && (logger2.debug("App is not embedded, redirecting to Shopify", { shop }), await redirectToShopifyOrAppRoot(request2, { api }));
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/ensure-session-token-search-param-if-required.mjs
var SESSION_TOKEN_PARAM2, ensureSessionTokenSearchParamIfRequired, init_ensure_session_token_search_param_if_required = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/ensure-session-token-search-param-if-required.mjs"() {
    init_redirect_to_bounce_page();
    SESSION_TOKEN_PARAM2 = "id_token", ensureSessionTokenSearchParamIfRequired = async (params, request2) => {
      let { api, logger: logger2 } = params, url = new URL(request2.url), shop = url.searchParams.get("shop"), searchParamSessionToken = url.searchParams.get(SESSION_TOKEN_PARAM2), isEmbedded = url.searchParams.get("embedded") === "1";
      api.config.isEmbeddedApp && isEmbedded && !searchParamSessionToken && (logger2.debug("Missing session token in search params, going to bounce page", { shop }), redirectToBouncePage(params, url));
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/app-bridge-url.mjs
function appBridgeUrl() {
  return appBridgeUrlOverride || APP_BRIDGE_URL;
}
var appBridgeUrlOverride, init_app_bridge_url = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/app-bridge-url.mjs"() {
    init_const();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/add-response-headers.mjs
function addDocumentResponseHeadersFactory(params) {
  let { api, config } = params;
  return function(request2, headers) {
    let { searchParams } = new URL(request2.url), shop = api.utils.sanitizeShop(searchParams.get("shop"));
    addDocumentResponseHeaders(headers, config.isEmbeddedApp, shop);
  };
}
function addDocumentResponseHeaders(headers, isEmbeddedApp, shop) {
  shop && headers.set("Link", '<https://cdn.shopify.com/shopifycloud/app-bridge.js>; rel="preload"; as="script";'), isEmbeddedApp ? shop && headers.set("Content-Security-Policy", `frame-ancestors https://${shop} https://admin.shopify.com https://*.spin.dev https://admin.myshopify.io https://admin.shop.dev;`) : headers.set("Content-Security-Policy", "frame-ancestors 'none';");
}
var init_add_response_headers = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/add-response-headers.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/validate-redirect-url.mjs
function isSafe(domain, redirectUrl, requireSSL = !0) {
  if (typeof redirectUrl != "string" || FILE_URI_MATCH.test(redirectUrl) || WHITESPACE_CHARACTER.test(redirectUrl))
    return !1;
  let url;
  try {
    url = new URL(redirectUrl, domain);
  } catch {
    return !1;
  }
  return !(INVALID_RELATIVE_URL.test(url.pathname) || !VALID_PROTOCOLS.includes(url.protocol) || requireSSL && url.protocol !== "https:");
}
function sanitizeRedirectUrl(domain, redirectUrl, options = {}) {
  if (isSafe(domain, redirectUrl, options.requireSSL))
    return new URL(redirectUrl, domain);
  if (options.throwOnInvalid === !1)
    return;
  throw new ShopifyError("Invalid URL. Refusing to redirect");
}
var FILE_URI_MATCH, INVALID_RELATIVE_URL, WHITESPACE_CHARACTER, VALID_PROTOCOLS, init_validate_redirect_url = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/validate-redirect-url.mjs"() {
    init_lib();
    FILE_URI_MATCH = /\/\/\//, INVALID_RELATIVE_URL = /[/\\][/\\]/, WHITESPACE_CHARACTER = /\s/, VALID_PROTOCOLS = ["https:", "http:"];
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/render-app-bridge.mjs
function renderAppBridge({ config }, request2, redirectTo) {
  let redirectToScript = "";
  if (redirectTo) {
    let destination = sanitizeRedirectUrl(config.appUrl, redirectTo.url), target = redirectTo.target ?? "_top";
    redirectToScript = `<script>window.open(${JSON.stringify(destination.toString())}, ${JSON.stringify(target)})</script>`;
  }
  let responseHeaders = new Headers({
    "content-type": "text/html;charset=utf-8"
  });
  throw addDocumentResponseHeaders(responseHeaders, config.isEmbeddedApp, new URL(request2.url).searchParams.get("shop")), new Response(`
      <script data-api-key="${config.apiKey}" src="${appBridgeUrl()}"></script>
      ${redirectToScript}
    `, { headers: responseHeaders });
}
var init_render_app_bridge = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/render-app-bridge.mjs"() {
    init_app_bridge_url();
    init_add_response_headers();
    init_validate_redirect_url();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect.mjs
function redirectFactory(params, request2, shop) {
  let { config, logger: logger2 } = params;
  return function(url, init) {
    let { searchParams } = new URL(request2.url), { url: parsedUrl, target } = parseURL({
      params,
      url,
      base: config.appUrl,
      shop,
      init
    });
    if (logger2.debug("Redirecting", { shop, url: parsedUrl.toString() }), (parsedUrl.origin === config.appUrl || url.startsWith("/")) && searchParams.forEach((value, key) => {
      parsedUrl.searchParams.has(key) || parsedUrl.searchParams.set(key, value);
    }), target === "_self") {
      if (isBounceRequest(request2))
        throw renderAppBridge(params, request2, {
          url: parsedUrl.toString(),
          target
        });
      return redirect3(parsedUrl.toString(), init);
    } else {
      if (isDataRequest(request2))
        throw redirectWithAppBridgeHeaders(parsedUrl.toString());
      if (isEmbeddedRequest(request2))
        throw renderAppBridge(params, request2, {
          url: parsedUrl.toString(),
          target
        });
    }
    return redirect3(url, init);
  };
}
function isBounceRequest(request2) {
  return Boolean(getSessionTokenHeader(request2)) && request2.headers.has("X-Shopify-Bounce");
}
function isDataRequest(request2) {
  let isGet = request2.method === "GET";
  return Boolean(getSessionTokenHeader(request2)) && !isBounceRequest(request2) && (!isEmbeddedRequest(request2) || !isGet);
}
function isEmbeddedRequest(request2) {
  let { searchParams } = new URL(request2.url);
  return searchParams.get("embedded") === "1";
}
function parseURL({ params, base, init, shop, url }) {
  let target = typeof init != "number" && init?.target ? init.target : void 0;
  if (isAdminRemotePath(url)) {
    let { config } = params, adminPath = getAdminRemotePath(url), cleanShopName = shop.replace(".myshopify.com", "");
    return target || (target = config.isEmbeddedApp ? "_parent" : "_self"), {
      url: new URL(`https://admin.shopify.com/store/${cleanShopName}${adminPath}`),
      target
    };
  } else
    return {
      url: new URL(url, base),
      target: target ?? "_self"
    };
}
function isAdminRemotePath(url) {
  return ADMIN_REGEX.test(url);
}
function getAdminRemotePath(url) {
  return removeRestrictedParams(new URL(url)).href.replace(ADMIN_REGEX, "/");
}
function removeRestrictedParams(url) {
  let newUrl = new URL(url);
  return embeddedFrameParamsToRemove.forEach((param) => newUrl.searchParams.delete(param)), newUrl;
}
var ADMIN_REGEX, embeddedFrameParamsToRemove, init_redirect = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect.mjs"() {
    init_esm();
    init_get_session_token_header();
    init_render_app_bridge();
    init_redirect_with_app_bridge_headers();
    ADMIN_REGEX = /^shopify:\/*admin\//i;
    embeddedFrameParamsToRemove = [
      "hmac",
      "locale",
      "protocol",
      "session",
      "id_token",
      "shop",
      "timestamp",
      "host",
      "embedded",
      // sent when clicking rel="home" nav item
      "appLoadId"
    ];
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/validate-shop-and-host-params.mjs
function validateShopAndHostParams(params, request2) {
  let { api, config, logger: logger2 } = params;
  if (config.isEmbeddedApp) {
    let url = new URL(request2.url), shop = api.utils.sanitizeShop(url.searchParams.get("shop"));
    if (!shop)
      throw logger2.debug("Missing or invalid shop, redirecting to login path", {
        shop
      }), redirectToLoginPath(request2, params);
    if (!api.utils.sanitizeHost(url.searchParams.get("host")))
      throw logger2.debug("Invalid host, redirecting to login path", {
        shop,
        host: url.searchParams.get("host")
      }), redirectToLoginPath(request2, params);
  }
}
function redirectToLoginPath(request2, params) {
  let { config, logger: logger2 } = params, { pathname } = new URL(request2.url);
  if (pathname === config.auth.loginPath) {
    let message = `Detected call to shopify.authenticate.admin() from configured login path ('${config.auth.loginPath}'), please make sure to call shopify.login() from that route instead.`;
    throw logger2.debug(message), new Response(message, { status: 500 });
  }
  throw redirect3(config.auth.loginPath);
}
var init_validate_shop_and_host_params = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/validate-shop-and-host-params.mjs"() {
    init_esm();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-install-page.mjs
async function redirectToInstallPage(params, shop, optionalScopes = []) {
  let installUrl = buildInstallUrl(params, shop, optionalScopes);
  throw params.config.isEmbeddedApp ? redirectWithAppBridgeHeaders(installUrl) : redirect3(installUrl);
}
function buildInstallUrl(params, shop, optionalScopes = []) {
  let baseInstallUrl = buildBaseInstallUrl(params, shop);
  return baseInstallUrl.search = buildParamsInstallUrl(params, optionalScopes).toString(), baseInstallUrl.href;
}
function buildBaseInstallUrl({ api }, shop) {
  let cleanShop = api.utils.sanitizeShop(shop, !0);
  return new URL(`https://${cleanShop}/admin/oauth/install`);
}
function buildParamsInstallUrl({ config }, optionalScopes = []) {
  let optionalScopesParam = optionalScopes && optionalScopes.length > 0 ? { optional_scopes: optionalScopes.join(",") } : void 0, query = {
    client_id: config.apiKey,
    scope: config.scopes?.toString() || "",
    ...optionalScopesParam
  };
  return new URLSearchParams(query);
}
var init_redirect_to_install_page = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/redirect-to-install-page.mjs"() {
    init_esm();
    init_redirect_with_app_bridge_headers();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/client/fetch-scopes-details.mjs
async function fetchScopeDetail(admin) {
  return (await (await admin.graphql(FETCH_SCOPES_DETAIL_QUERY)).json()).data;
}
var FETCH_SCOPES_DETAIL_QUERY, init_fetch_scopes_details = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/client/fetch-scopes-details.mjs"() {
    FETCH_SCOPES_DETAIL_QUERY = `#graphql
query FetchAccessScopes{
  app {
    requestedAccessScopes {
      handle
    }
    optionalAccessScopes {
      handle
    }
    installation {
      accessScopes {
        handle
      }
    }
  }
}`;
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/request.mjs
function requestScopesFactory(params, session, admin) {
  return async function(scopes) {
    let { logger: logger2 } = params;
    if (logger2.debug("Requesting optional scopes: ", { shop: session.shop, scopes }), scopes.length !== 0 && !await alreadyGranted(scopes, admin))
      throw await redirectToInstallPage(params, session.shop, scopes);
  };
  async function alreadyGranted(scopes, admin2) {
    let grantedScopes = (await fetchScopeDetail(admin2)).app.installation.accessScopes.map((scope) => scope.handle);
    return new AuthScopes(grantedScopes).has(scopes);
  }
}
var init_request3 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/request.mjs"() {
    init_lib();
    init_redirect_to_install_page();
    init_fetch_scopes_details();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/query.mjs
function queryScopesFactory(params, session, admin) {
  return async function() {
    let { logger: logger2 } = params;
    logger2.debug("Querying scopes details: ", {
      shop: session.shop
    });
    let scopesDetail = await fetchScopeDetail(admin);
    return mapFetchScopeDetail(scopesDetail);
  };
}
function mapFetchScopeDetail(scopesDetailResponse) {
  let appInformation = scopesDetailResponse.app, granted = new AuthScopes(appInformation.installation.accessScopes.map((scope) => scope.handle)).toArray(!0), required = new AuthScopes(appInformation.requestedAccessScopes.map((scope) => scope.handle)).toArray(!0), optional = new AuthScopes(appInformation.optionalAccessScopes.map((scope) => scope.handle)).toArray(!0);
  return {
    granted,
    required,
    optional
  };
}
var init_query = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/query.mjs"() {
    init_lib();
    init_fetch_scopes_details();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/client/revoke-scopes.mjs
async function revokeScopes(admin, scopes) {
  return (await (await admin.graphql(REVOKE_SCOPE_MUTATION, {
    variables: {
      scopes
    }
  })).json()).data.appRevokeAccessScopes;
}
var REVOKE_SCOPE_MUTATION, init_revoke_scopes = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/client/revoke-scopes.mjs"() {
    REVOKE_SCOPE_MUTATION = `#graphql
mutation AppRevokeAccessScopes($scopes: [String!]!) {
  appRevokeAccessScopes(scopes: $scopes){
    revoked {
      handle
    }
    userErrors {
      field
      message
    }
  }
}`;
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/revoke.mjs
function revokeScopesFactory(params, session, admin) {
  return async function(scopes) {
    let { logger: logger2 } = params;
    await validateScopes(scopes), logger2.debug("Revoke scopes: ", {
      shop: session.shop,
      scopes
    });
    let revokeScopesResult = await revokeScopes(admin, scopes);
    if (revokeScopesResult.userErrors?.length > 0)
      throw logger2.error("Failed to revoke scopes: ", {
        shop: session.shop,
        errors: revokeScopesResult.userErrors
      }), new Response(JSON.stringify(revokeScopesResult.userErrors), {
        status: 422,
        headers: {
          "Content-Type": "application/json"
        }
      });
    return {
      revoked: revokeScopesResult.revoked.map((scope) => scope.handle)
    };
  };
}
async function validateScopes(scopes) {
  if (!scopes || scopes.length === 0)
    throw new Response("No scopes provided", { status: 400 });
}
var init_revoke = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/revoke.mjs"() {
    init_revoke_scopes();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/factory.mjs
function scopesApiFactory(params, session, admin) {
  return {
    query: queryScopesFactory(params, session, admin),
    request: requestScopesFactory(params, session, admin),
    revoke: revokeScopesFactory(params, session, admin)
  };
}
var init_factory2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/scope/factory.mjs"() {
    init_request3();
    init_query();
    init_revoke();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/authenticate.mjs
function authStrategyFactory({ strategy, ...params }) {
  let { api, logger: logger2, config } = params;
  async function respondToBouncePageRequest(request2) {
    if (new URL(request2.url).pathname === config.auth.patchSessionTokenPath)
      throw logger2.debug("Rendering bounce page", {
        shop: getShopFromRequest(request2)
      }), renderAppBridge({ config }, request2);
  }
  async function respondToExitIframeRequest(request2) {
    let url = new URL(request2.url);
    if (url.pathname === config.auth.exitIframePath) {
      let destination = url.searchParams.get("exitIframe");
      throw logger2.debug("Rendering exit iframe page", {
        shop: getShopFromRequest(request2),
        destination
      }), renderAppBridge({ config }, request2, { url: destination });
    }
  }
  function createContext19(request2, session, authStrategy, sessionToken) {
    let context = {
      admin: createAdminApiContext(session, params, authStrategy.handleClientError(request2)),
      billing: {
        require: requireBillingFactory(params, request2, session),
        check: checkBillingFactory(params, request2, session),
        request: requestBillingFactory(params, request2, session),
        cancel: cancelBillingFactory(params, request2, session),
        createUsageRecord: createUsageRecordFactory(params, request2, session),
        updateUsageCappedAmount: updateUsageCappedAmountFactory(params, request2, session)
      },
      session,
      cors: ensureCORSHeadersFactory(params, request2)
    };
    return context = addEmbeddedFeatures(context, request2, session, sessionToken), context = addScopesFeatures(context), context;
  }
  function addEmbeddedFeatures(context, request2, session, sessionToken) {
    return config.isEmbeddedApp ? {
      ...context,
      sessionToken,
      redirect: redirectFactory(params, request2, session.shop)
    } : context;
  }
  function addScopesFeatures(context) {
    return {
      ...context,
      scopes: scopesApiFactory(params, context.session, context.admin)
    };
  }
  return async function(request2) {
    try {
      respondToBotRequest(params, request2), respondToOptionsRequest(params, request2), await respondToBouncePageRequest(request2), await respondToExitIframeRequest(request2), await strategy.respondToOAuthRequests(request2), getSessionTokenHeader(request2) || (validateShopAndHostParams(params, request2), await ensureAppIsEmbeddedIfRequired(params, request2), await ensureSessionTokenSearchParamIfRequired(params, request2)), logger2.info("Authenticating admin request", {
        shop: getShopFromRequest(request2)
      });
      let { payload, shop, sessionId, sessionToken } = await getSessionTokenContext(params, request2);
      logger2.debug("Loading session from storage", { shop, sessionId });
      let existingSession = sessionId ? await config.sessionStorage.loadSession(sessionId) : void 0, session = await strategy.authenticate(request2, {
        session: existingSession,
        sessionToken,
        shop
      });
      return createContext19(request2, session, strategy, payload);
    } catch (errorOrResponse) {
      throw errorOrResponse instanceof Response && (logger2.debug("Authenticate returned a response", {
        shop: getShopFromRequest(request2)
      }), ensureCORSHeadersFactory(params, request2)(errorOrResponse)), errorOrResponse;
    }
  };
}
async function getSessionTokenContext(params, request2) {
  let { api, config, logger: logger2 } = params, headerSessionToken = getSessionTokenHeader(request2), searchParamSessionToken = getSessionTokenFromUrlParam(request2), sessionToken = headerSessionToken || searchParamSessionToken;
  if (logger2.debug("Attempting to authenticate session token", {
    shop: getShopFromRequest(request2),
    sessionToken: JSON.stringify({
      header: headerSessionToken,
      search: searchParamSessionToken
    })
  }), config.isEmbeddedApp) {
    let payload = await validateSessionToken(params, request2, sessionToken), shop2 = new URL(payload.dest).hostname;
    logger2.debug("Session token is valid - authenticated", { shop: shop2, payload });
    let sessionId2 = config.useOnlineTokens ? api.session.getJwtSessionId(shop2, payload.sub) : api.session.getOfflineId(shop2);
    return { shop: shop2, payload, sessionId: sessionId2, sessionToken };
  }
  let shop = new URL(request2.url).searchParams.get("shop"), sessionId = await api.session.getCurrentId({
    isOnline: config.useOnlineTokens,
    rawRequest: request2
  });
  return { shop, sessionId, payload: void 0, sessionToken };
}
var init_authenticate = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/authenticate.mjs"() {
    init_ensure_cors_headers();
    init_validate_session_token();
    init_get_session_token_header();
    init_reject_bot_request();
    init_respond_to_options_request();
    init_types9();
    init_get_shop_from_request();
    init_cancel2();
    init_require();
    init_request2();
    init_check2();
    init_create_usage_record2();
    init_update_usage_subscription_capped_amount2();
    init_create_admin_api_context();
    init_ensure_app_is_embedded_if_required();
    init_ensure_session_token_search_param_if_required();
    init_redirect();
    init_render_app_bridge();
    init_validate_shop_and_host_params();
    init_factory2();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/handle-client-error.mjs
function handleClientErrorFactory({ request: request2, onError }) {
  return async function({ error, params, session }) {
    throw error instanceof HttpResponseError ? (params.logger.debug(`Got an HTTP response error from the API: ${error.message}`, {
      shop: session.shop,
      code: error.response.code,
      statusText: error.response.statusText,
      body: JSON.stringify(error.response.body)
    }), onError && await onError({ request: request2, session, error }), new Response(JSON.stringify(error.response.body), {
      status: error.response.code,
      headers: {
        "Content-Type": error.response.headers["Content-Type"]
      }
    })) : (params.logger.debug(`Got a response error from the API: ${error.message}`, { shop: session.shop }), error);
  };
}
var init_handle_client_error = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/handle-client-error.mjs"() {
    init_lib();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/create-or-load-offline-session.mjs
async function createOrLoadOfflineSession(shop, { api, config, logger: logger2 }) {
  if (config.distribution === AppDistribution.ShopifyAdmin)
    return logger2.debug("Creating custom app session from configured access token", {
      shop
    }), api.session.customAppSession(shop);
  {
    logger2.debug("Loading offline session from session storage", { shop });
    let offlineSessionId = api.session.getOfflineId(shop);
    return await config.sessionStorage.loadSession(offlineSessionId);
  }
}
var init_create_or_load_offline_session = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/create-or-load-offline-session.mjs"() {
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/webhooks/authenticate.mjs
import "isbot";
function authenticateWebhookFactory(params) {
  let { api, logger: logger2 } = params;
  return async function(request2) {
    if (request2.method !== "POST")
      throw logger2.debug("Received a non-POST request for a webhook. Only POST requests are allowed.", { url: request2.url, method: request2.method }), new Response(void 0, {
        status: 405,
        statusText: "Method not allowed"
      });
    let rawBody = await request2.text(), check2 = await api.webhooks.validate({
      rawBody,
      rawRequest: request2
    });
    if (!check2.valid)
      throw check2.reason === WebhookValidationErrorReason.InvalidHmac ? (logger2.debug("Webhook HMAC validation failed", check2), new Response(void 0, {
        status: 401,
        statusText: "Unauthorized"
      })) : (logger2.debug("Webhook validation failed", check2), new Response(void 0, { status: 400, statusText: "Bad Request" }));
    let session = await createOrLoadOfflineSession(check2.domain, params), webhookContext = {
      apiVersion: check2.apiVersion,
      shop: check2.domain,
      topic: check2.topic,
      webhookId: check2.webhookId,
      payload: JSON.parse(rawBody),
      subTopic: check2.subTopic || void 0,
      session: void 0,
      admin: void 0
    };
    if (!session)
      return webhookContext;
    let admin = adminClientFactory({
      params,
      session,
      handleClientError: handleClientErrorFactory({ request: request2 })
    });
    return {
      ...webhookContext,
      session,
      admin
    };
  };
}
var init_authenticate2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/webhooks/authenticate.mjs"() {
    init_lib();
    init_factory();
    init_handle_client_error();
    init_create_or_load_offline_session();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/override-logger.mjs
import { compare as compare2 } from "compare-versions";
function overrideLogger(logger2) {
  let baseContext = { package: "shopify-app" }, warningFunction = (message, context = {}) => logger2.warning(message, { ...baseContext, ...context });
  function deprecated2(warningFunction2) {
    return function(version, message) {
      if (compare2(SHOPIFY_REMIX_LIBRARY_VERSION, version, ">="))
        throw new FeatureDeprecatedError(`Feature was deprecated in version ${version}`);
      return warningFunction2(`[Deprecated | ${version}] ${message}`);
    };
  }
  return {
    ...logger2,
    log: (severity, message, context = {}) => logger2.log(severity, message, { ...baseContext, ...context }),
    debug: (message, context = {}) => logger2.debug(message, { ...baseContext, ...context }),
    info: (message, context = {}) => logger2.info(message, { ...baseContext, ...context }),
    warning: warningFunction,
    error: (message, context = {}) => logger2.error(message, { ...baseContext, ...context }),
    deprecated: deprecated2(warningFunction)
  };
}
var init_override_logger = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/override-logger.mjs"() {
    init_lib();
    init_version2();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/login/login.mjs
function loginFactory(params) {
  let { api, config, logger: logger2 } = params;
  return async function(request2) {
    let shopParam = new URL(request2.url).searchParams.get("shop");
    if (request2.method === "GET" && !shopParam)
      return {};
    let shop = shopParam || (await request2.formData()).get("shop");
    if (!shop)
      return logger2.debug("Missing shop parameter", { shop }), { shop: LoginErrorType.MissingShop };
    let shopWithoutProtocol = shop.replace(/^https?:\/\//, "").replace(/\/$/, ""), shopWithDomain = shop?.indexOf(".") === -1 ? `${shopWithoutProtocol}.myshopify.com` : shopWithoutProtocol, sanitizedShop = api.utils.sanitizeShop(shopWithDomain);
    if (!sanitizedShop)
      return logger2.debug("Invalid shop parameter", { shop }), { shop: LoginErrorType.InvalidShop };
    let authPath = `${config.appUrl}${config.auth.path}?shop=${sanitizedShop}`, installPath = `https://${api.utils.legacyUrlToShopAdminUrl(sanitizedShop)}/oauth/install?client_id=${config.apiKey}`, redirectUrl = config.isEmbeddedApp && config.future.unstable_newEmbeddedAuthStrategy ? installPath : authPath;
    throw logger2.info(`Redirecting login request to ${redirectUrl}`, {
      shop: sanitizedShop
    }), redirect3(redirectUrl);
  };
}
var init_login = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/login/login.mjs"() {
    init_esm();
    init_types9();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/errors.mjs
var SessionNotFoundError, init_errors3 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/errors.mjs"() {
    init_lib();
    SessionNotFoundError = class extends ShopifyError {
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/unauthenticated/admin/factory.mjs
function unauthenticatedAdminContextFactory(params) {
  return async (shop) => {
    let session = await createOrLoadOfflineSession(shop, params);
    if (!session)
      throw new SessionNotFoundError(`Could not find a session for shop ${shop} when creating unauthenticated admin context`);
    return {
      session,
      admin: adminClientFactory({ params, session })
    };
  };
}
var init_factory3 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/unauthenticated/admin/factory.mjs"() {
    init_create_or_load_offline_session();
    init_errors3();
    init_factory();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/extension/authenticate.mjs
function authenticateExtensionFactory(params, requestType) {
  return async function(request2, options = {}) {
    let { logger: logger2 } = params, corsHeaders = options.corsHeaders ?? [];
    respondToBotRequest(params, request2), respondToOptionsRequest(params, request2, corsHeaders);
    let sessionTokenHeader = getSessionTokenHeader(request2);
    if (logger2.info(`Authenticating ${requestType} request`, {
      shop: getShopFromRequest(request2)
    }), !sessionTokenHeader)
      throw logger2.debug("Request did not contain a session token", {
        shop: getShopFromRequest(request2)
      }), new Response(void 0, {
        status: 401,
        statusText: "Unauthorized"
      });
    return {
      sessionToken: await validateSessionToken(params, request2, sessionTokenHeader, { checkAudience: !1, retryRequest: !1 }),
      cors: ensureCORSHeadersFactory(params, request2, corsHeaders)
    };
  };
}
var init_authenticate3 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/extension/authenticate.mjs"() {
    init_ensure_cors_headers();
    init_validate_session_token();
    init_get_session_token_header();
    init_reject_bot_request();
    init_respond_to_options_request();
    init_types9();
    init_get_shop_from_request();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/checkout/authenticate.mjs
function authenticateCheckoutFactory(params) {
  return authenticateExtensionFactory(params, "checkout");
}
var init_authenticate4 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/checkout/authenticate.mjs"() {
    init_authenticate3();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/storefront/factory.mjs
function storefrontClientFactory({ params, session }) {
  let { api } = params;
  return {
    graphql: async (query, options = {}) => {
      let apiResponse = await new api.clients.Storefront({
        session,
        apiVersion: options.apiVersion
      }).request(query, {
        variables: options?.variables,
        retries: options?.tries ? options.tries - 1 : 0,
        headers: options?.headers
      });
      return new Response(JSON.stringify(apiResponse));
    }
  };
}
var init_factory4 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/clients/storefront/factory.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/appProxy/authenticate.mjs
function authenticateAppProxyFactory(params) {
  let { api, config, logger: logger2 } = params;
  return async function(request2) {
    let url = new URL(request2.url), shop = url.searchParams.get("shop");
    if (logger2.info("Authenticating app proxy request", { shop }), !await validateAppProxyHmac(params, url))
      throw logger2.info("App proxy request has invalid signature", { shop }), new Response(void 0, {
        status: 400,
        statusText: "Bad Request"
      });
    let sessionId = api.session.getOfflineId(shop), session = await config.sessionStorage.loadSession(sessionId);
    return session ? {
      liquid,
      session,
      admin: adminClientFactory({ params, session }),
      storefront: storefrontClientFactory({ params, session })
    } : (logger2.debug("Could not find offline session, returning empty context", {
      shop,
      ...Object.fromEntries(url.searchParams.entries())
    }), {
      liquid,
      session: void 0,
      admin: void 0,
      storefront: void 0
    });
  };
}
async function validateAppProxyHmac(params, url) {
  let { api, logger: logger2 } = params;
  try {
    let searchParams = new URLSearchParams(url.search);
    searchParams.get("index") || searchParams.delete("index");
    let isValid = await api.utils.validateHmac(Object.fromEntries(searchParams.entries()), { signator: "appProxy" });
    if (!isValid) {
      let data3 = `routes%2F${url.pathname.replace(/^\//, "").replace(/\/$/, "").replaceAll("/", ".")}`;
      if (searchParams = new URLSearchParams(`?_data=${data3}&${searchParams.toString().replace(/^\?/, "")}`), isValid = await api.utils.validateHmac(Object.fromEntries(searchParams.entries()), { signator: "appProxy" }), !isValid) {
        let searchParams2 = new URLSearchParams(`?_data=${data3}._index&${url.search.replace(/^\?/, "")}`);
        isValid = await api.utils.validateHmac(Object.fromEntries(searchParams2.entries()), { signator: "appProxy" });
      }
    }
    return isValid;
  } catch (error) {
    let shop = url.searchParams.get("shop");
    throw logger2.info(error.message, { shop }), new Response(void 0, { status: 400, statusText: "Bad Request" });
  }
}
function processLiquidBody(body) {
  return body.replaceAll(/<(form[^>]+)action="(\/[^"?]+)(\?[^"]+)?">/g, '<$1action="$2/$3">').replaceAll(/<(a[^>]+)href="(\/[^"?]+)(\?[^"]+)?">/g, '<$1href="$2/$3">');
}
var liquid, init_authenticate5 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/appProxy/authenticate.mjs"() {
    init_factory();
    init_factory4();
    liquid = (body, initAndOptions) => {
      let processedBody = processLiquidBody(body);
      if (typeof initAndOptions != "object")
        return new Response(processedBody, {
          status: initAndOptions || 200,
          headers: {
            "Content-Type": "application/liquid"
          }
        });
      let { layout, ...responseInit } = initAndOptions || {}, responseBody = layout === !1 ? `{% layout none %} ${processedBody}` : processedBody, headers = new Headers(responseInit.headers);
      return headers.set("Content-Type", "application/liquid"), new Response(responseBody, {
        ...responseInit,
        headers
      });
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/customer-account/authenticate.mjs
function authenticateCustomerAccountFactory(params) {
  return authenticateExtensionFactory(params, "customer account");
}
var init_authenticate6 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/customer-account/authenticate.mjs"() {
    init_authenticate3();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/pos/authenticate.mjs
function authenticatePOSFactory(params) {
  return authenticateExtensionFactory(params, "pos");
}
var init_authenticate7 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/pos/authenticate.mjs"() {
    init_authenticate3();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/factory.mjs
function authenticatePublicFactory(params) {
  let authenticateCheckout = authenticateCheckoutFactory(params), authenticateAppProxy = authenticateAppProxyFactory(params), authenticateCustomerAccount = authenticateCustomerAccountFactory(params), authenticatePOS = authenticatePOSFactory(params);
  return {
    checkout: authenticateCheckout,
    appProxy: authenticateAppProxy,
    customerAccount: authenticateCustomerAccount,
    pos: authenticatePOS
  };
}
var init_factory5 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/public/factory.mjs"() {
    init_authenticate4();
    init_authenticate5();
    init_authenticate6();
    init_authenticate7();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/unauthenticated/storefront/factory.mjs
function unauthenticatedStorefrontContextFactory(params) {
  return async (shop) => {
    let session = await createOrLoadOfflineSession(shop, params);
    if (!session)
      throw new SessionNotFoundError(`Could not find a session for shop ${shop} when creating unauthenticated storefront context`);
    return {
      session,
      storefront: storefrontClientFactory({ params, session })
    };
  };
}
var init_factory6 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/unauthenticated/storefront/factory.mjs"() {
    init_create_or_load_offline_session();
    init_errors3();
    init_factory4();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/trigger-after-auth-hook.mjs
async function triggerAfterAuthHook(params, session, request2, authStrategy) {
  let { config, logger: logger2 } = params;
  if (config.hooks.afterAuth) {
    logger2.info("Running afterAuth hook", { shop: session.shop });
    let admin = createAdminApiContext(session, params, authStrategy.handleClientError(request2));
    await config.hooks.afterAuth({
      session,
      admin
    });
  }
}
var init_trigger_after_auth_hook = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/helpers/trigger-after-auth-hook.mjs"() {
    init_create_admin_api_context();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/auth-code-flow.mjs
import "isbot";
var AuthCodeFlowStrategy, init_auth_code_flow = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/auth-code-flow.mjs"() {
    init_lib();
    init_begin_auth();
    init_redirect_to_shopify_or_app_root();
    init_handle_client_error();
    init_redirect_to_auth_page();
    init_redirect_with_exitiframe();
    init_get_session_token_header();
    init_trigger_after_auth_hook();
    init_validate_shop_and_host_params();
    init_types9();
    AuthCodeFlowStrategy = class {
      api;
      config;
      logger;
      constructor({ api, config, logger: logger2 }) {
        this.api = api, this.config = config, this.logger = logger2;
      }
      async respondToOAuthRequests(request2) {
        let { api, config } = this, url = new URL(request2.url), isAuthRequest = url.pathname === config.auth.path, isAuthCallbackRequest = url.pathname === config.auth.callbackPath;
        if (isAuthRequest || isAuthCallbackRequest) {
          let shop = api.utils.sanitizeShop(url.searchParams.get("shop"));
          throw shop ? isAuthRequest ? await this.handleAuthBeginRequest(request2, shop) : await this.handleAuthCallbackRequest(request2, shop) : new Response("Shop param is invalid", { status: 400 });
        }
        getSessionTokenHeader(request2) || await this.ensureInstalledOnShop(request2);
      }
      async authenticate(request2, sessionContext) {
        let { api, config, logger: logger2 } = this, { shop, session } = sessionContext;
        return session ? session.isActive(config.scopes) || (logger2.debug("Found a session, but it has expired, redirecting to OAuth", { shop }), await redirectToAuthPage({ config, api }, request2, shop)) : (logger2.debug("No session found, redirecting to OAuth", { shop }), await redirectToAuthPage({ config, api }, request2, shop)), logger2.debug("Found a valid session", { shop }), session;
      }
      handleClientError(request2) {
        let { api, config, logger: logger2 } = this;
        return handleClientErrorFactory({
          request: request2,
          onError: async ({ session, error }) => {
            if (error.response.code === 401)
              throw await redirectToAuthPage({ api, config }, request2, session.shop);
          }
        });
      }
      async ensureInstalledOnShop(request2) {
        let { api, config, logger: logger2 } = this;
        validateShopAndHostParams({ api, config, logger: logger2 }, request2);
        let url = new URL(request2.url), shop = url.searchParams.get("shop");
        if (logger2.debug("Ensuring app is installed on shop", { shop }), !await this.hasValidOfflineId(request2))
          throw logger2.info("Could not find a shop, can't authenticate request"), new Response(void 0, {
            status: 400,
            statusText: "Bad Request"
          });
        let offlineSession = await this.getOfflineSession(request2), isEmbedded = url.searchParams.get("embedded") === "1";
        if (!offlineSession)
          if (logger2.info("Shop hasn't installed app yet, redirecting to OAuth", {
            shop
          }), isEmbedded)
            redirectWithExitIframe({ api, config }, request2, shop);
          else
            throw await beginAuth({ api, config }, request2, !1, shop);
        if (shop = shop || offlineSession.shop, config.isEmbeddedApp && !isEmbedded)
          try {
            logger2.debug("Ensuring offline session is valid before embedding", {
              shop
            }), await this.testSession(offlineSession), logger2.debug("Offline session is still valid, embedding app", { shop });
          } catch (error) {
            await this.handleInvalidOfflineSession(error, request2, shop);
          }
      }
      async handleAuthBeginRequest(request2, shop) {
        let { api, config, logger: logger2 } = this;
        throw logger2.info("Handling OAuth begin request", { shop }), config.isEmbeddedApp && request2.headers.get("Sec-Fetch-Dest") === "iframe" ? (logger2.debug("Auth request in iframe detected, exiting iframe", { shop }), redirectWithExitIframe({ api, config }, request2, shop)) : await beginAuth({ api, config }, request2, !1, shop);
      }
      async handleAuthCallbackRequest(request2, shop) {
        let { api, config, logger: logger2 } = this;
        logger2.info("Handling OAuth callback request", { shop });
        try {
          let { session, headers: responseHeaders } = await api.auth.callback({
            rawRequest: request2
          });
          throw await config.sessionStorage.storeSession(session), config.useOnlineTokens && !session.isOnline && (logger2.info("Requesting online access token for offline session", {
            shop
          }), await beginAuth({ api, config, logger: logger2 }, request2, !0, shop)), logger2.debug("Request is valid, loaded session from OAuth callback", {
            shop: session.shop,
            isOnline: session.isOnline
          }), await triggerAfterAuthHook({ api, config, logger: logger2 }, session, request2, this), await redirectToShopifyOrAppRoot(request2, { api, config, logger: logger2 }, responseHeaders);
        } catch (error) {
          throw error instanceof Response ? error : await this.oauthCallbackError(error, request2, shop);
        }
      }
      async getOfflineSession(request2) {
        let offlineId = await this.getOfflineSessionId(request2);
        return this.config.sessionStorage.loadSession(offlineId);
      }
      async hasValidOfflineId(request2) {
        return Boolean(await this.getOfflineSessionId(request2));
      }
      async getOfflineSessionId(request2) {
        let { api } = this, shop = new URL(request2.url).searchParams.get("shop");
        return shop ? api.session.getOfflineId(shop) : api.session.getCurrentId({ isOnline: !1, rawRequest: request2 });
      }
      async testSession(session) {
        let { api } = this;
        await new api.clients.Graphql({
          session
        }).request(`#graphql
      query shopifyAppShopName {
        shop {
          name
        }
      }
    `);
      }
      async oauthCallbackError(error, request2, shop) {
        let { logger: logger2 } = this;
        return logger2.error("Error during OAuth callback", { shop, error: error.message }), error instanceof CookieNotFound ? this.handleAuthBeginRequest(request2, shop) : error instanceof InvalidHmacError || error instanceof InvalidOAuthError ? new Response(void 0, {
          status: 400,
          statusText: "Invalid OAuth Request"
        }) : new Response(void 0, {
          status: 500,
          statusText: "Internal Server Error"
        });
      }
      async handleInvalidOfflineSession(error, request2, shop) {
        let { api, logger: logger2, config } = this;
        if (error instanceof HttpResponseError) {
          if (error.response.code === 401)
            throw logger2.info("Shop session is no longer valid, redirecting to OAuth", {
              shop
            }), await beginAuth({ api, config }, request2, !1, shop);
          {
            let message = JSON.stringify(error.response.body, null, 2);
            throw logger2.error(`Unexpected error during session validation: ${message}`, {
              shop
            }), new Response(void 0, {
              status: error.response.code,
              statusText: error.response.statusText
            });
          }
        } else if (error instanceof GraphqlQueryError) {
          let context = { shop };
          throw error.response && (context.response = JSON.stringify(error.body)), logger2.error(`Unexpected error during session validation: ${error.message}`, context), new Response(void 0, {
            status: 500,
            statusText: "Internal Server Error"
          });
        }
      }
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/token-exchange.mjs
import "isbot";
var TokenExchangeStrategy, init_token_exchange2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/token-exchange.mjs"() {
    init_lib();
    init_respond_to_invalid_session_token();
    init_get_shop_from_request();
    init_invalidate_access_token();
    init_types9();
    init_handle_client_error();
    init_trigger_after_auth_hook();
    TokenExchangeStrategy = class {
      api;
      config;
      logger;
      constructor({ api, config, logger: logger2 }) {
        this.api = api, this.config = config, this.logger = logger2;
      }
      async respondToOAuthRequests(_request) {
      }
      async authenticate(request2, sessionContext) {
        let { api, config, logger: logger2 } = this, { shop, session, sessionToken } = sessionContext;
        if (!sessionToken)
          throw new InvalidJwtError();
        if (!session || !session.isActive(void 0)) {
          logger2.info("No valid session found", { shop }), logger2.info("Requesting offline access token", { shop });
          let { session: offlineSession } = await this.exchangeToken({
            request: request2,
            sessionToken,
            shop,
            requestedTokenType: RequestedTokenType.OfflineAccessToken
          });
          await config.sessionStorage.storeSession(offlineSession);
          let newSession = offlineSession;
          if (config.useOnlineTokens) {
            logger2.info("Requesting online access token", { shop });
            let { session: onlineSession } = await this.exchangeToken({
              request: request2,
              sessionToken,
              shop,
              requestedTokenType: RequestedTokenType.OnlineAccessToken
            });
            await config.sessionStorage.storeSession(onlineSession), newSession = onlineSession;
          }
          logger2.debug("Request is valid, loaded session from session token", {
            shop: newSession.shop,
            isOnline: newSession.isOnline
          });
          try {
            await this.handleAfterAuthHook({ api, config, logger: logger2 }, newSession, request2, sessionToken);
          } catch (errorOrResponse) {
            throw errorOrResponse instanceof Response ? errorOrResponse : new Response(void 0, {
              status: 500,
              statusText: "Internal Server Error"
            });
          }
          return newSession;
        }
        return session;
      }
      handleClientError(request2) {
        let { api, config, logger: logger2 } = this;
        return handleClientErrorFactory({
          request: request2,
          onError: async ({ session, error }) => {
            error.response.code === 401 && (logger2.debug("Responding to invalid access token", {
              shop: getShopFromRequest(request2)
            }), await invalidateAccessToken({ config, logger: logger2 }, session), respondToInvalidSessionToken({
              params: { config, api, logger: logger2 },
              request: request2
            }));
          }
        });
      }
      async exchangeToken({ request: request2, shop, sessionToken, requestedTokenType }) {
        let { api, config, logger: logger2 } = this;
        try {
          return await api.auth.tokenExchange({
            sessionToken,
            shop,
            requestedTokenType
          });
        } catch (error) {
          throw error instanceof InvalidJwtError || error instanceof HttpResponseError && error.response.code === 400 && error.response.body?.error === "invalid_subject_token" ? respondToInvalidSessionToken({
            params: { api, config, logger: logger2 },
            request: request2,
            retryRequest: !0
          }) : new Response(void 0, {
            status: 500,
            statusText: "Internal Server Error"
          });
        }
      }
      async handleAfterAuthHook(params, session, request2, sessionToken) {
        let { config } = params;
        await config.idempotentPromiseHandler.handlePromise({
          promiseFunction: () => triggerAfterAuthHook(params, session, request2, this),
          identifier: sessionToken
        });
      }
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/merchant-custom-app.mjs
import "isbot";
var MerchantCustomAuth, init_merchant_custom_app = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/admin/strategies/merchant-custom-app.mjs"() {
    init_lib();
    init_handle_client_error();
    init_get_shop_from_request();
    init_types9();
    MerchantCustomAuth = class {
      api;
      config;
      logger;
      constructor({ api, config, logger: logger2 }) {
        this.api = api, this.config = config, this.logger = logger2;
      }
      async respondToOAuthRequests(request2) {
        this.logger.debug("Skipping OAuth request for merchant custom app", {
          shop: getShopFromRequest(request2)
        });
      }
      async authenticate(_request, sessionContext) {
        let { shop } = sessionContext;
        return this.logger.debug("Building session from configured access token for merchant custom app", { shop }), this.api.session.customAppSession(shop);
      }
      handleClientError(request2) {
        return handleClientErrorFactory({
          request: request2,
          onError: async ({ error }) => {
            if (error.response.code === 401)
              throw this.logger.info("Request failed with 401. Review your API credentials or generate new tokens. https://shopify.dev/docs/apps/build/authentication-authorization/access-token-types/generate-app-access-tokens-admin#rotating-api-credentials-for-admin-created-apps "), new ShopifyError("Unauthorized: Access token has been revoked.");
          }
        });
      }
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/idempotent-promise-handler.mjs
var IdempotentPromiseHandler, init_idempotent_promise_handler = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/helpers/idempotent-promise-handler.mjs"() {
    IdempotentPromiseHandler = class {
      identifiers;
      constructor() {
        this.identifiers = /* @__PURE__ */ new Map();
      }
      async handlePromise({ promiseFunction, identifier }) {
        try {
          this.isPromiseRunnable(identifier) && await promiseFunction();
        } finally {
          this.clearStaleIdentifiers();
        }
        return Promise.resolve();
      }
      isPromiseRunnable(identifier) {
        return this.identifiers.has(identifier) ? !1 : (this.identifiers.set(identifier, Date.now()), !0);
      }
      async clearStaleIdentifiers() {
        this.identifiers.forEach((date, identifier, map) => {
          Date.now() - date > 6e4 && map.delete(identifier);
        });
      }
    };
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/flow/authenticate.mjs
function authenticateFlowFactory(params) {
  let { api, config, logger: logger2 } = params;
  return async function(request2) {
    if (logger2.info("Authenticating flow request"), request2.method !== "POST")
      throw logger2.debug("Received a non-POST request for flow. Only POST requests are allowed.", { url: request2.url, method: request2.method }), new Response(void 0, {
        status: 405,
        statusText: "Method not allowed"
      });
    let rawBody = await request2.text(), result = await api.flow.validate({
      rawBody,
      rawRequest: request2
    });
    if (!result.valid)
      throw logger2.error("Received an invalid flow request", { reason: result.reason }), new Response(void 0, {
        status: 400,
        statusText: "Bad Request"
      });
    let payload = JSON.parse(rawBody);
    logger2.debug("Flow request is valid, looking for an offline session", {
      shop: payload.shopify_domain
    });
    let sessionId = api.session.getOfflineId(payload.shopify_domain), session = await config.sessionStorage.loadSession(sessionId);
    if (!session)
      throw logger2.info("Flow request could not find session", {
        shop: payload.shopify_domain
      }), new Response(void 0, {
        status: 400,
        statusText: "Bad Request"
      });
    return logger2.debug("Found a session for the flow request", { shop: session.shop }), {
      session,
      payload,
      admin: adminClientFactory({ params, session })
    };
  };
}
var init_authenticate8 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/flow/authenticate.mjs"() {
    init_factory();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/fulfillment-service/authenticate.mjs
import "isbot";
function authenticateFulfillmentServiceFactory(params) {
  let { api, logger: logger2 } = params;
  return async function(request2) {
    if (logger2.info("Authenticating fulfillment service request"), request2.method !== "POST")
      throw logger2.debug("Received a non-POST request for fulfillment service. Only POST requests are allowed.", { url: request2.url, method: request2.method }), new Response(void 0, {
        status: 405,
        statusText: "Method not allowed"
      });
    let rawBody = await request2.text(), result = await api.fulfillmentService.validate({
      rawBody,
      rawRequest: request2
    });
    if (!result.valid)
      throw logger2.error("Received an invalid fulfillment service request", {
        reason: result.reason
      }), new Response(void 0, {
        status: 400,
        statusText: "Bad Request"
      });
    let payload = JSON.parse(rawBody), shop = request2.headers.get(ShopifyHeader.Domain) || "";
    logger2.debug("Fulfillment service request is valid, looking for an offline session", {
      shop
    });
    let session = await createOrLoadOfflineSession(shop, params);
    if (!session)
      throw logger2.info("Fulfillment service request could not find session", {
        shop
      }), new Response(void 0, {
        status: 400,
        statusText: "Bad Request"
      });
    return logger2.debug("Found a session for the fulfillment service request", {
      shop
    }), {
      session,
      payload,
      admin: adminClientFactory({ params, session })
    };
  };
}
var init_authenticate9 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/authenticate/fulfillment-service/authenticate.mjs"() {
    init_lib();
    init_factory();
    init_create_or_load_offline_session();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/future/flags.mjs
function logDisabledFutureFlags2(config, logger2) {
  let logFlag = (flag, message) => logger2.info(`Future flag ${flag} is disabled.

  ${message}
`);
  config.future.unstable_newEmbeddedAuthStrategy || logFlag("unstable_newEmbeddedAuthStrategy", `Enable this to use OAuth token exchange instead of auth code to generate API access tokens.
  Your app must be using Shopify managed install: https://shopify.dev/docs/apps/auth/installation`);
}
var init_flags2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/future/flags.mjs"() {
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/shopify-app.mjs
import "isbot";
function shopifyApp(appConfig) {
  let api = deriveApi(appConfig), config = deriveConfig(appConfig, api.config), logger2 = overrideLogger(api.logger);
  appConfig.webhooks && api.webhooks.addHandlers(appConfig.webhooks);
  let params = { api, config, logger: logger2 }, strategy;
  config.distribution === AppDistribution.ShopifyAdmin ? strategy = new MerchantCustomAuth(params) : config.future.unstable_newEmbeddedAuthStrategy && config.isEmbeddedApp ? strategy = new TokenExchangeStrategy(params) : strategy = new AuthCodeFlowStrategy(params);
  let authStrategy = authStrategyFactory({
    ...params,
    strategy
  }), shopify2 = {
    sessionStorage: config.sessionStorage,
    addDocumentResponseHeaders: addDocumentResponseHeadersFactory(params),
    registerWebhooks: registerWebhooksFactory(params),
    authenticate: {
      admin: authStrategy,
      flow: authenticateFlowFactory(params),
      public: authenticatePublicFactory(params),
      fulfillmentService: authenticateFulfillmentServiceFactory(params),
      webhook: authenticateWebhookFactory(params)
    },
    unauthenticated: {
      admin: unauthenticatedAdminContextFactory(params),
      storefront: unauthenticatedStorefrontContextFactory(params)
    }
  };
  return (isAppStoreApp(shopify2, appConfig) || isSingleMerchantApp(shopify2, appConfig)) && (shopify2.login = loginFactory(params)), logDisabledFutureFlags2(config, logger2), shopify2;
}
function isAppStoreApp(_shopify, config) {
  return config.distribution === AppDistribution.AppStore;
}
function isSingleMerchantApp(_shopify, config) {
  return config.distribution === AppDistribution.SingleMerchant;
}
function deriveApi(appConfig) {
  let appUrl;
  try {
    appUrl = new URL(appConfig.appUrl);
  } catch {
    let message = appConfig.appUrl === "" ? `Detected an empty appUrl configuration, please make sure to set the necessary environment variables.
If you're deploying your app, you can find more information at https://shopify.dev/docs/apps/launch/deployment/deploy-web-app/deploy-to-hosting-service#step-4-set-up-environment-variables` : `Invalid appUrl configuration '${appConfig.appUrl}', please provide a valid URL.`;
    throw new ShopifyError(message);
  }
  appUrl.hostname === "localhost" && !appUrl.port && process.env.PORT && (appUrl.port = process.env.PORT), appConfig.appUrl = appUrl.origin;
  let userAgentPrefix = `Shopify Remix Library v${SHOPIFY_REMIX_LIBRARY_VERSION}`;
  return appConfig.userAgentPrefix && (userAgentPrefix = `${appConfig.userAgentPrefix} | ${userAgentPrefix}`), shopifyApi({
    ...appConfig,
    hostName: appUrl.host,
    hostScheme: appUrl.protocol.replace(":", ""),
    userAgentPrefix,
    isEmbeddedApp: appConfig.isEmbeddedApp ?? !0,
    apiVersion: appConfig.apiVersion,
    isCustomStoreApp: appConfig.distribution === AppDistribution.ShopifyAdmin,
    billing: appConfig.billing,
    future: {
      unstable_managedPricingSupport: !0
    },
    _logDisabledFutureFlags: !1
  });
}
function deriveConfig(appConfig, apiConfig) {
  if (!appConfig.sessionStorage && appConfig.distribution !== AppDistribution.ShopifyAdmin)
    throw new ShopifyError("Please provide a valid session storage. Refer to https://github.com/Shopify/shopify-app-js/blob/main/README.md#session-storage-options for options.");
  let authPathPrefix = appConfig.authPathPrefix || "/auth";
  return appConfig.distribution = appConfig.distribution ?? AppDistribution.AppStore, {
    ...appConfig,
    ...apiConfig,
    billing: appConfig.billing,
    scopes: apiConfig.scopes,
    idempotentPromiseHandler: new IdempotentPromiseHandler(),
    canUseLoginForm: appConfig.distribution !== AppDistribution.ShopifyAdmin,
    useOnlineTokens: appConfig.useOnlineTokens ?? !1,
    hooks: appConfig.hooks ?? {},
    sessionStorage: appConfig.sessionStorage,
    future: appConfig.future ?? {},
    auth: {
      path: authPathPrefix,
      callbackPath: `${authPathPrefix}/callback`,
      patchSessionTokenPath: `${authPathPrefix}/session-token`,
      exitIframePath: `${authPathPrefix}/exit-iframe`,
      loginPath: `${authPathPrefix}/login`
    },
    distribution: appConfig.distribution
  };
}
var init_shopify_app = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/shopify-app.mjs"() {
    init_web_api();
    init_lib();
    init_types9();
    init_version2();
    init_register2();
    init_authenticate();
    init_authenticate2();
    init_override_logger();
    init_add_response_headers();
    init_login();
    init_factory3();
    init_factory5();
    init_factory6();
    init_auth_code_flow();
    init_token_exchange2();
    init_merchant_custom_app();
    init_idempotent_promise_handler();
    init_authenticate8();
    init_authenticate9();
    init_flags2();
  }
});

// node_modules/@shopify/shopify-app-remix/dist/esm/server/index.mjs
var init_server2 = __esm({
  "node_modules/@shopify/shopify-app-remix/dist/esm/server/index.mjs"() {
    init_web_api();
    init_runtime();
    init_types9();
    init_boundary();
    init_shopify_app();
    init_errors3();
    setAbstractRuntimeString(() => "Remix");
  }
});

// node_modules/@shopify/shopify-app-session-storage-prisma/dist/esm/prisma.mjs
import { Prisma } from "@prisma/client";
async function sleep2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var UNIQUE_KEY_CONSTRAINT_ERROR_CODE, PrismaSessionStorage, MissingSessionTableError, MissingSessionStorageError, init_prisma = __esm({
  "node_modules/@shopify/shopify-app-session-storage-prisma/dist/esm/prisma.mjs"() {
    init_lib();
    UNIQUE_KEY_CONSTRAINT_ERROR_CODE = "P2002", PrismaSessionStorage = class {
      prisma;
      ready;
      tableName = "session";
      connectionRetries = 2;
      connectionRetryIntervalMs = 5e3;
      constructor(prisma, { tableName, connectionRetries, connectionRetryIntervalMs } = {}) {
        if (this.prisma = prisma, tableName && (this.tableName = tableName), connectionRetries !== void 0 && (this.connectionRetries = connectionRetries), connectionRetryIntervalMs !== void 0 && (this.connectionRetryIntervalMs = connectionRetryIntervalMs), this.getSessionTable() === void 0)
          throw new Error(`PrismaClient does not have a ${this.tableName} table`);
        this.ready = this.pollForTable().then(() => !0).catch((cause) => {
          throw new MissingSessionTableError(`Prisma ${this.tableName} table does not exist. This could happen for a few reasons, see https://github.com/Shopify/shopify-app-js/tree/main/packages/apps/session-storage/shopify-app-session-storage-prisma#troubleshooting for more information`, cause);
        });
      }
      async storeSession(session) {
        await this.ensureReady();
        let data3 = this.sessionToRow(session);
        try {
          await this.getSessionTable().upsert({
            where: { id: session.id },
            update: data3,
            create: data3
          });
        } catch (error) {
          if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === UNIQUE_KEY_CONSTRAINT_ERROR_CODE)
            return console.log("Caught PrismaClientKnownRequestError P2002 - Unique Key Key Constraint, retrying upsert."), await this.getSessionTable().upsert({
              where: { id: session.id },
              update: data3,
              create: data3
            }), !0;
          throw error;
        }
        return !0;
      }
      async loadSession(id) {
        await this.ensureReady();
        let row = await this.getSessionTable().findUnique({
          where: { id }
        });
        if (row)
          return this.rowToSession(row);
      }
      async deleteSession(id) {
        await this.ensureReady();
        try {
          await this.getSessionTable().delete({ where: { id } });
        } catch {
          return !0;
        }
        return !0;
      }
      async deleteSessions(ids) {
        return await this.ensureReady(), await this.getSessionTable().deleteMany({ where: { id: { in: ids } } }), !0;
      }
      async findSessionsByShop(shop) {
        return await this.ensureReady(), (await this.getSessionTable().findMany({
          where: { shop },
          take: 25,
          orderBy: [{ expires: "desc" }]
        })).map((session) => this.rowToSession(session));
      }
      async isReady() {
        try {
          await this.pollForTable(), this.ready = Promise.resolve(!0);
        } catch {
          this.ready = Promise.resolve(!1);
        }
        return this.ready;
      }
      async ensureReady() {
        if (!await this.ready)
          throw new MissingSessionStorageError("Prisma session storage is not ready. Use the `isReady` method to poll for the table.");
      }
      async pollForTable() {
        for (let i = 0; i < this.connectionRetries; i++) {
          try {
            await this.getSessionTable().count();
            return;
          } catch (error) {
            console.log(`Error obtaining session table: ${error}`);
          }
          await sleep2(this.connectionRetryIntervalMs);
        }
        throw Error(`The table \`${this.tableName}\` does not exist in the current database.`);
      }
      sessionToRow(session) {
        let sessionParams = session.toObject();
        return {
          id: session.id,
          shop: session.shop,
          state: session.state,
          isOnline: session.isOnline,
          scope: session.scope || null,
          expires: session.expires || null,
          accessToken: session.accessToken || "",
          userId: sessionParams.onlineAccessInfo?.associated_user.id || null,
          firstName: sessionParams.onlineAccessInfo?.associated_user.first_name || null,
          lastName: sessionParams.onlineAccessInfo?.associated_user.last_name || null,
          email: sessionParams.onlineAccessInfo?.associated_user.email || null,
          accountOwner: sessionParams.onlineAccessInfo?.associated_user.account_owner || !1,
          locale: sessionParams.onlineAccessInfo?.associated_user.locale || null,
          collaborator: sessionParams.onlineAccessInfo?.associated_user.collaborator || !1,
          emailVerified: sessionParams.onlineAccessInfo?.associated_user.email_verified || !1
        };
      }
      rowToSession(row) {
        let sessionParams = {
          id: row.id,
          shop: row.shop,
          state: row.state,
          isOnline: row.isOnline,
          userId: String(row.userId),
          firstName: String(row.firstName),
          lastName: String(row.lastName),
          email: String(row.email),
          locale: String(row.locale)
        };
        return row.accountOwner !== null && (sessionParams.accountOwner = row.accountOwner), row.collaborator !== null && (sessionParams.collaborator = row.collaborator), row.emailVerified !== null && (sessionParams.emailVerified = row.emailVerified), row.expires && (sessionParams.expires = row.expires.getTime()), row.scope && (sessionParams.scope = row.scope), row.accessToken && (sessionParams.accessToken = row.accessToken), Session.fromPropertyArray(Object.entries(sessionParams), !0);
      }
      getSessionTable() {
        return this.prisma[this.tableName];
      }
    }, MissingSessionTableError = class extends Error {
      cause;
      constructor(message, cause) {
        super(message), this.cause = cause;
      }
    }, MissingSessionStorageError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
  }
});

// app/shopify.server.ts
var shopify_server_exports = {};
__export(shopify_server_exports, {
  addDocumentResponseHeaders: () => addDocumentResponseHeaders2,
  apiVersion: () => apiVersion,
  authenticate: () => authenticate,
  default: () => shopify_server_default,
  registerWebhooks: () => registerWebhooks,
  sessionStorage: () => sessionStorage2,
  unauthenticated: () => unauthenticated
});
var shopify, shopify_server_default, apiVersion, addDocumentResponseHeaders2, authenticate, unauthenticated, registerWebhooks, sessionStorage2, init_shopify_server = __esm({
  "app/shopify.server.ts"() {
    "use strict";
    init_server2();
    init_prisma();
    init_db();
    shopify = shopifyApp({
      apiKey: process.env.SHOPIFY_API_KEY,
      apiSecretKey: process.env.SHOPIFY_API_SECRET,
      appUrl: process.env.SHOPIFY_APP_URL,
      apiVersion: "2025-10",
      scopes: process.env.SCOPES?.split(",") || ["read_products", "read_inventory", "write_metafields", "read_orders"],
      sessionStorage: new PrismaSessionStorage(db),
      distribution: "app",
      useOnlineTokens: !1,
      // Use offline tokens for background API calls
      hooks: {
        afterAuth: async ({ session }) => {
          console.log("\u{1F50D} afterAuth triggered for shop:", session.shop);
          try {
            let user = await db.user.upsert({
              where: { shopId: session.shop },
              update: {
                accessToken: session.accessToken,
                updatedAt: /* @__PURE__ */ new Date()
              },
              create: {
                shopId: session.shop,
                shopDomain: session.shop,
                accessToken: session.accessToken,
                tier: "starter",
                aiUsage: 0
              }
            });
            console.log("\u2705 User created/updated:", user.id);
          } catch (error) {
            throw console.error("\u274C afterAuth error:", error), error;
          }
        }
      }
    }), shopify_server_default = shopify, apiVersion = "2025-10", addDocumentResponseHeaders2 = shopify.addDocumentResponseHeaders, authenticate = shopify.authenticate, unauthenticated = shopify.unauthenticated, registerWebhooks = shopify.registerWebhooks, sessionStorage2 = shopify.sessionStorage;
  }
});

// app/utils/shopifySync.ts
var shopifySync_exports = {};
__export(shopifySync_exports, {
  ShopifySyncService: () => ShopifySyncService
});
import { GraphQLClient } from "graphql-request";
var PRODUCTS_QUERY, ShopifySyncService, init_shopifySync = __esm({
  "app/utils/shopifySync.ts"() {
    "use strict";
    init_db();
    PRODUCTS_QUERY = `
  query getProducts($first: Int!, $after: String) {
    products(first: $first, after: $after) {
      pageInfo {
        hasNextPage
        endCursor
      }
      edges {
        node {
          id
          title
          description
          handle
          productType
          vendor
          tags
          variants(first: 100) {
            edges {
              node {
                id
                title
                price
                compareAtPrice
                sku
                inventoryQuantity
                availableForSale
              }
            }
          }
          metafields(first: 100) {
            edges {
              node {
                id
                namespace
                key
                value
                type
              }
            }
          }
          images(first: 10) {
            edges {
              node {
                id
                url
                altText
              }
            }
          }
        }
      }
    }
  }
`, ShopifySyncService = class {
      client;
      constructor(shopDomain, accessToken) {
        console.log("\u{1F527} ShopifySyncService constructor [v2]:", {
          shopDomain,
          accessTokenLength: accessToken?.length || 0,
          accessTokenPrefix: accessToken?.substring(0, 10) + "...",
          endpoint: `https://${shopDomain}/admin/api/2025-10/graphql`
        }), this.testAccessToken(shopDomain, accessToken), this.client = new GraphQLClient(
          `https://${shopDomain}/admin/api/2025-10/graphql`,
          {
            headers: {
              "X-Shopify-Access-Token": accessToken,
              "Content-Type": "application/json"
            }
          }
        );
      }
      async testAccessToken(shopDomain, accessToken) {
        try {
          console.log("\u{1F9EA} Testing access token with REST API...");
          let response = await fetch(`https://${shopDomain}/admin/api/2025-10/shop.json`, {
            headers: {
              "X-Shopify-Access-Token": accessToken,
              "Content-Type": "application/json"
            }
          });
          if (console.log("\u{1F9EA} REST API test response:", {
            status: response.status,
            statusText: response.statusText,
            ok: response.ok
          }), response.ok) {
            let data3 = await response.json();
            console.log("\u2705 Access token is valid, shop name:", data3.shop?.name);
          } else
            console.log("\u274C Access token test failed:", response.status, response.statusText);
        } catch (error) {
          console.log("\u274C Access token test error:", error);
        }
      }
      async syncProducts(userId) {
        let allProducts = [], hasNextPage = !0, after, pageCount = 0;
        console.log("\u{1F504} Starting product sync for user:", userId);
        try {
          for (; hasNextPage; ) {
            pageCount++, console.log(`\u{1F4C4} Fetching page ${pageCount}${after ? ` (after: ${after.substring(0, 20)}...)` : " (first page)"}`);
            let startTime = Date.now(), response = await this.client.request(PRODUCTS_QUERY, {
              first: 250,
              after
            }), fetchTime = Date.now() - startTime;
            console.log(`\u23F1\uFE0F  Page ${pageCount} fetched in ${fetchTime}ms`), console.log(`\u{1F4E6} Products in this page: ${response.products.edges.length}`);
            let products = response.products.edges.map((edge) => ({
              id: edge.node.id.replace("gid://shopify/Product/", ""),
              title: edge.node.title,
              description: edge.node.description || "",
              handle: edge.node.handle,
              productType: edge.node.productType || "",
              vendor: edge.node.vendor || "",
              tags: edge.node.tags || [],
              variants: edge.node.variants.edges.map((v) => ({
                id: v.node.id.replace("gid://shopify/ProductVariant/", ""),
                title: v.node.title,
                price: v.node.price,
                compareAtPrice: v.node.compareAtPrice,
                sku: v.node.sku,
                inventoryQuantity: v.node.inventoryQuantity,
                availableForSale: v.node.availableForSale
              })),
              metafields: edge.node.metafields.edges.map((m) => ({
                id: m.node.id.replace("gid://shopify/Metafield/", ""),
                namespace: m.node.namespace,
                key: m.node.key,
                value: m.node.value,
                type: m.node.type
              })),
              images: edge.node.images.edges.map((i) => ({
                id: i.node.id.replace("gid://shopify/MediaImage/", ""),
                url: i.node.url,
                altText: i.node.altText
              }))
            }));
            allProducts.push(...products), console.log(`\u{1F4CA} Total products so far: ${allProducts.length}`), hasNextPage = response.products.pageInfo.hasNextPage, after = response.products.pageInfo.endCursor, console.log(`\u{1F517} Has next page: ${hasNextPage}`), hasNextPage && (console.log("\u23F3 Waiting 500ms before next request..."), await new Promise((resolve) => setTimeout(resolve, 500)));
          }
          return console.log(`\u2705 Sync complete! Total products: ${allProducts.length}`), await db.log.create({
            data: {
              userId,
              type: "sync",
              message: `Synchronized ${allProducts.length} products from Shopify`,
              metadata: {
                productsCount: allProducts.length,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              }
            }
          }), allProducts;
        } catch (error) {
          throw console.error("\u274C Sync failed:", error), console.error("\u274C Error details:", {
            message: error instanceof Error ? error.message : "Unknown error",
            stack: error instanceof Error ? error.stack : String(error),
            pageCount,
            totalProducts: allProducts.length
          }), await db.log.create({
            data: {
              userId,
              type: "error",
              message: `Failed to sync products: ${error instanceof Error ? error.message : "Unknown error"}`,
              error: error instanceof Error ? error.stack : String(error),
              metadata: {
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                pageCount,
                totalProducts: allProducts.length
              }
            }
          }), error;
        }
      }
      async getInventoryLevels(shopDomain, accessToken) {
        try {
          let response = await fetch(
            `https://${shopDomain}/admin/api/2025-10/inventory_levels.json`,
            {
              headers: {
                "X-Shopify-Access-Token": accessToken,
                "Content-Type": "application/json"
              }
            }
          );
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          return (await response.json()).inventory_levels || [];
        } catch (error) {
          throw console.error("Error fetching inventory levels:", error), error;
        }
      }
      async getRecentOrders(shopDomain, accessToken, limit = 50) {
        try {
          let response = await fetch(
            `https://${shopDomain}/admin/api/2025-10/orders.json?limit=${limit}&status=any`,
            {
              headers: {
                "X-Shopify-Access-Token": accessToken,
                "Content-Type": "application/json"
              }
            }
          );
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          return (await response.json()).orders || [];
        } catch (error) {
          throw console.error("Error fetching orders:", error), error;
        }
      }
    };
  }
});

// app/utils/openaiSpec.ts
function getFieldInputType(fieldName) {
  return FIELD_INPUT_TYPES.customer_input_required.includes(fieldName) ? "customer_required" : FIELD_INPUT_TYPES.ai_generatable.includes(fieldName) ? "ai_generatable" : FIELD_INPUT_TYPES.core_required.includes(fieldName) ? "core_required" : "customer_required";
}
var OPENAI_PRODUCT_SCHEMA, FIELD_WEIGHTS, FIELD_POINTS, FIELD_INPUT_TYPES, FIELD_LABELS, init_openaiSpec = __esm({
  "app/utils/openaiSpec.ts"() {
    "use strict";
    OPENAI_PRODUCT_SCHEMA = {
      type: "object",
      required: [
        "title",
        "description",
        "price",
        "availability",
        "category"
      ],
      properties: {
        // Core Product Information
        title: {
          type: "string",
          maxLength: 150,
          description: "Product title - clear, descriptive, keyword-rich"
        },
        description: {
          type: "string",
          minLength: 100,
          maxLength: 4e3,
          description: "Detailed product description with features, benefits, use cases"
        },
        price: {
          type: "string",
          pattern: "^\\d+\\.\\d{2} [A-Z]{3}$",
          description: "Price in format 'XX.XX USD'"
        },
        availability: {
          type: "string",
          enum: ["in_stock", "out_of_stock", "pre_order", "discontinued"],
          description: "Current availability status"
        },
        category: {
          type: "string",
          description: "Product category for classification"
        },
        // Physical Attributes
        material: {
          type: "string",
          description: "Primary material composition"
        },
        dimensions: {
          type: "object",
          properties: {
            length: { type: "string", description: "Length with unit" },
            width: { type: "string", description: "Width with unit" },
            height: { type: "string", description: "Height with unit" }
          },
          description: "Product dimensions"
        },
        weight: {
          type: "string",
          description: "Product weight with unit"
        },
        color: {
          type: "string",
          description: "Primary color"
        },
        size: {
          type: "string",
          description: "Size information"
        },
        // Functional Attributes
        brand: {
          type: "string",
          description: "Brand or manufacturer"
        },
        model: {
          type: "string",
          description: "Model number or name"
        },
        sku: {
          type: "string",
          description: "Stock keeping unit"
        },
        upc: {
          type: "string",
          description: "Universal Product Code"
        },
        // Usage and Context
        use_cases: {
          type: "array",
          items: { type: "string" },
          description: "List of use cases and applications"
        },
        target_audience: {
          type: "string",
          description: "Primary target audience"
        },
        age_range: {
          type: "string",
          description: "Recommended age range"
        },
        gender: {
          type: "string",
          enum: ["male", "female", "unisex", "kids"],
          description: "Target gender"
        },
        // Technical Specifications
        features: {
          type: "array",
          items: { type: "string" },
          description: "Key product features"
        },
        specifications: {
          type: "object",
          description: "Technical specifications as key-value pairs"
        },
        compatibility: {
          type: "array",
          items: { type: "string" },
          description: "Compatibility information"
        },
        // SEO and Search
        keywords: {
          type: "array",
          items: { type: "string" },
          description: "SEO keywords for search optimization"
        },
        tags: {
          type: "array",
          items: { type: "string" },
          description: "Product tags for categorization"
        },
        // Media and Links
        image_urls: {
          type: "array",
          items: { type: "string" },
          description: "High-quality product image URLs"
        },
        video_urls: {
          type: "array",
          items: { type: "string" },
          description: "Product video URLs"
        },
        documentation_url: {
          type: "string",
          format: "uri",
          description: "Link to product documentation"
        },
        // Business Information
        vendor: {
          type: "string",
          description: "Vendor or supplier"
        },
        warranty: {
          type: "string",
          description: "Warranty information"
        },
        return_policy: {
          type: "string",
          description: "Return policy information"
        },
        shipping_info: {
          type: "string",
          description: "Shipping information"
        },
        // AI-Specific Fields
        ai_search_queries: {
          type: "array",
          items: { type: "string" },
          description: "Sample AI search queries this product should match"
        },
        semantic_description: {
          type: "string",
          description: "AI-optimized semantic description for better matching"
        }
      }
    }, FIELD_WEIGHTS = {
      // Required fields (must be 100% complete) - Higher impact
      required: {
        title: 2.5,
        description: 2.5,
        price: 2,
        availability: 2,
        category: 2
      },
      // High importance optional fields (critical for AI search) - Meaningful impact
      high: {
        material: 2,
        dimensions: 2,
        weight: 1.8,
        brand: 2,
        use_cases: 2.2,
        features: 2,
        image_urls: 1.8
      },
      // Medium importance fields (enhance discoverability) - Good impact
      medium: {
        color: 1.5,
        size: 1.5,
        target_audience: 1.8,
        keywords: 1.8,
        upc: 1.2,
        compatibility: 1.5,
        age_range: 1.2,
        gender: 1.2,
        video_urls: 1.5
      },
      // Low importance fields (nice to have) - Still meaningful
      low: {
        model: 1,
        sku: 1.2,
        tags: 1.2,
        vendor: 1,
        warranty: 1,
        return_policy: 1,
        shipping_info: 1,
        documentation_url: 1,
        specifications: 1.2,
        ai_search_queries: 1,
        semantic_description: 1
      }
    }, FIELD_POINTS = {
      required: {
        title: 25,
        description: 25,
        price: 20,
        availability: 20,
        category: 20
      },
      high: {
        material: 20,
        dimensions: 20,
        weight: 18,
        brand: 20,
        use_cases: 22,
        features: 20,
        image_urls: 18
      },
      medium: {
        color: 15,
        size: 15,
        target_audience: 18,
        keywords: 18,
        upc: 12,
        compatibility: 15,
        age_range: 12,
        gender: 12,
        video_urls: 15
      },
      low: {
        model: 10,
        sku: 12,
        tags: 12,
        vendor: 10,
        warranty: 10,
        return_policy: 10,
        shipping_info: 10,
        documentation_url: 10,
        specifications: 12,
        ai_search_queries: 10,
        semantic_description: 10
      }
    }, FIELD_INPUT_TYPES = {
      // Fields that REQUIRE customer/brand input - AI cannot determine these accurately
      customer_input_required: [
        // Physical specifications (only the brand/manufacturer knows these)
        "material",
        "dimensions",
        "weight",
        "color",
        "size",
        // Identification & business info (brand-specific data)
        "brand",
        "model",
        "upc",
        "vendor",
        // Age/gender restrictions (brand policy)
        "age_range",
        "gender",
        "compatibility",
        // Business policies (company-specific)
        "warranty",
        "return_policy",
        "shipping_info",
        "specifications",
        "documentation_url",
        "video_urls"
      ],
      // Fields that AI can generate based on product info
      ai_generatable: [
        // Marketing content (AI can create based on existing product data)
        "description",
        "use_cases",
        "features",
        "keywords",
        "tags",
        "target_audience",
        "sku",
        "ai_search_queries",
        "semantic_description"
      ],
      // Core required fields (must exist, usually already present)
      core_required: [
        "title",
        "price",
        "availability",
        "category",
        "image_urls"
      ]
    };
    FIELD_LABELS = {
      material: "Material",
      dimensions: "Dimensions",
      weight: "Weight",
      color: "Color",
      size: "Size",
      brand: "Brand",
      model: "Model",
      upc: "UPC/Barcode",
      vendor: "Vendor",
      age_range: "Age Range",
      gender: "Target Gender",
      compatibility: "Compatibility",
      warranty: "Warranty Info",
      return_policy: "Return Policy",
      shipping_info: "Shipping Info",
      specifications: "Technical Specs",
      documentation_url: "Documentation URL",
      video_urls: "Video URLs"
    };
  }
});

// app/utils/fieldMapper.ts
var fieldMapper_exports = {};
__export(fieldMapper_exports, {
  calculateProductScore: () => calculateProductScore,
  mapProductsToSpec: () => mapProductsToSpec,
  mapShopifyToSpec: () => mapShopifyToSpec
});
function mapShopifyToSpec(product) {
  let spec = {
    // Core required fields - map directly from Shopify
    title: product.title || "",
    description: product.description || "",
    price: product.variants[0]?.price ? `${product.variants[0].price} USD` : "0.00 USD",
    availability: getAvailabilityStatus(product.variants),
    category: product.productType || "Uncategorized",
    // Physical attributes - from metafields or inference
    material: getMetafieldValue(product.metafields, "material") || inferMaterial(product.title, product.description),
    weight: getMetafieldValue(product.metafields, "weight"),
    color: getMetafieldValue(product.metafields, "color") || inferColor(product.title, product.description),
    size: getMetafieldValue(product.metafields, "size"),
    // Identification fields
    brand: product.vendor || getMetafieldValue(product.metafields, "brand"),
    model: getMetafieldValue(product.metafields, "model"),
    sku: product.variants[0]?.sku,
    upc: getMetafieldValue(product.metafields, "upc") || getMetafieldValue(product.metafields, "barcode"),
    // Usage and context
    use_cases: getMetafieldArray(product.metafields, "use_cases") || inferUseCases(product.title, product.description),
    target_audience: getMetafieldValue(product.metafields, "target_audience"),
    age_range: getMetafieldValue(product.metafields, "age_range"),
    gender: getMetafieldValue(product.metafields, "gender"),
    // Technical specifications
    features: getMetafieldArray(product.metafields, "features") || inferFeatures(product.description),
    compatibility: getMetafieldArray(product.metafields, "compatibility"),
    // SEO and search
    keywords: product.tags || [],
    tags: product.tags || [],
    // Media
    image_urls: product.images.map((img) => img.url),
    video_urls: getMetafieldArray(product.metafields, "video_urls") || getMetafieldArray(product.metafields, "videos"),
    documentation_url: getMetafieldValue(product.metafields, "documentation_url") || getMetafieldValue(product.metafields, "manual_url"),
    // Business information
    vendor: product.vendor,
    warranty: getMetafieldValue(product.metafields, "warranty"),
    return_policy: getMetafieldValue(product.metafields, "return_policy"),
    shipping_info: getMetafieldValue(product.metafields, "shipping_info"),
    // AI-specific fields
    ai_search_queries: getMetafieldArray(product.metafields, "ai_search_queries"),
    semantic_description: getMetafieldValue(product.metafields, "semantic_description")
  }, dimensions = getDimensionsFromMetafields(product.metafields);
  dimensions && (spec.dimensions = dimensions);
  let specifications = getSpecificationsFromMetafields(product.metafields);
  return specifications && Object.keys(specifications).length > 0 && (spec.specifications = specifications), spec;
}
function getAvailabilityStatus(variants) {
  if (variants.length === 0)
    return "out_of_stock";
  let hasAvailable = variants.some((v) => v.availableForSale && (v.inventoryQuantity || 0) > 0), hasInventory = variants.some((v) => (v.inventoryQuantity || 0) > 0);
  return hasAvailable ? "in_stock" : hasInventory && !hasAvailable ? "pre_order" : "out_of_stock";
}
function getMetafieldValue(metafields, key) {
  let metafield = metafields.find(
    (m) => m.namespace === "catalogai" && (m.key === key || m.key.toLowerCase().includes(key.toLowerCase()))
  );
  return metafield || (metafield = metafields.find(
    (m) => m.key === key || m.key.toLowerCase().includes(key.toLowerCase())
  )), metafield?.value;
}
function getMetafieldArray(metafields, key) {
  let value = getMetafieldValue(metafields, key);
  if (value)
    try {
      let parsed = JSON.parse(value);
      if (Array.isArray(parsed))
        return parsed.filter((item) => typeof item == "string");
    } catch {
      return value.includes(`
-`) || value.startsWith("-") ? value.split(`
`).map((line) => line.replace(/^[-*]\s*/, "").trim()).filter(Boolean) : value.split(/[,;|]/).map((item) => item.trim()).filter(Boolean);
    }
}
function getDimensionsFromMetafields(metafields) {
  let length = getMetafieldValue(metafields, "length"), width2 = getMetafieldValue(metafields, "width"), height2 = getMetafieldValue(metafields, "height");
  return !length && !width2 && !height2 ? null : {
    ...length && { length },
    ...width2 && { width: width2 },
    ...height2 && { height: height2 }
  };
}
function getSpecificationsFromMetafields(metafields) {
  let specs = {}, specMetafields = metafields.filter(
    (m) => m.namespace === "specifications" || m.namespace === "specs"
  );
  for (let metafield of specMetafields)
    specs[metafield.key] = metafield.value;
  return Object.keys(specs).length > 0 ? specs : null;
}
function inferMaterial(title, description) {
  let materialKeywords = [
    "cotton",
    "polyester",
    "leather",
    "metal",
    "wood",
    "plastic",
    "glass",
    "ceramic",
    "fabric",
    "denim",
    "silk",
    "wool",
    "bamboo",
    "steel",
    "aluminum",
    "bronze",
    "silver",
    "gold",
    "rubber",
    "silicone"
  ], text2 = `${title} ${description}`.toLowerCase();
  for (let material of materialKeywords)
    if (text2.includes(material))
      return material.charAt(0).toUpperCase() + material.slice(1);
}
function inferColor(title, description) {
  let colorKeywords = [
    "red",
    "blue",
    "green",
    "yellow",
    "black",
    "white",
    "gray",
    "grey",
    "pink",
    "purple",
    "orange",
    "brown",
    "beige",
    "navy",
    "maroon"
  ], text2 = `${title} ${description}`.toLowerCase();
  for (let color2 of colorKeywords)
    if (text2.includes(color2))
      return color2.charAt(0).toUpperCase() + color2.slice(1);
}
function inferUseCases(title, description) {
  let useCaseKeywords = [
    "home",
    "office",
    "kitchen",
    "bedroom",
    "bathroom",
    "garden",
    "outdoor",
    "travel",
    "sports",
    "fitness",
    "workout",
    "cooking",
    "cleaning",
    "decorative",
    "functional",
    "storage",
    "organization"
  ], text2 = `${title} ${description}`.toLowerCase(), foundUseCases = [];
  for (let useCase of useCaseKeywords)
    text2.includes(useCase) && foundUseCases.push(useCase.charAt(0).toUpperCase() + useCase.slice(1));
  return foundUseCases;
}
function inferFeatures(description) {
  let featureKeywords = [
    "waterproof",
    "durable",
    "lightweight",
    "compact",
    "portable",
    "adjustable",
    "reversible",
    "washable",
    "dishwasher safe",
    "battery powered",
    "cordless",
    "wireless",
    "bluetooth",
    "stainless steel",
    "non-stick",
    "heat resistant"
  ], text2 = description.toLowerCase(), foundFeatures = [];
  for (let feature of featureKeywords)
    text2.includes(feature) && foundFeatures.push(feature.charAt(0).toUpperCase() + feature.slice(1));
  return foundFeatures;
}
function calculateProductScore(spec) {
  let gaps = [], recommendations = [], totalWeight = 0, weightedScore = 0, totalPoints = 0, maxPossiblePoints = 0, fieldProgress = {}, categoryProgress = {
    required: { completed: 0, total: 0, points: 0 },
    high: { completed: 0, total: 0, points: 0 },
    medium: { completed: 0, total: 0, points: 0 },
    low: { completed: 0, total: 0, points: 0 }
  }, hasValue = (value) => value != null && (typeof value != "string" || value.trim() !== "") && (!Array.isArray(value) || value.length > 0) && (typeof value != "object" || Object.keys(value).length > 0);
  [
    { name: "required", fields: FIELD_WEIGHTS.required, points: FIELD_POINTS.required },
    { name: "high", fields: FIELD_WEIGHTS.high, points: FIELD_POINTS.high },
    { name: "medium", fields: FIELD_WEIGHTS.medium, points: FIELD_POINTS.medium },
    { name: "low", fields: FIELD_WEIGHTS.low, points: FIELD_POINTS.low }
  ].forEach(({ name, fields, points }) => {
    categoryProgress[name].total = Object.keys(fields).length;
    for (let [field, weight] of Object.entries(fields)) {
      totalWeight += weight, maxPossiblePoints += points[field];
      let value = spec[field], completed = hasValue(value);
      fieldProgress[field] = {
        completed,
        category: name,
        points: points[field],
        weight
      }, completed ? (weightedScore += weight, totalPoints += points[field], categoryProgress[name].completed++, categoryProgress[name].points += points[field]) : (gaps.push(field), name === "high" && recommendations.push(`Add ${field} to improve product discoverability`));
    }
  });
  let score = totalWeight > 0 ? Math.round(weightedScore / totalWeight * 100) : 0, totalFields = Object.keys(fieldProgress).length, completedFields = Object.values(fieldProgress).filter((f) => f.completed).length, completeness = totalFields > 0 ? Math.round(completedFields / totalFields * 100) : 0;
  return {
    score,
    completeness,
    gaps,
    recommendations,
    points: totalPoints,
    maxPoints: maxPossiblePoints,
    fieldProgress,
    categoryProgress
  };
}
function mapProductsToSpec(products) {
  return products.map((product) => {
    let spec = mapShopifyToSpec(product), score = calculateProductScore(spec);
    return {
      ...spec,
      originalId: product.id,
      score
    };
  });
}
var init_fieldMapper = __esm({
  "app/utils/fieldMapper.ts"() {
    "use strict";
    init_openaiSpec();
  }
});

// app/utils/aiClient.ts
import OpenAI from "openai";
var openai, AIClient, init_aiClient = __esm({
  "app/utils/aiClient.ts"() {
    "use strict";
    init_db();
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    }), AIClient = class {
      async trackUsage(userId, usage) {
        try {
          await db.user.update({
            where: { id: userId },
            data: {
              aiUsage: {
                increment: usage.totalTokens
              }
            }
          });
        } catch (error) {
          console.error("Failed to track AI usage:", error);
        }
      }
      async enrichDescription(userId, title, currentDescription, category, material) {
        let prompt = `You are an expert product copywriter specializing in e-commerce optimization for AI search systems. 

Your task is to enrich the following product description to make it more comprehensive, SEO-friendly, and optimized for AI search queries. The description should be between 400-4000 characters and written in plain text (no HTML).

Product Information:
- Title: ${title}
- Category: ${category || "Not specified"}
- Material: ${material || "Not specified"}
- Current Description: ${currentDescription}

Requirements:
1. Expand the description with specific details about features, benefits, and use cases
2. Include relevant keywords that customers might search for
3. Add information about dimensions, weight, or other specifications if relevant
4. Mention target audience and ideal use cases
5. Use descriptive, engaging language that highlights product value
6. Ensure the description flows naturally and is easy to read
7. Do not include HTML tags or special formatting
8. Focus on factual, helpful information that aids in product discovery

Return only the enriched description text.`;
        try {
          let response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "system",
                content: "You are a professional product copywriter who creates detailed, SEO-optimized product descriptions for e-commerce platforms."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 1e3,
            temperature: 0.7
          }), enriched = response.choices[0]?.message?.content || currentDescription, usage = {
            promptTokens: response.usage?.prompt_tokens || 0,
            completionTokens: response.usage?.completion_tokens || 0,
            totalTokens: response.usage?.total_tokens || 0
          };
          return await this.trackUsage(userId, usage), { enriched, usage };
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to enrich description: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      async inferMaterial(userId, title, description, category) {
        let prompt = `Based on the following product information, determine the most likely primary material composition. Return only the material name.

Product Information:
- Title: ${title}
- Category: ${category || "Not specified"}
- Description: ${description}

Common materials include: cotton, polyester, leather, metal, wood, plastic, glass, ceramic, fabric, denim, silk, wool, bamboo, steel, aluminum, bronze, silver, gold, rubber, silicone, etc.

If the material is unclear, return "Unknown". Return only the material name, nothing else.`;
        try {
          let response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "system",
                content: "You are a product analyst who identifies material composition from product descriptions."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 50,
            temperature: 0.3
          }), material = response.choices[0]?.message?.content?.trim() || "Unknown", usage = {
            promptTokens: response.usage?.prompt_tokens || 0,
            completionTokens: response.usage?.completion_tokens || 0,
            totalTokens: response.usage?.total_tokens || 0
          };
          return await this.trackUsage(userId, usage), { material, usage };
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to infer material: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      async generateUseCases(userId, title, description, category) {
        let prompt = `Based on the following product information, generate 3-5 specific use cases or applications for this product. Return the use cases as a JSON array of strings.

Product Information:
- Title: ${title}
- Category: ${category || "Not specified"}
- Description: ${description}

Focus on practical, specific use cases that would help customers understand how to use this product. Examples might include specific activities, environments, or situations where the product would be useful.

Return only a JSON array like: ["Use case 1", "Use case 2", "Use case 3"]`;
        try {
          let response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "system",
                content: "You are a product analyst who identifies practical use cases for products."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 200,
            temperature: 0.7
          }), content = response.choices[0]?.message?.content || "[]", useCases = [];
          try {
            useCases = JSON.parse(content), Array.isArray(useCases) || (useCases = []);
          } catch {
            useCases = [];
          }
          let usage = {
            promptTokens: response.usage?.prompt_tokens || 0,
            completionTokens: response.usage?.completion_tokens || 0,
            totalTokens: response.usage?.total_tokens || 0
          };
          return await this.trackUsage(userId, usage), { useCases, usage };
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to generate use cases: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      async generateFeatures(userId, title, description, category) {
        let prompt = `Based on the following product information, extract and generate 3-6 key features or characteristics of this product. Return the features as a JSON array of strings.

Product Information:
- Title: ${title}
- Category: ${category || "Not specified"}
- Description: ${description}

Focus on specific, factual features that highlight the product's benefits or characteristics. These should be features that customers would care about when making a purchase decision.

Return only a JSON array like: ["Feature 1", "Feature 2", "Feature 3"]`;
        try {
          let response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "system",
                content: "You are a product analyst who extracts key features from product descriptions."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 200,
            temperature: 0.5
          }), content = response.choices[0]?.message?.content || "[]", features = [];
          try {
            features = JSON.parse(content), Array.isArray(features) || (features = []);
          } catch {
            features = [];
          }
          let usage = {
            promptTokens: response.usage?.prompt_tokens || 0,
            completionTokens: response.usage?.completion_tokens || 0,
            totalTokens: response.usage?.total_tokens || 0
          };
          return await this.trackUsage(userId, usage), { features, usage };
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to generate features: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      async generateKeywords(userId, title, description, category) {
        let prompt = `Based on the following product information, generate 5-10 relevant SEO keywords that customers might use to search for this product. Return the keywords as a JSON array of strings.

Product Information:
- Title: ${title}
- Category: ${category || "Not specified"}
- Description: ${description}

Focus on keywords that are:
1. Relevant to the product
2. Commonly used in search queries
3. Specific enough to be meaningful
4. Broad enough to capture search volume

Include a mix of short-tail and long-tail keywords.

Return only a JSON array like: ["keyword 1", "keyword 2", "keyword 3"]`;
        try {
          let response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "system",
                content: "You are an SEO specialist who generates relevant keywords for product optimization."
              },
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: 200,
            temperature: 0.6
          }), content = response.choices[0]?.message?.content || "[]", keywords = [];
          try {
            keywords = JSON.parse(content), Array.isArray(keywords) || (keywords = []);
          } catch {
            keywords = [];
          }
          let usage = {
            promptTokens: response.usage?.prompt_tokens || 0,
            completionTokens: response.usage?.completion_tokens || 0,
            totalTokens: response.usage?.total_tokens || 0
          };
          return await this.trackUsage(userId, usage), { keywords, usage };
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to generate keywords: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      async generateText(prompt, maxTokens = 100) {
        try {
          return ((await openai.chat.completions.create({
            model: "gpt-3.5-turbo",
            messages: [
              {
                role: "user",
                content: prompt
              }
            ],
            max_tokens: maxTokens,
            temperature: 0.7
          })).choices[0]?.message?.content || "").trim();
        } catch (error) {
          throw console.error("OpenAI API error:", error), new Error(`Failed to generate text: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    };
  }
});

// app/utils/aiEnrich.ts
var aiEnrich_exports = {};
__export(aiEnrich_exports, {
  AIEnrichmentService: () => AIEnrichmentService
});
var AIEnrichmentService, init_aiEnrich = __esm({
  "app/utils/aiEnrich.ts"() {
    "use strict";
    init_aiClient();
    init_db();
    AIEnrichmentService = class {
      aiClient;
      constructor() {
        this.aiClient = new AIClient();
      }
      async enrichProduct(userId, product, gaps = []) {
        let improvements = [], errors = [], totalUsage = 0, baseSpec = {
          title: product.title || "",
          description: product.description || "",
          price: product.variants[0]?.price ? `${product.variants[0].price} USD` : "0.00 USD",
          availability: this.getAvailabilityStatus(product.variants),
          category: product.productType || "Uncategorized",
          sku: product.variants[0]?.sku,
          image_urls: product.images.map((img) => img.url),
          vendor: product.vendor
        };
        console.log("\u{1F3AF} Enriching product for gaps:", gaps);
        for (let gap of gaps)
          try {
            let result = await this.generateRecommendationForGap(gap, baseSpec, userId);
            result && (improvements.push(result), totalUsage += result.newValue?.length || 0);
          } catch (error) {
            errors.push(`Failed to generate recommendation for ${gap}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        return {
          originalProduct: product,
          enrichedSpec: baseSpec,
          improvements,
          totalUsage,
          errors
        };
      }
      async generateRecommendationForGap(gap, baseSpec, userId) {
        if ([
          "material",
          "dimensions",
          "weight",
          "color",
          "size",
          "model",
          "brand",
          "vendor",
          "upc",
          "age_range",
          "gender",
          "compatibility",
          "specifications",
          "video_urls",
          "documentation_url",
          "return_policy",
          "shipping_info"
        ].includes(gap))
          return {
            field: gap,
            originalValue: baseSpec[gap] || null,
            newValue: "Need Customer Input",
            improvement: "This field requires actual product specifications from the brand/manufacturer"
          };
        let mapping = {
          description: {
            prompt: `Given the product title "${baseSpec.title}", generate a comprehensive and engaging product description. Highlight its key features, benefits, and target audience. Aim for a length of at least 200 words. Current description: "${baseSpec.description || "No description"}"`,
            maxTokens: 500,
            reason: "Generated comprehensive product description"
          },
          use_cases: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", generate a comma-separated list of 3-5 practical use cases or scenarios where this product would be ideal. Focus on how a customer would use it.`,
            maxTokens: 100,
            reason: "Generated practical use cases"
          },
          features: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", generate a bulleted list of 3-5 key features of the product. Focus on unique selling points and technical specifications.`,
            maxTokens: 150,
            reason: "Generated key product features"
          },
          keywords: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", generate a comma-separated list of relevant keywords for SEO and search. Focus on terms a customer would use to find this product. Do not include the product title itself as a keyword.`,
            maxTokens: 100,
            reason: "Generated SEO keywords"
          },
          target_audience: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", suggest the primary target audience for this product (e.g., 'Beginner snowboarders', 'Professional athletes', 'Casual users').`,
            maxTokens: 50,
            reason: "Suggested target audience"
          },
          sku: {
            prompt: `Given the product title "${baseSpec.title}", description "${baseSpec.description}", and current SKU "${baseSpec.sku || "N/A"}", suggest a concise SKU for the product if it's missing or generic. If a good SKU exists, state 'N/A'.`,
            maxTokens: 20,
            reason: "Suggested concise SKU"
          },
          tags: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", generate a comma-separated list of relevant tags for product categorization and search. Focus on broad categories and attributes.`,
            maxTokens: 100,
            reason: "Generated relevant tags"
          },
          warranty: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", suggest typical warranty information for this type of product (e.g., '1-year limited warranty', 'Manufacturer warranty applies').`,
            maxTokens: 50,
            reason: "Suggested warranty information"
          },
          ai_search_queries: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", generate 5-7 example search queries that customers might use to find this product when using AI search or voice search. Focus on natural language queries.`,
            maxTokens: 150,
            reason: "Generated AI search query examples"
          },
          semantic_description: {
            prompt: `Given the product title "${baseSpec.title}" and description "${baseSpec.description}", create a concise semantic description optimized for AI understanding. Focus on key attributes, use cases, and context in 2-3 sentences.`,
            maxTokens: 150,
            reason: "Generated AI-optimized semantic description"
          },
          image_urls: {
            prompt: "Note: Image URLs cannot be generated by AI. This field requires actual product images to be uploaded to Shopify.",
            maxTokens: 10,
            reason: "Images require manual upload"
          }
        }[gap];
        if (!mapping)
          return console.log(`\u26A0\uFE0F No mapping found for gap: ${gap}`), null;
        try {
          let aiResponse = await this.aiClient.generateText(mapping.prompt, mapping.maxTokens);
          if (console.log(`\u{1F916} AI Response for ${gap}:`, aiResponse), aiResponse && aiResponse.trim() !== "" && !aiResponse.toLowerCase().includes("error") && aiResponse.trim().toLowerCase() !== "n/a")
            return {
              field: gap,
              originalValue: baseSpec[gap] || null,
              newValue: aiResponse,
              improvement: mapping.reason
            };
          console.log(`\u26A0\uFE0F Skipping ${gap}: Response was empty, N/A, or contained error`);
        } catch (error) {
          console.error(`Error generating recommendation for ${gap}:`, error);
        }
        return null;
      }
      async enrichProducts(userId, products, options = {}) {
        let results = [];
        for (let product of products)
          try {
            let { mapShopifyToSpec: mapShopifyToSpec2, calculateProductScore: calculateProductScore2 } = await Promise.resolve().then(() => (init_fieldMapper(), fieldMapper_exports)), spec = mapShopifyToSpec2(product), gaps = calculateProductScore2(spec).gaps;
            console.log(`\u{1F3AF} Enriching product ${product.title} with gaps:`, gaps);
            let result = await this.enrichProduct(userId, product, gaps);
            results.push(result);
          } catch (error) {
            console.error(`Failed to enrich product ${product.title}:`, error), results.push({
              originalProduct: product,
              enrichedSpec: {},
              improvements: [],
              totalUsage: 0,
              errors: [`Failed to enrich product: ${error instanceof Error ? error.message : "Unknown error"}`]
            });
          }
        return results;
      }
      async applyEnrichmentToShopify(userId, shopDomain, accessToken, enrichmentResult) {
        try {
          console.log("\u{1F504} Applying enrichment to Shopify with improvements:", enrichmentResult.improvements.length);
          for (let improvement of enrichmentResult.improvements) {
            let { field, newValue } = improvement;
            if (console.log(`\u{1F4DD} Applying ${field}: ${newValue}`), field === "description")
              await this.updateProductDescription(
                shopDomain,
                accessToken,
                enrichmentResult.originalProduct.id,
                newValue
              ), console.log("\u2705 Updated product description");
            else {
              let metafieldType = this.getMetafieldType(field, newValue), metafieldValue = this.formatMetafieldValue(field, newValue);
              console.log("\u{1F4DD} Creating metafield:", {
                namespace: "catalogai",
                key: field,
                type: metafieldType,
                originalValue: newValue,
                formattedValue: metafieldValue,
                valueType: typeof newValue
              }), await this.createProductMetafield(
                shopDomain,
                accessToken,
                enrichmentResult.originalProduct.id,
                {
                  namespace: "catalogai",
                  key: field,
                  value: metafieldValue,
                  type: metafieldType
                }
              ), console.log(`\u2705 Updated metafield: catalogai.${field}`);
            }
          }
          return await db.log.create({
            data: {
              userId,
              type: "enrichment",
              message: `Applied AI enrichment to product: ${enrichmentResult.originalProduct.title}`,
              metadata: {
                productId: enrichmentResult.originalProduct.id,
                improvements: enrichmentResult.improvements.length,
                usage: enrichmentResult.totalUsage,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              }
            }
          }), !0;
        } catch (error) {
          return console.error("Failed to apply enrichment to Shopify:", error), await db.log.create({
            data: {
              userId,
              type: "error",
              message: `Failed to apply enrichment to Shopify: ${error instanceof Error ? error.message : "Unknown error"}`,
              error: error instanceof Error ? error.stack : String(error),
              metadata: {
                productId: enrichmentResult.originalProduct.id,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              }
            }
          }), !1;
        }
      }
      getMetafieldType(field, value) {
        return field === "dimensions" || ["use_cases", "features", "keywords", "ai_search_queries"].includes(field) ? "json" : ["weight", "price"].includes(field) ? "number_decimal" : (field === "availability", "single_line_text_field");
      }
      formatMetafieldValue(field, value) {
        if (typeof value == "object" || Array.isArray(value))
          return JSON.stringify(value);
        if (["use_cases", "features", "keywords", "ai_search_queries", "tags"].includes(field)) {
          let stringValue = String(value);
          if (stringValue.includes(`
-`) || stringValue.startsWith("-")) {
            let items = stringValue.split(`
`).map((line) => line.replace(/^[-*]\s*/, "").trim()).filter(Boolean);
            return JSON.stringify(items);
          }
          if (stringValue.includes(",")) {
            let items = stringValue.split(",").map((item) => item.trim()).filter(Boolean);
            return JSON.stringify(items);
          }
          return JSON.stringify([stringValue]);
        }
        return String(value);
      }
      getAvailabilityStatus(variants) {
        if (variants.length === 0)
          return "out_of_stock";
        let hasAvailable = variants.some((v) => v.availableForSale && (v.inventoryQuantity || 0) > 0), hasInventory = variants.some((v) => (v.inventoryQuantity || 0) > 0);
        return hasAvailable ? "in_stock" : hasInventory && !hasAvailable ? "pre_order" : "out_of_stock";
      }
      getMetafieldValue(metafields, key) {
        return metafields.find(
          (m) => m.key === key || m.key.toLowerCase().includes(key.toLowerCase())
        )?.value;
      }
      getMetafieldArray(metafields, key) {
        let value = this.getMetafieldValue(metafields, key);
        if (value)
          try {
            let parsed = JSON.parse(value);
            if (Array.isArray(parsed))
              return parsed.filter((item) => typeof item == "string");
          } catch {
            return value.split(/[,;|]/).map((item) => item.trim()).filter(Boolean);
          }
      }
      async updateProductDescription(shopDomain, accessToken, productId, description) {
        let mutation = `
      mutation productUpdate($input: ProductInput!) {
        productUpdate(input: $input) {
          product {
            id
            title
            descriptionHtml
          }
          userErrors {
            field
            message
          }
        }
      }
    `, variables = {
          input: {
            id: `gid://shopify/Product/${productId}`,
            descriptionHtml: description
          }
        }, response = await fetch(`https://${shopDomain}/admin/api/2025-10/graphql`, {
          method: "POST",
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: mutation,
            variables
          })
        });
        if (!response.ok)
          throw new Error(`Failed to update product description: ${response.status}`);
        let result = await response.json();
        if (result.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(result.errors)}`);
        if (result.data?.productUpdate?.userErrors?.length > 0)
          throw new Error(`Shopify validation errors: ${JSON.stringify(result.data.productUpdate.userErrors)}`);
      }
      async createProductMetafield(shopDomain, accessToken, productId, metafield) {
        let mutation = `
      mutation metafieldsSet($metafields: [MetafieldsSetInput!]!) {
        metafieldsSet(metafields: $metafields) {
          metafields {
            id
            namespace
            key
            value
          }
          userErrors {
            field
            message
          }
        }
      }
    `, variables = {
          metafields: [
            {
              ownerId: `gid://shopify/Product/${productId}`,
              namespace: metafield.namespace,
              key: metafield.key,
              value: metafield.value,
              type: metafield.type
            }
          ]
        }, response = await fetch(`https://${shopDomain}/admin/api/2025-10/graphql`, {
          method: "POST",
          headers: {
            "X-Shopify-Access-Token": accessToken,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: mutation,
            variables
          })
        });
        if (!response.ok)
          throw new Error(`Failed to create metafield: ${response.status}`);
        let result = await response.json();
        if (result.errors)
          throw new Error(`GraphQL errors: ${JSON.stringify(result.errors)}`);
      }
    };
  }
});

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
var import_node = __toESM(require_dist(), 1);
import { PassThrough } from "node:stream";

// node_modules/@remix-run/react/dist/esm/index.js
init_dist2();

// node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js
function _extends4() {
  return _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends4.apply(this, arguments);
}

// node_modules/@remix-run/react/dist/esm/components.js
var React8 = __toESM(require_react());
init_dist2();

// node_modules/@remix-run/react/dist/esm/invariant.js
function invariant3(value, message) {
  if (value === !1 || value === null || typeof value > "u")
    throw new Error(message);
}

// node_modules/@remix-run/react/dist/esm/links.js
init_dist2();

// node_modules/@remix-run/react/dist/esm/routeModules.js
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache)
    return routeModulesCache[route.id];
  try {
    let routeModule = await import(
      /* webpackIgnore: true */
      route.module
    );
    return routeModulesCache[route.id] = routeModule, routeModule;
  } catch (error) {
    if (console.error(`Error loading route module \`${route.module}\`, reloading page...`), console.error(error), window.__remixContext.isSpaMode && // @ts-expect-error
    typeof import.meta.hot < "u")
      throw error;
    return window.location.reload(), new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/dist/esm/links.js
function getKeyedLinksForMatches(matches2, routeModules, manifest) {
  let descriptors = matches2.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id], route = manifest.routes[match.route.id];
    return [route.css ? route.css.map((href) => ({
      rel: "stylesheet",
      href
    })) : [], (module == null || (_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || []];
  }).flat(2), preloads = getCurrentPageModulePreloadHrefs(matches2, manifest);
  return dedupeLinkDescriptors(descriptors, preloads);
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page == "string";
}
function isHtmlLinkDescriptor(object) {
  return object == null ? !1 : object.href == null ? object.rel === "preload" && typeof object.imageSrcSet == "string" && typeof object.imageSizes == "string" : typeof object.rel == "string" && typeof object.href == "string";
}
async function getKeyedPrefetchLinks(matches2, manifest, routeModules) {
  let links2 = await Promise.all(matches2.map(async (match) => {
    let mod = await loadRouteModule(manifest.routes[match.route.id], routeModules);
    return mod.links ? mod.links() : [];
  }));
  return dedupeLinkDescriptors(links2.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "stylesheet" ? {
    ...link,
    rel: "prefetch",
    as: "style"
  } : {
    ...link,
    rel: "prefetch"
  }));
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, future2, mode2) {
  let path = parsePathPatch(page), isNew = (match, index) => currentMatches[index] ? match.route.id !== currentMatches[index].route.id : !0, matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  return mode2 === "data" && (future2.v3_singleFetch || location.search !== path.search) ? (
    // this is really similar to stuff in transition.ts, maybe somebody smarter
    // than me (or in less of a hurry) can share some of it. You're the best.
    nextMatches.filter((match, index) => {
      if (!manifest.routes[match.route.id].hasLoader)
        return !1;
      if (isNew(match, index) || matchPathChanged(match, index))
        return !0;
      let defaultShouldRevalidate = future2.v3_singleFetch || location.search !== path.search;
      if (match.route.shouldRevalidate) {
        var _currentMatches$;
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
          currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate
        });
        if (typeof routeChoice == "boolean")
          return routeChoice;
      }
      return defaultShouldRevalidate;
    })
  ) : nextMatches.filter((match, index) => {
    let manifestRoute = manifest.routes[match.route.id];
    return (mode2 === "assets" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function getDataLinkHrefs(page, matches2, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches2.filter((match) => manifest.routes[match.route.id].hasLoader && !manifest.routes[match.route.id].hasClientLoader).map((match) => {
    let {
      pathname,
      search
    } = path, searchParams = new URLSearchParams(search);
    return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches2, manifestPatch) {
  return dedupeHrefs(matches2.map((match) => {
    let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches2, manifest) {
  return dedupeHrefs(matches2.map((match) => {
    let route = manifest.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {}, keys = Object.keys(obj).sort();
  for (let key of keys)
    sorted[key] = obj[key];
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    if (preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
      return deduped;
    let key = JSON.stringify(sortKeys(descriptor));
    return set.has(key) || (set.add(key), deduped.push({
      key,
      link: descriptor
    })), deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = parsePath(href);
  return path.search === void 0 && (path.search = ""), path;
}

// node_modules/@remix-run/react/dist/esm/markup.js
var ESCAPE_LOOKUP2 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
function escapeHtml2(html) {
  return html.replace(ESCAPE_REGEX2, (match) => ESCAPE_LOOKUP2[match]);
}
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/dist/esm/single-fetch.js
var React3 = __toESM(require_react());
import { decode } from "turbo-stream";
function StreamTransfer({
  context,
  identifier,
  reader,
  textDecoder,
  nonce: nonce2
}) {
  if (!context.renderMeta || !context.renderMeta.didRenderScripts)
    return null;
  context.renderMeta.streamCache || (context.renderMeta.streamCache = {});
  let {
    streamCache
  } = context.renderMeta, promise = streamCache[identifier];
  if (promise || (promise = streamCache[identifier] = reader.read().then((result) => {
    streamCache[identifier].result = {
      done: result.done,
      value: textDecoder.decode(result.value, {
        stream: !0
      })
    };
  }).catch((e) => {
    streamCache[identifier].error = e;
  })), promise.error)
    throw promise.error;
  if (promise.result === void 0)
    throw promise;
  let {
    done,
    value
  } = promise.result, scriptTag = value ? /* @__PURE__ */ React3.createElement("script", {
    nonce: nonce2,
    dangerouslySetInnerHTML: {
      __html: `window.__remixContext.streamController.enqueue(${escapeHtml2(JSON.stringify(value))});`
    }
  }) : null;
  return done ? /* @__PURE__ */ React3.createElement(React3.Fragment, null, scriptTag, /* @__PURE__ */ React3.createElement("script", {
    nonce: nonce2,
    dangerouslySetInnerHTML: {
      __html: "window.__remixContext.streamController.close();"
    }
  })) : /* @__PURE__ */ React3.createElement(React3.Fragment, null, scriptTag, /* @__PURE__ */ React3.createElement(React3.Suspense, null, /* @__PURE__ */ React3.createElement(StreamTransfer, {
    context,
    identifier: identifier + 1,
    reader,
    textDecoder,
    nonce: nonce2
  })));
}
function singleFetchUrl(reqUrl) {
  let url = typeof reqUrl == "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  return url.pathname === "/" ? url.pathname = "_root.data" : url.pathname = `${url.pathname.replace(/\/$/, "")}.data`, url;
}

// node_modules/@remix-run/react/dist/esm/fog-of-war.js
init_router();
var React7 = __toESM(require_react());

// node_modules/@remix-run/react/dist/esm/routes.js
var React6 = __toESM(require_react());
init_dist2();

// node_modules/@remix-run/react/dist/esm/errorBoundaries.js
var React4 = __toESM(require_react());
init_dist2();
var RemixErrorBoundary = class extends React4.Component {
  constructor(props) {
    super(props), this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    return state.location !== props.location ? {
      error: props.error || null,
      location: props.location
    } : {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ React4.createElement(RemixRootDefaultErrorBoundary, {
      error: this.state.error,
      isOutsideRemixApp: !0
    }) : this.props.children;
  }
};
function RemixRootDefaultErrorBoundary({
  error,
  isOutsideRemixApp
}) {
  console.error(error);
  let heyDeveloper = /* @__PURE__ */ React4.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
        console.log(
          "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
        );
      `
    }
  });
  if (isRouteErrorResponse(error))
    return /* @__PURE__ */ React4.createElement(BoundaryShell, {
      title: "Unhandled Thrown Response!"
    }, /* @__PURE__ */ React4.createElement("h1", {
      style: {
        fontSize: "24px"
      }
    }, error.status, " ", error.statusText), heyDeveloper);
  let errorInstance;
  if (error instanceof Error)
    errorInstance = error;
  else {
    let errorString = error == null ? "Unknown Error" : typeof error == "object" && "toString" in error ? error.toString() : JSON.stringify(error);
    errorInstance = new Error(errorString);
  }
  return /* @__PURE__ */ React4.createElement(BoundaryShell, {
    title: "Application Error!",
    isOutsideRemixApp
  }, /* @__PURE__ */ React4.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ React4.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, errorInstance.stack), heyDeveloper);
}
function BoundaryShell({
  title,
  renderScripts,
  isOutsideRemixApp,
  children
}) {
  var _routeModules$root;
  let {
    routeModules
  } = useRemixContext();
  return (_routeModules$root = routeModules.root) !== null && _routeModules$root !== void 0 && _routeModules$root.Layout && !isOutsideRemixApp ? children : /* @__PURE__ */ React4.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ React4.createElement("head", null, /* @__PURE__ */ React4.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ React4.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ React4.createElement("title", null, title)), /* @__PURE__ */ React4.createElement("body", null, /* @__PURE__ */ React4.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, children, renderScripts ? /* @__PURE__ */ React4.createElement(Scripts, null) : null)));
}

// node_modules/@remix-run/react/dist/esm/fallback.js
var React5 = __toESM(require_react());
function RemixRootDefaultHydrateFallback() {
  return /* @__PURE__ */ React5.createElement(BoundaryShell, {
    title: "Loading...",
    renderScripts: !0
  }, /* @__PURE__ */ React5.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://remix.run/route/hydrate-fallback " +
                "for more information."
              );
            `
    }
  }));
}

// node_modules/@remix-run/react/dist/esm/routes.js
function groupRoutesByParentId2(manifest) {
  let routes2 = {};
  return Object.values(manifest).forEach((route) => {
    let parentId = route.parentId || "";
    routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
  }), routes2;
}
function getRouteComponents(route, routeModule, isSpaMode) {
  let Component5 = getRouteModuleComponent(routeModule), HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === "root") ? routeModule.HydrateFallback : route.id === "root" ? RemixRootDefaultHydrateFallback : void 0, ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === "root" ? () => /* @__PURE__ */ React6.createElement(RemixRootDefaultErrorBoundary, {
    error: useRouteError()
  }) : void 0;
  return route.id === "root" && routeModule.Layout ? {
    ...Component5 ? {
      element: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(Component5, null))
    } : {
      Component: Component5
    },
    ...ErrorBoundary ? {
      errorElement: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(ErrorBoundary, null))
    } : {
      ErrorBoundary
    },
    ...HydrateFallback ? {
      hydrateFallbackElement: /* @__PURE__ */ React6.createElement(routeModule.Layout, null, /* @__PURE__ */ React6.createElement(HydrateFallback, null))
    } : {
      HydrateFallback
    }
  } : {
    Component: Component5,
    ErrorBoundary,
    HydrateFallback
  };
}
function createServerRoutes(manifest, routeModules, future2, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId2(manifest), spaModeLazyPromise = Promise.resolve({
  Component: () => null
})) {
  return (routesByParentId[parentId] || []).map((route) => {
    let routeModule = routeModules[route.id];
    invariant3(routeModule, "No `routeModule` available to create server routes");
    let dataRoute = {
      ...getRouteComponents(route, routeModule, isSpaMode),
      caseSensitive: route.caseSensitive,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: routeModule.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0
      // We don't need action/shouldRevalidate on these routes since they're
      // for a static render
    }, children = createServerRoutes(manifest, routeModules, future2, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);
    return children.length > 0 && (dataRoute.children = children), dataRoute;
  });
}
function getRouteModuleComponent(routeModule) {
  if (routeModule.default == null)
    return;
  if (!(typeof routeModule.default == "object" && Object.keys(routeModule.default).length === 0))
    return routeModule.default;
}
function shouldHydrateRouteLoader(route, routeModule, isSpaMode) {
  return isSpaMode && route.id !== "root" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === !0 || route.hasLoader !== !0);
}

// node_modules/@remix-run/react/dist/esm/fog-of-war.js
function isFogOfWarEnabled(future2, isSpaMode) {
  return future2.v3_lazyRouteDiscovery === !0 && !isSpaMode;
}
function getPartialManifest(manifest, router) {
  let routeIds = new Set(router.state.matches.map((m) => m.route.id)), segments = router.state.location.pathname.split("/").filter(Boolean), paths = ["/"];
  for (segments.pop(); segments.length > 0; )
    paths.push(`/${segments.join("/")}`), segments.pop();
  paths.forEach((path) => {
    let matches2 = matchRoutes(router.routes, path, router.basename);
    matches2 && matches2.forEach((m) => routeIds.add(m.route.id));
  });
  let initialRoutes = [...routeIds].reduce((acc, id) => Object.assign(acc, {
    [id]: manifest.routes[id]
  }), {});
  return {
    ...manifest,
    routes: initialRoutes
  };
}

// node_modules/@remix-run/react/dist/esm/components.js
function useDataRouterContext3() {
  let context = React8.useContext(DataRouterContext);
  return invariant3(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
}
function useDataRouterStateContext() {
  let context = React8.useContext(DataRouterStateContext);
  return invariant3(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
}
var RemixContext = /* @__PURE__ */ React8.createContext(void 0);
RemixContext.displayName = "Remix";
function useRemixContext() {
  let context = React8.useContext(RemixContext);
  return invariant3(context, "You must render this element inside a <Remix> element"), context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React8.useState(!1), [shouldPrefetch, setShouldPrefetch] = React8.useState(!1), {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps, ref = React8.useRef(null);
  React8.useEffect(() => {
    if (prefetch === "render" && setShouldPrefetch(!0), prefetch === "viewport") {
      let callback2 = (entries) => {
        entries.forEach((entry2) => {
          setShouldPrefetch(entry2.isIntersecting);
        });
      }, observer = new IntersectionObserver(callback2, {
        threshold: 0.5
      });
      return ref.current && observer.observe(ref.current), () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  let setIntent = () => {
    prefetch === "intent" && setMaybePrefetch(!0);
  }, cancelIntent = () => {
    prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
  };
  return React8.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(!0);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]), [shouldPrefetch, ref, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function getDiscoverAttr(discover, isAbsolute, reloadDocument) {
  return discover === "render" && !isAbsolute && !reloadDocument ? "true" : void 0;
}
var NavLink2 = /* @__PURE__ */ React8.forwardRef(({
  to,
  prefetch = "none",
  discover = "render",
  ...props
}, forwardedRef) => {
  let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX3.test(to), href = useHref(to), [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(NavLink, _extends4({}, props, prefetchHandlers, {
    ref: mergeRefs(forwardedRef, ref),
    to,
    "data-discover": getDiscoverAttr(discover, isAbsolute, props.reloadDocument)
  })), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React8.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
NavLink2.displayName = "NavLink";
var Link2 = /* @__PURE__ */ React8.forwardRef(({
  to,
  prefetch = "none",
  discover = "render",
  ...props
}, forwardedRef) => {
  let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX3.test(to), href = useHref(to), [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(Link, _extends4({}, props, prefetchHandlers, {
    ref: mergeRefs(forwardedRef, ref),
    to,
    "data-discover": getDiscoverAttr(discover, isAbsolute, props.reloadDocument)
  })), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React8.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
Link2.displayName = "Link";
var Form2 = /* @__PURE__ */ React8.forwardRef(({
  discover = "render",
  ...props
}, forwardedRef) => {
  let isAbsolute = typeof props.action == "string" && ABSOLUTE_URL_REGEX3.test(props.action);
  return /* @__PURE__ */ React8.createElement(Form, _extends4({}, props, {
    ref: forwardedRef,
    "data-discover": getDiscoverAttr(discover, isAbsolute, props.reloadDocument)
  }));
});
Form2.displayName = "Form";
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event);
  };
}
function getActiveMatches(matches2, errors, isSpaMode) {
  if (isSpaMode && !isHydrated)
    return [matches2[0]];
  if (errors) {
    let errorIdx = matches2.findIndex((m) => errors[m.route.id] !== void 0);
    return matches2.slice(0, errorIdx + 1);
  }
  return matches2;
}
function Links() {
  let {
    isSpaMode,
    manifest,
    routeModules,
    criticalCss
  } = useRemixContext(), {
    errors,
    matches: routerMatches
  } = useDataRouterStateContext(), matches2 = getActiveMatches(routerMatches, errors, isSpaMode), keyedLinks = React8.useMemo(() => getKeyedLinksForMatches(matches2, routeModules, manifest), [matches2, routeModules, manifest]);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, criticalCss ? /* @__PURE__ */ React8.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: criticalCss
    }
  }) : null, keyedLinks.map(({
    key,
    link
  }) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React8.createElement(PrefetchPageLinks, _extends4({
    key
  }, link)) : /* @__PURE__ */ React8.createElement("link", _extends4({
    key
  }, link))));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let {
    router
  } = useDataRouterContext3(), matches2 = React8.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);
  return matches2 ? /* @__PURE__ */ React8.createElement(PrefetchPageLinksImpl, _extends4({
    page,
    matches: matches2
  }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
}
function useKeyedPrefetchLinks(matches2) {
  let {
    manifest,
    routeModules
  } = useRemixContext(), [keyedPrefetchLinks, setKeyedPrefetchLinks] = React8.useState([]);
  return React8.useEffect(() => {
    let interrupted = !1;
    return getKeyedPrefetchLinks(matches2, manifest, routeModules).then((links2) => {
      interrupted || setKeyedPrefetchLinks(links2);
    }), () => {
      interrupted = !0;
    };
  }, [matches2, manifest, routeModules]), keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation(), {
    future: future2,
    manifest,
    routeModules
  } = useRemixContext(), {
    loaderData,
    matches: matches2
  } = useDataRouterStateContext(), newMatchesForData = React8.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches2, manifest, location, future2, "data"), [page, nextMatches, matches2, manifest, location, future2]), dataHrefs = React8.useMemo(() => {
    if (!future2.v3_singleFetch)
      return getDataLinkHrefs(page, newMatchesForData, manifest);
    if (page === location.pathname + location.search + location.hash)
      return [];
    let routesParams = /* @__PURE__ */ new Set(), foundOptOutRoute = !1;
    if (nextMatches.forEach((m) => {
      var _routeModules$m$route;
      manifest.routes[m.route.id].hasLoader && (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && (_routeModules$m$route = routeModules[m.route.id]) !== null && _routeModules$m$route !== void 0 && _routeModules$m$route.shouldRevalidate || manifest.routes[m.route.id].hasClientLoader ? foundOptOutRoute = !0 : routesParams.add(m.route.id));
    }), routesParams.size === 0)
      return [];
    let url = singleFetchUrl(page);
    return foundOptOutRoute && routesParams.size > 0 && url.searchParams.set("_routes", nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")), [url.pathname + url.search];
  }, [future2.v3_singleFetch, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]), newMatchesForAssets = React8.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches2, manifest, location, future2, "assets"), [page, nextMatches, matches2, manifest, location, future2]), moduleHrefs = React8.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", _extends4({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", _extends4({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), keyedPrefetchLinks.map(({
    key,
    link
  }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ React8.createElement("link", _extends4({
      key
    }, link))
  )));
}
function Meta() {
  let {
    isSpaMode,
    routeModules
  } = useRemixContext(), {
    errors,
    matches: routerMatches,
    loaderData
  } = useDataRouterStateContext(), location = useLocation(), _matches = getActiveMatches(routerMatches, errors, isSpaMode), error = null;
  errors && (error = errors[_matches[_matches.length - 1].route.id]);
  let meta2 = [], leafMeta = null, matches2 = [];
  for (let i = 0; i < _matches.length; i++) {
    let _match = _matches[i], routeId = _match.route.id, data3 = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
      id: routeId,
      data: data3,
      meta: [],
      params: _match.params,
      pathname: _match.pathname,
      handle: _match.route.handle,
      error
    };
    if (matches2[i] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
      data: data3,
      params,
      location,
      matches: matches2,
      error
    }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
      throw new Error("The route at " + _match.route.path + ` returns an invalid value. All route meta functions must return an array of meta objects.

To reference the meta function API, see https://remix.run/route/meta`);
    match.meta = routeMeta, matches2[i] = match, meta2 = [...routeMeta], leafMeta = meta2;
  }
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, meta2.flat().map((metaProps) => {
    if (!metaProps)
      return null;
    if ("tagName" in metaProps) {
      let {
        tagName,
        ...rest
      } = metaProps;
      return isValidMetaTag(tagName) ? /* @__PURE__ */ React8.createElement(tagName, _extends4({
        key: JSON.stringify(rest)
      }, rest)) : (console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null);
    }
    if ("title" in metaProps)
      return /* @__PURE__ */ React8.createElement("title", {
        key: "title"
      }, String(metaProps.title));
    if ("charset" in metaProps && (metaProps.charSet ??= metaProps.charset, delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
      return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React8.createElement("meta", {
        key: "charSet",
        charSet: metaProps.charSet
      }) : null;
    if ("script:ld+json" in metaProps)
      try {
        let json14 = JSON.stringify(metaProps["script:ld+json"]);
        return /* @__PURE__ */ React8.createElement("script", {
          key: `script:ld+json:${json14}`,
          type: "application/ld+json",
          dangerouslySetInnerHTML: {
            __html: escapeHtml2(json14)
          }
        });
      } catch {
        return null;
      }
    return /* @__PURE__ */ React8.createElement("meta", _extends4({
      key: JSON.stringify(metaProps)
    }, metaProps));
  }));
}
function isValidMetaTag(tagName) {
  return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
}
function Await2(props) {
  return /* @__PURE__ */ React8.createElement(Await, props);
}
var isHydrated = !1;
function Scripts(props) {
  let {
    manifest,
    serverHandoffString,
    abortDelay,
    serializeError: serializeError2,
    isSpaMode,
    future: future2,
    renderMeta
  } = useRemixContext(), {
    router,
    static: isStatic,
    staticContext
  } = useDataRouterContext3(), {
    matches: routerMatches
  } = useDataRouterStateContext(), enableFogOfWar = isFogOfWarEnabled(future2, isSpaMode);
  renderMeta && (renderMeta.didRenderScripts = !0);
  let matches2 = getActiveMatches(routerMatches, null, isSpaMode);
  React8.useEffect(() => {
    isHydrated = !0;
  }, []);
  let serializePreResolvedErrorImp = (key, error) => {
    let toSerialize;
    return serializeError2 && error instanceof Error ? toSerialize = serializeError2(error) : toSerialize = error, `${JSON.stringify(key)}:__remixContext.p(!1, ${escapeHtml2(JSON.stringify(toSerialize))})`;
  }, serializePreresolvedDataImp = (routeId, key, data3) => {
    let serializedData;
    try {
      serializedData = JSON.stringify(data3);
    } catch (error) {
      return serializePreResolvedErrorImp(key, error);
    }
    return `${JSON.stringify(key)}:__remixContext.p(${escapeHtml2(serializedData)})`;
  }, serializeErrorImp = (routeId, key, error) => {
    let toSerialize;
    return serializeError2 && error instanceof Error ? toSerialize = serializeError2(error) : toSerialize = error, `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, !1, ${escapeHtml2(JSON.stringify(toSerialize))})`;
  }, serializeDataImp = (routeId, key, data3) => {
    let serializedData;
    try {
      serializedData = JSON.stringify(data3);
    } catch (error) {
      return serializeErrorImp(routeId, key, error);
    }
    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, ${escapeHtml2(serializedData)})`;
  }, deferredScripts = [], initialScripts = React8.useMemo(() => {
    var _manifest$hmr;
    let streamScript = future2.v3_singleFetch ? (
      // prettier-ignore
      "window.__remixContext.stream = new ReadableStream({start(controller){window.__remixContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());"
    ) : "", contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};${streamScript}` : " ", activeDeferreds = future2.v3_singleFetch ? void 0 : staticContext?.activeDeferreds;
    contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
      let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key) => {
        if (pendingKeys.has(key))
          return deferredScripts.push(/* @__PURE__ */ React8.createElement(DeferredHydrationScript, {
            key: `${routeId} | ${key}`,
            deferredData,
            routeId,
            dataKey: key,
            scriptProps: props,
            serializeData: serializeDataImp,
            serializeError: serializeErrorImp
          })), `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;
        {
          let trackedPromise = deferredData.data[key];
          return typeof trackedPromise._error < "u" ? serializePreResolvedErrorImp(key, trackedPromise._error) : serializePreresolvedDataImp(routeId, key, trackedPromise._data);
        }
      }).join(`,
`);
      return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
    }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
    let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${enableFogOfWar ? "" : `import ${JSON.stringify(manifest.url)}`};
${matches2.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
${enableFogOfWar ? (
      // Inline a minimal manifest with the SSR matches
      `window.__remixManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};`
    ) : ""}
window.__remixRouteModules = {${matches2.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
    return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement("script", _extends4({}, props, {
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: createHtml(contextScript),
      type: void 0
    })), /* @__PURE__ */ React8.createElement("script", _extends4({}, props, {
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module",
      async: !0
    })));
  }, []);
  if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
    for (let i = 0; i < __remixContext.a; i++)
      deferredScripts.push(/* @__PURE__ */ React8.createElement(DeferredHydrationScript, {
        key: i,
        scriptProps: props,
        serializeData: serializeDataImp,
        serializeError: serializeErrorImp
      }));
  let routePreloads = matches2.map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1), preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
  return isHydrated ? null : /* @__PURE__ */ React8.createElement(React8.Fragment, null, enableFogOfWar ? null : /* @__PURE__ */ React8.createElement("link", {
    rel: "modulepreload",
    href: manifest.url,
    crossOrigin: props.crossOrigin
  }), /* @__PURE__ */ React8.createElement("link", {
    rel: "modulepreload",
    href: manifest.entry.module,
    crossOrigin: props.crossOrigin
  }), dedupe(preloads).map((path) => /* @__PURE__ */ React8.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), initialScripts, deferredScripts);
}
function DeferredHydrationScript({
  dataKey,
  deferredData,
  routeId,
  scriptProps,
  serializeData,
  serializeError: serializeError2
}) {
  return typeof document > "u" && deferredData && dataKey && routeId && invariant3(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React8.createElement(React8.Suspense, {
    fallback: (
      // This makes absolutely no sense. The server renders null as a fallback,
      // but when hydrating, we need to render a script tag to avoid a hydration issue.
      // To reproduce a hydration mismatch, just render null as a fallback.
      typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React8.createElement("script", _extends4({}, scriptProps, {
        async: !0,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: " "
        }
      }))
    )
  }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React8.createElement(Await2, {
    resolve: deferredData.data[dataKey],
    errorElement: /* @__PURE__ */ React8.createElement(ErrorDeferredHydrationScript, {
      dataKey,
      routeId,
      scriptProps,
      serializeError: serializeError2
    }),
    children: (data3) => /* @__PURE__ */ React8.createElement("script", _extends4({}, scriptProps, {
      async: !0,
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: serializeData(routeId, dataKey, data3)
      }
    }))
  }) : /* @__PURE__ */ React8.createElement("script", _extends4({}, scriptProps, {
    async: !0,
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: " "
    }
  })));
}
function ErrorDeferredHydrationScript({
  dataKey,
  routeId,
  scriptProps,
  serializeError: serializeError2
}) {
  let error = useAsyncError();
  return /* @__PURE__ */ React8.createElement("script", _extends4({}, scriptProps, {
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: serializeError2(routeId, dataKey, error)
    }
  }));
}
function dedupe(array) {
  return [...new Set(array)];
}
function useLoaderData2() {
  return useLoaderData();
}
function useFetcher2(opts = {}) {
  return useFetcher(opts);
}
var LiveReload = () => null;
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      typeof ref == "function" ? ref(value) : ref != null && (ref.current = value);
    });
  };
}

// node_modules/@remix-run/react/dist/esm/scroll-restoration.js
var React9 = __toESM(require_react());
init_dist2();
var STORAGE_KEY = "positions";
function ScrollRestoration2({
  getKey,
  ...props
}) {
  let {
    isSpaMode
  } = useRemixContext(), location = useLocation(), matches2 = useMatches();
  useScrollRestoration({
    getKey,
    storageKey: STORAGE_KEY
  });
  let key = React9.useMemo(
    () => {
      if (!getKey)
        return null;
      let userKey = getKey(location, matches2);
      return userKey !== location.key ? userKey : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (isSpaMode)
    return null;
  let restoreScroll = ((STORAGE_KEY2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key2 = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key: key2
      }, "");
    }
    try {
      let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[restoreKey || window.history.state.key];
      typeof storedY == "number" && window.scrollTo(0, storedY);
    } catch (error) {
      console.error(error), sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ React9.createElement("script", _extends4({}, props, {
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`
    }
  }));
}

// node_modules/@remix-run/react/dist/esm/server.js
var React10 = __toESM(require_react()), import_server2 = __toESM(require_server());
function RemixServer({
  context,
  url,
  abortDelay,
  nonce: nonce2
}) {
  typeof url == "string" && (url = new URL(url));
  let {
    manifest,
    routeModules,
    criticalCss,
    serverHandoffString
  } = context, routes2 = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);
  context.staticHandlerContext.loaderData = {
    ...context.staticHandlerContext.loaderData
  };
  for (let match of context.staticHandlerContext.matches) {
    let routeId = match.route.id, route = routeModules[routeId], manifestRoute = context.manifest.routes[routeId];
    route && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader) && (context.staticHandlerContext.loaderData[routeId] = void 0);
  }
  let router = (0, import_server2.createStaticRouter)(routes2, context.staticHandlerContext, {
    future: {
      v7_partialHydration: !0,
      v7_relativeSplatPath: context.future.v3_relativeSplatPath
    }
  });
  return /* @__PURE__ */ React10.createElement(React10.Fragment, null, /* @__PURE__ */ React10.createElement(RemixContext.Provider, {
    value: {
      manifest,
      routeModules,
      criticalCss,
      serverHandoffString,
      future: context.future,
      isSpaMode: context.isSpaMode,
      serializeError: context.serializeError,
      abortDelay,
      renderMeta: context.renderMeta
    }
  }, /* @__PURE__ */ React10.createElement(RemixErrorBoundary, {
    location: router.state.location
  }, /* @__PURE__ */ React10.createElement(import_server2.StaticRouterProvider, {
    router,
    context: context.staticHandlerContext,
    hydrate: !1
  }))), context.future.v3_singleFetch && context.serverHandoffStream ? /* @__PURE__ */ React10.createElement(React10.Suspense, null, /* @__PURE__ */ React10.createElement(StreamTransfer, {
    context,
    identifier: 0,
    reader: context.serverHandoffStream.getReader(),
    textDecoder: new TextDecoder(),
    nonce: nonce2
  })) : null);
}

// app/entry.server.tsx
var import_server4 = __toESM(require_server_node(), 1);
import { isbot } from "isbot";

// app/utils/queue.ts
init_db();
import { Queue, Worker, QueueEvents } from "bullmq";
import { Redis } from "ioredis";

// app/utils/healthChecker.ts
init_db();

// app/utils/emailService.ts
init_db();
var _EmailService = class {
  isConfigured = !1;
  constructor() {
    this.isConfigured = !!(process.env.SMTP_HOST && process.env.SMTP_PORT && process.env.SMTP_USER && process.env.SMTP_PASS);
  }
  static getInstance() {
    return _EmailService.instance || (_EmailService.instance = new _EmailService()), _EmailService.instance;
  }
  async sendWeeklyHealthSummary(summary) {
    try {
      if (!this.isConfigured)
        return console.log("Email service not configured - logging summary instead"), await this.logSummary(summary), !0;
      let template = this.generateWeeklyHealthTemplate(summary), emailAddress = await this.getUserEmailAddress(summary.userId);
      return emailAddress ? (console.log("Would send email:", {
        to: emailAddress,
        subject: template.subject,
        html: template.html
      }), await db.log.create({
        data: {
          userId: summary.userId,
          type: "email_sent",
          message: `Weekly health summary sent to ${emailAddress}`,
          metadata: {
            subject: template.subject,
            currentScore: summary.currentScore,
            scoreChange: summary.scoreChange,
            issuesFound: summary.issuesFound,
            issuesFixed: summary.issuesFixed
          }
        }
      }), !0) : (console.log("No email address found for user - logging summary instead"), await this.logSummary(summary), !0);
    } catch (error) {
      return console.error("Failed to send weekly health summary:", error), await db.log.create({
        data: {
          userId: summary.userId,
          type: "error",
          message: `Failed to send weekly health summary: ${error instanceof Error ? error.message : "Unknown error"}`,
          error: error instanceof Error ? error.message : "Unknown error"
        }
      }), !1;
    }
  }
  async getUserEmailAddress(userId) {
    try {
      let user = await db.user.findUnique({
        where: { id: userId },
        select: { shopDomain: !0 }
      });
      return user ? `admin@${user.shopDomain.replace(".myshopify.com", "")}.myshopify.com` : null;
    } catch (error) {
      return console.error("Failed to get user email address:", error), null;
    }
  }
  generateWeeklyHealthTemplate(summary) {
    let scoreTrend = summary.scoreChange >= 0 ? "\u{1F4C8}" : "\u{1F4C9}", scoreColor = summary.scoreChange >= 0 ? "#00a047" : "#d82c0d", html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Weekly Health Summary - ${summary.shopDomain}</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; text-align: center; }
          .content { background: #fff; padding: 30px; border: 1px solid #e1e5e9; }
          .score-card { background: #f8f9fa; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center; }
          .score-number { font-size: 48px; font-weight: bold; color: ${scoreColor}; margin: 10px 0; }
          .trend { font-size: 18px; color: ${scoreColor}; }
          .stats { display: flex; justify-content: space-around; margin: 20px 0; }
          .stat { text-align: center; }
          .stat-number { font-size: 24px; font-weight: bold; color: #667eea; }
          .stat-label { color: #666; font-size: 14px; }
          .footer { background: #f8f9fa; padding: 20px; text-align: center; border-radius: 0 0 10px 10px; font-size: 14px; color: #666; }
          .cta-button { display: inline-block; background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>\u{1F3E5} Catalog Health Report</h1>
          <p>Weekly summary for ${summary.shopDomain}</p>
        </div>
        
        <div class="content">
          <div class="score-card">
            <div class="score-number">${summary.currentScore}%</div>
            <div class="trend">
              ${scoreTrend} ${summary.scoreChange >= 0 ? "+" : ""}${summary.scoreChange.toFixed(1)}% from last week
            </div>
            <p>Current Health Score</p>
          </div>
          
          <div class="stats">
            <div class="stat">
              <div class="stat-number">${summary.totalProducts}</div>
              <div class="stat-label">Total Products</div>
            </div>
            <div class="stat">
              <div class="stat-number">${summary.issuesFound}</div>
              <div class="stat-label">Issues Found</div>
            </div>
            <div class="stat">
              <div class="stat-number">${summary.issuesFixed}</div>
              <div class="stat-label">Issues Fixed</div>
            </div>
          </div>
          
          ${summary.currentScore < 90 ? `
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px; margin: 20px 0;">
              <strong>\u26A0\uFE0F Attention Needed:</strong> Your catalog health is below 90%. Consider running a health check to identify and fix issues.
            </div>
          ` : `
            <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 15px; margin: 20px 0;">
              <strong>\u2705 Great Job!</strong> Your catalog is in excellent health. Keep up the good work!
            </div>
          `}
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${process.env.SHOPIFY_APP_URL}/dashboard" class="cta-button">
              View Dashboard
            </a>
          </div>
        </div>
        
        <div class="footer">
          <p>This is an automated report from CatalogAI Optimizer.</p>
          <p>To adjust your email preferences, visit your dashboard settings.</p>
        </div>
      </body>
      </html>
    `, text2 = `
Catalog Health Report - ${summary.shopDomain}

Health Score: ${summary.currentScore}%
Trend: ${summary.scoreChange >= 0 ? "+" : ""}${summary.scoreChange.toFixed(1)}% from last week

Statistics:
- Total Products: ${summary.totalProducts}
- Issues Found: ${summary.issuesFound}
- Issues Fixed: ${summary.issuesFixed}

${summary.currentScore < 90 ? "\u26A0\uFE0F Your catalog health is below 90%. Consider running a health check to identify and fix issues." : "\u2705 Your catalog is in excellent health. Keep up the good work!"}

View your dashboard: ${process.env.SHOPIFY_APP_URL}/dashboard

---
This is an automated report from CatalogAI Optimizer.
To adjust your email preferences, visit your dashboard settings.
    `;
    return {
      subject: `\u{1F4CA} Weekly Health Report: ${summary.currentScore}% (${summary.scoreChange >= 0 ? "+" : ""}${summary.scoreChange.toFixed(1)}%)`,
      html,
      text: text2
    };
  }
  async logSummary(summary) {
    await db.log.create({
      data: {
        userId: summary.userId,
        type: "email_summary",
        message: `Weekly health summary: ${summary.currentScore}% (${summary.scoreChange >= 0 ? "+" : ""}${summary.scoreChange.toFixed(1)}%) - ${summary.issuesFound} issues found, ${summary.issuesFixed} fixed`,
        metadata: {
          currentScore: summary.currentScore,
          previousScore: summary.previousScore,
          scoreChange: summary.scoreChange,
          totalProducts: summary.totalProducts,
          issuesFound: summary.issuesFound,
          issuesFixed: summary.issuesFixed
        }
      }
    });
  }
  async sendHealthAlert(userId, shopDomain, alertType, message) {
    try {
      if (!this.isConfigured)
        return console.log("Email service not configured - logging alert instead"), await this.logAlert(userId, alertType, message), !0;
      let emailAddress = await this.getUserEmailAddress(userId);
      if (!emailAddress)
        return console.log("No email address found for user - logging alert instead"), await this.logAlert(userId, alertType, message), !0;
      let template = this.generateHealthAlertTemplate(shopDomain, alertType, message);
      return console.log("Would send health alert:", {
        to: emailAddress,
        subject: template.subject,
        html: template.html
      }), await db.log.create({
        data: {
          userId,
          type: "health_alert",
          message: `Health alert sent: ${message}`,
          metadata: {
            alertType,
            message
          }
        }
      }), !0;
    } catch (error) {
      return console.error("Failed to send health alert:", error), !1;
    }
  }
  generateHealthAlertTemplate(shopDomain, alertType, message) {
    let isCritical = alertType === "critical", color2 = isCritical ? "#d82c0d" : "#f59e0b", icon = isCritical ? "\u{1F6A8}" : "\u26A0\uFE0F", html = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Health Alert - ${shopDomain}</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: ${color2}; color: white; padding: 30px; border-radius: 10px 10px 0 0; text-align: center; }
          .content { background: #fff; padding: 30px; border: 1px solid #e1e5e9; }
          .alert-box { background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 20px; margin: 20px 0; }
          .cta-button { display: inline-block; background: ${color2}; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 20px 0; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${icon} Health Alert</h1>
          <p>${shopDomain}</p>
        </div>
        
        <div class="content">
          <div class="alert-box">
            <h3>${isCritical ? "Critical Issue Detected" : "Warning"}</h3>
            <p>${message}</p>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${process.env.SHOPIFY_APP_URL}/dashboard" class="cta-button">
              View Dashboard
            </a>
          </div>
        </div>
      </body>
      </html>
    `, text2 = `
${icon} Health Alert - ${shopDomain}

${isCritical ? "Critical Issue Detected" : "Warning"}

${message}

View your dashboard: ${process.env.SHOPIFY_APP_URL}/dashboard
    `;
    return {
      subject: `${icon} ${isCritical ? "Critical" : "Warning"}: ${shopDomain}`,
      html,
      text: text2
    };
  }
  async logAlert(userId, alertType, message) {
    await db.log.create({
      data: {
        userId,
        type: "health_alert",
        message: `Health alert (${alertType}): ${message}`,
        metadata: {
          alertType,
          message
        }
      }
    });
  }
}, EmailService = _EmailService;
__publicField(EmailService, "instance");
var emailService = EmailService.getInstance();

// app/utils/analyticsService.ts
init_db();
var _AnalyticsService = class {
  static getInstance() {
    return _AnalyticsService.instance || (_AnalyticsService.instance = new _AnalyticsService()), _AnalyticsService.instance;
  }
  async trackPerformanceMetrics(metrics) {
    try {
      await db.log.create({
        data: {
          userId: metrics.userId,
          type: "performance_metrics",
          message: `Performance tracked: ${metrics.healthScore}% health, ${metrics.totalProducts} products, ${metrics.issuesFound} issues`,
          metadata: {
            healthScore: metrics.healthScore,
            totalProducts: metrics.totalProducts,
            validProducts: metrics.validProducts,
            issuesFound: metrics.issuesFound,
            issuesFixed: metrics.issuesFixed,
            aiUsage: metrics.aiUsage,
            syncCount: metrics.syncCount,
            enrichmentCount: metrics.enrichmentCount,
            timestamp: metrics.timestamp
          }
        }
      });
      let deltaMetrics = await this.calculateDeltaMetrics(metrics.userId, metrics.timestamp);
      deltaMetrics && await this.storeDeltaMetrics(metrics.userId, deltaMetrics);
      let roiMetrics = await this.calculateROIMetrics(metrics.userId, metrics.shopDomain);
      roiMetrics && await this.storeROIMetrics(roiMetrics);
    } catch (error) {
      console.error("Failed to track performance metrics:", error);
    }
  }
  async calculateDeltaMetrics(userId, currentTimestamp) {
    try {
      let hourAgo = new Date(currentTimestamp.getTime() - 36e5), dayAgo = new Date(currentTimestamp.getTime() - 24 * 60 * 60 * 1e3), weekAgo = new Date(currentTimestamp.getTime() - 7 * 24 * 60 * 60 * 1e3), currentMetrics = await this.getLatestMetrics(userId);
      if (!currentMetrics)
        return null;
      let previousMetrics = await this.getPreviousMetrics(userId, dayAgo);
      if (!previousMetrics)
        return null;
      let scoreDelta = currentMetrics.healthScore - previousMetrics.healthScore, productsDelta = currentMetrics.totalProducts - previousMetrics.totalProducts, issuesDelta = currentMetrics.issuesFound - previousMetrics.issuesFound, aiUsageDelta = currentMetrics.aiUsage - previousMetrics.aiUsage, syncDelta = currentMetrics.syncCount - previousMetrics.syncCount, enrichmentDelta = currentMetrics.enrichmentCount - previousMetrics.enrichmentCount;
      return {
        scoreDelta,
        productsDelta,
        issuesDelta,
        aiUsageDelta,
        syncDelta,
        enrichmentDelta,
        timePeriod: "day"
      };
    } catch (error) {
      return console.error("Failed to calculate delta metrics:", error), null;
    }
  }
  async getLatestMetrics(userId) {
    try {
      let latestAudit = await db.audit.findFirst({
        where: { userId },
        orderBy: { timestamp: "desc" }
      }), user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!latestAudit || !user)
        return null;
      let oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3), syncCount = await db.log.count({
        where: {
          userId,
          type: "sync",
          createdAt: { gte: oneDayAgo }
        }
      }), enrichmentCount = await db.log.count({
        where: {
          userId,
          type: "ai_enrichment",
          createdAt: { gte: oneDayAgo }
        }
      });
      return {
        userId,
        shopDomain: user.shopDomain,
        timestamp: latestAudit.timestamp,
        healthScore: latestAudit.score,
        totalProducts: latestAudit.totalProducts,
        validProducts: latestAudit.validProducts,
        issuesFound: Array.isArray(latestAudit.gaps) ? latestAudit.gaps.length : 0,
        issuesFixed: 0,
        // Will be calculated separately
        aiUsage: user.aiUsage,
        syncCount,
        enrichmentCount
      };
    } catch (error) {
      return console.error("Failed to get latest metrics:", error), null;
    }
  }
  async getPreviousMetrics(userId, fromDate) {
    try {
      let audit = await db.audit.findFirst({
        where: {
          userId,
          timestamp: { gte: fromDate }
        },
        orderBy: { timestamp: "asc" }
      }), user = await db.user.findUnique({
        where: { id: userId }
      });
      return !audit || !user ? null : {
        userId,
        shopDomain: user.shopDomain,
        timestamp: audit.timestamp,
        healthScore: audit.score,
        totalProducts: audit.totalProducts,
        validProducts: audit.validProducts,
        issuesFound: Array.isArray(audit.gaps) ? audit.gaps.length : 0,
        issuesFixed: 0,
        aiUsage: user.aiUsage,
        syncCount: 0,
        enrichmentCount: 0
      };
    } catch (error) {
      return console.error("Failed to get previous metrics:", error), null;
    }
  }
  async storeDeltaMetrics(userId, deltaMetrics) {
    try {
      await db.log.create({
        data: {
          userId,
          type: "delta_metrics",
          message: `Delta metrics: ${deltaMetrics.scoreDelta >= 0 ? "+" : ""}${deltaMetrics.scoreDelta.toFixed(1)}% score, ${deltaMetrics.productsDelta >= 0 ? "+" : ""}${deltaMetrics.productsDelta} products`,
          metadata: {
            scoreDelta: deltaMetrics.scoreDelta,
            productsDelta: deltaMetrics.productsDelta,
            issuesDelta: deltaMetrics.issuesDelta,
            aiUsageDelta: deltaMetrics.aiUsageDelta,
            syncDelta: deltaMetrics.syncCount,
            enrichmentDelta: deltaMetrics.enrichmentDelta,
            timePeriod: deltaMetrics.timePeriod
          }
        }
      });
    } catch (error) {
      console.error("Failed to store delta metrics:", error);
    }
  }
  async calculateROIMetrics(userId, shopDomain) {
    try {
      let oneWeekAgo = new Date(Date.now() - 6048e5), audits = await db.audit.findMany({
        where: {
          userId,
          timestamp: { gte: oneWeekAgo }
        },
        orderBy: { timestamp: "asc" }
      });
      if (audits.length < 2)
        return null;
      let firstAudit = audits[0], lastAudit = audits[audits.length - 1], user = await db.user.findUnique({
        where: { id: userId }
      });
      if (!user)
        return null;
      let aiTokensUsed = user.aiUsage, healthScoreImprovement = lastAudit.score - firstAudit.score, productsProcessed = lastAudit.totalProducts, estimatedValueAdded = healthScoreImprovement * productsProcessed * 0.1, tokenCost = aiTokensUsed * 1e-4, costPerImprovement = tokenCost / Math.max(healthScoreImprovement, 1), roi = estimatedValueAdded / Math.max(tokenCost, 1);
      return {
        userId,
        shopDomain,
        timePeriod: "week",
        healthScoreImprovement,
        productsProcessed,
        aiTokensUsed,
        estimatedValueAdded,
        costPerImprovement,
        roi
      };
    } catch (error) {
      return console.error("Failed to calculate ROI metrics:", error), null;
    }
  }
  async storeROIMetrics(roiMetrics) {
    try {
      await db.log.create({
        data: {
          userId: roiMetrics.userId,
          type: "roi_metrics",
          message: `ROI: ${roiMetrics.roi.toFixed(2)}x return, $${roiMetrics.estimatedValueAdded.toFixed(2)} value added`,
          metadata: {
            healthScoreImprovement: roiMetrics.healthScoreImprovement,
            productsProcessed: roiMetrics.productsProcessed,
            aiTokensUsed: roiMetrics.aiTokensUsed,
            estimatedValueAdded: roiMetrics.estimatedValueAdded,
            costPerImprovement: roiMetrics.costPerImprovement,
            roi: roiMetrics.roi,
            timePeriod: roiMetrics.timePeriod
          }
        }
      });
    } catch (error) {
      console.error("Failed to store ROI metrics:", error);
    }
  }
  async getPerformanceTrends(userId, days = 30) {
    try {
      let startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1e3), audits = await db.audit.findMany({
        where: {
          userId,
          timestamp: { gte: startDate }
        },
        orderBy: { timestamp: "asc" }
      }), user = await db.user.findUnique({
        where: { id: userId }
      });
      return audits.map((audit) => ({
        date: audit.timestamp.toISOString().split("T")[0],
        healthScore: audit.score,
        totalProducts: audit.totalProducts,
        issuesFound: Array.isArray(audit.gaps) ? audit.gaps.length : 0,
        aiUsage: user?.aiUsage || 0
      }));
    } catch (error) {
      return console.error("Failed to get performance trends:", error), [];
    }
  }
  async getROISummary(userId) {
    try {
      let roiLogs = await db.log.findMany({
        where: {
          userId,
          type: "roi_metrics"
        },
        orderBy: { createdAt: "desc" },
        take: 10
      });
      if (roiLogs.length === 0)
        return null;
      let totalValueAdded = 0, totalCost = 0, totalROI = 0;
      for (let log2 of roiLogs) {
        let metadata = log2.metadata;
        metadata && (totalValueAdded += metadata.estimatedValueAdded || 0, totalCost += (metadata.aiTokensUsed || 0) * 1e-4, totalROI += metadata.roi || 0);
      }
      return {
        totalROI,
        totalValueAdded,
        totalCost,
        averageROI: totalROI / roiLogs.length
      };
    } catch (error) {
      return console.error("Failed to get ROI summary:", error), null;
    }
  }
}, AnalyticsService = _AnalyticsService;
__publicField(AnalyticsService, "instance");
var analyticsService = AnalyticsService.getInstance();

// app/utils/healthChecker.ts
import Ajv from "ajv";
import addFormats from "ajv-formats";
import axios from "axios";
var ajv = new Ajv();
addFormats(ajv);
var HealthCheckerService = class {
  shopDomain;
  accessToken;
  constructor(shopDomain, accessToken) {
    this.shopDomain = shopDomain, this.accessToken = accessToken;
  }
  async performHealthCheck(options = {}) {
    let {
      maxProducts = 100,
      includePings = !0,
      includeInventory = !0,
      includeValidation = !0
    } = options;
    try {
      let user = await db.user.findUnique({
        where: { shopId: this.shopDomain }
      });
      if (!user)
        throw new Error("User not found");
      let thirtyDaysAgo = /* @__PURE__ */ new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      let products = await db.product.findMany({
        where: {
          userId: user.id,
          updatedAt: {
            gte: thirtyDaysAgo
          }
        },
        take: maxProducts,
        orderBy: {
          updatedAt: "desc"
        }
      }), gaps = [], validProducts = 0;
      if (includeValidation) {
        let validationResults = await this.validateProducts(products);
        gaps.push(...validationResults.gaps), validProducts = validationResults.validCount;
      }
      if (includePings) {
        let pingResults = await this.checkProductUrls(products.slice(0, 20));
        gaps.push(...pingResults);
      }
      if (includeInventory) {
        let inventoryResults = await this.checkInventoryDeltas(products);
        gaps.push(...inventoryResults);
      }
      let score = this.calculateHealthScore(products.length, validProducts, gaps), trends = await this.getHealthTrends(user.id, 7);
      await db.audit.create({
        data: {
          userId: user.id,
          score,
          totalProducts: products.length,
          validProducts,
          gaps,
          // Store as JSON
          timestamp: /* @__PURE__ */ new Date()
        }
      });
      let performanceMetrics = {
        userId: user.id,
        shopDomain: this.shopDomain,
        timestamp: /* @__PURE__ */ new Date(),
        healthScore: score,
        totalProducts: products.length,
        validProducts,
        issuesFound: gaps.length,
        issuesFixed: 0,
        // Will be updated after auto-fix
        aiUsage: user.aiUsage,
        syncCount: 0,
        // Will be calculated separately
        enrichmentCount: 0
        // Will be calculated separately
      };
      return await analyticsService.trackPerformanceMetrics(performanceMetrics), {
        score,
        totalProducts: products.length,
        validProducts,
        gaps,
        trends,
        timestamp: /* @__PURE__ */ new Date()
      };
    } catch (error) {
      throw console.error("Health check failed:", error), new Error(`Health check failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async validateProducts(products) {
    let gaps = [], validCount = 0, requiredFields = [
      "title",
      "description",
      "vendor",
      "productType",
      "tags",
      "images",
      "variants",
      "options",
      "status"
    ], fieldCounts = {}, missingFieldProducts = {};
    for (let product of products) {
      let isValid = !0;
      for (let field of requiredFields)
        (!product[field] || Array.isArray(product[field]) && product[field].length === 0 || typeof product[field] == "string" && product[field].trim() === "") && (fieldCounts[field] = (fieldCounts[field] || 0) + 1, missingFieldProducts[field] = missingFieldProducts[field] || [], missingFieldProducts[field].push(product.id), isValid = !1);
      isValid && validCount++;
    }
    for (let [field, count] of Object.entries(fieldCounts))
      if (count > 0) {
        let severity = count > products.length * 0.5 ? "critical" : count > products.length * 0.2 ? "error" : "warning";
        gaps.push({
          field,
          severity,
          count,
          products: missingFieldProducts[field],
          fixable: ["title", "description", "tags"].includes(field)
        });
      }
    return { gaps, validCount };
  }
  async checkProductUrls(products) {
    let gaps = [], failedUrls = [];
    for (let product of products)
      if (product.handle)
        try {
          let url = `https://${this.shopDomain}/products/${product.handle}`;
          (await axios.get(url, {
            timeout: 5e3,
            validateStatus: (status) => status < 500
            // Accept redirects and client errors
          })).status >= 400 && failedUrls.push(product.id);
        } catch {
          failedUrls.push(product.id);
        }
    return failedUrls.length > 0 && gaps.push({
      field: "product_url",
      severity: failedUrls.length > products.length * 0.3 ? "error" : "warning",
      count: failedUrls.length,
      products: failedUrls,
      fixable: !1
    }), gaps;
  }
  async checkInventoryDeltas(products) {
    let gaps = [], lowInventory = [], outOfStock = [];
    for (let product of products)
      if (product.variants && Array.isArray(product.variants))
        for (let variant of product.variants)
          variant.inventoryQuantity !== void 0 && (variant.inventoryQuantity === 0 ? outOfStock.push(variant.id) : variant.inventoryQuantity < 5 && lowInventory.push(variant.id));
    return outOfStock.length > 0 && gaps.push({
      field: "inventory_out_of_stock",
      severity: "error",
      count: outOfStock.length,
      products: outOfStock,
      fixable: !1
    }), lowInventory.length > 0 && gaps.push({
      field: "inventory_low",
      severity: "warning",
      count: lowInventory.length,
      products: lowInventory,
      fixable: !1
    }), gaps;
  }
  calculateHealthScore(totalProducts, validProducts, gaps) {
    if (totalProducts === 0)
      return 100;
    let score = validProducts / totalProducts * 100;
    for (let gap of gaps) {
      let penalty = gap.severity === "critical" ? 5 : gap.severity === "error" ? 3 : 1;
      score -= Math.min(penalty * (gap.count / totalProducts), 10);
    }
    return Math.max(0, Math.round(score));
  }
  async getHealthTrends(userId, days) {
    let startDate = /* @__PURE__ */ new Date();
    return startDate.setDate(startDate.getDate() - days), (await db.audit.findMany({
      where: {
        userId,
        timestamp: {
          gte: startDate
        }
      },
      orderBy: {
        timestamp: "asc"
      }
    })).map((audit) => ({
      date: audit.timestamp.toISOString().split("T")[0],
      score: audit.score,
      totalProducts: audit.totalProducts,
      validProducts: audit.validProducts
    }));
  }
  async autoFixGaps(gaps) {
    let fixed = 0, failed = 0;
    for (let gap of gaps)
      if (gap.fixable)
        try {
          console.log(`Auto-fixing gap: ${gap.field} for ${gap.count} products`), fixed++;
        } catch (error) {
          console.error(`Failed to fix gap ${gap.field}:`, error), failed++;
        }
    return { fixed, failed };
  }
  async sendWeeklyHealthSummary(userId) {
    try {
      let fourteenDaysAgo = /* @__PURE__ */ new Date();
      fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
      let audits = await db.audit.findMany({
        where: {
          userId,
          timestamp: {
            gte: fourteenDaysAgo
          }
        },
        orderBy: {
          timestamp: "desc"
        }
      });
      if (audits.length === 0)
        return console.log("No audit data available for weekly summary"), !1;
      let currentAudit = audits[0], previousAudit = audits[audits.length - 1] || currentAudit, oneWeekAgo = /* @__PURE__ */ new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
      let fixedIssues = await db.log.count({
        where: {
          userId,
          type: "auto_fix",
          createdAt: {
            gte: oneWeekAgo
          }
        }
      }), summary = {
        userId,
        shopDomain: this.shopDomain,
        currentScore: currentAudit.score,
        previousScore: previousAudit.score,
        scoreChange: currentAudit.score - previousAudit.score,
        totalProducts: currentAudit.totalProducts,
        issuesFound: Array.isArray(currentAudit.gaps) ? currentAudit.gaps.length : 0,
        issuesFixed: fixedIssues,
        trendData: audits.slice(0, 7).map((audit) => ({
          date: audit.timestamp.toISOString().split("T")[0],
          score: audit.score
        }))
      };
      return await emailService.sendWeeklyHealthSummary(summary);
    } catch (error) {
      return console.error("Failed to send weekly health summary:", error), !1;
    }
  }
  async sendHealthAlert(userId, alertType, message) {
    return await emailService.sendHealthAlert(userId, this.shopDomain, alertType, message);
  }
};

// app/utils/queue.ts
var redis = null;
try {
  console.log("Checking Redis configuration:", {
    redisHost: process.env.REDIS_HOST,
    redisPort: process.env.REDIS_PORT,
    hasRedisPassword: !!process.env.REDIS_PASSWORD,
    allEnvVars: Object.keys(process.env).filter((key) => key.startsWith("REDIS"))
  }), process.env.REDIS_URL ? (console.log("Attempting Redis connection using REDIS_URL:", process.env.REDIS_URL.replace(/\/\/default:[^@]+@/, "//default:***@")), redis = new Redis(process.env.REDIS_URL, {
    maxRetriesPerRequest: null,
    // Required by BullMQ for blocking operations
    connectTimeout: 5e3,
    // 5 second timeout
    lazyConnect: !0,
    // Don't connect immediately
    db: 0
    // Force database 0 (default)
  })) : process.env.REDIS_HOST && process.env.REDIS_PASSWORD ? (console.log("Attempting Redis connection to:", process.env.REDIS_HOST), redis = new Redis({
    host: process.env.REDIS_HOST,
    port: parseInt(process.env.REDIS_PORT || "6379"),
    password: process.env.REDIS_PASSWORD,
    maxRetriesPerRequest: null,
    // Required by BullMQ for blocking operations
    connectTimeout: 5e3,
    // 5 second timeout
    lazyConnect: !0,
    // Don't connect immediately
    db: 0
    // Force database 0 (default)
  })) : console.log("Redis not configured - skipping connection"), redis && redis.connect().then(() => {
    console.log("\u2705 Redis connected successfully");
  }).catch((error) => {
    console.error("\u274C Redis connection failed:", error.message), redis = null;
  });
} catch (error) {
  console.error("Failed to initialize Redis connection:", error), redis = null;
}
var bullmqQueueConnection = null, bullmqWorkerConnection = null, bullmqEventsConnection = null;
if (redis)
  try {
    let connectionConfig = null;
    if (process.env.REDIS_URL) {
      let cleanRedisUrl = process.env.REDIS_URL.replace(/['"]+$/, "");
      console.log("Cleaned REDIS_URL:", cleanRedisUrl.replace(/\/\/default:[^@]+@/, "//default:***@"));
      let url = new URL(cleanRedisUrl);
      connectionConfig = {
        host: url.hostname,
        port: parseInt(url.port) || 6379,
        password: url.password,
        db: 0,
        // Explicitly force database 0
        maxRetriesPerRequest: null,
        retryDelayOnFailover: 100,
        connectTimeout: 5e3,
        lazyConnect: !0,
        enableAutoPipelining: !1
      };
    } else
      process.env.REDIS_HOST && process.env.REDIS_PASSWORD && (connectionConfig = {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT || "6379"),
        password: process.env.REDIS_PASSWORD,
        db: 0,
        // Explicitly force database 0
        maxRetriesPerRequest: null,
        retryDelayOnFailover: 100,
        connectTimeout: 5e3,
        lazyConnect: !0,
        enableAutoPipelining: !1
      });
    connectionConfig && (bullmqQueueConnection = new Redis(connectionConfig), bullmqWorkerConnection = new Redis(connectionConfig), bullmqEventsConnection = new Redis(connectionConfig), bullmqQueueConnection.on("connect", () => {
      console.log("BullMQ Queue Redis connected to database:", bullmqQueueConnection?.options.db);
    }), bullmqWorkerConnection.on("connect", () => {
      console.log("BullMQ Worker Redis connected to database:", bullmqWorkerConnection?.options.db);
    }), bullmqEventsConnection.on("connect", () => {
      console.log("BullMQ Events Redis connected to database:", bullmqEventsConnection?.options.db);
    }), console.log("BullMQ Redis connections created with database 0"));
  } catch (error) {
    console.error("Failed to create BullMQ Redis connections:", error), bullmqQueueConnection = null, bullmqWorkerConnection = null, bullmqEventsConnection = null;
  }
var healthCheckQueue = bullmqQueueConnection ? new Queue("health-checks", {
  connection: bullmqQueueConnection,
  defaultJobOptions: {
    removeOnComplete: 10,
    removeOnFail: 5,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 2e3
    }
  }
}) : null, backgroundJobsQueue = bullmqQueueConnection ? new Queue("background-jobs", {
  connection: bullmqQueueConnection,
  defaultJobOptions: {
    removeOnComplete: 50,
    removeOnFail: 10,
    attempts: 2,
    backoff: {
      type: "exponential",
      delay: 5e3
    }
  }
}) : null, queueEvents = bullmqEventsConnection ? new QueueEvents("health-checks", { connection: bullmqEventsConnection }) : null, healthCheckWorker = bullmqWorkerConnection ? new Worker(
  "health-checks",
  async (job) => {
    let { type, data: data3 } = job.data;
    switch (type) {
      case "url-ping":
        return await performUrlPing(data3);
      case "inventory-validation":
        return await performInventoryValidation(data3);
      case "database-health":
        return await performDatabaseHealthCheck(data3);
      case "api-status":
        return await performApiStatusCheck(data3);
      case "health-scan":
        return await performHealthScan(data3);
      default:
        throw new Error(`Unknown health check type: ${type}`);
    }
  },
  {
    connection: bullmqWorkerConnection,
    concurrency: 5
  }
) : null, backgroundJobsWorker = bullmqWorkerConnection ? new Worker(
  "background-jobs",
  async (job) => {
    let { type, data: data3 } = job.data;
    switch (type) {
      case "sync-products":
        return await performProductSync(data3);
      case "ai-enrichment":
        return await performAIEnrichment(data3);
      case "cleanup-logs":
        return await performLogCleanup(data3);
      case "weekly-email-summary":
        return await performWeeklyEmailSummary(data3);
      default:
        throw new Error(`Unknown background job type: ${type}`);
    }
  },
  {
    connection: bullmqWorkerConnection,
    concurrency: 3
  }
) : null;
async function performUrlPing(data3) {
  try {
    let response = await fetch(data3.url, {
      method: "HEAD",
      signal: AbortSignal.timeout(data3.timeout || 5e3)
    });
    return {
      success: response.ok,
      status: response.status,
      responseTime: Date.now(),
      url: data3.url
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Unknown error",
      url: data3.url
    };
  }
}
async function performInventoryValidation(data3) {
  try {
    let user = await db.user.findUnique({
      where: { shopId: data3.shopId },
      include: {
        audits: {
          orderBy: { timestamp: "desc" },
          take: 1
        }
      }
    });
    if (!user)
      return {
        success: !1,
        error: "User not found",
        shopId: data3.shopId
      };
    let latestAudit = user.audits[0];
    return {
      success: !0,
      hasRecentSync: latestAudit && Date.now() - new Date(latestAudit.timestamp).getTime() < 24 * 60 * 60 * 1e3,
      totalProducts: latestAudit?.totalProducts || 0,
      lastSync: latestAudit?.timestamp || null,
      shopId: data3.shopId
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Database error",
      shopId: data3.shopId
    };
  }
}
async function performDatabaseHealthCheck(data3) {
  try {
    return await db.$queryRaw`SELECT 1`, {
      success: !0,
      userCount: await db.user.count(),
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Database connection failed"
    };
  }
}
async function performApiStatusCheck(data3) {
  try {
    return {
      success: !0,
      shopId: data3.shopId,
      apiVersion: "2025-10",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "API check failed",
      shopId: data3.shopId
    };
  }
}
async function performProductSync(data3) {
  try {
    return await db.log.create({
      data: {
        userId: data3.userId,
        type: "sync",
        message: `Product sync initiated for shop ${data3.shopId}`
      }
    }), {
      success: !0,
      shopId: data3.shopId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Sync failed",
      shopId: data3.shopId
    };
  }
}
async function performAIEnrichment(data3) {
  try {
    return await db.log.create({
      data: {
        userId: data3.userId,
        type: "ai_enrichment",
        message: `AI enrichment initiated for ${data3.productIds.length} products`
      }
    }), {
      success: !0,
      shopId: data3.shopId,
      productCount: data3.productIds.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "AI enrichment failed",
      shopId: data3.shopId
    };
  }
}
async function performLogCleanup(data3) {
  try {
    let daysToKeep = data3.daysToKeep || 30, cutoffDate = /* @__PURE__ */ new Date();
    return cutoffDate.setDate(cutoffDate.getDate() - daysToKeep), {
      success: !0,
      deletedCount: (await db.log.deleteMany({
        where: {
          createdAt: {
            lt: cutoffDate
          }
        }
      })).count,
      cutoffDate: cutoffDate.toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Log cleanup failed"
    };
  }
}
async function performHealthScan(data3) {
  try {
    let user = await db.user.findUnique({
      where: { shopId: data3.shopId }
    });
    if (!user)
      throw new Error("User not found");
    let healthChecker = new HealthCheckerService(data3.shopId, user.accessToken), result = await healthChecker.performHealthCheck(data3.options || {
      maxProducts: 100,
      includePings: !0,
      includeInventory: !0,
      includeValidation: !0
    });
    if (await db.log.create({
      data: {
        userId: data3.userId,
        type: "health_scan",
        message: `Health scan completed: ${result.score}% score, ${result.gaps.length} gaps found`,
        metadata: {
          score: result.score,
          totalProducts: result.totalProducts,
          validProducts: result.validProducts,
          gapsCount: result.gaps.length
        }
      }
    }), result.score < 90 && result.gaps.length > 0) {
      let fixableGaps = result.gaps.filter((gap) => gap.fixable);
      if (fixableGaps.length > 0) {
        let fixResult = await healthChecker.autoFixGaps(fixableGaps);
        await db.log.create({
          data: {
            userId: data3.userId,
            type: "auto_fix",
            message: `Auto-fixed ${fixResult.fixed} gaps, ${fixResult.failed} failed`,
            metadata: {
              fixed: fixResult.fixed,
              failed: fixResult.failed,
              originalScore: result.score
            }
          }
        });
        let user2 = await db.user.findUnique({
          where: { id: data3.userId }
        });
        user2 && await analyticsService.trackPerformanceMetrics({
          userId: data3.userId,
          shopDomain: data3.shopId,
          timestamp: /* @__PURE__ */ new Date(),
          healthScore: result.score,
          totalProducts: result.totalProducts,
          validProducts: result.validProducts,
          issuesFound: result.gaps.length,
          issuesFixed: fixResult.fixed,
          aiUsage: user2.aiUsage,
          syncCount: 0,
          enrichmentCount: 0
        });
      }
    }
    return {
      success: !0,
      result,
      shopId: data3.shopId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return await db.log.create({
      data: {
        userId: data3.userId,
        type: "error",
        message: `Health scan failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        error: error instanceof Error ? error.message : "Unknown error"
      }
    }), {
      success: !1,
      error: error instanceof Error ? error.message : "Health scan failed",
      shopId: data3.shopId
    };
  }
}
async function scheduleHealthChecks() {
  if (!healthCheckQueue || !backgroundJobsQueue) {
    console.log("Health checks skipped - queues not available");
    return;
  }
  try {
    await healthCheckQueue.add(
      "database-health",
      {},
      {
        repeat: { pattern: "*/5 * * * *" },
        jobId: "database-health-recurring"
      }
    ), await healthCheckQueue.add(
      "url-ping",
      { url: process.env.SHOPIFY_APP_URL + "/health" },
      {
        repeat: { pattern: "*/2 * * * *" },
        jobId: "url-ping-recurring"
      }
    ), await backgroundJobsQueue.add(
      "cleanup-logs",
      { daysToKeep: 30 },
      {
        repeat: { pattern: "0 2 * * *" },
        jobId: "log-cleanup-recurring"
      }
    ), await backgroundJobsQueue.add(
      "weekly-email-summary",
      {},
      {
        repeat: { pattern: "0 8 * * 1" },
        jobId: "weekly-email-summary-recurring"
      }
    ), console.log("Health checks scheduled successfully");
  } catch (error) {
    console.error("Failed to schedule health checks:", error);
  }
}
async function performWeeklyEmailSummary(data3) {
  try {
    let validUsers = (data3.userId ? [await db.user.findUnique({ where: { id: data3.userId } })] : await db.user.findMany()).filter((user) => user !== null);
    for (let user of validUsers) {
      if (!user)
        continue;
      let success = await new HealthCheckerService(user.shopDomain, user.accessToken).sendWeeklyHealthSummary(user.id);
      await db.log.create({
        data: {
          userId: user.id,
          type: "weekly_email_summary",
          message: `Weekly email summary ${success ? "sent" : "failed"} for ${user.shopDomain}`,
          metadata: {
            success,
            shopDomain: user.shopDomain
          }
        }
      });
    }
    return {
      success: !0,
      usersProcessed: validUsers.length,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    return {
      success: !1,
      error: error instanceof Error ? error.message : "Weekly email summary failed"
    };
  }
}
async function scheduleDailyHealthScans() {
  if (!healthCheckQueue) {
    console.log("Health scans skipped - queue not available");
    return;
  }
  try {
    let users = await db.user.findMany({
      select: {
        id: !0,
        shopId: !0,
        tier: !0
      }
    });
    for (let user of users)
      await healthCheckQueue.add(
        "health-scan",
        {
          shopId: user.shopId,
          userId: user.id,
          options: {
            maxProducts: user.tier === "enterprise" ? 500 : 100,
            includePings: !0,
            includeInventory: !0,
            includeValidation: !0
          }
        },
        {
          repeat: { pattern: "0 2 * * *" },
          jobId: `health-scan-${user.shopId}`
        }
      );
    console.log(`Daily health scans scheduled for ${users.length} users`);
  } catch (error) {
    console.error("Failed to schedule daily health scans:", error);
  }
}
healthCheckWorker && healthCheckWorker.on("error", (error) => {
  console.error("Health check worker error:", error);
});
backgroundJobsWorker && backgroundJobsWorker.on("error", (error) => {
  console.error("Background jobs worker error:", error);
});
queueEvents && queueEvents.on("error", (error) => {
  console.error("Queue events error:", error);
});

// app/entry.server.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1), ABORT_DELAY = 5e3;
typeof global < "u" && !global.healthChecksInitialized && (console.log("Checking Redis configuration:", {
  redisHost: process.env.REDIS_HOST,
  redisPort: process.env.REDIS_PORT,
  hasRedisPassword: !!process.env.REDIS_PASSWORD,
  allEnvVars: Object.keys(process.env).filter((key) => key.startsWith("REDIS"))
}), process.env.REDIS_HOST && process.env.REDIS_PASSWORD ? (console.log("Redis configuration found - initializing health checks"), scheduleHealthChecks().catch((error) => {
  console.error("Failed to initialize health checks:", error);
}), scheduleDailyHealthScans().catch((error) => {
  console.error("Failed to schedule daily health scans:", error);
})) : console.log("Health checks skipped - Redis not configured"), global.healthChecksInitialized = !0);
function handleRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return isbot(request2.headers.get("user-agent")) ? handleBotRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request2,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function handleBotRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = !1, { pipe, abort } = (0, import_server4.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onAllReady() {
          shellRendered = !0;
          let body = new PassThrough(), stream = (0, import_node.createReadableStreamFromReadable)(body);
          responseHeaders.set("Content-Type", "text/html"), responseHeaders.set("X-Frame-Options", "ALLOWALL"), responseHeaders.set("Content-Security-Policy", "frame-ancestors https://*.myshopify.com https://admin.shopify.com"), resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500, shellRendered && console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request2, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let shellRendered = !1, { pipe, abort } = (0, import_server4.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        RemixServer,
        {
          context: remixContext,
          url: request2.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onShellReady() {
          shellRendered = !0;
          let body = new PassThrough(), stream = (0, import_node.createReadableStreamFromReadable)(body);
          responseHeaders.set("Content-Type", "text/html"), responseHeaders.set("X-Frame-Options", "ALLOWALL"), responseHeaders.set("Content-Security-Policy", "frame-ancestors https://*.myshopify.com https://admin.shopify.com"), resolve(
            new Response(stream, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500, shellRendered && console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});

// node_modules/@shopify/polaris/build/esm/types.js
var Key;
(function(Key2) {
  Key2[Key2.Backspace = 8] = "Backspace", Key2[Key2.Tab = 9] = "Tab", Key2[Key2.Enter = 13] = "Enter", Key2[Key2.Shift = 16] = "Shift", Key2[Key2.Ctrl = 17] = "Ctrl", Key2[Key2.Alt = 18] = "Alt", Key2[Key2.Pause = 19] = "Pause", Key2[Key2.CapsLock = 20] = "CapsLock", Key2[Key2.Escape = 27] = "Escape", Key2[Key2.Space = 32] = "Space", Key2[Key2.PageUp = 33] = "PageUp", Key2[Key2.PageDown = 34] = "PageDown", Key2[Key2.End = 35] = "End", Key2[Key2.Home = 36] = "Home", Key2[Key2.LeftArrow = 37] = "LeftArrow", Key2[Key2.UpArrow = 38] = "UpArrow", Key2[Key2.RightArrow = 39] = "RightArrow", Key2[Key2.DownArrow = 40] = "DownArrow", Key2[Key2.Insert = 45] = "Insert", Key2[Key2.Delete = 46] = "Delete", Key2[Key2.Key0 = 48] = "Key0", Key2[Key2.Key1 = 49] = "Key1", Key2[Key2.Key2 = 50] = "Key2", Key2[Key2.Key3 = 51] = "Key3", Key2[Key2.Key4 = 52] = "Key4", Key2[Key2.Key5 = 53] = "Key5", Key2[Key2.Key6 = 54] = "Key6", Key2[Key2.Key7 = 55] = "Key7", Key2[Key2.Key8 = 56] = "Key8", Key2[Key2.Key9 = 57] = "Key9", Key2[Key2.KeyA = 65] = "KeyA", Key2[Key2.KeyB = 66] = "KeyB", Key2[Key2.KeyC = 67] = "KeyC", Key2[Key2.KeyD = 68] = "KeyD", Key2[Key2.KeyE = 69] = "KeyE", Key2[Key2.KeyF = 70] = "KeyF", Key2[Key2.KeyG = 71] = "KeyG", Key2[Key2.KeyH = 72] = "KeyH", Key2[Key2.KeyI = 73] = "KeyI", Key2[Key2.KeyJ = 74] = "KeyJ", Key2[Key2.KeyK = 75] = "KeyK", Key2[Key2.KeyL = 76] = "KeyL", Key2[Key2.KeyM = 77] = "KeyM", Key2[Key2.KeyN = 78] = "KeyN", Key2[Key2.KeyO = 79] = "KeyO", Key2[Key2.KeyP = 80] = "KeyP", Key2[Key2.KeyQ = 81] = "KeyQ", Key2[Key2.KeyR = 82] = "KeyR", Key2[Key2.KeyS = 83] = "KeyS", Key2[Key2.KeyT = 84] = "KeyT", Key2[Key2.KeyU = 85] = "KeyU", Key2[Key2.KeyV = 86] = "KeyV", Key2[Key2.KeyW = 87] = "KeyW", Key2[Key2.KeyX = 88] = "KeyX", Key2[Key2.KeyY = 89] = "KeyY", Key2[Key2.KeyZ = 90] = "KeyZ", Key2[Key2.LeftMeta = 91] = "LeftMeta", Key2[Key2.RightMeta = 92] = "RightMeta", Key2[Key2.Select = 93] = "Select", Key2[Key2.Numpad0 = 96] = "Numpad0", Key2[Key2.Numpad1 = 97] = "Numpad1", Key2[Key2.Numpad2 = 98] = "Numpad2", Key2[Key2.Numpad3 = 99] = "Numpad3", Key2[Key2.Numpad4 = 100] = "Numpad4", Key2[Key2.Numpad5 = 101] = "Numpad5", Key2[Key2.Numpad6 = 102] = "Numpad6", Key2[Key2.Numpad7 = 103] = "Numpad7", Key2[Key2.Numpad8 = 104] = "Numpad8", Key2[Key2.Numpad9 = 105] = "Numpad9", Key2[Key2.Multiply = 106] = "Multiply", Key2[Key2.Add = 107] = "Add", Key2[Key2.Subtract = 109] = "Subtract", Key2[Key2.Decimal = 110] = "Decimal", Key2[Key2.Divide = 111] = "Divide", Key2[Key2.F1 = 112] = "F1", Key2[Key2.F2 = 113] = "F2", Key2[Key2.F3 = 114] = "F3", Key2[Key2.F4 = 115] = "F4", Key2[Key2.F5 = 116] = "F5", Key2[Key2.F6 = 117] = "F6", Key2[Key2.F7 = 118] = "F7", Key2[Key2.F8 = 119] = "F8", Key2[Key2.F9 = 120] = "F9", Key2[Key2.F10 = 121] = "F10", Key2[Key2.F11 = 122] = "F11", Key2[Key2.F12 = 123] = "F12", Key2[Key2.NumLock = 144] = "NumLock", Key2[Key2.ScrollLock = 145] = "ScrollLock", Key2[Key2.Semicolon = 186] = "Semicolon", Key2[Key2.Equals = 187] = "Equals", Key2[Key2.Comma = 188] = "Comma", Key2[Key2.Dash = 189] = "Dash", Key2[Key2.Period = 190] = "Period", Key2[Key2.ForwardSlash = 191] = "ForwardSlash", Key2[Key2.GraveAccent = 192] = "GraveAccent", Key2[Key2.OpenBracket = 219] = "OpenBracket", Key2[Key2.BackSlash = 220] = "BackSlash", Key2[Key2.CloseBracket = 221] = "CloseBracket", Key2[Key2.SingleQuote = 222] = "SingleQuote";
})(Key || (Key = {}));

// node_modules/@shopify/polaris/build/esm/components/shared.js
var scrollable = {
  props: {
    "data-polaris-scrollable": !0
  },
  selector: "[data-polaris-scrollable]"
}, overlay = {
  props: {
    "data-polaris-overlay": !0
  },
  selector: "[data-polaris-overlay]"
}, layer = {
  props: {
    "data-polaris-layer": !0
  },
  selector: "[data-polaris-layer]"
}, unstyled = {
  props: {
    "data-polaris-unstyled": !0
  },
  selector: "[data-polaris-unstyled]"
}, dataPolarisTopBar = {
  props: {
    "data-polaris-top-bar": !0
  },
  selector: "[data-polaris-top-bar]"
}, headerCell = {
  props: {
    "data-polaris-header-cell": !0
  },
  selector: "[data-polaris-header-cell]"
}, portal = {
  props: ["data-portal-id"],
  selector: "[data-portal-id]"
};

// node_modules/@shopify/polaris/build/esm/components/ThemeProvider/ThemeProvider.js
var import_react3 = __toESM(require_react());

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/breakpoints.mjs
var breakpointsAliases = ["xs", "sm", "md", "lg", "xl"], breakpoints = {
  "breakpoints-xs": {
    value: "0px",
    description: "Commonly used for sizing containers (e.g. max-width). See below for media query usage."
  },
  "breakpoints-sm": {
    value: "490px",
    description: "Commonly used for sizing containers (e.g. max-width). See below for media query usage."
  },
  "breakpoints-md": {
    value: "768px",
    description: "Commonly used for sizing containers (e.g. max-width). See below for media query usage."
  },
  "breakpoints-lg": {
    value: "1040px",
    description: "Commonly used for sizing containers (e.g. max-width). See below for media query usage."
  },
  "breakpoints-xl": {
    value: "1440px",
    description: "Commonly used for sizing containers (e.g. max-width). See below for media query usage."
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/_virtual/_rollupPluginBabelHelpers.mjs
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, i === 0) {
        if (Object(_i) !== _i)
          return;
        _n = !1;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0)
          ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && _i.return != null && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _taggedTemplateLiteralLoose(strings, raw) {
  return raw || (raw = strings.slice(0)), strings.raw = raw, strings;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if (typeof o == "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
}
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}

// node_modules/@shopify/polaris-tokens/dist/esm/src/utils.mjs
var _templateObject, BASE_FONT_SIZE = 16, UNIT_PX = "px", UNIT_EM = "em", UNIT_REM = "rem", DIGIT_REGEX = new RegExp(String.raw(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["-?d+(?:.d+|d*)"], ["-?\\d+(?:\\.\\d+|\\d*)"])))), UNIT_REGEX = new RegExp(UNIT_PX + "|" + UNIT_EM + "|" + UNIT_REM);
function getUnit(value) {
  value === void 0 && (value = "");
  var unit = value.match(new RegExp(DIGIT_REGEX.source + "(" + UNIT_REGEX.source + ")"));
  return unit && unit[1];
}
function toPx(value) {
  value === void 0 && (value = "");
  var unit = getUnit(value);
  if (!unit || unit === UNIT_PX)
    return value;
  if (unit === UNIT_EM || unit === UNIT_REM)
    return "" + parseFloat(value) * BASE_FONT_SIZE + UNIT_PX;
}
function toEm(value, fontSize) {
  value === void 0 && (value = ""), fontSize === void 0 && (fontSize = BASE_FONT_SIZE);
  var unit = getUnit(value);
  if (!unit || unit === UNIT_EM)
    return value;
  if (unit === UNIT_PX)
    return "" + parseFloat(value) / fontSize + UNIT_EM;
  if (unit === UNIT_REM)
    return "" + parseFloat(value) * BASE_FONT_SIZE / fontSize + UNIT_EM;
}
function toRem(value) {
  value === void 0 && (value = "");
  var unit = getUnit(value);
  if (!unit || unit === UNIT_REM)
    return value;
  if (unit === UNIT_EM)
    return "" + parseFloat(value) + UNIT_REM;
  if (unit === UNIT_PX)
    return "" + parseFloat(value) / BASE_FONT_SIZE + UNIT_REM;
}
function rem(value) {
  return value.replace(new RegExp(DIGIT_REGEX.source + "(" + UNIT_PX + ")", "g"), function(px) {
    var _toRem;
    return (_toRem = toRem(px)) != null ? _toRem : px;
  });
}
function tokenGroupToRems(metaTokenGroup) {
  return Object.fromEntries(
    Object.entries(metaTokenGroup).map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), tokenName = _ref2[0], tokenProperties = _ref2[1];
      return [tokenName, Object.assign(Object.assign({}, tokenProperties), {}, {
        value: rem(tokenProperties.value)
      })];
    })
    // We loose the `metaTokenGroup` inference after transforming the object with
    // `Object.fromEntries()` and `Object.entries()`. Thus, we cast the result
    // back to `T` since we are simply converting the `value` from px to rem.
  );
}
function createVarName(tokenName) {
  return "--p-" + tokenName;
}
function createVar(tokenName) {
  return "var(" + createVarName(tokenName) + ")";
}
function getTokenNames(theme) {
  return Object.values(theme).flatMap(function(tokenGroup) {
    return Object.keys(tokenGroup);
  });
}
function getMediaConditions(breakpoints2) {
  var breakpointEntries = Object.entries(breakpoints2), lastBreakpointIndex = breakpointEntries.length - 1;
  return Object.fromEntries(breakpointEntries.map(function(entry2, index) {
    var _ref3 = entry2, _ref4 = _slicedToArray(_ref3, 2), breakpointsTokenName = _ref4[0], breakpoint = _ref4[1], upMediaCondition = getUpMediaCondition(breakpoint), downMediaCondition = getDownMediaCondition(breakpoint), onlyMediaCondition = index === lastBreakpointIndex ? upMediaCondition : upMediaCondition + " and " + getDownMediaCondition(breakpointEntries[index + 1][1]);
    return [breakpointsTokenName, {
      // Media condition for the current breakpoint and up
      up: upMediaCondition,
      // Media condition for current breakpoint and down
      down: downMediaCondition,
      // Media condition for only the current breakpoint
      only: onlyMediaCondition
    }];
  }));
}
function getUpMediaCondition(breakpoint) {
  return "(min-width: " + toEm(breakpoint) + ")";
}
function getDownMediaCondition(breakpoint) {
  var _toPx2, offsetBreakpoint = parseFloat((_toPx2 = toPx(breakpoint)) != null ? _toPx2 : "") - 0.04;
  return "(max-width: " + toEm(offsetBreakpoint + "px") + ")";
}
var tokenGroupNamesToRems = ["border", "breakpoints", "font", "height", "shadow", "space", "text", "width"];
function createMetaThemeBase(metaTheme) {
  return Object.fromEntries(Object.entries(metaTheme).map(function(_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2), tokenGroupName = _ref6[0], tokenGroup = _ref6[1];
    return [tokenGroupName, tokenGroupNamesToRems.includes(tokenGroupName) ? tokenGroupToRems(tokenGroup) : tokenGroup];
  }));
}

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/utils.mjs
import deepmerge from "deepmerge";

// node_modules/@shopify/polaris-tokens/dist/esm/src/size.mjs
var size = {
  0: "0px",
  "0165": "0.66px",
  "025": "1px",
  "050": "2px",
  100: "4px",
  150: "6px",
  200: "8px",
  275: "11px",
  300: "12px",
  325: "13px",
  350: "14px",
  400: "16px",
  450: "18px",
  500: "20px",
  550: "22px",
  600: "24px",
  700: "28px",
  750: "30px",
  800: "32px",
  900: "36px",
  1e3: "40px",
  1200: "48px",
  1600: "64px",
  2e3: "80px",
  2400: "96px",
  2800: "112px",
  3200: "128px"
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/border.mjs
var border = {
  "border-radius-0": {
    value: size[0]
  },
  "border-radius-050": {
    value: size["050"]
  },
  "border-radius-100": {
    value: size[100]
  },
  "border-radius-150": {
    value: size[150]
  },
  "border-radius-200": {
    value: size[200]
  },
  "border-radius-300": {
    value: size[300]
  },
  "border-radius-400": {
    value: size[400]
  },
  "border-radius-500": {
    value: size[500]
  },
  "border-radius-750": {
    value: size[750]
  },
  "border-radius-full": {
    value: "9999px"
  },
  "border-width-0": {
    value: size[0]
  },
  "border-width-0165": {
    value: size["0165"]
  },
  "border-width-025": {
    value: size["025"]
  },
  "border-width-050": {
    value: size["050"]
  },
  "border-width-100": {
    value: size[100]
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/colors.mjs
var gray = {
  1: "rgba(255, 255, 255, 1)",
  2: "rgba(253, 253, 253, 1)",
  3: "rgba(250, 250, 250, 1)",
  4: "rgba(247, 247, 247, 1)",
  5: "rgba(243, 243, 243, 1)",
  6: "rgba(241, 241, 241, 1)",
  7: "rgba(235, 235, 235, 1)",
  8: "rgba(227, 227, 227, 1)",
  9: "rgba(212, 212, 212, 1)",
  10: "rgba(204, 204, 204, 1)",
  11: "rgba(181, 181, 181, 1)",
  12: "rgba(138, 138, 138, 1)",
  13: "rgba(97, 97, 97, 1)",
  14: "rgba(74, 74, 74, 1)",
  15: "rgba(48, 48, 48, 1)",
  16: "rgba(26, 26, 26, 1)"
}, azure = {
  1: "rgba(251, 253, 255, 1)",
  2: "rgba(242, 249, 255, 1)",
  3: "rgba(234, 244, 255, 1)",
  4: "rgba(224, 240, 255, 1)",
  5: "rgba(213, 235, 255, 1)",
  6: "rgba(202, 230, 255, 1)",
  7: "rgba(192, 225, 255, 1)",
  8: "rgba(168, 216, 255, 1)",
  9: "rgba(145, 208, 255, 1)",
  10: "rgba(81, 192, 255, 1)",
  11: "rgba(0, 148, 213, 1)",
  12: "rgba(0, 124, 180, 1)",
  13: "rgba(0, 103, 155, 1)",
  14: "rgba(0, 82, 124, 1)",
  15: "rgba(0, 58, 90, 1)",
  16: "rgba(0, 33, 51, 1)"
}, blue = {
  1: "rgba(252, 253, 255, 1)",
  2: "rgba(246, 248, 255, 1)",
  3: "rgba(240, 242, 255, 1)",
  4: "rgba(234, 237, 255, 1)",
  5: "rgba(226, 231, 255, 1)",
  6: "rgba(219, 225, 255, 1)",
  7: "rgba(213, 220, 255, 1)",
  8: "rgba(197, 208, 255, 1)",
  9: "rgba(186, 199, 255, 1)",
  10: "rgba(151, 173, 255, 1)",
  11: "rgba(65, 136, 255, 1)",
  12: "rgba(0, 113, 233, 1)",
  13: "rgba(0, 91, 211, 1)",
  14: "rgba(0, 66, 153, 1)",
  15: "rgba(0, 46, 106, 1)",
  16: "rgba(0, 22, 51, 1)"
}, green = {
  1: "rgba(248, 255, 251, 1)",
  2: "rgba(227, 255, 237, 1)",
  3: "rgba(205, 254, 225, 1)",
  4: "rgba(180, 254, 210, 1)",
  5: "rgba(146, 254, 194, 1)",
  6: "rgba(99, 253, 176, 1)",
  7: "rgba(56, 250, 163, 1)",
  8: "rgba(53, 238, 155, 1)",
  9: "rgba(50, 225, 147, 1)",
  10: "rgba(46, 211, 137, 1)",
  11: "rgba(50, 160, 110, 1)",
  12: "rgba(41, 132, 90, 1)",
  13: "rgba(19, 111, 69, 1)",
  14: "rgba(12, 81, 50, 1)",
  15: "rgba(8, 61, 37, 1)",
  16: "rgba(9, 42, 27, 1)"
}, lime = {
  1: "rgba(250, 255, 250, 1)",
  2: "rgba(228, 255, 229, 1)",
  3: "rgba(208, 255, 209, 1)",
  4: "rgba(187, 254, 190, 1)",
  5: "rgba(157, 254, 160, 1)",
  6: "rgba(119, 254, 122, 1)",
  7: "rgba(56, 254, 62, 1)",
  8: "rgba(40, 242, 47, 1)",
  9: "rgba(37, 232, 43, 1)",
  10: "rgba(32, 207, 39, 1)",
  11: "rgba(24, 168, 29, 1)",
  12: "rgba(17, 135, 21, 1)",
  13: "rgba(12, 113, 15, 1)",
  14: "rgba(11, 85, 13, 1)",
  15: "rgba(3, 61, 5, 1)",
  16: "rgba(3, 33, 4, 1)"
}, magenta = {
  1: "rgba(255, 253, 255, 1)",
  2: "rgba(255, 245, 255, 1)",
  3: "rgba(253, 239, 253, 1)",
  4: "rgba(254, 231, 254, 1)",
  5: "rgba(252, 223, 252, 1)",
  6: "rgba(251, 215, 251, 1)",
  7: "rgba(251, 207, 251, 1)",
  8: "rgba(249, 190, 249, 1)",
  9: "rgba(248, 177, 248, 1)",
  10: "rgba(246, 141, 246, 1)",
  11: "rgba(225, 86, 225, 1)",
  12: "rgba(197, 48, 197, 1)",
  13: "rgba(159, 38, 159, 1)",
  14: "rgba(121, 26, 121, 1)",
  15: "rgba(86, 16, 86, 1)",
  16: "rgba(52, 6, 52, 1)"
}, orange = {
  1: "rgba(255, 253, 250, 1)",
  2: "rgba(255, 247, 238, 1)",
  3: "rgba(255, 241, 227, 1)",
  4: "rgba(255, 235, 213, 1)",
  5: "rgba(255, 228, 198, 1)",
  6: "rgba(255, 221, 182, 1)",
  7: "rgba(255, 214, 164, 1)",
  8: "rgba(255, 200, 121, 1)",
  9: "rgba(255, 184, 0, 1)",
  10: "rgba(229, 165, 0, 1)",
  11: "rgba(178, 132, 0, 1)",
  12: "rgba(149, 111, 0, 1)",
  13: "rgba(124, 88, 0, 1)",
  14: "rgba(94, 66, 0, 1)",
  15: "rgba(65, 45, 0, 1)",
  16: "rgba(37, 26, 0, 1)"
}, purple = {
  1: "rgba(253, 253, 255, 1)",
  2: "rgba(248, 247, 255, 1)",
  3: "rgba(243, 241, 255, 1)",
  4: "rgba(239, 236, 255, 1)",
  5: "rgba(233, 229, 255, 1)",
  6: "rgba(228, 222, 255, 1)",
  7: "rgba(223, 217, 255, 1)",
  8: "rgba(212, 204, 255, 1)",
  9: "rgba(199, 188, 255, 1)",
  10: "rgba(170, 149, 255, 1)",
  11: "rgba(148, 116, 255, 1)",
  12: "rgba(128, 81, 255, 1)",
  13: "rgba(113, 38, 255, 1)",
  14: "rgba(87, 0, 209, 1)",
  15: "rgba(59, 0, 147, 1)",
  16: "rgba(28, 0, 79, 1)"
}, red = {
  1: "rgba(255, 251, 251, 1)",
  2: "rgba(255, 246, 246, 1)",
  3: "rgba(255, 237, 236, 1)",
  4: "rgba(254, 233, 232, 1)",
  5: "rgba(254, 226, 225, 1)",
  6: "rgba(254, 218, 217, 1)",
  7: "rgba(254, 211, 209, 1)",
  8: "rgba(254, 195, 193, 1)",
  9: "rgba(253, 176, 172, 1)",
  10: "rgba(253, 129, 122, 1)",
  11: "rgba(239, 77, 47, 1)",
  12: "rgba(229, 28, 0, 1)",
  13: "rgba(181, 38, 11, 1)",
  14: "rgba(142, 31, 11, 1)",
  15: "rgba(95, 21, 7, 1)",
  16: "rgba(47, 10, 4, 1)"
}, rose = {
  1: "rgba(255, 253, 253, 1)",
  2: "rgba(255, 246, 248, 1)",
  3: "rgba(255, 239, 243, 1)",
  4: "rgba(255, 232, 238, 1)",
  5: "rgba(255, 225, 232, 1)",
  6: "rgba(255, 217, 227, 1)",
  7: "rgba(254, 209, 221, 1)",
  8: "rgba(254, 193, 210, 1)",
  9: "rgba(254, 181, 202, 1)",
  10: "rgba(254, 142, 177, 1)",
  11: "rgba(253, 75, 146, 1)",
  12: "rgba(227, 12, 118, 1)",
  13: "rgba(185, 7, 95, 1)",
  14: "rgba(141, 4, 72, 1)",
  15: "rgba(100, 2, 49, 1)",
  16: "rgba(62, 1, 28, 1)"
}, teal = {
  1: "rgba(248, 255, 254, 1)",
  2: "rgba(232, 252, 250, 1)",
  3: "rgba(215, 250, 247, 1)",
  4: "rgba(195, 247, 242, 1)",
  5: "rgba(170, 246, 239, 1)",
  6: "rgba(137, 245, 236, 1)",
  7: "rgba(112, 240, 229, 1)",
  8: "rgba(90, 230, 219, 1)",
  9: "rgba(44, 224, 212, 1)",
  10: "rgba(30, 199, 188, 1)",
  11: "rgba(0, 161, 152, 1)",
  12: "rgba(18, 131, 124, 1)",
  13: "rgba(12, 106, 100, 1)",
  14: "rgba(12, 83, 79, 1)",
  15: "rgba(3, 60, 57, 1)",
  16: "rgba(6, 44, 41, 1)"
}, yellow = {
  1: "rgba(255, 253, 246, 1)",
  2: "rgba(255, 248, 219, 1)",
  3: "rgba(255, 244, 191, 1)",
  4: "rgba(255, 239, 157, 1)",
  5: "rgba(255, 235, 120, 1)",
  6: "rgba(255, 230, 0, 1)",
  7: "rgba(247, 223, 0, 1)",
  8: "rgba(234, 211, 0, 1)",
  9: "rgba(225, 203, 0, 1)",
  10: "rgba(197, 178, 0, 1)",
  11: "rgba(153, 138, 0, 1)",
  12: "rgba(130, 117, 0, 1)",
  13: "rgba(105, 95, 0, 1)",
  14: "rgba(79, 71, 0, 1)",
  15: "rgba(51, 46, 0, 1)",
  16: "rgba(31, 28, 0, 1)"
}, blackAlpha = {
  1: "rgba(0, 0, 0, 0)",
  2: "rgba(0, 0, 0, 0.01)",
  3: "rgba(0, 0, 0, 0.02)",
  4: "rgba(0, 0, 0, 0.03)",
  5: "rgba(0, 0, 0, 0.05)",
  6: "rgba(0, 0, 0, 0.06)",
  7: "rgba(0, 0, 0, 0.08)",
  8: "rgba(0, 0, 0, 0.11)",
  9: "rgba(0, 0, 0, 0.17)",
  10: "rgba(0, 0, 0, 0.20)",
  11: "rgba(0, 0, 0, 0.29)",
  12: "rgba(0, 0, 0, 0.46)",
  13: "rgba(0, 0, 0, 0.62)",
  14: "rgba(0, 0, 0, 0.71)",
  15: "rgba(0, 0, 0, 0.81)",
  16: "rgba(0, 0, 0, 0.90)"
}, whiteAlpha = {
  1: "rgba(255, 255, 255, 0)",
  2: "rgba(255, 255, 255, 0.01)",
  3: "rgba(255, 255, 255, 0.02)",
  4: "rgba(255, 255, 255, 0.03)",
  5: "rgba(255, 255, 255, 0.05)",
  6: "rgba(255, 255, 255, 0.06)",
  7: "rgba(255, 255, 255, 0.08)",
  8: "rgba(255, 255, 255, 0.11)",
  9: "rgba(255, 255, 255, 0.17)",
  10: "rgba(255, 255, 255, 0.20)",
  11: "rgba(255, 255, 255, 0.28)",
  12: "rgba(255, 255, 255, 0.46)",
  13: "rgba(255, 255, 255, 0.62)",
  14: "rgba(255, 255, 255, 0.71)",
  15: "rgba(255, 255, 255, 0.81)",
  16: "rgba(255, 255, 255, 0.90)"
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/color.mjs
var color = {
  "color-scheme": {
    value: "light"
  },
  "color-bg": {
    value: gray[6],
    description: "The default background color of the admin."
  },
  "color-bg-inverse": {
    value: gray[16],
    description: "Use for high contrast page or component backgrounds."
  },
  "color-bg-surface": {
    value: gray[1],
    description: "The background color for elements with the highest level of prominence, like a card."
  },
  "color-bg-surface-hover": {
    value: gray[4],
    description: "The hover state color for elements with the highest level of prominence."
  },
  "color-bg-surface-active": {
    value: gray[5],
    description: "The active state (on press) color for elements with the highest level of prominence."
  },
  "color-bg-surface-selected": {
    value: gray[6],
    description: "The selected state color for elements with the highest level of prominence."
  },
  "color-bg-surface-disabled": {
    value: blackAlpha[5],
    description: "The disabled state color for elements."
  },
  "color-bg-surface-secondary": {
    value: gray[4],
    description: "The background color for elements with a secondary level of prominence."
  },
  "color-bg-surface-secondary-hover": {
    value: gray[6],
    description: "The hover state color for elements with a secondary level of prominence."
  },
  "color-bg-surface-secondary-active": {
    value: gray[7],
    description: "The active state (on press) color for elements with a secondary level of prominence."
  },
  "color-bg-surface-secondary-selected": {
    value: gray[7],
    description: "The selected state color for elements with a secondary level of prominence."
  },
  "color-bg-surface-tertiary": {
    value: gray[5],
    description: "The background color for elements with a third level of prominence."
  },
  "color-bg-surface-tertiary-hover": {
    value: gray[7],
    description: "The hover state color for elements with a third level of prominence."
  },
  "color-bg-surface-tertiary-active": {
    value: gray[8],
    description: "The active state (on press) color for elements with a third level of prominence."
  },
  "color-bg-surface-brand": {
    value: gray[8],
    description: "Use to apply the key color to elements."
  },
  "color-bg-surface-brand-hover": {
    value: gray[7],
    description: "The hover state color for key elements."
  },
  "color-bg-surface-brand-active": {
    value: gray[6],
    description: "The active state (on press) color for key elements."
  },
  "color-bg-surface-brand-selected": {
    value: gray[6],
    description: "The selected state color for key elements."
  },
  "color-bg-surface-info": {
    value: azure[3],
    description: "Use for backgrounds communicating important information, like banners."
  },
  "color-bg-surface-info-hover": {
    value: azure[4],
    description: "The hover state color for communicating important information."
  },
  "color-bg-surface-info-active": {
    value: azure[6],
    description: "The active state (on press) color for communicating important information."
  },
  "color-bg-surface-success": {
    value: green[3],
    description: "Use for backgrounds communicating success, like banners."
  },
  "color-bg-surface-success-hover": {
    value: green[4],
    description: "The hover state color for communicating success."
  },
  "color-bg-surface-success-active": {
    value: green[5],
    description: "The active state (on press) color for communicating success."
  },
  "color-bg-surface-caution": {
    value: yellow[2],
    description: "Use for backgrounds communicating caution, like banners."
  },
  "color-bg-surface-caution-hover": {
    value: yellow[3],
    description: "The hover state for communicating caution."
  },
  "color-bg-surface-caution-active": {
    value: yellow[4],
    description: "The active state (on press) color for communicating caution."
  },
  "color-bg-surface-warning": {
    value: orange[3],
    description: "Use for backgrounds communicating warning, like banners."
  },
  "color-bg-surface-warning-hover": {
    value: orange[4],
    description: "The hover state color for communicating warning."
  },
  "color-bg-surface-warning-active": {
    value: orange[5],
    description: "The active state (on press) color for communicating warning."
  },
  "color-bg-surface-critical": {
    value: red[4],
    description: "Use for backgrounds communicating critical information, like banners or input errors."
  },
  "color-bg-surface-critical-hover": {
    value: red[5],
    description: "The hover state color for communicating critical information."
  },
  "color-bg-surface-critical-active": {
    value: red[6],
    description: "The active state (on press) color for communicating critical information."
  },
  "color-bg-surface-emphasis": {
    value: blue[3],
    description: "Use for backgrounds indicating areas of focus in editors, such as the theme editor."
  },
  "color-bg-surface-emphasis-hover": {
    value: blue[4],
    description: "The hover state color for elements indicating areas of focus in editors."
  },
  "color-bg-surface-emphasis-active": {
    value: blue[5],
    description: "The active state (on press) color for elements indicating areas of focus in editors."
  },
  "color-bg-surface-magic": {
    value: purple[2],
    description: "Use for backgrounds of elements suggested by magic AI."
  },
  "color-bg-surface-magic-hover": {
    value: purple[3],
    description: "The hover state color for elements suggested by magic AI."
  },
  "color-bg-surface-magic-active": {
    value: purple[5],
    description: "The active state (on press) color for elements suggested by magic AI."
  },
  "color-bg-surface-inverse": {
    value: gray[15],
    description: "Use for elements on bg-inverse."
  },
  "color-bg-surface-transparent": {
    value: blackAlpha[1],
    description: "Use for elements that need a fully transparent background."
  },
  "color-bg-fill": {
    value: gray[1],
    description: "The background color of contained elements with a smaller surface area, like a button."
  },
  "color-bg-fill-hover": {
    value: gray[3],
    description: "The hover state color of contained elements with a smaller surface area, like a button."
  },
  "color-bg-fill-active": {
    value: gray[4],
    description: "The active state (on press) color of contained elements with a smaller surface area, like a button."
  },
  "color-bg-fill-selected": {
    value: gray[10],
    description: "The selected state color of contained elements with a smaller surface area, like a button or checkbox."
  },
  "color-bg-fill-disabled": {
    value: blackAlpha[5],
    description: "The disabled state color of contained elements with a smaller surface area, like a button."
  },
  "color-bg-fill-secondary": {
    value: gray[6],
    description: "The background color of elements with a smaller surface area and a secondary level of prominence."
  },
  "color-bg-fill-secondary-hover": {
    value: gray[7],
    description: "The hover state color of elements with a smaller surface area and a secondary level of prominence."
  },
  "color-bg-fill-secondary-active": {
    value: gray[8],
    description: "The active state (on press) color of elements with a smaller surface area and a secondary level of prominence."
  },
  "color-bg-fill-tertiary": {
    value: gray[8],
    description: "The background color of elements with a smaller surface area and a third level of prominence."
  },
  "color-bg-fill-tertiary-hover": {
    value: gray[9],
    description: "The hover state color of elements with a smaller surface area and a third level of prominence."
  },
  "color-bg-fill-tertiary-active": {
    value: gray[10],
    description: "The active state (on press) color of elements with a smaller surface area and a third level of prominence."
  },
  "color-bg-fill-brand": {
    value: gray[15],
    description: "The background color of main actions, like primary buttons."
  },
  "color-bg-fill-brand-hover": {
    value: gray[16],
    description: "The hover state color of main actions, like primary buttons."
  },
  "color-bg-fill-brand-active": {
    value: gray[16],
    description: "The active state (on press) color of main actions, like primary buttons."
  },
  "color-bg-fill-brand-selected": {
    value: gray[15],
    description: "The selected state color of main actions, like primary buttons."
  },
  "color-bg-fill-brand-disabled": {
    value: blackAlpha[9],
    description: "The disabled state color of main actions, like primary buttons."
  },
  "color-bg-fill-info": {
    value: azure[9],
    description: "Use for backgrounds communicating important information on elements with a smaller surface area, like a badge or button."
  },
  "color-bg-fill-info-hover": {
    value: azure[10],
    description: "The hover state color for communicating important information on elements with a smaller surface area."
  },
  "color-bg-fill-info-active": {
    value: azure[11],
    description: "The active state (on press) color for communicating important information on elements with a smaller surface area."
  },
  "color-bg-fill-info-secondary": {
    value: azure[5],
    description: "Use for backgrounds communicating important information on elements with a smaller surface area, with a secondary level of prominence."
  },
  "color-bg-fill-success": {
    value: green[12],
    description: "Use for backgrounds communicating success on elements with a smaller surface area, like a badge or a banner."
  },
  "color-bg-fill-success-hover": {
    value: green[13],
    description: "The hover state color for communicating success on elements with a smaller surface area."
  },
  "color-bg-fill-success-active": {
    value: green[14],
    description: "The active state (on press) color for communicating success on elements with a smaller surface area."
  },
  "color-bg-fill-success-secondary": {
    value: green[4],
    description: "Use for backgrounds communicating success on elements with a smaller surface area, with a secondary level of prominence."
  },
  "color-bg-fill-warning": {
    value: orange[9],
    description: "Use for backgrounds communicating warning on elements with a smaller surface area, like a badge or a banner."
  },
  "color-bg-fill-warning-hover": {
    value: orange[10],
    description: "The hover state color for communicating warning on elements with a smaller surface area."
  },
  "color-bg-fill-warning-active": {
    value: orange[11],
    description: "The active state (on press) color for communicating warning on elements with a smaller surface area."
  },
  "color-bg-fill-warning-secondary": {
    value: orange[7],
    description: "Use for backgrounds communicating warning on elements with a smaller surface area, with a secondary level of prominence."
  },
  "color-bg-fill-caution": {
    value: yellow[6],
    description: "Use for backgrounds communicating caution on elements with a smaller surface area, like a badge or a banner."
  },
  "color-bg-fill-caution-hover": {
    value: yellow[8],
    description: "The hover state color for communicating caution on elements with a smaller surface area."
  },
  "color-bg-fill-caution-active": {
    value: yellow[9],
    description: "The active state (on press) color for communicating caution on elements with a smaller surface area."
  },
  "color-bg-fill-caution-secondary": {
    value: yellow[5],
    description: "Use for backgrounds communicating caution on elements with a smaller surface area, with a secondary level of prominence."
  },
  "color-bg-fill-critical": {
    value: red[12],
    description: "Use for backgrounds communicating critical information on elements with a smaller surface area, like a badge or a banner."
  },
  "color-bg-fill-critical-hover": {
    value: red[13],
    description: "The hover state color for communicating critical information on elements with a smaller surface area."
  },
  "color-bg-fill-critical-active": {
    value: red[14],
    description: "The active state (on press) color for communicating critical information on elements with a smaller surface area."
  },
  "color-bg-fill-critical-selected": {
    value: red[14],
    description: "The selected state color for communicating critical information on elements with a smaller surface area."
  },
  "color-bg-fill-critical-secondary": {
    value: red[7],
    description: "Use for backgrounds communicating critical information on elements with a smaller surface area, with a secondary level of prominence."
  },
  "color-bg-fill-emphasis": {
    value: blue[13],
    description: "Use for backgrounds indicating areas of focus in editors on elements with a smaller surface area, like a button or a badge."
  },
  "color-bg-fill-emphasis-hover": {
    value: blue[14],
    description: "The hover state color for indicating areas of focus in editors on elements with a smaller surface area."
  },
  "color-bg-fill-emphasis-active": {
    value: blue[15],
    description: "The active state (on press) color for indicating areas of focus in editors on elements with a smaller surface area."
  },
  "color-bg-fill-magic": {
    value: purple[12],
    description: "The background color of elements suggested by magic AI, like a badge or a banner."
  },
  "color-bg-fill-magic-secondary": {
    value: purple[5],
    description: "The background color of elements suggested by magic AI, with a secondary level of prominence."
  },
  "color-bg-fill-magic-secondary-hover": {
    value: purple[6],
    description: "The hover state color of elements suggested by magic AI, with a secondary level of prominence."
  },
  "color-bg-fill-magic-secondary-active": {
    value: purple[7],
    description: "The active state (on press) color of elements suggested by magic AI, with a secondary level of prominence."
  },
  "color-bg-fill-inverse": {
    value: gray[15],
    description: "The background color of elements with a smaller surface area on an inverse background."
  },
  "color-bg-fill-inverse-hover": {
    value: gray[14],
    description: "The hover state color of elements with a smaller surface area on an inverse background."
  },
  "color-bg-fill-inverse-active": {
    value: gray[13],
    description: "The active state (on press) color of elements with a smaller surface area on an inverse background."
  },
  "color-bg-fill-transparent": {
    value: blackAlpha[3],
    description: "The background color of elements that need to sit on different background colors, like tabs."
  },
  "color-bg-fill-transparent-hover": {
    value: blackAlpha[5],
    description: "The hover state color of elements that need to sit on different background colors, like tabs."
  },
  "color-bg-fill-transparent-active": {
    value: blackAlpha[7],
    description: "The active state (on press) color of elements that need to sit on different background colors, like tabs."
  },
  "color-bg-fill-transparent-selected": {
    value: blackAlpha[7],
    description: "The selected state color of elements that need to sit on different background colors, like tabs."
  },
  "color-bg-fill-transparent-secondary": {
    value: blackAlpha[6],
    description: "The background color of elements that need to sit on different background colors, with a secondary level of prominence."
  },
  "color-bg-fill-transparent-secondary-hover": {
    value: blackAlpha[7],
    description: "The hover state color of elements that need to sit on different background colors, with a secondary level of prominence."
  },
  "color-bg-fill-transparent-secondary-active": {
    value: blackAlpha[8],
    description: "The active state (on press) color of elements that need to sit on different background colors, with a secondary level of prominence."
  },
  "color-text": {
    value: gray[15],
    description: "The default text color."
  },
  "color-text-secondary": {
    value: gray[13],
    description: "Use for text with a secondary level of prominence."
  },
  "color-text-disabled": {
    value: gray[11],
    description: "Use for text in a disabled state."
  },
  "color-text-link": {
    value: blue[13],
    description: "Use for text links."
  },
  "color-text-link-hover": {
    value: blue[14],
    description: "The hover state color for text links."
  },
  "color-text-link-active": {
    value: blue[15],
    description: "The active state (on press) color for text links."
  },
  "color-text-brand": {
    value: gray[14],
    description: "Use for text that needs to pull attention."
  },
  "color-text-brand-hover": {
    value: gray[15],
    description: "The hover state color for text that needs to pull attention."
  },
  "color-text-brand-on-bg-fill": {
    value: gray[1],
    description: "Use for text on bg-fill-brand, like primary buttons."
  },
  "color-text-brand-on-bg-fill-hover": {
    value: gray[8],
    description: "The hover state color for text on bg-fill-brand-hover."
  },
  "color-text-brand-on-bg-fill-active": {
    value: gray[10],
    description: "The active state (on press) color for text on bg-fill-brand."
  },
  "color-text-brand-on-bg-fill-disabled": {
    value: gray[1],
    description: "The disabled state color for text on bg-fill-brand-disabled."
  },
  "color-text-info": {
    value: azure[15],
    description: "Use for text communicating important information."
  },
  "color-text-info-hover": {
    value: azure[15],
    description: "The hover state color for text communicating important information."
  },
  "color-text-info-active": {
    value: azure[16],
    description: "The active state (on press) color for text communicating important information."
  },
  "color-text-info-secondary": {
    value: azure[12],
    description: "Use for text communicating important information with a secondary level of prominence."
  },
  "color-text-info-on-bg-fill": {
    value: azure[16],
    description: "Use for text and icons on bg-fill-info."
  },
  "color-text-success": {
    value: green[14],
    description: "Use for text communicating success."
  },
  "color-text-success-hover": {
    value: green[15],
    description: "The hover state color for text communicating success."
  },
  "color-text-success-active": {
    value: green[16],
    description: "The active state (on press) color for text communicating success."
  },
  "color-text-success-secondary": {
    value: green[12],
    description: "Use for text communicating success with a secondary level of prominence."
  },
  "color-text-success-on-bg-fill": {
    value: green[1],
    description: "Use for text and icons on bg-fill-success."
  },
  "color-text-caution": {
    value: yellow[14],
    description: "Use for text communicating caution."
  },
  "color-text-caution-hover": {
    value: yellow[15],
    description: "The hover state color for text communicating caution."
  },
  "color-text-caution-active": {
    value: yellow[16],
    description: "The active state (on press) color for text communicating caution."
  },
  "color-text-caution-secondary": {
    value: yellow[12],
    description: "Use for text communicating caution with a secondary level of prominence."
  },
  "color-text-caution-on-bg-fill": {
    value: yellow[15],
    description: "Use for text and icons on bg-fill-caution."
  },
  "color-text-warning": {
    value: orange[14],
    description: "Use for text communicating warning."
  },
  "color-text-warning-hover": {
    value: orange[15],
    description: "The hover state color for text communicating warning."
  },
  "color-text-warning-active": {
    value: orange[16],
    description: "The active state (on press) color for text communicating warning."
  },
  "color-text-warning-secondary": {
    value: orange[12],
    description: "Use for text communicating warning with a secondary level of prominence."
  },
  "color-text-warning-on-bg-fill": {
    value: orange[16],
    description: "Use for text and icons on bg-fill-warning."
  },
  "color-text-critical": {
    value: red[14],
    description: "Use for text communicating critical information."
  },
  "color-text-critical-hover": {
    value: red[15],
    description: "The hover state color for text communicating critical information."
  },
  "color-text-critical-active": {
    value: red[16],
    description: "The active state (on press) color for text communicating critical information."
  },
  "color-text-critical-secondary": {
    value: red[12],
    description: "Use for text communicating critical information with a secondary level of prominence."
  },
  "color-text-critical-on-bg-fill": {
    value: red[1],
    description: "Use for text and icons on bg-fill-critical."
  },
  "color-text-emphasis": {
    value: blue[13],
    description: "Use for text indicating areas of focus in editors, like the theme editor."
  },
  "color-text-emphasis-hover": {
    value: blue[14],
    description: "The hover state color for text indicating areas of focus."
  },
  "color-text-emphasis-active": {
    value: blue[15],
    description: "The active state (on press) color for text indicating areas of focus."
  },
  "color-text-emphasis-on-bg-fill": {
    value: blue[1],
    description: "Use for text and icons on bg-fill-emphasis."
  },
  "color-text-emphasis-on-bg-fill-hover": {
    value: blue[5],
    description: "Use for text and icons on bg-fill-emphasis-hover."
  },
  "color-text-emphasis-on-bg-fill-active": {
    value: blue[7],
    description: "Use for text and icons on bg-fill-emphasis-active."
  },
  "color-text-magic": {
    value: purple[14],
    description: "Use for text suggested by magic AI."
  },
  "color-text-magic-secondary": {
    value: purple[13],
    description: "Use for text suggested by magic AI with a secondary level of prominence."
  },
  "color-text-magic-on-bg-fill": {
    value: purple[1],
    description: "Use for text and icons on bg-fill-magic."
  },
  "color-text-inverse": {
    value: gray[8],
    description: "Use for text on an inverse background."
  },
  "color-text-inverse-secondary": {
    value: gray[11],
    description: "Use for secondary text on an inverse background."
  },
  "color-text-link-inverse": {
    value: blue[8],
    description: "Use for text links on an inverse background."
  },
  "color-border": {
    value: gray[8],
    description: "The default color for borders on any element."
  },
  "color-border-hover": {
    value: gray[10],
    description: "The hover color for borders on any element."
  },
  "color-border-disabled": {
    value: gray[7],
    description: "The disabled color for borders on any element."
  },
  "color-border-secondary": {
    value: gray[7],
    description: "The color for hr elements or any visual dividers."
  },
  "color-border-tertiary": {
    value: gray[10],
    description: "The border color on any element. Pair with bg-surface-tertiary or bg-fill-tertiary."
  },
  "color-border-focus": {
    value: blue[13],
    description: "The focus ring for any interactive element in a focused state."
  },
  "color-border-brand": {
    value: gray[8],
    description: "Use for borders paired with brand colors."
  },
  "color-border-info": {
    value: azure[8],
    description: "Use for borders communicating information."
  },
  "color-border-success": {
    value: green[5],
    description: "Use for borders communicating success."
  },
  "color-border-caution": {
    value: yellow[5],
    description: "Use for borders communicating caution."
  },
  "color-border-warning": {
    value: orange[8],
    description: "Use for borders communicating warning."
  },
  "color-border-critical": {
    value: red[8],
    description: "Use for borders communicating critical information."
  },
  "color-border-critical-secondary": {
    value: red[14],
    description: "Use for borders communicating critical information, such as borders on invalid text fields."
  },
  "color-border-emphasis": {
    value: blue[13],
    description: "Use for borders indicating areas of focus."
  },
  "color-border-emphasis-hover": {
    value: blue[14],
    description: "The hover state color for borders indicating areas of focus."
  },
  "color-border-emphasis-active": {
    value: blue[15],
    description: "The active state (on press) color for borders indicating areas of focus."
  },
  "color-border-magic": {
    value: purple[6],
    description: "Use for borders suggested by magic AI."
  },
  "color-border-magic-secondary": {
    value: purple[11],
    description: "Use for borders suggested by magic AI, such as borders on text fields."
  },
  "color-border-magic-secondary-hover": {
    value: purple[12],
    description: "Use for borders suggested by magic AI, such as borders on text fields."
  },
  "color-border-inverse": {
    value: gray[13],
    description: "Use for borders on an inverse background, such as borders on the global search."
  },
  "color-border-inverse-hover": {
    value: gray[10],
    description: "The hover state color for borders on an inverse background."
  },
  "color-border-inverse-active": {
    value: gray[8],
    description: "The active state (on press) color for borders on an inverse background."
  },
  "color-tooltip-tail-down-border-experimental": {
    value: gray[9],
    description: "The border color for tooltip tails pointing down."
  },
  "color-tooltip-tail-up-border-experimental": {
    value: gray[8],
    description: "The border color for tooltip tails pointing up."
  },
  "color-border-gradient-experimental": {
    value: "linear-gradient(to bottom, " + gray[7] + ", " + gray[10] + " 78%, " + gray[11] + ")"
  },
  "color-border-gradient-hover-experimental": {
    value: "linear-gradient(to bottom, " + gray[7] + ", " + gray[10] + " 78%, " + gray[11] + ")"
  },
  "color-border-gradient-selected-experimental": {
    value: "linear-gradient(to bottom, " + gray[7] + ", " + gray[10] + " 78%, " + gray[11] + ")"
  },
  "color-border-gradient-active-experimental": {
    value: "linear-gradient(to bottom, " + gray[7] + ", " + gray[10] + " 78%, " + gray[11] + ")"
  },
  "color-icon": {
    value: gray[14],
    description: "The default color for icons."
  },
  "color-icon-hover": {
    value: gray[15],
    description: "The hover state color for icons."
  },
  "color-icon-active": {
    value: gray[16],
    description: "The active state (on press) color for icons."
  },
  "color-icon-disabled": {
    value: gray[10],
    description: "The disabled state color for icons."
  },
  "color-icon-secondary": {
    value: gray[12],
    description: "Use for secondary icons."
  },
  "color-icon-secondary-hover": {
    value: gray[13],
    description: "The hover state color for secondary icons."
  },
  "color-icon-secondary-active": {
    value: gray[14],
    description: "The active state (on press) color for secondary icons."
  },
  "color-icon-brand": {
    value: gray[16],
    description: "Use for icons that need to pull more focus."
  },
  "color-icon-info": {
    value: azure[11],
    description: "Use for icons communicating information."
  },
  "color-icon-success": {
    value: green[12],
    description: "Use for icons communicating success."
  },
  "color-icon-caution": {
    value: yellow[11],
    description: "Use for icons communicating caution."
  },
  "color-icon-warning": {
    value: orange[11],
    description: "Use for icons communicating warning."
  },
  "color-icon-critical": {
    value: red[11],
    description: "Use for icons communicating critical information."
  },
  "color-icon-emphasis": {
    value: blue[13],
    description: "Use for icons indicating areas of focus in editors, like the theme editor."
  },
  "color-icon-emphasis-hover": {
    value: blue[14],
    description: "The hover color for icons indicating areas of focus in editors."
  },
  "color-icon-emphasis-active": {
    value: blue[15],
    description: "The active state (on press) color for icons indicating areas of focus in editors."
  },
  "color-icon-magic": {
    value: purple[12],
    description: "Use for icons suggested by magic AI."
  },
  "color-icon-inverse": {
    value: gray[8],
    description: "Use for icons on an inverse background."
  },
  "color-avatar-bg-fill": {
    value: gray[11]
  },
  "color-avatar-five-bg-fill": {
    value: rose[11]
  },
  "color-avatar-five-text-on-bg-fill": {
    value: rose[2]
  },
  "color-avatar-four-bg-fill": {
    value: azure[10]
  },
  "color-avatar-four-text-on-bg-fill": {
    value: azure[16]
  },
  "color-avatar-one-bg-fill": {
    value: magenta[12]
  },
  "color-avatar-one-text-on-bg-fill": {
    value: magenta[3]
  },
  "color-avatar-seven-bg-fill": {
    value: purple[11]
  },
  "color-avatar-seven-text-on-bg-fill": {
    value: purple[2]
  },
  "color-avatar-six-bg-fill": {
    value: lime[9]
  },
  "color-avatar-six-text-on-bg-fill": {
    value: lime[15]
  },
  "color-avatar-text-on-bg-fill": {
    value: gray[1]
  },
  "color-avatar-three-bg-fill": {
    value: teal[9]
  },
  "color-avatar-three-text-on-bg-fill": {
    value: teal[15]
  },
  "color-avatar-two-bg-fill": {
    value: green[7]
  },
  "color-avatar-two-text-on-bg-fill": {
    value: green[14]
  },
  "color-backdrop-bg": {
    value: blackAlpha[14]
  },
  "color-button-gradient-bg-fill": {
    value: "linear-gradient(180deg, rgba(48, 48, 48, 0) 63.53%, rgba(255, 255, 255, 0.15) 100%)"
  },
  "color-checkbox-bg-surface-disabled": {
    value: blackAlpha[7]
  },
  "color-checkbox-icon-disabled": {
    value: gray[1]
  },
  "color-input-bg-surface": {
    value: gray[2]
  },
  "color-input-bg-surface-hover": {
    value: gray[3]
  },
  "color-input-bg-surface-active": {
    value: gray[4]
  },
  "color-input-border": {
    value: gray[12]
  },
  "color-input-border-hover": {
    value: gray[13]
  },
  "color-input-border-active": {
    value: gray[16]
  },
  "color-nav-bg": {
    value: gray[7]
  },
  "color-nav-bg-surface": {
    value: blackAlpha[3]
  },
  "color-nav-bg-surface-hover": {
    value: gray[6]
  },
  "color-nav-bg-surface-active": {
    value: gray[3]
  },
  "color-nav-bg-surface-selected": {
    value: gray[3]
  },
  "color-radio-button-bg-surface-disabled": {
    value: blackAlpha[7]
  },
  "color-radio-button-icon-disabled": {
    value: gray[1]
  },
  "color-video-thumbnail-play-button-bg-fill-hover": {
    value: blackAlpha[15]
  },
  "color-video-thumbnail-play-button-bg-fill": {
    value: blackAlpha[14]
  },
  "color-video-thumbnail-play-button-text-on-bg-fill": {
    value: gray[1]
  },
  "color-scrollbar-thumb-bg-hover": {
    value: gray[12]
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/font.mjs
var font = {
  "font-family-sans": {
    value: "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif"
  },
  "font-family-mono": {
    value: "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace"
  },
  "font-size-275": {
    value: size[275]
  },
  "font-size-300": {
    value: size[300]
  },
  "font-size-325": {
    value: size[325]
  },
  "font-size-350": {
    value: size[350]
  },
  "font-size-400": {
    value: size[400]
  },
  "font-size-450": {
    value: size[450]
  },
  "font-size-500": {
    value: size[500]
  },
  "font-size-550": {
    value: size[550]
  },
  "font-size-600": {
    value: size[600]
  },
  "font-size-750": {
    value: size[750]
  },
  "font-size-800": {
    value: size[800]
  },
  "font-size-900": {
    value: size[900]
  },
  "font-size-1000": {
    value: size[1e3]
  },
  "font-weight-regular": {
    value: "450"
  },
  "font-weight-medium": {
    value: "550"
  },
  "font-weight-semibold": {
    value: "650"
  },
  "font-weight-bold": {
    value: "700"
  },
  "font-letter-spacing-densest": {
    value: "-0.54px"
  },
  "font-letter-spacing-denser": {
    value: "-0.3px"
  },
  "font-letter-spacing-dense": {
    value: "-0.2px"
  },
  "font-letter-spacing-normal": {
    value: "0px"
  },
  "font-line-height-300": {
    value: size[300]
  },
  "font-line-height-400": {
    value: size[400]
  },
  "font-line-height-500": {
    value: size[500]
  },
  "font-line-height-600": {
    value: size[600]
  },
  "font-line-height-700": {
    value: size[700]
  },
  "font-line-height-800": {
    value: size[800]
  },
  "font-line-height-1000": {
    value: size[1e3]
  },
  "font-line-height-1200": {
    value: size[1200]
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/height.mjs
var height = {
  "height-0": {
    value: size[0]
  },
  "height-025": {
    value: size["025"]
  },
  "height-050": {
    value: size["050"]
  },
  "height-100": {
    value: size[100]
  },
  "height-150": {
    value: size[150]
  },
  "height-200": {
    value: size[200]
  },
  "height-300": {
    value: size[300]
  },
  "height-400": {
    value: size[400]
  },
  "height-500": {
    value: size[500]
  },
  "height-600": {
    value: size[600]
  },
  "height-700": {
    value: size[700]
  },
  "height-800": {
    value: size[800]
  },
  "height-900": {
    value: size[900]
  },
  "height-1000": {
    value: size[1e3]
  },
  "height-1200": {
    value: size[1200]
  },
  "height-1600": {
    value: size[1600]
  },
  "height-2000": {
    value: size[2e3]
  },
  "height-2400": {
    value: size[2400]
  },
  "height-2800": {
    value: size[2800]
  },
  "height-3200": {
    value: size[3200]
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/motion.mjs
var motion = {
  "motion-duration-0": {
    value: "0ms"
  },
  "motion-duration-50": {
    value: "50ms"
  },
  "motion-duration-100": {
    value: "100ms"
  },
  "motion-duration-150": {
    value: "150ms"
  },
  "motion-duration-200": {
    value: "200ms"
  },
  "motion-duration-250": {
    value: "250ms"
  },
  "motion-duration-300": {
    value: "300ms"
  },
  "motion-duration-350": {
    value: "350ms"
  },
  "motion-duration-400": {
    value: "400ms"
  },
  "motion-duration-450": {
    value: "450ms"
  },
  "motion-duration-500": {
    value: "500ms"
  },
  "motion-duration-5000": {
    value: "5000ms"
  },
  "motion-ease": {
    value: "cubic-bezier(0.25, 0.1, 0.25, 1)",
    description: "Responds quickly and finishes with control. A great default for any user interaction."
  },
  "motion-ease-in": {
    value: "cubic-bezier(0.42, 0, 1, 1)",
    description: "Starts slowly and finishes at top speed. Use sparingly."
  },
  "motion-ease-out": {
    value: "cubic-bezier(0.19, 0.91, 0.38, 1)",
    description: "Starts at top speed and finishes slowly. Use sparingly."
  },
  "motion-ease-in-out": {
    value: "cubic-bezier(0.42, 0, 0.58, 1)",
    description: "Starts and finishes with equal speed. A good default for transitions triggered by the system."
  },
  "motion-linear": {
    value: "cubic-bezier(0, 0, 1, 1)",
    description: "Moves with constant speed. Use for continuous and mechanical animations, such as rotating spinners."
  },
  "motion-keyframes-bounce": {
    value: "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }"
  },
  "motion-keyframes-fade-in": {
    value: "{ to { opacity: 1 } }"
  },
  "motion-keyframes-pulse": {
    value: "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }"
  },
  "motion-keyframes-spin": {
    value: "{ to { transform: rotate(1turn) } }"
  },
  "motion-keyframes-appear-above": {
    value: "{ from { transform: translateY(var(--p-space-100)); opacity: 0; } to { transform: none; opacity: 1; } }"
  },
  "motion-keyframes-appear-below": {
    value: "{ from { transform: translateY(calc(var(--p-space-100) * -1)); opacity: 0; } to { transform: none; opacity: 1; } }"
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/shadow.mjs
var shadow = {
  "shadow-0": {
    value: "none"
  },
  "shadow-100": {
    value: "0px 1px 0px 0px rgba(26, 26, 26, 0.07)"
  },
  "shadow-200": {
    value: "0px 3px 1px -1px rgba(26, 26, 26, 0.07)"
  },
  "shadow-300": {
    value: "0px 4px 6px -2px rgba(26, 26, 26, 0.20)"
  },
  "shadow-400": {
    value: "0px 8px 16px -4px rgba(26, 26, 26, 0.22)"
  },
  "shadow-500": {
    value: "0px 12px 20px -8px rgba(26, 26, 26, 0.24)"
  },
  "shadow-600": {
    value: "0px 20px 20px -8px rgba(26, 26, 26, 0.28)"
  },
  "shadow-bevel-100": {
    value: "1px 0px 0px 0px rgba(0, 0, 0, 0.13) inset, -1px 0px 0px 0px rgba(0, 0, 0, 0.13) inset, 0px -1px 0px 0px rgba(0, 0, 0, 0.17) inset, 0px 1px 0px 0px rgba(204, 204, 204, 0.5) inset"
  },
  "shadow-inset-100": {
    value: "0px 1px 2px 0px rgba(26, 26, 26, 0.15) inset, 0px 1px 1px 0px rgba(26, 26, 26, 0.15) inset"
  },
  "shadow-inset-200": {
    value: "0px 2px 1px 0px rgba(26, 26, 26, 0.20) inset, 1px 0px 1px 0px rgba(26, 26, 26, 0.12) inset, -1px 0px 1px 0px rgba(26, 26, 26, 0.12) inset"
  },
  "shadow-button": {
    value: "0px -1px 0px 0px #b5b5b5 inset, 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset, 0px 0.5px 0px 1.5px #FFF inset"
  },
  "shadow-button-hover": {
    value: "0px 1px 0px 0px #EBEBEB inset, -1px 0px 0px 0px #EBEBEB inset, 1px 0px 0px 0px #EBEBEB inset, 0px -1px 0px 0px #CCC inset"
  },
  "shadow-button-inset": {
    value: "-1px 0px 1px 0px rgba(26, 26, 26, 0.122) inset, 1px 0px 1px 0px rgba(26, 26, 26, 0.122) inset, 0px 2px 1px 0px rgba(26, 26, 26, 0.2) inset"
  },
  "shadow-button-primary": {
    value: "0px -1px 0px 1px rgba(0, 0, 0, 0.8) inset, 0px 0px 0px 1px rgba(48, 48, 48, 1) inset, 0px 0.5px 0px 1.5px rgba(255, 255, 255, 0.25) inset;"
  },
  "shadow-button-primary-hover": {
    value: "0px 1px 0px 0px rgba(255, 255, 255, 0.24) inset, 1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, -1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, 0px -1px 0px 0px #000 inset, 0px -1px 0px 1px #1A1A1A"
  },
  "shadow-button-primary-inset": {
    value: "0px 3px 0px 0px rgb(0, 0, 0) inset"
  },
  "shadow-button-primary-critical": {
    value: "0px -1px 0px 1px rgba(142, 31, 11, 0.8) inset, 0px 0px 0px 1px rgba(181, 38, 11, 0.8) inset, 0px 0.5px 0px 1.5px rgba(255, 255, 255, 0.349) inset"
  },
  "shadow-button-primary-critical-hover": {
    value: "0px 1px 0px 0px rgba(255, 255, 255, 0.48) inset, 1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, -1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, 0px -1.5px 0px 0px rgba(0, 0, 0, 0.25) inset"
  },
  "shadow-button-primary-critical-inset": {
    value: "-1px 0px 1px 0px rgba(0, 0, 0, 0.2) inset, 1px 0px 1px 0px rgba(0, 0, 0, 0.2) inset, 0px 2px 0px 0px rgba(0, 0, 0, 0.6) inset"
  },
  "shadow-button-primary-success": {
    value: "0px -1px 0px 1px rgba(12, 81, 50, 0.8) inset, 0px 0px 0px 1px rgba(19, 111, 69, 0.8) inset, 0px 0.5px 0px 1.5px rgba(255, 255, 255, 0.251) inset"
  },
  "shadow-button-primary-success-hover": {
    value: "0px 1px 0px 0px rgba(255, 255, 255, 0.48) inset, 1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, -1px 0px 0px 0px rgba(255, 255, 255, 0.20) inset, 0px -1.5px 0px 0px rgba(0, 0, 0, 0.25) inset"
  },
  "shadow-button-primary-success-inset": {
    value: "-1px 0px 1px 0px rgba(0, 0, 0, 0.2) inset, 1px 0px 1px 0px rgba(0, 0, 0, 0.2) inset, 0px 2px 0px 0px rgba(0, 0, 0, 0.6) inset"
  },
  "shadow-border-inset": {
    value: "0px 0px 0px 1px rgba(0, 0, 0, 0.08) inset"
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/space.mjs
var space = {
  "space-0": {
    value: size[0]
  },
  "space-025": {
    value: size["025"]
  },
  "space-050": {
    value: size["050"]
  },
  "space-100": {
    value: size[100]
  },
  "space-150": {
    value: size[150]
  },
  "space-200": {
    value: size[200]
  },
  "space-300": {
    value: size[300]
  },
  "space-400": {
    value: size[400]
  },
  "space-500": {
    value: size[500]
  },
  "space-600": {
    value: size[600]
  },
  "space-800": {
    value: size[800]
  },
  "space-1000": {
    value: size[1e3]
  },
  "space-1200": {
    value: size[1200]
  },
  "space-1600": {
    value: size[1600]
  },
  "space-2000": {
    value: size[2e3]
  },
  "space-2400": {
    value: size[2400]
  },
  "space-2800": {
    value: size[2800]
  },
  "space-3200": {
    value: size[3200]
  },
  "space-button-group-gap": {
    value: createVar2("space-200")
  },
  "space-card-gap": {
    value: createVar2("space-400")
  },
  "space-card-padding": {
    value: createVar2("space-400")
  },
  "space-table-cell-padding": {
    value: createVar2("space-150")
  }
};
function createVar2(spaceTokenName) {
  return "var(" + createVarName(spaceTokenName) + ")";
}

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/text.mjs
var text = {
  // heading-3xl
  "text-heading-3xl-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-3xl-font-size": {
    value: createVar("font-size-900")
  },
  "text-heading-3xl-font-weight": {
    value: createVar("font-weight-bold")
  },
  "text-heading-3xl-font-letter-spacing": {
    value: createVar("font-letter-spacing-densest")
  },
  "text-heading-3xl-font-line-height": {
    value: createVar("font-line-height-1200")
  },
  // heading-2xl
  "text-heading-2xl-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-2xl-font-size": {
    value: createVar("font-size-750")
  },
  "text-heading-2xl-font-weight": {
    value: createVar("font-weight-bold")
  },
  "text-heading-2xl-font-letter-spacing": {
    value: createVar("font-letter-spacing-denser")
  },
  "text-heading-2xl-font-line-height": {
    value: createVar("font-line-height-1000")
  },
  // heading-xl
  "text-heading-xl-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-xl-font-size": {
    value: createVar("font-size-600")
  },
  "text-heading-xl-font-weight": {
    value: createVar("font-weight-bold")
  },
  "text-heading-xl-font-letter-spacing": {
    value: createVar("font-letter-spacing-dense")
  },
  "text-heading-xl-font-line-height": {
    value: createVar("font-line-height-800")
  },
  // heading-lg
  "text-heading-lg-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-lg-font-size": {
    value: createVar("font-size-500")
  },
  "text-heading-lg-font-weight": {
    value: createVar("font-weight-semibold")
  },
  "text-heading-lg-font-letter-spacing": {
    value: createVar("font-letter-spacing-dense")
  },
  "text-heading-lg-font-line-height": {
    value: createVar("font-line-height-600")
  },
  // heading-md
  "text-heading-md-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-md-font-size": {
    value: createVar("font-size-350")
  },
  "text-heading-md-font-weight": {
    value: createVar("font-weight-semibold")
  },
  "text-heading-md-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-heading-md-font-line-height": {
    value: createVar("font-line-height-500")
  },
  // heading-sm
  "text-heading-sm-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-sm-font-size": {
    value: createVar("font-size-325")
  },
  "text-heading-sm-font-weight": {
    value: createVar("font-weight-semibold")
  },
  "text-heading-sm-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-heading-sm-font-line-height": {
    value: createVar("font-line-height-500")
  },
  // heading-xs
  "text-heading-xs-font-family": {
    value: createVar("font-family-sans")
  },
  "text-heading-xs-font-size": {
    value: createVar("font-size-300")
  },
  "text-heading-xs-font-weight": {
    value: createVar("font-weight-semibold")
  },
  "text-heading-xs-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-heading-xs-font-line-height": {
    value: createVar("font-line-height-400")
  },
  // body-lg
  "text-body-lg-font-family": {
    value: createVar("font-family-sans")
  },
  "text-body-lg-font-size": {
    value: createVar("font-size-350")
  },
  "text-body-lg-font-weight": {
    value: createVar("font-weight-regular")
  },
  "text-body-lg-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-body-lg-font-line-height": {
    value: createVar("font-line-height-500")
  },
  // body-md
  "text-body-md-font-family": {
    value: createVar("font-family-sans")
  },
  "text-body-md-font-size": {
    value: createVar("font-size-325")
  },
  "text-body-md-font-weight": {
    value: createVar("font-weight-regular")
  },
  "text-body-md-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-body-md-font-line-height": {
    value: createVar("font-line-height-500")
  },
  // body-sm
  "text-body-sm-font-family": {
    value: createVar("font-family-sans")
  },
  "text-body-sm-font-size": {
    value: createVar("font-size-300")
  },
  "text-body-sm-font-weight": {
    value: createVar("font-weight-regular")
  },
  "text-body-sm-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-body-sm-font-line-height": {
    value: createVar("font-line-height-400")
  },
  // body-xs
  "text-body-xs-font-family": {
    value: createVar("font-family-sans")
  },
  "text-body-xs-font-size": {
    value: createVar("font-size-275")
  },
  "text-body-xs-font-weight": {
    value: createVar("font-weight-regular")
  },
  "text-body-xs-font-letter-spacing": {
    value: createVar("font-letter-spacing-normal")
  },
  "text-body-xs-font-line-height": {
    value: createVar("font-line-height-300")
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/width.mjs
var width = {
  "width-0": {
    value: size[0]
  },
  "width-025": {
    value: size["025"]
  },
  "width-050": {
    value: size["050"]
  },
  "width-100": {
    value: size[100]
  },
  "width-150": {
    value: size[150]
  },
  "width-200": {
    value: size[200]
  },
  "width-300": {
    value: size[300]
  },
  "width-400": {
    value: size[400]
  },
  "width-500": {
    value: size[500]
  },
  "width-600": {
    value: size[600]
  },
  "width-700": {
    value: size[700]
  },
  "width-800": {
    value: size[800]
  },
  "width-900": {
    value: size[900]
  },
  "width-1000": {
    value: size[1e3]
  },
  "width-1200": {
    value: size[1200]
  },
  "width-1600": {
    value: size[1600]
  },
  "width-2000": {
    value: size[2e3]
  },
  "width-2400": {
    value: size[2400]
  },
  "width-2800": {
    value: size[2800]
  },
  "width-3200": {
    value: size[3200]
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/zIndex.mjs
var zIndex = {
  "z-index-0": {
    value: "auto"
  },
  "z-index-1": {
    value: "100"
  },
  "z-index-2": {
    value: "400"
  },
  "z-index-3": {
    value: "510"
  },
  "z-index-4": {
    value: "512"
  },
  "z-index-5": {
    value: "513"
  },
  "z-index-6": {
    value: "514"
  },
  "z-index-7": {
    value: "515"
  },
  "z-index-8": {
    value: "516"
  },
  "z-index-9": {
    value: "517"
  },
  "z-index-10": {
    value: "518"
  },
  "z-index-11": {
    value: "519"
  },
  "z-index-12": {
    value: "520"
  }
};

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/base/index.mjs
var metaThemeBase = createMetaThemeBase({
  border,
  breakpoints,
  color,
  font,
  height,
  motion,
  shadow,
  space,
  text,
  width,
  zIndex
});

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/utils.mjs
function createMetaThemePartial(metaThemePartial) {
  return Object.fromEntries(Object.entries(metaThemePartial).map(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), tokenGroupName = _ref2[0], tokenGroup = _ref2[1];
    return [tokenGroupName, tokenGroup && tokenGroupNamesToRems.includes(tokenGroupName) ? tokenGroupToRems(tokenGroup) : tokenGroup];
  }));
}
function createMetaTheme(metaThemePartial) {
  return deepmerge(metaThemeBase, metaThemePartial);
}
function createThemeClassName(themeName) {
  return "p-theme-" + themeName;
}
function createIsTokenName(theme) {
  var tokenNames = new Set(getTokenNames(theme));
  return function(tokenName) {
    return tokenNames.has(tokenName);
  };
}
createIsTokenName(metaThemeBase);

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/constants.mjs
var themeNameLight = "light", themeNameDefault = themeNameLight, themeNames = [themeNameLight, "light-mobile", "light-high-contrast-experimental", "dark-experimental"];

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/light.mjs
var metaThemeLightPartial = createMetaThemePartial({}), metaThemeLight = createMetaTheme(metaThemeLightPartial);

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/light-high-contrast.mjs
var metaThemeLightHighContrastPartial = createMetaThemePartial({
  color: {
    "color-text": {
      value: gray[16]
    },
    "color-text-secondary": {
      value: gray[16]
    },
    "color-text-brand": {
      value: gray[16]
    },
    "color-icon-secondary": {
      value: gray[14]
    },
    "color-border": {
      value: gray[12]
    },
    "color-input-border": {
      value: gray[14]
    },
    "color-border-secondary": {
      value: gray[12]
    },
    "color-bg-surface-secondary": {
      value: gray[6]
    }
  },
  shadow: {
    "shadow-bevel-100": {
      value: "0px 1px 0px 0px rgba(26, 26, 26, 0.07), 0px 1px 0px 0px rgba(208, 208, 208, 0.40) inset, 1px 0px 0px 0px #CCC inset, -1px 0px 0px 0px #CCC inset, 0px -1px 0px 0px #999 inset"
    }
  }
}), metaThemeLightHighContrast = createMetaTheme(metaThemeLightHighContrastPartial);

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/light-mobile.mjs
var buttonShadow = "0 0 0 " + createVar("border-width-025") + " " + createVar("color-border") + " inset", metaThemeLightMobilePartial = createMetaThemePartial({
  color: {
    "color-button-gradient-bg-fill": {
      value: "none"
    }
  },
  shadow: {
    "shadow-100": {
      value: "none"
    },
    "shadow-bevel-100": {
      value: "none"
    },
    "shadow-button": {
      value: buttonShadow
    },
    "shadow-button-hover": {
      value: buttonShadow
    },
    "shadow-button-inset": {
      value: buttonShadow
    },
    "shadow-button-primary": {
      value: "none"
    },
    "shadow-button-primary-hover": {
      value: "none"
    },
    "shadow-button-primary-inset": {
      value: "none"
    },
    "shadow-button-primary-critical": {
      value: "none"
    },
    "shadow-button-primary-critical-hover": {
      value: "none"
    },
    "shadow-button-primary-critical-inset": {
      value: "none"
    },
    "shadow-button-primary-success": {
      value: "none"
    },
    "shadow-button-primary-success-hover": {
      value: "none"
    },
    "shadow-button-primary-success-inset": {
      value: "none"
    }
  },
  space: {
    "space-card-gap": {
      value: createVar("space-200")
    }
  },
  text: {
    // heading-2xl
    "text-heading-2xl-font-size": {
      value: createVar("font-size-800")
    },
    // heading-xl
    "text-heading-xl-font-size": {
      value: createVar("font-size-550")
    },
    "text-heading-xl-font-line-height": {
      value: createVar("font-line-height-700")
    },
    // heading-lg
    "text-heading-lg-font-size": {
      value: createVar("font-size-450")
    },
    // heading-md
    "text-heading-md-font-size": {
      value: createVar("font-size-400")
    },
    // heading-sm
    "text-heading-sm-font-size": {
      value: createVar("font-size-350")
    },
    // body-lg
    "text-body-lg-font-size": {
      value: createVar("font-size-450")
    },
    "text-body-lg-font-line-height": {
      value: createVar("font-line-height-700")
    },
    // body-md
    "text-body-md-font-size": {
      value: createVar("font-size-400")
    },
    "text-body-md-font-line-height": {
      value: createVar("font-line-height-600")
    },
    // body-sm
    "text-body-sm-font-size": {
      value: createVar("font-size-350")
    },
    "text-body-sm-font-line-height": {
      value: createVar("font-line-height-500")
    },
    // body-xs
    "text-body-xs-font-size": {
      value: createVar("font-size-300")
    },
    "text-body-xs-font-line-height": {
      value: createVar("font-line-height-400")
    }
  }
}), metaThemeLightMobile = createMetaTheme(metaThemeLightMobilePartial);

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/dark.mjs
var metaThemeDarkPartial = createMetaThemePartial({
  color: {
    "color-scheme": {
      value: "dark"
    },
    "color-bg": {
      value: gray[16]
    },
    "color-bg-surface": {
      value: gray[15]
    },
    "color-bg-fill": {
      value: gray[15]
    },
    "color-icon": {
      value: gray[8]
    },
    "color-icon-secondary": {
      value: gray[12]
    },
    "color-text": {
      value: gray[8]
    },
    "color-text-secondary": {
      value: gray[11]
    },
    "color-bg-surface-secondary-active": {
      value: gray[13]
    },
    "color-bg-surface-secondary-hover": {
      value: gray[14]
    },
    "color-bg-fill-transparent": {
      value: whiteAlpha[8]
    },
    "color-bg-fill-brand": {
      value: gray[1]
    },
    "color-text-brand-on-bg-fill": {
      value: gray[15]
    },
    "color-bg-surface-hover": {
      value: gray[14]
    },
    "color-bg-fill-hover": {
      value: gray[14]
    },
    "color-bg-fill-transparent-hover": {
      value: whiteAlpha[9]
    },
    "color-bg-fill-brand-hover": {
      value: gray[5]
    },
    "color-bg-surface-selected": {
      value: gray[13]
    },
    "color-bg-fill-selected": {
      value: gray[13]
    },
    "color-bg-fill-transparent-selected": {
      value: whiteAlpha[11]
    },
    "color-bg-fill-brand-selected": {
      value: gray[9]
    },
    "color-bg-surface-active": {
      value: gray[13]
    },
    "color-bg-fill-active": {
      value: gray[13]
    },
    "color-bg-fill-transparent-active": {
      value: whiteAlpha[10]
    },
    "color-bg-fill-brand-active": {
      value: gray[4]
    },
    "color-bg-surface-brand-selected": {
      value: gray[14]
    },
    "color-border-secondary": {
      value: gray[13]
    },
    "color-tooltip-tail-down-border-experimental": {
      value: "rgba(60, 60, 60, 1)"
    },
    "color-tooltip-tail-up-border-experimental": {
      value: "rgba(71, 71, 71, 1)"
    },
    "color-border-gradient-experimental": {
      value: "linear-gradient(to bottom, " + whiteAlpha[9] + ", " + whiteAlpha[4] + ")"
    },
    "color-border-gradient-hover-experimental": {
      value: "linear-gradient(to bottom, " + whiteAlpha[9] + ", " + whiteAlpha[4] + ")"
    },
    "color-border-gradient-selected-experimental": {
      value: "linear-gradient(to bottom, " + blackAlpha[10] + ", " + whiteAlpha[10] + ")"
    },
    "color-border-gradient-active-experimental": {
      value: "linear-gradient(to bottom, " + whiteAlpha[10] + ", " + whiteAlpha[4] + ")"
    }
  },
  shadow: {
    "shadow-bevel-100": {
      value: "1px 0px 0px 0px rgba(204, 204, 204, 0.08) inset, -1px 0px 0px 0px rgba(204, 204, 204, 0.08) inset, 0px -1px 0px 0px rgba(204, 204, 204, 0.08) inset, 0px 1px 0px 0px rgba(204, 204, 204, 0.16) inset"
    }
  }
}), metaThemeDark = createMetaTheme(metaThemeDarkPartial);

// node_modules/@shopify/polaris-tokens/dist/esm/src/themes/index.mjs
var metaThemePartials = {
  light: metaThemeLightPartial,
  "light-mobile": metaThemeLightMobilePartial,
  "light-high-contrast-experimental": metaThemeLightHighContrastPartial,
  "dark-experimental": metaThemeDarkPartial
}, metaThemeDefaultPartial = metaThemePartials[themeNameDefault], metaThemeDefault = createMetaTheme(metaThemeDefaultPartial);

// node_modules/@shopify/polaris-tokens/dist/esm/build/index.mjs
var themes = {
  light: {
    border: {
      "border-radius-0": "0rem",
      "border-radius-050": "0.125rem",
      "border-radius-100": "0.25rem",
      "border-radius-150": "0.375rem",
      "border-radius-200": "0.5rem",
      "border-radius-300": "0.75rem",
      "border-radius-400": "1rem",
      "border-radius-500": "1.25rem",
      "border-radius-750": "1.875rem",
      "border-radius-full": "624.9375rem",
      "border-width-0": "0rem",
      "border-width-0165": "0.04125rem",
      "border-width-025": "0.0625rem",
      "border-width-050": "0.125rem",
      "border-width-100": "0.25rem"
    },
    breakpoints: {
      "breakpoints-xs": "0rem",
      "breakpoints-sm": "30.625rem",
      "breakpoints-md": "48rem",
      "breakpoints-lg": "65rem",
      "breakpoints-xl": "90rem"
    },
    color: {
      "color-scheme": "light",
      "color-bg": "rgba(241, 241, 241, 1)",
      "color-bg-inverse": "rgba(26, 26, 26, 1)",
      "color-bg-surface": "rgba(255, 255, 255, 1)",
      "color-bg-surface-hover": "rgba(247, 247, 247, 1)",
      "color-bg-surface-active": "rgba(243, 243, 243, 1)",
      "color-bg-surface-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-surface-secondary": "rgba(247, 247, 247, 1)",
      "color-bg-surface-secondary-hover": "rgba(241, 241, 241, 1)",
      "color-bg-surface-secondary-active": "rgba(235, 235, 235, 1)",
      "color-bg-surface-secondary-selected": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary": "rgba(243, 243, 243, 1)",
      "color-bg-surface-tertiary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary-active": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-brand-active": "rgba(241, 241, 241, 1)",
      "color-bg-surface-brand-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-info": "rgba(234, 244, 255, 1)",
      "color-bg-surface-info-hover": "rgba(224, 240, 255, 1)",
      "color-bg-surface-info-active": "rgba(202, 230, 255, 1)",
      "color-bg-surface-success": "rgba(205, 254, 225, 1)",
      "color-bg-surface-success-hover": "rgba(180, 254, 210, 1)",
      "color-bg-surface-success-active": "rgba(146, 254, 194, 1)",
      "color-bg-surface-caution": "rgba(255, 248, 219, 1)",
      "color-bg-surface-caution-hover": "rgba(255, 244, 191, 1)",
      "color-bg-surface-caution-active": "rgba(255, 239, 157, 1)",
      "color-bg-surface-warning": "rgba(255, 241, 227, 1)",
      "color-bg-surface-warning-hover": "rgba(255, 235, 213, 1)",
      "color-bg-surface-warning-active": "rgba(255, 228, 198, 1)",
      "color-bg-surface-critical": "rgba(254, 233, 232, 1)",
      "color-bg-surface-critical-hover": "rgba(254, 226, 225, 1)",
      "color-bg-surface-critical-active": "rgba(254, 218, 217, 1)",
      "color-bg-surface-emphasis": "rgba(240, 242, 255, 1)",
      "color-bg-surface-emphasis-hover": "rgba(234, 237, 255, 1)",
      "color-bg-surface-emphasis-active": "rgba(226, 231, 255, 1)",
      "color-bg-surface-magic": "rgba(248, 247, 255, 1)",
      "color-bg-surface-magic-hover": "rgba(243, 241, 255, 1)",
      "color-bg-surface-magic-active": "rgba(233, 229, 255, 1)",
      "color-bg-surface-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-surface-transparent": "rgba(0, 0, 0, 0)",
      "color-bg-fill": "rgba(255, 255, 255, 1)",
      "color-bg-fill-hover": "rgba(250, 250, 250, 1)",
      "color-bg-fill-active": "rgba(247, 247, 247, 1)",
      "color-bg-fill-selected": "rgba(204, 204, 204, 1)",
      "color-bg-fill-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-secondary": "rgba(241, 241, 241, 1)",
      "color-bg-fill-secondary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-fill-secondary-active": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary-hover": "rgba(212, 212, 212, 1)",
      "color-bg-fill-tertiary-active": "rgba(204, 204, 204, 1)",
      "color-bg-fill-brand": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-hover": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-active": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-selected": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-disabled": "rgba(0, 0, 0, 0.17)",
      "color-bg-fill-info": "rgba(145, 208, 255, 1)",
      "color-bg-fill-info-hover": "rgba(81, 192, 255, 1)",
      "color-bg-fill-info-active": "rgba(0, 148, 213, 1)",
      "color-bg-fill-info-secondary": "rgba(213, 235, 255, 1)",
      "color-bg-fill-success": "rgba(41, 132, 90, 1)",
      "color-bg-fill-success-hover": "rgba(19, 111, 69, 1)",
      "color-bg-fill-success-active": "rgba(12, 81, 50, 1)",
      "color-bg-fill-success-secondary": "rgba(180, 254, 210, 1)",
      "color-bg-fill-warning": "rgba(255, 184, 0, 1)",
      "color-bg-fill-warning-hover": "rgba(229, 165, 0, 1)",
      "color-bg-fill-warning-active": "rgba(178, 132, 0, 1)",
      "color-bg-fill-warning-secondary": "rgba(255, 214, 164, 1)",
      "color-bg-fill-caution": "rgba(255, 230, 0, 1)",
      "color-bg-fill-caution-hover": "rgba(234, 211, 0, 1)",
      "color-bg-fill-caution-active": "rgba(225, 203, 0, 1)",
      "color-bg-fill-caution-secondary": "rgba(255, 235, 120, 1)",
      "color-bg-fill-critical": "rgba(229, 28, 0, 1)",
      "color-bg-fill-critical-hover": "rgba(181, 38, 11, 1)",
      "color-bg-fill-critical-active": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-selected": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-secondary": "rgba(254, 211, 209, 1)",
      "color-bg-fill-emphasis": "rgba(0, 91, 211, 1)",
      "color-bg-fill-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-bg-fill-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-bg-fill-magic": "rgba(128, 81, 255, 1)",
      "color-bg-fill-magic-secondary": "rgba(233, 229, 255, 1)",
      "color-bg-fill-magic-secondary-hover": "rgba(228, 222, 255, 1)",
      "color-bg-fill-magic-secondary-active": "rgba(223, 217, 255, 1)",
      "color-bg-fill-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-fill-inverse-hover": "rgba(74, 74, 74, 1)",
      "color-bg-fill-inverse-active": "rgba(97, 97, 97, 1)",
      "color-bg-fill-transparent": "rgba(0, 0, 0, 0.02)",
      "color-bg-fill-transparent-hover": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-transparent-active": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-selected": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary": "rgba(0, 0, 0, 0.06)",
      "color-bg-fill-transparent-secondary-hover": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary-active": "rgba(0, 0, 0, 0.11)",
      "color-text": "rgba(48, 48, 48, 1)",
      "color-text-secondary": "rgba(97, 97, 97, 1)",
      "color-text-disabled": "rgba(181, 181, 181, 1)",
      "color-text-link": "rgba(0, 91, 211, 1)",
      "color-text-link-hover": "rgba(0, 66, 153, 1)",
      "color-text-link-active": "rgba(0, 46, 106, 1)",
      "color-text-brand": "rgba(74, 74, 74, 1)",
      "color-text-brand-hover": "rgba(48, 48, 48, 1)",
      "color-text-brand-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-text-brand-on-bg-fill-hover": "rgba(227, 227, 227, 1)",
      "color-text-brand-on-bg-fill-active": "rgba(204, 204, 204, 1)",
      "color-text-brand-on-bg-fill-disabled": "rgba(255, 255, 255, 1)",
      "color-text-info": "rgba(0, 58, 90, 1)",
      "color-text-info-hover": "rgba(0, 58, 90, 1)",
      "color-text-info-active": "rgba(0, 33, 51, 1)",
      "color-text-info-secondary": "rgba(0, 124, 180, 1)",
      "color-text-info-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-text-success": "rgba(12, 81, 50, 1)",
      "color-text-success-hover": "rgba(8, 61, 37, 1)",
      "color-text-success-active": "rgba(9, 42, 27, 1)",
      "color-text-success-secondary": "rgba(41, 132, 90, 1)",
      "color-text-success-on-bg-fill": "rgba(248, 255, 251, 1)",
      "color-text-caution": "rgba(79, 71, 0, 1)",
      "color-text-caution-hover": "rgba(51, 46, 0, 1)",
      "color-text-caution-active": "rgba(31, 28, 0, 1)",
      "color-text-caution-secondary": "rgba(130, 117, 0, 1)",
      "color-text-caution-on-bg-fill": "rgba(51, 46, 0, 1)",
      "color-text-warning": "rgba(94, 66, 0, 1)",
      "color-text-warning-hover": "rgba(65, 45, 0, 1)",
      "color-text-warning-active": "rgba(37, 26, 0, 1)",
      "color-text-warning-secondary": "rgba(149, 111, 0, 1)",
      "color-text-warning-on-bg-fill": "rgba(37, 26, 0, 1)",
      "color-text-critical": "rgba(142, 31, 11, 1)",
      "color-text-critical-hover": "rgba(95, 21, 7, 1)",
      "color-text-critical-active": "rgba(47, 10, 4, 1)",
      "color-text-critical-secondary": "rgba(229, 28, 0, 1)",
      "color-text-critical-on-bg-fill": "rgba(255, 251, 251, 1)",
      "color-text-emphasis": "rgba(0, 91, 211, 1)",
      "color-text-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-text-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-text-emphasis-on-bg-fill": "rgba(252, 253, 255, 1)",
      "color-text-emphasis-on-bg-fill-hover": "rgba(226, 231, 255, 1)",
      "color-text-emphasis-on-bg-fill-active": "rgba(213, 220, 255, 1)",
      "color-text-magic": "rgba(87, 0, 209, 1)",
      "color-text-magic-secondary": "rgba(113, 38, 255, 1)",
      "color-text-magic-on-bg-fill": "rgba(253, 253, 255, 1)",
      "color-text-inverse": "rgba(227, 227, 227, 1)",
      "color-text-inverse-secondary": "rgba(181, 181, 181, 1)",
      "color-text-link-inverse": "rgba(197, 208, 255, 1)",
      "color-border": "rgba(227, 227, 227, 1)",
      "color-border-hover": "rgba(204, 204, 204, 1)",
      "color-border-disabled": "rgba(235, 235, 235, 1)",
      "color-border-secondary": "rgba(235, 235, 235, 1)",
      "color-border-tertiary": "rgba(204, 204, 204, 1)",
      "color-border-focus": "rgba(0, 91, 211, 1)",
      "color-border-brand": "rgba(227, 227, 227, 1)",
      "color-border-info": "rgba(168, 216, 255, 1)",
      "color-border-success": "rgba(146, 254, 194, 1)",
      "color-border-caution": "rgba(255, 235, 120, 1)",
      "color-border-warning": "rgba(255, 200, 121, 1)",
      "color-border-critical": "rgba(254, 195, 193, 1)",
      "color-border-critical-secondary": "rgba(142, 31, 11, 1)",
      "color-border-emphasis": "rgba(0, 91, 211, 1)",
      "color-border-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-border-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-border-magic": "rgba(228, 222, 255, 1)",
      "color-border-magic-secondary": "rgba(148, 116, 255, 1)",
      "color-border-magic-secondary-hover": "rgba(128, 81, 255, 1)",
      "color-border-inverse": "rgba(97, 97, 97, 1)",
      "color-border-inverse-hover": "rgba(204, 204, 204, 1)",
      "color-border-inverse-active": "rgba(227, 227, 227, 1)",
      "color-tooltip-tail-down-border-experimental": "rgba(212, 212, 212, 1)",
      "color-tooltip-tail-up-border-experimental": "rgba(227, 227, 227, 1)",
      "color-border-gradient-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-hover-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-selected-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-active-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-icon": "rgba(74, 74, 74, 1)",
      "color-icon-hover": "rgba(48, 48, 48, 1)",
      "color-icon-active": "rgba(26, 26, 26, 1)",
      "color-icon-disabled": "rgba(204, 204, 204, 1)",
      "color-icon-secondary": "rgba(138, 138, 138, 1)",
      "color-icon-secondary-hover": "rgba(97, 97, 97, 1)",
      "color-icon-secondary-active": "rgba(74, 74, 74, 1)",
      "color-icon-brand": "rgba(26, 26, 26, 1)",
      "color-icon-info": "rgba(0, 148, 213, 1)",
      "color-icon-success": "rgba(41, 132, 90, 1)",
      "color-icon-caution": "rgba(153, 138, 0, 1)",
      "color-icon-warning": "rgba(178, 132, 0, 1)",
      "color-icon-critical": "rgba(239, 77, 47, 1)",
      "color-icon-emphasis": "rgba(0, 91, 211, 1)",
      "color-icon-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-icon-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-icon-magic": "rgba(128, 81, 255, 1)",
      "color-icon-inverse": "rgba(227, 227, 227, 1)",
      "color-avatar-bg-fill": "rgba(181, 181, 181, 1)",
      "color-avatar-five-bg-fill": "rgba(253, 75, 146, 1)",
      "color-avatar-five-text-on-bg-fill": "rgba(255, 246, 248, 1)",
      "color-avatar-four-bg-fill": "rgba(81, 192, 255, 1)",
      "color-avatar-four-text-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-avatar-one-bg-fill": "rgba(197, 48, 197, 1)",
      "color-avatar-one-text-on-bg-fill": "rgba(253, 239, 253, 1)",
      "color-avatar-seven-bg-fill": "rgba(148, 116, 255, 1)",
      "color-avatar-seven-text-on-bg-fill": "rgba(248, 247, 255, 1)",
      "color-avatar-six-bg-fill": "rgba(37, 232, 43, 1)",
      "color-avatar-six-text-on-bg-fill": "rgba(3, 61, 5, 1)",
      "color-avatar-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-avatar-three-bg-fill": "rgba(44, 224, 212, 1)",
      "color-avatar-three-text-on-bg-fill": "rgba(3, 60, 57, 1)",
      "color-avatar-two-bg-fill": "rgba(56, 250, 163, 1)",
      "color-avatar-two-text-on-bg-fill": "rgba(12, 81, 50, 1)",
      "color-backdrop-bg": "rgba(0, 0, 0, 0.71)",
      "color-button-gradient-bg-fill": "linear-gradient(180deg, rgba(48, 48, 48, 0) 63.53%, rgba(255, 255, 255, 0.15) 100%)",
      "color-checkbox-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-checkbox-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-input-bg-surface": "rgba(253, 253, 253, 1)",
      "color-input-bg-surface-hover": "rgba(250, 250, 250, 1)",
      "color-input-bg-surface-active": "rgba(247, 247, 247, 1)",
      "color-input-border": "rgba(138, 138, 138, 1)",
      "color-input-border-hover": "rgba(97, 97, 97, 1)",
      "color-input-border-active": "rgba(26, 26, 26, 1)",
      "color-nav-bg": "rgba(235, 235, 235, 1)",
      "color-nav-bg-surface": "rgba(0, 0, 0, 0.02)",
      "color-nav-bg-surface-hover": "rgba(241, 241, 241, 1)",
      "color-nav-bg-surface-active": "rgba(250, 250, 250, 1)",
      "color-nav-bg-surface-selected": "rgba(250, 250, 250, 1)",
      "color-radio-button-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-radio-button-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-video-thumbnail-play-button-bg-fill-hover": "rgba(0, 0, 0, 0.81)",
      "color-video-thumbnail-play-button-bg-fill": "rgba(0, 0, 0, 0.71)",
      "color-video-thumbnail-play-button-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-scrollbar-thumb-bg-hover": "rgba(138, 138, 138, 1)"
    },
    font: {
      "font-family-sans": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "font-family-mono": "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace",
      "font-size-275": "0.6875rem",
      "font-size-300": "0.75rem",
      "font-size-325": "0.8125rem",
      "font-size-350": "0.875rem",
      "font-size-400": "1rem",
      "font-size-450": "1.125rem",
      "font-size-500": "1.25rem",
      "font-size-550": "1.375rem",
      "font-size-600": "1.5rem",
      "font-size-750": "1.875rem",
      "font-size-800": "2rem",
      "font-size-900": "2.25rem",
      "font-size-1000": "2.5rem",
      "font-weight-regular": "450",
      "font-weight-medium": "550",
      "font-weight-semibold": "650",
      "font-weight-bold": "700",
      "font-letter-spacing-densest": "-0.03375rem",
      "font-letter-spacing-denser": "-0.01875rem",
      "font-letter-spacing-dense": "-0.0125rem",
      "font-letter-spacing-normal": "0rem",
      "font-line-height-300": "0.75rem",
      "font-line-height-400": "1rem",
      "font-line-height-500": "1.25rem",
      "font-line-height-600": "1.5rem",
      "font-line-height-700": "1.75rem",
      "font-line-height-800": "2rem",
      "font-line-height-1000": "2.5rem",
      "font-line-height-1200": "3rem"
    },
    height: {
      "height-0": "0rem",
      "height-025": "0.0625rem",
      "height-050": "0.125rem",
      "height-100": "0.25rem",
      "height-150": "0.375rem",
      "height-200": "0.5rem",
      "height-300": "0.75rem",
      "height-400": "1rem",
      "height-500": "1.25rem",
      "height-600": "1.5rem",
      "height-700": "1.75rem",
      "height-800": "2rem",
      "height-900": "2.25rem",
      "height-1000": "2.5rem",
      "height-1200": "3rem",
      "height-1600": "4rem",
      "height-2000": "5rem",
      "height-2400": "6rem",
      "height-2800": "7rem",
      "height-3200": "8rem"
    },
    motion: {
      "motion-duration-0": "0ms",
      "motion-duration-50": "50ms",
      "motion-duration-100": "100ms",
      "motion-duration-150": "150ms",
      "motion-duration-200": "200ms",
      "motion-duration-250": "250ms",
      "motion-duration-300": "300ms",
      "motion-duration-350": "350ms",
      "motion-duration-400": "400ms",
      "motion-duration-450": "450ms",
      "motion-duration-500": "500ms",
      "motion-duration-5000": "5000ms",
      "motion-ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
      "motion-ease-in": "cubic-bezier(0.42, 0, 1, 1)",
      "motion-ease-out": "cubic-bezier(0.19, 0.91, 0.38, 1)",
      "motion-ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
      "motion-linear": "cubic-bezier(0, 0, 1, 1)",
      "motion-keyframes-bounce": "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }",
      "motion-keyframes-fade-in": "{ to { opacity: 1 } }",
      "motion-keyframes-pulse": "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }",
      "motion-keyframes-spin": "{ to { transform: rotate(1turn) } }",
      "motion-keyframes-appear-above": "{ from { transform: translateY(var(--p-space-100)); opacity: 0; } to { transform: none; opacity: 1; } }",
      "motion-keyframes-appear-below": "{ from { transform: translateY(calc(var(--p-space-100) * -1)); opacity: 0; } to { transform: none; opacity: 1; } }"
    },
    shadow: {
      "shadow-0": "none",
      "shadow-100": "0rem 0.0625rem 0rem 0rem rgba(26, 26, 26, 0.07)",
      "shadow-200": "0rem 0.1875rem 0.0625rem -0.0625rem rgba(26, 26, 26, 0.07)",
      "shadow-300": "0rem 0.25rem 0.375rem -0.125rem rgba(26, 26, 26, 0.20)",
      "shadow-400": "0rem 0.5rem 1rem -0.25rem rgba(26, 26, 26, 0.22)",
      "shadow-500": "0rem 0.75rem 1.25rem -0.5rem rgba(26, 26, 26, 0.24)",
      "shadow-600": "0rem 1.25rem 1.25rem -0.5rem rgba(26, 26, 26, 0.28)",
      "shadow-bevel-100": "0.0625rem 0rem 0rem 0rem rgba(0, 0, 0, 0.13) inset, -0.0625rem 0rem 0rem 0rem rgba(0, 0, 0, 0.13) inset, 0rem -0.0625rem 0rem 0rem rgba(0, 0, 0, 0.17) inset, 0rem 0.0625rem 0rem 0rem rgba(204, 204, 204, 0.5) inset",
      "shadow-inset-100": "0rem 0.0625rem 0.125rem 0rem rgba(26, 26, 26, 0.15) inset, 0rem 0.0625rem 0.0625rem 0rem rgba(26, 26, 26, 0.15) inset",
      "shadow-inset-200": "0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.20) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset, -0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset",
      "shadow-button": "0rem -0.0625rem 0rem 0rem #b5b5b5 inset, 0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.1) inset, 0rem 0.03125rem 0rem 0.09375rem #FFF inset",
      "shadow-button-hover": "0rem 0.0625rem 0rem 0rem #EBEBEB inset, -0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0rem -0.0625rem 0rem 0rem #CCC inset",
      "shadow-button-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.2) inset",
      "shadow-button-primary": "0rem -0.0625rem 0rem 0.0625rem rgba(0, 0, 0, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(48, 48, 48, 1) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.25) inset;",
      "shadow-button-primary-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.24) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.0625rem 0rem 0rem #000 inset, 0rem -0.0625rem 0rem 0.0625rem #1A1A1A",
      "shadow-button-primary-inset": "0rem 0.1875rem 0rem 0rem rgb(0, 0, 0) inset",
      "shadow-button-primary-critical": "0rem -0.0625rem 0rem 0.0625rem rgba(142, 31, 11, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(181, 38, 11, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.349) inset",
      "shadow-button-primary-critical-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-critical-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-button-primary-success": "0rem -0.0625rem 0rem 0.0625rem rgba(12, 81, 50, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(19, 111, 69, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.251) inset",
      "shadow-button-primary-success-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-success-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-border-inset": "0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.08) inset"
    },
    space: {
      "space-0": "0rem",
      "space-025": "0.0625rem",
      "space-050": "0.125rem",
      "space-100": "0.25rem",
      "space-150": "0.375rem",
      "space-200": "0.5rem",
      "space-300": "0.75rem",
      "space-400": "1rem",
      "space-500": "1.25rem",
      "space-600": "1.5rem",
      "space-800": "2rem",
      "space-1000": "2.5rem",
      "space-1200": "3rem",
      "space-1600": "4rem",
      "space-2000": "5rem",
      "space-2400": "6rem",
      "space-2800": "7rem",
      "space-3200": "8rem",
      "space-button-group-gap": "0.5rem",
      "space-card-gap": "1rem",
      "space-card-padding": "1rem",
      "space-table-cell-padding": "0.375rem"
    },
    text: {
      "text-heading-3xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-3xl-font-size": "2.25rem",
      "text-heading-3xl-font-weight": "700",
      "text-heading-3xl-font-letter-spacing": "-0.03375rem",
      "text-heading-3xl-font-line-height": "3rem",
      "text-heading-2xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-2xl-font-size": "1.875rem",
      "text-heading-2xl-font-weight": "700",
      "text-heading-2xl-font-letter-spacing": "-0.01875rem",
      "text-heading-2xl-font-line-height": "2.5rem",
      "text-heading-xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xl-font-size": "1.5rem",
      "text-heading-xl-font-weight": "700",
      "text-heading-xl-font-letter-spacing": "-0.0125rem",
      "text-heading-xl-font-line-height": "2rem",
      "text-heading-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-lg-font-size": "1.25rem",
      "text-heading-lg-font-weight": "650",
      "text-heading-lg-font-letter-spacing": "-0.0125rem",
      "text-heading-lg-font-line-height": "1.5rem",
      "text-heading-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-md-font-size": "0.875rem",
      "text-heading-md-font-weight": "650",
      "text-heading-md-font-letter-spacing": "0rem",
      "text-heading-md-font-line-height": "1.25rem",
      "text-heading-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-sm-font-size": "0.8125rem",
      "text-heading-sm-font-weight": "650",
      "text-heading-sm-font-letter-spacing": "0rem",
      "text-heading-sm-font-line-height": "1.25rem",
      "text-heading-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xs-font-size": "0.75rem",
      "text-heading-xs-font-weight": "650",
      "text-heading-xs-font-letter-spacing": "0rem",
      "text-heading-xs-font-line-height": "1rem",
      "text-body-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-lg-font-size": "0.875rem",
      "text-body-lg-font-weight": "450",
      "text-body-lg-font-letter-spacing": "0rem",
      "text-body-lg-font-line-height": "1.25rem",
      "text-body-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-md-font-size": "0.8125rem",
      "text-body-md-font-weight": "450",
      "text-body-md-font-letter-spacing": "0rem",
      "text-body-md-font-line-height": "1.25rem",
      "text-body-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-sm-font-size": "0.75rem",
      "text-body-sm-font-weight": "450",
      "text-body-sm-font-letter-spacing": "0rem",
      "text-body-sm-font-line-height": "1rem",
      "text-body-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-xs-font-size": "0.6875rem",
      "text-body-xs-font-weight": "450",
      "text-body-xs-font-letter-spacing": "0rem",
      "text-body-xs-font-line-height": "0.75rem"
    },
    width: {
      "width-0": "0rem",
      "width-025": "0.0625rem",
      "width-050": "0.125rem",
      "width-100": "0.25rem",
      "width-150": "0.375rem",
      "width-200": "0.5rem",
      "width-300": "0.75rem",
      "width-400": "1rem",
      "width-500": "1.25rem",
      "width-600": "1.5rem",
      "width-700": "1.75rem",
      "width-800": "2rem",
      "width-900": "2.25rem",
      "width-1000": "2.5rem",
      "width-1200": "3rem",
      "width-1600": "4rem",
      "width-2000": "5rem",
      "width-2400": "6rem",
      "width-2800": "7rem",
      "width-3200": "8rem"
    },
    zIndex: {
      "z-index-0": "auto",
      "z-index-1": "100",
      "z-index-2": "400",
      "z-index-3": "510",
      "z-index-4": "512",
      "z-index-5": "513",
      "z-index-6": "514",
      "z-index-7": "515",
      "z-index-8": "516",
      "z-index-9": "517",
      "z-index-10": "518",
      "z-index-11": "519",
      "z-index-12": "520"
    }
  },
  "light-mobile": {
    border: {
      "border-radius-0": "0rem",
      "border-radius-050": "0.125rem",
      "border-radius-100": "0.25rem",
      "border-radius-150": "0.375rem",
      "border-radius-200": "0.5rem",
      "border-radius-300": "0.75rem",
      "border-radius-400": "1rem",
      "border-radius-500": "1.25rem",
      "border-radius-750": "1.875rem",
      "border-radius-full": "624.9375rem",
      "border-width-0": "0rem",
      "border-width-0165": "0.04125rem",
      "border-width-025": "0.0625rem",
      "border-width-050": "0.125rem",
      "border-width-100": "0.25rem"
    },
    breakpoints: {
      "breakpoints-xs": "0rem",
      "breakpoints-sm": "30.625rem",
      "breakpoints-md": "48rem",
      "breakpoints-lg": "65rem",
      "breakpoints-xl": "90rem"
    },
    color: {
      "color-scheme": "light",
      "color-bg": "rgba(241, 241, 241, 1)",
      "color-bg-inverse": "rgba(26, 26, 26, 1)",
      "color-bg-surface": "rgba(255, 255, 255, 1)",
      "color-bg-surface-hover": "rgba(247, 247, 247, 1)",
      "color-bg-surface-active": "rgba(243, 243, 243, 1)",
      "color-bg-surface-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-surface-secondary": "rgba(247, 247, 247, 1)",
      "color-bg-surface-secondary-hover": "rgba(241, 241, 241, 1)",
      "color-bg-surface-secondary-active": "rgba(235, 235, 235, 1)",
      "color-bg-surface-secondary-selected": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary": "rgba(243, 243, 243, 1)",
      "color-bg-surface-tertiary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary-active": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-brand-active": "rgba(241, 241, 241, 1)",
      "color-bg-surface-brand-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-info": "rgba(234, 244, 255, 1)",
      "color-bg-surface-info-hover": "rgba(224, 240, 255, 1)",
      "color-bg-surface-info-active": "rgba(202, 230, 255, 1)",
      "color-bg-surface-success": "rgba(205, 254, 225, 1)",
      "color-bg-surface-success-hover": "rgba(180, 254, 210, 1)",
      "color-bg-surface-success-active": "rgba(146, 254, 194, 1)",
      "color-bg-surface-caution": "rgba(255, 248, 219, 1)",
      "color-bg-surface-caution-hover": "rgba(255, 244, 191, 1)",
      "color-bg-surface-caution-active": "rgba(255, 239, 157, 1)",
      "color-bg-surface-warning": "rgba(255, 241, 227, 1)",
      "color-bg-surface-warning-hover": "rgba(255, 235, 213, 1)",
      "color-bg-surface-warning-active": "rgba(255, 228, 198, 1)",
      "color-bg-surface-critical": "rgba(254, 233, 232, 1)",
      "color-bg-surface-critical-hover": "rgba(254, 226, 225, 1)",
      "color-bg-surface-critical-active": "rgba(254, 218, 217, 1)",
      "color-bg-surface-emphasis": "rgba(240, 242, 255, 1)",
      "color-bg-surface-emphasis-hover": "rgba(234, 237, 255, 1)",
      "color-bg-surface-emphasis-active": "rgba(226, 231, 255, 1)",
      "color-bg-surface-magic": "rgba(248, 247, 255, 1)",
      "color-bg-surface-magic-hover": "rgba(243, 241, 255, 1)",
      "color-bg-surface-magic-active": "rgba(233, 229, 255, 1)",
      "color-bg-surface-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-surface-transparent": "rgba(0, 0, 0, 0)",
      "color-bg-fill": "rgba(255, 255, 255, 1)",
      "color-bg-fill-hover": "rgba(250, 250, 250, 1)",
      "color-bg-fill-active": "rgba(247, 247, 247, 1)",
      "color-bg-fill-selected": "rgba(204, 204, 204, 1)",
      "color-bg-fill-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-secondary": "rgba(241, 241, 241, 1)",
      "color-bg-fill-secondary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-fill-secondary-active": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary-hover": "rgba(212, 212, 212, 1)",
      "color-bg-fill-tertiary-active": "rgba(204, 204, 204, 1)",
      "color-bg-fill-brand": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-hover": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-active": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-selected": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-disabled": "rgba(0, 0, 0, 0.17)",
      "color-bg-fill-info": "rgba(145, 208, 255, 1)",
      "color-bg-fill-info-hover": "rgba(81, 192, 255, 1)",
      "color-bg-fill-info-active": "rgba(0, 148, 213, 1)",
      "color-bg-fill-info-secondary": "rgba(213, 235, 255, 1)",
      "color-bg-fill-success": "rgba(41, 132, 90, 1)",
      "color-bg-fill-success-hover": "rgba(19, 111, 69, 1)",
      "color-bg-fill-success-active": "rgba(12, 81, 50, 1)",
      "color-bg-fill-success-secondary": "rgba(180, 254, 210, 1)",
      "color-bg-fill-warning": "rgba(255, 184, 0, 1)",
      "color-bg-fill-warning-hover": "rgba(229, 165, 0, 1)",
      "color-bg-fill-warning-active": "rgba(178, 132, 0, 1)",
      "color-bg-fill-warning-secondary": "rgba(255, 214, 164, 1)",
      "color-bg-fill-caution": "rgba(255, 230, 0, 1)",
      "color-bg-fill-caution-hover": "rgba(234, 211, 0, 1)",
      "color-bg-fill-caution-active": "rgba(225, 203, 0, 1)",
      "color-bg-fill-caution-secondary": "rgba(255, 235, 120, 1)",
      "color-bg-fill-critical": "rgba(229, 28, 0, 1)",
      "color-bg-fill-critical-hover": "rgba(181, 38, 11, 1)",
      "color-bg-fill-critical-active": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-selected": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-secondary": "rgba(254, 211, 209, 1)",
      "color-bg-fill-emphasis": "rgba(0, 91, 211, 1)",
      "color-bg-fill-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-bg-fill-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-bg-fill-magic": "rgba(128, 81, 255, 1)",
      "color-bg-fill-magic-secondary": "rgba(233, 229, 255, 1)",
      "color-bg-fill-magic-secondary-hover": "rgba(228, 222, 255, 1)",
      "color-bg-fill-magic-secondary-active": "rgba(223, 217, 255, 1)",
      "color-bg-fill-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-fill-inverse-hover": "rgba(74, 74, 74, 1)",
      "color-bg-fill-inverse-active": "rgba(97, 97, 97, 1)",
      "color-bg-fill-transparent": "rgba(0, 0, 0, 0.02)",
      "color-bg-fill-transparent-hover": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-transparent-active": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-selected": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary": "rgba(0, 0, 0, 0.06)",
      "color-bg-fill-transparent-secondary-hover": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary-active": "rgba(0, 0, 0, 0.11)",
      "color-text": "rgba(48, 48, 48, 1)",
      "color-text-secondary": "rgba(97, 97, 97, 1)",
      "color-text-disabled": "rgba(181, 181, 181, 1)",
      "color-text-link": "rgba(0, 91, 211, 1)",
      "color-text-link-hover": "rgba(0, 66, 153, 1)",
      "color-text-link-active": "rgba(0, 46, 106, 1)",
      "color-text-brand": "rgba(74, 74, 74, 1)",
      "color-text-brand-hover": "rgba(48, 48, 48, 1)",
      "color-text-brand-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-text-brand-on-bg-fill-hover": "rgba(227, 227, 227, 1)",
      "color-text-brand-on-bg-fill-active": "rgba(204, 204, 204, 1)",
      "color-text-brand-on-bg-fill-disabled": "rgba(255, 255, 255, 1)",
      "color-text-info": "rgba(0, 58, 90, 1)",
      "color-text-info-hover": "rgba(0, 58, 90, 1)",
      "color-text-info-active": "rgba(0, 33, 51, 1)",
      "color-text-info-secondary": "rgba(0, 124, 180, 1)",
      "color-text-info-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-text-success": "rgba(12, 81, 50, 1)",
      "color-text-success-hover": "rgba(8, 61, 37, 1)",
      "color-text-success-active": "rgba(9, 42, 27, 1)",
      "color-text-success-secondary": "rgba(41, 132, 90, 1)",
      "color-text-success-on-bg-fill": "rgba(248, 255, 251, 1)",
      "color-text-caution": "rgba(79, 71, 0, 1)",
      "color-text-caution-hover": "rgba(51, 46, 0, 1)",
      "color-text-caution-active": "rgba(31, 28, 0, 1)",
      "color-text-caution-secondary": "rgba(130, 117, 0, 1)",
      "color-text-caution-on-bg-fill": "rgba(51, 46, 0, 1)",
      "color-text-warning": "rgba(94, 66, 0, 1)",
      "color-text-warning-hover": "rgba(65, 45, 0, 1)",
      "color-text-warning-active": "rgba(37, 26, 0, 1)",
      "color-text-warning-secondary": "rgba(149, 111, 0, 1)",
      "color-text-warning-on-bg-fill": "rgba(37, 26, 0, 1)",
      "color-text-critical": "rgba(142, 31, 11, 1)",
      "color-text-critical-hover": "rgba(95, 21, 7, 1)",
      "color-text-critical-active": "rgba(47, 10, 4, 1)",
      "color-text-critical-secondary": "rgba(229, 28, 0, 1)",
      "color-text-critical-on-bg-fill": "rgba(255, 251, 251, 1)",
      "color-text-emphasis": "rgba(0, 91, 211, 1)",
      "color-text-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-text-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-text-emphasis-on-bg-fill": "rgba(252, 253, 255, 1)",
      "color-text-emphasis-on-bg-fill-hover": "rgba(226, 231, 255, 1)",
      "color-text-emphasis-on-bg-fill-active": "rgba(213, 220, 255, 1)",
      "color-text-magic": "rgba(87, 0, 209, 1)",
      "color-text-magic-secondary": "rgba(113, 38, 255, 1)",
      "color-text-magic-on-bg-fill": "rgba(253, 253, 255, 1)",
      "color-text-inverse": "rgba(227, 227, 227, 1)",
      "color-text-inverse-secondary": "rgba(181, 181, 181, 1)",
      "color-text-link-inverse": "rgba(197, 208, 255, 1)",
      "color-border": "rgba(227, 227, 227, 1)",
      "color-border-hover": "rgba(204, 204, 204, 1)",
      "color-border-disabled": "rgba(235, 235, 235, 1)",
      "color-border-secondary": "rgba(235, 235, 235, 1)",
      "color-border-tertiary": "rgba(204, 204, 204, 1)",
      "color-border-focus": "rgba(0, 91, 211, 1)",
      "color-border-brand": "rgba(227, 227, 227, 1)",
      "color-border-info": "rgba(168, 216, 255, 1)",
      "color-border-success": "rgba(146, 254, 194, 1)",
      "color-border-caution": "rgba(255, 235, 120, 1)",
      "color-border-warning": "rgba(255, 200, 121, 1)",
      "color-border-critical": "rgba(254, 195, 193, 1)",
      "color-border-critical-secondary": "rgba(142, 31, 11, 1)",
      "color-border-emphasis": "rgba(0, 91, 211, 1)",
      "color-border-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-border-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-border-magic": "rgba(228, 222, 255, 1)",
      "color-border-magic-secondary": "rgba(148, 116, 255, 1)",
      "color-border-magic-secondary-hover": "rgba(128, 81, 255, 1)",
      "color-border-inverse": "rgba(97, 97, 97, 1)",
      "color-border-inverse-hover": "rgba(204, 204, 204, 1)",
      "color-border-inverse-active": "rgba(227, 227, 227, 1)",
      "color-tooltip-tail-down-border-experimental": "rgba(212, 212, 212, 1)",
      "color-tooltip-tail-up-border-experimental": "rgba(227, 227, 227, 1)",
      "color-border-gradient-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-hover-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-selected-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-active-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-icon": "rgba(74, 74, 74, 1)",
      "color-icon-hover": "rgba(48, 48, 48, 1)",
      "color-icon-active": "rgba(26, 26, 26, 1)",
      "color-icon-disabled": "rgba(204, 204, 204, 1)",
      "color-icon-secondary": "rgba(138, 138, 138, 1)",
      "color-icon-secondary-hover": "rgba(97, 97, 97, 1)",
      "color-icon-secondary-active": "rgba(74, 74, 74, 1)",
      "color-icon-brand": "rgba(26, 26, 26, 1)",
      "color-icon-info": "rgba(0, 148, 213, 1)",
      "color-icon-success": "rgba(41, 132, 90, 1)",
      "color-icon-caution": "rgba(153, 138, 0, 1)",
      "color-icon-warning": "rgba(178, 132, 0, 1)",
      "color-icon-critical": "rgba(239, 77, 47, 1)",
      "color-icon-emphasis": "rgba(0, 91, 211, 1)",
      "color-icon-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-icon-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-icon-magic": "rgba(128, 81, 255, 1)",
      "color-icon-inverse": "rgba(227, 227, 227, 1)",
      "color-avatar-bg-fill": "rgba(181, 181, 181, 1)",
      "color-avatar-five-bg-fill": "rgba(253, 75, 146, 1)",
      "color-avatar-five-text-on-bg-fill": "rgba(255, 246, 248, 1)",
      "color-avatar-four-bg-fill": "rgba(81, 192, 255, 1)",
      "color-avatar-four-text-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-avatar-one-bg-fill": "rgba(197, 48, 197, 1)",
      "color-avatar-one-text-on-bg-fill": "rgba(253, 239, 253, 1)",
      "color-avatar-seven-bg-fill": "rgba(148, 116, 255, 1)",
      "color-avatar-seven-text-on-bg-fill": "rgba(248, 247, 255, 1)",
      "color-avatar-six-bg-fill": "rgba(37, 232, 43, 1)",
      "color-avatar-six-text-on-bg-fill": "rgba(3, 61, 5, 1)",
      "color-avatar-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-avatar-three-bg-fill": "rgba(44, 224, 212, 1)",
      "color-avatar-three-text-on-bg-fill": "rgba(3, 60, 57, 1)",
      "color-avatar-two-bg-fill": "rgba(56, 250, 163, 1)",
      "color-avatar-two-text-on-bg-fill": "rgba(12, 81, 50, 1)",
      "color-backdrop-bg": "rgba(0, 0, 0, 0.71)",
      "color-button-gradient-bg-fill": "none",
      "color-checkbox-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-checkbox-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-input-bg-surface": "rgba(253, 253, 253, 1)",
      "color-input-bg-surface-hover": "rgba(250, 250, 250, 1)",
      "color-input-bg-surface-active": "rgba(247, 247, 247, 1)",
      "color-input-border": "rgba(138, 138, 138, 1)",
      "color-input-border-hover": "rgba(97, 97, 97, 1)",
      "color-input-border-active": "rgba(26, 26, 26, 1)",
      "color-nav-bg": "rgba(235, 235, 235, 1)",
      "color-nav-bg-surface": "rgba(0, 0, 0, 0.02)",
      "color-nav-bg-surface-hover": "rgba(241, 241, 241, 1)",
      "color-nav-bg-surface-active": "rgba(250, 250, 250, 1)",
      "color-nav-bg-surface-selected": "rgba(250, 250, 250, 1)",
      "color-radio-button-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-radio-button-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-video-thumbnail-play-button-bg-fill-hover": "rgba(0, 0, 0, 0.81)",
      "color-video-thumbnail-play-button-bg-fill": "rgba(0, 0, 0, 0.71)",
      "color-video-thumbnail-play-button-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-scrollbar-thumb-bg-hover": "rgba(138, 138, 138, 1)"
    },
    font: {
      "font-family-sans": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "font-family-mono": "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace",
      "font-size-275": "0.6875rem",
      "font-size-300": "0.75rem",
      "font-size-325": "0.8125rem",
      "font-size-350": "0.875rem",
      "font-size-400": "1rem",
      "font-size-450": "1.125rem",
      "font-size-500": "1.25rem",
      "font-size-550": "1.375rem",
      "font-size-600": "1.5rem",
      "font-size-750": "1.875rem",
      "font-size-800": "2rem",
      "font-size-900": "2.25rem",
      "font-size-1000": "2.5rem",
      "font-weight-regular": "450",
      "font-weight-medium": "550",
      "font-weight-semibold": "650",
      "font-weight-bold": "700",
      "font-letter-spacing-densest": "-0.03375rem",
      "font-letter-spacing-denser": "-0.01875rem",
      "font-letter-spacing-dense": "-0.0125rem",
      "font-letter-spacing-normal": "0rem",
      "font-line-height-300": "0.75rem",
      "font-line-height-400": "1rem",
      "font-line-height-500": "1.25rem",
      "font-line-height-600": "1.5rem",
      "font-line-height-700": "1.75rem",
      "font-line-height-800": "2rem",
      "font-line-height-1000": "2.5rem",
      "font-line-height-1200": "3rem"
    },
    height: {
      "height-0": "0rem",
      "height-025": "0.0625rem",
      "height-050": "0.125rem",
      "height-100": "0.25rem",
      "height-150": "0.375rem",
      "height-200": "0.5rem",
      "height-300": "0.75rem",
      "height-400": "1rem",
      "height-500": "1.25rem",
      "height-600": "1.5rem",
      "height-700": "1.75rem",
      "height-800": "2rem",
      "height-900": "2.25rem",
      "height-1000": "2.5rem",
      "height-1200": "3rem",
      "height-1600": "4rem",
      "height-2000": "5rem",
      "height-2400": "6rem",
      "height-2800": "7rem",
      "height-3200": "8rem"
    },
    motion: {
      "motion-duration-0": "0ms",
      "motion-duration-50": "50ms",
      "motion-duration-100": "100ms",
      "motion-duration-150": "150ms",
      "motion-duration-200": "200ms",
      "motion-duration-250": "250ms",
      "motion-duration-300": "300ms",
      "motion-duration-350": "350ms",
      "motion-duration-400": "400ms",
      "motion-duration-450": "450ms",
      "motion-duration-500": "500ms",
      "motion-duration-5000": "5000ms",
      "motion-ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
      "motion-ease-in": "cubic-bezier(0.42, 0, 1, 1)",
      "motion-ease-out": "cubic-bezier(0.19, 0.91, 0.38, 1)",
      "motion-ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
      "motion-linear": "cubic-bezier(0, 0, 1, 1)",
      "motion-keyframes-bounce": "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }",
      "motion-keyframes-fade-in": "{ to { opacity: 1 } }",
      "motion-keyframes-pulse": "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }",
      "motion-keyframes-spin": "{ to { transform: rotate(1turn) } }",
      "motion-keyframes-appear-above": "{ from { transform: translateY(var(--p-space-100)); opacity: 0; } to { transform: none; opacity: 1; } }",
      "motion-keyframes-appear-below": "{ from { transform: translateY(calc(var(--p-space-100) * -1)); opacity: 0; } to { transform: none; opacity: 1; } }"
    },
    shadow: {
      "shadow-0": "none",
      "shadow-100": "none",
      "shadow-200": "0rem 0.1875rem 0.0625rem -0.0625rem rgba(26, 26, 26, 0.07)",
      "shadow-300": "0rem 0.25rem 0.375rem -0.125rem rgba(26, 26, 26, 0.20)",
      "shadow-400": "0rem 0.5rem 1rem -0.25rem rgba(26, 26, 26, 0.22)",
      "shadow-500": "0rem 0.75rem 1.25rem -0.5rem rgba(26, 26, 26, 0.24)",
      "shadow-600": "0rem 1.25rem 1.25rem -0.5rem rgba(26, 26, 26, 0.28)",
      "shadow-bevel-100": "none",
      "shadow-inset-100": "0rem 0.0625rem 0.125rem 0rem rgba(26, 26, 26, 0.15) inset, 0rem 0.0625rem 0.0625rem 0rem rgba(26, 26, 26, 0.15) inset",
      "shadow-inset-200": "0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.20) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset, -0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset",
      "shadow-button": "0 0 0 var(--p-border-width-025) var(--p-color-border) inset",
      "shadow-button-hover": "0 0 0 var(--p-border-width-025) var(--p-color-border) inset",
      "shadow-button-inset": "0 0 0 var(--p-border-width-025) var(--p-color-border) inset",
      "shadow-button-primary": "none",
      "shadow-button-primary-hover": "none",
      "shadow-button-primary-inset": "none",
      "shadow-button-primary-critical": "none",
      "shadow-button-primary-critical-hover": "none",
      "shadow-button-primary-critical-inset": "none",
      "shadow-button-primary-success": "none",
      "shadow-button-primary-success-hover": "none",
      "shadow-button-primary-success-inset": "none",
      "shadow-border-inset": "0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.08) inset"
    },
    space: {
      "space-0": "0rem",
      "space-025": "0.0625rem",
      "space-050": "0.125rem",
      "space-100": "0.25rem",
      "space-150": "0.375rem",
      "space-200": "0.5rem",
      "space-300": "0.75rem",
      "space-400": "1rem",
      "space-500": "1.25rem",
      "space-600": "1.5rem",
      "space-800": "2rem",
      "space-1000": "2.5rem",
      "space-1200": "3rem",
      "space-1600": "4rem",
      "space-2000": "5rem",
      "space-2400": "6rem",
      "space-2800": "7rem",
      "space-3200": "8rem",
      "space-button-group-gap": "0.5rem",
      "space-card-gap": "0.5rem",
      "space-card-padding": "1rem",
      "space-table-cell-padding": "0.375rem"
    },
    text: {
      "text-heading-3xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-3xl-font-size": "2.25rem",
      "text-heading-3xl-font-weight": "700",
      "text-heading-3xl-font-letter-spacing": "-0.03375rem",
      "text-heading-3xl-font-line-height": "3rem",
      "text-heading-2xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-2xl-font-size": "2rem",
      "text-heading-2xl-font-weight": "700",
      "text-heading-2xl-font-letter-spacing": "-0.01875rem",
      "text-heading-2xl-font-line-height": "2.5rem",
      "text-heading-xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xl-font-size": "1.375rem",
      "text-heading-xl-font-weight": "700",
      "text-heading-xl-font-letter-spacing": "-0.0125rem",
      "text-heading-xl-font-line-height": "1.75rem",
      "text-heading-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-lg-font-size": "1.125rem",
      "text-heading-lg-font-weight": "650",
      "text-heading-lg-font-letter-spacing": "-0.0125rem",
      "text-heading-lg-font-line-height": "1.5rem",
      "text-heading-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-md-font-size": "1rem",
      "text-heading-md-font-weight": "650",
      "text-heading-md-font-letter-spacing": "0rem",
      "text-heading-md-font-line-height": "1.25rem",
      "text-heading-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-sm-font-size": "0.875rem",
      "text-heading-sm-font-weight": "650",
      "text-heading-sm-font-letter-spacing": "0rem",
      "text-heading-sm-font-line-height": "1.25rem",
      "text-heading-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xs-font-size": "0.75rem",
      "text-heading-xs-font-weight": "650",
      "text-heading-xs-font-letter-spacing": "0rem",
      "text-heading-xs-font-line-height": "1rem",
      "text-body-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-lg-font-size": "1.125rem",
      "text-body-lg-font-weight": "450",
      "text-body-lg-font-letter-spacing": "0rem",
      "text-body-lg-font-line-height": "1.75rem",
      "text-body-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-md-font-size": "1rem",
      "text-body-md-font-weight": "450",
      "text-body-md-font-letter-spacing": "0rem",
      "text-body-md-font-line-height": "1.5rem",
      "text-body-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-sm-font-size": "0.875rem",
      "text-body-sm-font-weight": "450",
      "text-body-sm-font-letter-spacing": "0rem",
      "text-body-sm-font-line-height": "1.25rem",
      "text-body-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-xs-font-size": "0.75rem",
      "text-body-xs-font-weight": "450",
      "text-body-xs-font-letter-spacing": "0rem",
      "text-body-xs-font-line-height": "1rem"
    },
    width: {
      "width-0": "0rem",
      "width-025": "0.0625rem",
      "width-050": "0.125rem",
      "width-100": "0.25rem",
      "width-150": "0.375rem",
      "width-200": "0.5rem",
      "width-300": "0.75rem",
      "width-400": "1rem",
      "width-500": "1.25rem",
      "width-600": "1.5rem",
      "width-700": "1.75rem",
      "width-800": "2rem",
      "width-900": "2.25rem",
      "width-1000": "2.5rem",
      "width-1200": "3rem",
      "width-1600": "4rem",
      "width-2000": "5rem",
      "width-2400": "6rem",
      "width-2800": "7rem",
      "width-3200": "8rem"
    },
    zIndex: {
      "z-index-0": "auto",
      "z-index-1": "100",
      "z-index-2": "400",
      "z-index-3": "510",
      "z-index-4": "512",
      "z-index-5": "513",
      "z-index-6": "514",
      "z-index-7": "515",
      "z-index-8": "516",
      "z-index-9": "517",
      "z-index-10": "518",
      "z-index-11": "519",
      "z-index-12": "520"
    }
  },
  "light-high-contrast-experimental": {
    border: {
      "border-radius-0": "0rem",
      "border-radius-050": "0.125rem",
      "border-radius-100": "0.25rem",
      "border-radius-150": "0.375rem",
      "border-radius-200": "0.5rem",
      "border-radius-300": "0.75rem",
      "border-radius-400": "1rem",
      "border-radius-500": "1.25rem",
      "border-radius-750": "1.875rem",
      "border-radius-full": "624.9375rem",
      "border-width-0": "0rem",
      "border-width-0165": "0.04125rem",
      "border-width-025": "0.0625rem",
      "border-width-050": "0.125rem",
      "border-width-100": "0.25rem"
    },
    breakpoints: {
      "breakpoints-xs": "0rem",
      "breakpoints-sm": "30.625rem",
      "breakpoints-md": "48rem",
      "breakpoints-lg": "65rem",
      "breakpoints-xl": "90rem"
    },
    color: {
      "color-scheme": "light",
      "color-bg": "rgba(241, 241, 241, 1)",
      "color-bg-inverse": "rgba(26, 26, 26, 1)",
      "color-bg-surface": "rgba(255, 255, 255, 1)",
      "color-bg-surface-hover": "rgba(247, 247, 247, 1)",
      "color-bg-surface-active": "rgba(243, 243, 243, 1)",
      "color-bg-surface-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-surface-secondary": "rgba(241, 241, 241, 1)",
      "color-bg-surface-secondary-hover": "rgba(241, 241, 241, 1)",
      "color-bg-surface-secondary-active": "rgba(235, 235, 235, 1)",
      "color-bg-surface-secondary-selected": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary": "rgba(243, 243, 243, 1)",
      "color-bg-surface-tertiary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary-active": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-brand-active": "rgba(241, 241, 241, 1)",
      "color-bg-surface-brand-selected": "rgba(241, 241, 241, 1)",
      "color-bg-surface-info": "rgba(234, 244, 255, 1)",
      "color-bg-surface-info-hover": "rgba(224, 240, 255, 1)",
      "color-bg-surface-info-active": "rgba(202, 230, 255, 1)",
      "color-bg-surface-success": "rgba(205, 254, 225, 1)",
      "color-bg-surface-success-hover": "rgba(180, 254, 210, 1)",
      "color-bg-surface-success-active": "rgba(146, 254, 194, 1)",
      "color-bg-surface-caution": "rgba(255, 248, 219, 1)",
      "color-bg-surface-caution-hover": "rgba(255, 244, 191, 1)",
      "color-bg-surface-caution-active": "rgba(255, 239, 157, 1)",
      "color-bg-surface-warning": "rgba(255, 241, 227, 1)",
      "color-bg-surface-warning-hover": "rgba(255, 235, 213, 1)",
      "color-bg-surface-warning-active": "rgba(255, 228, 198, 1)",
      "color-bg-surface-critical": "rgba(254, 233, 232, 1)",
      "color-bg-surface-critical-hover": "rgba(254, 226, 225, 1)",
      "color-bg-surface-critical-active": "rgba(254, 218, 217, 1)",
      "color-bg-surface-emphasis": "rgba(240, 242, 255, 1)",
      "color-bg-surface-emphasis-hover": "rgba(234, 237, 255, 1)",
      "color-bg-surface-emphasis-active": "rgba(226, 231, 255, 1)",
      "color-bg-surface-magic": "rgba(248, 247, 255, 1)",
      "color-bg-surface-magic-hover": "rgba(243, 241, 255, 1)",
      "color-bg-surface-magic-active": "rgba(233, 229, 255, 1)",
      "color-bg-surface-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-surface-transparent": "rgba(0, 0, 0, 0)",
      "color-bg-fill": "rgba(255, 255, 255, 1)",
      "color-bg-fill-hover": "rgba(250, 250, 250, 1)",
      "color-bg-fill-active": "rgba(247, 247, 247, 1)",
      "color-bg-fill-selected": "rgba(204, 204, 204, 1)",
      "color-bg-fill-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-secondary": "rgba(241, 241, 241, 1)",
      "color-bg-fill-secondary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-fill-secondary-active": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary-hover": "rgba(212, 212, 212, 1)",
      "color-bg-fill-tertiary-active": "rgba(204, 204, 204, 1)",
      "color-bg-fill-brand": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-hover": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-active": "rgba(26, 26, 26, 1)",
      "color-bg-fill-brand-selected": "rgba(48, 48, 48, 1)",
      "color-bg-fill-brand-disabled": "rgba(0, 0, 0, 0.17)",
      "color-bg-fill-info": "rgba(145, 208, 255, 1)",
      "color-bg-fill-info-hover": "rgba(81, 192, 255, 1)",
      "color-bg-fill-info-active": "rgba(0, 148, 213, 1)",
      "color-bg-fill-info-secondary": "rgba(213, 235, 255, 1)",
      "color-bg-fill-success": "rgba(41, 132, 90, 1)",
      "color-bg-fill-success-hover": "rgba(19, 111, 69, 1)",
      "color-bg-fill-success-active": "rgba(12, 81, 50, 1)",
      "color-bg-fill-success-secondary": "rgba(180, 254, 210, 1)",
      "color-bg-fill-warning": "rgba(255, 184, 0, 1)",
      "color-bg-fill-warning-hover": "rgba(229, 165, 0, 1)",
      "color-bg-fill-warning-active": "rgba(178, 132, 0, 1)",
      "color-bg-fill-warning-secondary": "rgba(255, 214, 164, 1)",
      "color-bg-fill-caution": "rgba(255, 230, 0, 1)",
      "color-bg-fill-caution-hover": "rgba(234, 211, 0, 1)",
      "color-bg-fill-caution-active": "rgba(225, 203, 0, 1)",
      "color-bg-fill-caution-secondary": "rgba(255, 235, 120, 1)",
      "color-bg-fill-critical": "rgba(229, 28, 0, 1)",
      "color-bg-fill-critical-hover": "rgba(181, 38, 11, 1)",
      "color-bg-fill-critical-active": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-selected": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-secondary": "rgba(254, 211, 209, 1)",
      "color-bg-fill-emphasis": "rgba(0, 91, 211, 1)",
      "color-bg-fill-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-bg-fill-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-bg-fill-magic": "rgba(128, 81, 255, 1)",
      "color-bg-fill-magic-secondary": "rgba(233, 229, 255, 1)",
      "color-bg-fill-magic-secondary-hover": "rgba(228, 222, 255, 1)",
      "color-bg-fill-magic-secondary-active": "rgba(223, 217, 255, 1)",
      "color-bg-fill-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-fill-inverse-hover": "rgba(74, 74, 74, 1)",
      "color-bg-fill-inverse-active": "rgba(97, 97, 97, 1)",
      "color-bg-fill-transparent": "rgba(0, 0, 0, 0.02)",
      "color-bg-fill-transparent-hover": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-transparent-active": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-selected": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary": "rgba(0, 0, 0, 0.06)",
      "color-bg-fill-transparent-secondary-hover": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary-active": "rgba(0, 0, 0, 0.11)",
      "color-text": "rgba(26, 26, 26, 1)",
      "color-text-secondary": "rgba(26, 26, 26, 1)",
      "color-text-disabled": "rgba(181, 181, 181, 1)",
      "color-text-link": "rgba(0, 91, 211, 1)",
      "color-text-link-hover": "rgba(0, 66, 153, 1)",
      "color-text-link-active": "rgba(0, 46, 106, 1)",
      "color-text-brand": "rgba(26, 26, 26, 1)",
      "color-text-brand-hover": "rgba(48, 48, 48, 1)",
      "color-text-brand-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-text-brand-on-bg-fill-hover": "rgba(227, 227, 227, 1)",
      "color-text-brand-on-bg-fill-active": "rgba(204, 204, 204, 1)",
      "color-text-brand-on-bg-fill-disabled": "rgba(255, 255, 255, 1)",
      "color-text-info": "rgba(0, 58, 90, 1)",
      "color-text-info-hover": "rgba(0, 58, 90, 1)",
      "color-text-info-active": "rgba(0, 33, 51, 1)",
      "color-text-info-secondary": "rgba(0, 124, 180, 1)",
      "color-text-info-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-text-success": "rgba(12, 81, 50, 1)",
      "color-text-success-hover": "rgba(8, 61, 37, 1)",
      "color-text-success-active": "rgba(9, 42, 27, 1)",
      "color-text-success-secondary": "rgba(41, 132, 90, 1)",
      "color-text-success-on-bg-fill": "rgba(248, 255, 251, 1)",
      "color-text-caution": "rgba(79, 71, 0, 1)",
      "color-text-caution-hover": "rgba(51, 46, 0, 1)",
      "color-text-caution-active": "rgba(31, 28, 0, 1)",
      "color-text-caution-secondary": "rgba(130, 117, 0, 1)",
      "color-text-caution-on-bg-fill": "rgba(51, 46, 0, 1)",
      "color-text-warning": "rgba(94, 66, 0, 1)",
      "color-text-warning-hover": "rgba(65, 45, 0, 1)",
      "color-text-warning-active": "rgba(37, 26, 0, 1)",
      "color-text-warning-secondary": "rgba(149, 111, 0, 1)",
      "color-text-warning-on-bg-fill": "rgba(37, 26, 0, 1)",
      "color-text-critical": "rgba(142, 31, 11, 1)",
      "color-text-critical-hover": "rgba(95, 21, 7, 1)",
      "color-text-critical-active": "rgba(47, 10, 4, 1)",
      "color-text-critical-secondary": "rgba(229, 28, 0, 1)",
      "color-text-critical-on-bg-fill": "rgba(255, 251, 251, 1)",
      "color-text-emphasis": "rgba(0, 91, 211, 1)",
      "color-text-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-text-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-text-emphasis-on-bg-fill": "rgba(252, 253, 255, 1)",
      "color-text-emphasis-on-bg-fill-hover": "rgba(226, 231, 255, 1)",
      "color-text-emphasis-on-bg-fill-active": "rgba(213, 220, 255, 1)",
      "color-text-magic": "rgba(87, 0, 209, 1)",
      "color-text-magic-secondary": "rgba(113, 38, 255, 1)",
      "color-text-magic-on-bg-fill": "rgba(253, 253, 255, 1)",
      "color-text-inverse": "rgba(227, 227, 227, 1)",
      "color-text-inverse-secondary": "rgba(181, 181, 181, 1)",
      "color-text-link-inverse": "rgba(197, 208, 255, 1)",
      "color-border": "rgba(138, 138, 138, 1)",
      "color-border-hover": "rgba(204, 204, 204, 1)",
      "color-border-disabled": "rgba(235, 235, 235, 1)",
      "color-border-secondary": "rgba(138, 138, 138, 1)",
      "color-border-tertiary": "rgba(204, 204, 204, 1)",
      "color-border-focus": "rgba(0, 91, 211, 1)",
      "color-border-brand": "rgba(227, 227, 227, 1)",
      "color-border-info": "rgba(168, 216, 255, 1)",
      "color-border-success": "rgba(146, 254, 194, 1)",
      "color-border-caution": "rgba(255, 235, 120, 1)",
      "color-border-warning": "rgba(255, 200, 121, 1)",
      "color-border-critical": "rgba(254, 195, 193, 1)",
      "color-border-critical-secondary": "rgba(142, 31, 11, 1)",
      "color-border-emphasis": "rgba(0, 91, 211, 1)",
      "color-border-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-border-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-border-magic": "rgba(228, 222, 255, 1)",
      "color-border-magic-secondary": "rgba(148, 116, 255, 1)",
      "color-border-magic-secondary-hover": "rgba(128, 81, 255, 1)",
      "color-border-inverse": "rgba(97, 97, 97, 1)",
      "color-border-inverse-hover": "rgba(204, 204, 204, 1)",
      "color-border-inverse-active": "rgba(227, 227, 227, 1)",
      "color-tooltip-tail-down-border-experimental": "rgba(212, 212, 212, 1)",
      "color-tooltip-tail-up-border-experimental": "rgba(227, 227, 227, 1)",
      "color-border-gradient-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-hover-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-selected-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-border-gradient-active-experimental": "linear-gradient(to bottom, rgba(235, 235, 235, 1), rgba(204, 204, 204, 1) 78%, rgba(181, 181, 181, 1))",
      "color-icon": "rgba(74, 74, 74, 1)",
      "color-icon-hover": "rgba(48, 48, 48, 1)",
      "color-icon-active": "rgba(26, 26, 26, 1)",
      "color-icon-disabled": "rgba(204, 204, 204, 1)",
      "color-icon-secondary": "rgba(74, 74, 74, 1)",
      "color-icon-secondary-hover": "rgba(97, 97, 97, 1)",
      "color-icon-secondary-active": "rgba(74, 74, 74, 1)",
      "color-icon-brand": "rgba(26, 26, 26, 1)",
      "color-icon-info": "rgba(0, 148, 213, 1)",
      "color-icon-success": "rgba(41, 132, 90, 1)",
      "color-icon-caution": "rgba(153, 138, 0, 1)",
      "color-icon-warning": "rgba(178, 132, 0, 1)",
      "color-icon-critical": "rgba(239, 77, 47, 1)",
      "color-icon-emphasis": "rgba(0, 91, 211, 1)",
      "color-icon-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-icon-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-icon-magic": "rgba(128, 81, 255, 1)",
      "color-icon-inverse": "rgba(227, 227, 227, 1)",
      "color-avatar-bg-fill": "rgba(181, 181, 181, 1)",
      "color-avatar-five-bg-fill": "rgba(253, 75, 146, 1)",
      "color-avatar-five-text-on-bg-fill": "rgba(255, 246, 248, 1)",
      "color-avatar-four-bg-fill": "rgba(81, 192, 255, 1)",
      "color-avatar-four-text-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-avatar-one-bg-fill": "rgba(197, 48, 197, 1)",
      "color-avatar-one-text-on-bg-fill": "rgba(253, 239, 253, 1)",
      "color-avatar-seven-bg-fill": "rgba(148, 116, 255, 1)",
      "color-avatar-seven-text-on-bg-fill": "rgba(248, 247, 255, 1)",
      "color-avatar-six-bg-fill": "rgba(37, 232, 43, 1)",
      "color-avatar-six-text-on-bg-fill": "rgba(3, 61, 5, 1)",
      "color-avatar-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-avatar-three-bg-fill": "rgba(44, 224, 212, 1)",
      "color-avatar-three-text-on-bg-fill": "rgba(3, 60, 57, 1)",
      "color-avatar-two-bg-fill": "rgba(56, 250, 163, 1)",
      "color-avatar-two-text-on-bg-fill": "rgba(12, 81, 50, 1)",
      "color-backdrop-bg": "rgba(0, 0, 0, 0.71)",
      "color-button-gradient-bg-fill": "linear-gradient(180deg, rgba(48, 48, 48, 0) 63.53%, rgba(255, 255, 255, 0.15) 100%)",
      "color-checkbox-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-checkbox-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-input-bg-surface": "rgba(253, 253, 253, 1)",
      "color-input-bg-surface-hover": "rgba(250, 250, 250, 1)",
      "color-input-bg-surface-active": "rgba(247, 247, 247, 1)",
      "color-input-border": "rgba(74, 74, 74, 1)",
      "color-input-border-hover": "rgba(97, 97, 97, 1)",
      "color-input-border-active": "rgba(26, 26, 26, 1)",
      "color-nav-bg": "rgba(235, 235, 235, 1)",
      "color-nav-bg-surface": "rgba(0, 0, 0, 0.02)",
      "color-nav-bg-surface-hover": "rgba(241, 241, 241, 1)",
      "color-nav-bg-surface-active": "rgba(250, 250, 250, 1)",
      "color-nav-bg-surface-selected": "rgba(250, 250, 250, 1)",
      "color-radio-button-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-radio-button-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-video-thumbnail-play-button-bg-fill-hover": "rgba(0, 0, 0, 0.81)",
      "color-video-thumbnail-play-button-bg-fill": "rgba(0, 0, 0, 0.71)",
      "color-video-thumbnail-play-button-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-scrollbar-thumb-bg-hover": "rgba(138, 138, 138, 1)"
    },
    font: {
      "font-family-sans": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "font-family-mono": "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace",
      "font-size-275": "0.6875rem",
      "font-size-300": "0.75rem",
      "font-size-325": "0.8125rem",
      "font-size-350": "0.875rem",
      "font-size-400": "1rem",
      "font-size-450": "1.125rem",
      "font-size-500": "1.25rem",
      "font-size-550": "1.375rem",
      "font-size-600": "1.5rem",
      "font-size-750": "1.875rem",
      "font-size-800": "2rem",
      "font-size-900": "2.25rem",
      "font-size-1000": "2.5rem",
      "font-weight-regular": "450",
      "font-weight-medium": "550",
      "font-weight-semibold": "650",
      "font-weight-bold": "700",
      "font-letter-spacing-densest": "-0.03375rem",
      "font-letter-spacing-denser": "-0.01875rem",
      "font-letter-spacing-dense": "-0.0125rem",
      "font-letter-spacing-normal": "0rem",
      "font-line-height-300": "0.75rem",
      "font-line-height-400": "1rem",
      "font-line-height-500": "1.25rem",
      "font-line-height-600": "1.5rem",
      "font-line-height-700": "1.75rem",
      "font-line-height-800": "2rem",
      "font-line-height-1000": "2.5rem",
      "font-line-height-1200": "3rem"
    },
    height: {
      "height-0": "0rem",
      "height-025": "0.0625rem",
      "height-050": "0.125rem",
      "height-100": "0.25rem",
      "height-150": "0.375rem",
      "height-200": "0.5rem",
      "height-300": "0.75rem",
      "height-400": "1rem",
      "height-500": "1.25rem",
      "height-600": "1.5rem",
      "height-700": "1.75rem",
      "height-800": "2rem",
      "height-900": "2.25rem",
      "height-1000": "2.5rem",
      "height-1200": "3rem",
      "height-1600": "4rem",
      "height-2000": "5rem",
      "height-2400": "6rem",
      "height-2800": "7rem",
      "height-3200": "8rem"
    },
    motion: {
      "motion-duration-0": "0ms",
      "motion-duration-50": "50ms",
      "motion-duration-100": "100ms",
      "motion-duration-150": "150ms",
      "motion-duration-200": "200ms",
      "motion-duration-250": "250ms",
      "motion-duration-300": "300ms",
      "motion-duration-350": "350ms",
      "motion-duration-400": "400ms",
      "motion-duration-450": "450ms",
      "motion-duration-500": "500ms",
      "motion-duration-5000": "5000ms",
      "motion-ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
      "motion-ease-in": "cubic-bezier(0.42, 0, 1, 1)",
      "motion-ease-out": "cubic-bezier(0.19, 0.91, 0.38, 1)",
      "motion-ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
      "motion-linear": "cubic-bezier(0, 0, 1, 1)",
      "motion-keyframes-bounce": "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }",
      "motion-keyframes-fade-in": "{ to { opacity: 1 } }",
      "motion-keyframes-pulse": "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }",
      "motion-keyframes-spin": "{ to { transform: rotate(1turn) } }",
      "motion-keyframes-appear-above": "{ from { transform: translateY(var(--p-space-100)); opacity: 0; } to { transform: none; opacity: 1; } }",
      "motion-keyframes-appear-below": "{ from { transform: translateY(calc(var(--p-space-100) * -1)); opacity: 0; } to { transform: none; opacity: 1; } }"
    },
    shadow: {
      "shadow-0": "none",
      "shadow-100": "0rem 0.0625rem 0rem 0rem rgba(26, 26, 26, 0.07)",
      "shadow-200": "0rem 0.1875rem 0.0625rem -0.0625rem rgba(26, 26, 26, 0.07)",
      "shadow-300": "0rem 0.25rem 0.375rem -0.125rem rgba(26, 26, 26, 0.20)",
      "shadow-400": "0rem 0.5rem 1rem -0.25rem rgba(26, 26, 26, 0.22)",
      "shadow-500": "0rem 0.75rem 1.25rem -0.5rem rgba(26, 26, 26, 0.24)",
      "shadow-600": "0rem 1.25rem 1.25rem -0.5rem rgba(26, 26, 26, 0.28)",
      "shadow-bevel-100": "0rem 0.0625rem 0rem 0rem rgba(26, 26, 26, 0.07), 0rem 0.0625rem 0rem 0rem rgba(208, 208, 208, 0.40) inset, 0.0625rem 0rem 0rem 0rem #CCC inset, -0.0625rem 0rem 0rem 0rem #CCC inset, 0rem -0.0625rem 0rem 0rem #999 inset",
      "shadow-inset-100": "0rem 0.0625rem 0.125rem 0rem rgba(26, 26, 26, 0.15) inset, 0rem 0.0625rem 0.0625rem 0rem rgba(26, 26, 26, 0.15) inset",
      "shadow-inset-200": "0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.20) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset, -0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset",
      "shadow-button": "0rem -0.0625rem 0rem 0rem #b5b5b5 inset, 0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.1) inset, 0rem 0.03125rem 0rem 0.09375rem #FFF inset",
      "shadow-button-hover": "0rem 0.0625rem 0rem 0rem #EBEBEB inset, -0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0rem -0.0625rem 0rem 0rem #CCC inset",
      "shadow-button-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.2) inset",
      "shadow-button-primary": "0rem -0.0625rem 0rem 0.0625rem rgba(0, 0, 0, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(48, 48, 48, 1) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.25) inset;",
      "shadow-button-primary-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.24) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.0625rem 0rem 0rem #000 inset, 0rem -0.0625rem 0rem 0.0625rem #1A1A1A",
      "shadow-button-primary-inset": "0rem 0.1875rem 0rem 0rem rgb(0, 0, 0) inset",
      "shadow-button-primary-critical": "0rem -0.0625rem 0rem 0.0625rem rgba(142, 31, 11, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(181, 38, 11, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.349) inset",
      "shadow-button-primary-critical-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-critical-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-button-primary-success": "0rem -0.0625rem 0rem 0.0625rem rgba(12, 81, 50, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(19, 111, 69, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.251) inset",
      "shadow-button-primary-success-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-success-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-border-inset": "0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.08) inset"
    },
    space: {
      "space-0": "0rem",
      "space-025": "0.0625rem",
      "space-050": "0.125rem",
      "space-100": "0.25rem",
      "space-150": "0.375rem",
      "space-200": "0.5rem",
      "space-300": "0.75rem",
      "space-400": "1rem",
      "space-500": "1.25rem",
      "space-600": "1.5rem",
      "space-800": "2rem",
      "space-1000": "2.5rem",
      "space-1200": "3rem",
      "space-1600": "4rem",
      "space-2000": "5rem",
      "space-2400": "6rem",
      "space-2800": "7rem",
      "space-3200": "8rem",
      "space-button-group-gap": "0.5rem",
      "space-card-gap": "1rem",
      "space-card-padding": "1rem",
      "space-table-cell-padding": "0.375rem"
    },
    text: {
      "text-heading-3xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-3xl-font-size": "2.25rem",
      "text-heading-3xl-font-weight": "700",
      "text-heading-3xl-font-letter-spacing": "-0.03375rem",
      "text-heading-3xl-font-line-height": "3rem",
      "text-heading-2xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-2xl-font-size": "1.875rem",
      "text-heading-2xl-font-weight": "700",
      "text-heading-2xl-font-letter-spacing": "-0.01875rem",
      "text-heading-2xl-font-line-height": "2.5rem",
      "text-heading-xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xl-font-size": "1.5rem",
      "text-heading-xl-font-weight": "700",
      "text-heading-xl-font-letter-spacing": "-0.0125rem",
      "text-heading-xl-font-line-height": "2rem",
      "text-heading-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-lg-font-size": "1.25rem",
      "text-heading-lg-font-weight": "650",
      "text-heading-lg-font-letter-spacing": "-0.0125rem",
      "text-heading-lg-font-line-height": "1.5rem",
      "text-heading-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-md-font-size": "0.875rem",
      "text-heading-md-font-weight": "650",
      "text-heading-md-font-letter-spacing": "0rem",
      "text-heading-md-font-line-height": "1.25rem",
      "text-heading-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-sm-font-size": "0.8125rem",
      "text-heading-sm-font-weight": "650",
      "text-heading-sm-font-letter-spacing": "0rem",
      "text-heading-sm-font-line-height": "1.25rem",
      "text-heading-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xs-font-size": "0.75rem",
      "text-heading-xs-font-weight": "650",
      "text-heading-xs-font-letter-spacing": "0rem",
      "text-heading-xs-font-line-height": "1rem",
      "text-body-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-lg-font-size": "0.875rem",
      "text-body-lg-font-weight": "450",
      "text-body-lg-font-letter-spacing": "0rem",
      "text-body-lg-font-line-height": "1.25rem",
      "text-body-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-md-font-size": "0.8125rem",
      "text-body-md-font-weight": "450",
      "text-body-md-font-letter-spacing": "0rem",
      "text-body-md-font-line-height": "1.25rem",
      "text-body-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-sm-font-size": "0.75rem",
      "text-body-sm-font-weight": "450",
      "text-body-sm-font-letter-spacing": "0rem",
      "text-body-sm-font-line-height": "1rem",
      "text-body-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-xs-font-size": "0.6875rem",
      "text-body-xs-font-weight": "450",
      "text-body-xs-font-letter-spacing": "0rem",
      "text-body-xs-font-line-height": "0.75rem"
    },
    width: {
      "width-0": "0rem",
      "width-025": "0.0625rem",
      "width-050": "0.125rem",
      "width-100": "0.25rem",
      "width-150": "0.375rem",
      "width-200": "0.5rem",
      "width-300": "0.75rem",
      "width-400": "1rem",
      "width-500": "1.25rem",
      "width-600": "1.5rem",
      "width-700": "1.75rem",
      "width-800": "2rem",
      "width-900": "2.25rem",
      "width-1000": "2.5rem",
      "width-1200": "3rem",
      "width-1600": "4rem",
      "width-2000": "5rem",
      "width-2400": "6rem",
      "width-2800": "7rem",
      "width-3200": "8rem"
    },
    zIndex: {
      "z-index-0": "auto",
      "z-index-1": "100",
      "z-index-2": "400",
      "z-index-3": "510",
      "z-index-4": "512",
      "z-index-5": "513",
      "z-index-6": "514",
      "z-index-7": "515",
      "z-index-8": "516",
      "z-index-9": "517",
      "z-index-10": "518",
      "z-index-11": "519",
      "z-index-12": "520"
    }
  },
  "dark-experimental": {
    border: {
      "border-radius-0": "0rem",
      "border-radius-050": "0.125rem",
      "border-radius-100": "0.25rem",
      "border-radius-150": "0.375rem",
      "border-radius-200": "0.5rem",
      "border-radius-300": "0.75rem",
      "border-radius-400": "1rem",
      "border-radius-500": "1.25rem",
      "border-radius-750": "1.875rem",
      "border-radius-full": "624.9375rem",
      "border-width-0": "0rem",
      "border-width-0165": "0.04125rem",
      "border-width-025": "0.0625rem",
      "border-width-050": "0.125rem",
      "border-width-100": "0.25rem"
    },
    breakpoints: {
      "breakpoints-xs": "0rem",
      "breakpoints-sm": "30.625rem",
      "breakpoints-md": "48rem",
      "breakpoints-lg": "65rem",
      "breakpoints-xl": "90rem"
    },
    color: {
      "color-scheme": "dark",
      "color-bg": "rgba(26, 26, 26, 1)",
      "color-bg-inverse": "rgba(26, 26, 26, 1)",
      "color-bg-surface": "rgba(48, 48, 48, 1)",
      "color-bg-surface-hover": "rgba(74, 74, 74, 1)",
      "color-bg-surface-active": "rgba(97, 97, 97, 1)",
      "color-bg-surface-selected": "rgba(97, 97, 97, 1)",
      "color-bg-surface-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-surface-secondary": "rgba(247, 247, 247, 1)",
      "color-bg-surface-secondary-hover": "rgba(74, 74, 74, 1)",
      "color-bg-surface-secondary-active": "rgba(97, 97, 97, 1)",
      "color-bg-surface-secondary-selected": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary": "rgba(243, 243, 243, 1)",
      "color-bg-surface-tertiary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-tertiary-active": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand": "rgba(227, 227, 227, 1)",
      "color-bg-surface-brand-hover": "rgba(235, 235, 235, 1)",
      "color-bg-surface-brand-active": "rgba(241, 241, 241, 1)",
      "color-bg-surface-brand-selected": "rgba(74, 74, 74, 1)",
      "color-bg-surface-info": "rgba(234, 244, 255, 1)",
      "color-bg-surface-info-hover": "rgba(224, 240, 255, 1)",
      "color-bg-surface-info-active": "rgba(202, 230, 255, 1)",
      "color-bg-surface-success": "rgba(205, 254, 225, 1)",
      "color-bg-surface-success-hover": "rgba(180, 254, 210, 1)",
      "color-bg-surface-success-active": "rgba(146, 254, 194, 1)",
      "color-bg-surface-caution": "rgba(255, 248, 219, 1)",
      "color-bg-surface-caution-hover": "rgba(255, 244, 191, 1)",
      "color-bg-surface-caution-active": "rgba(255, 239, 157, 1)",
      "color-bg-surface-warning": "rgba(255, 241, 227, 1)",
      "color-bg-surface-warning-hover": "rgba(255, 235, 213, 1)",
      "color-bg-surface-warning-active": "rgba(255, 228, 198, 1)",
      "color-bg-surface-critical": "rgba(254, 233, 232, 1)",
      "color-bg-surface-critical-hover": "rgba(254, 226, 225, 1)",
      "color-bg-surface-critical-active": "rgba(254, 218, 217, 1)",
      "color-bg-surface-emphasis": "rgba(240, 242, 255, 1)",
      "color-bg-surface-emphasis-hover": "rgba(234, 237, 255, 1)",
      "color-bg-surface-emphasis-active": "rgba(226, 231, 255, 1)",
      "color-bg-surface-magic": "rgba(248, 247, 255, 1)",
      "color-bg-surface-magic-hover": "rgba(243, 241, 255, 1)",
      "color-bg-surface-magic-active": "rgba(233, 229, 255, 1)",
      "color-bg-surface-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-surface-transparent": "rgba(0, 0, 0, 0)",
      "color-bg-fill": "rgba(48, 48, 48, 1)",
      "color-bg-fill-hover": "rgba(74, 74, 74, 1)",
      "color-bg-fill-active": "rgba(97, 97, 97, 1)",
      "color-bg-fill-selected": "rgba(97, 97, 97, 1)",
      "color-bg-fill-disabled": "rgba(0, 0, 0, 0.05)",
      "color-bg-fill-secondary": "rgba(241, 241, 241, 1)",
      "color-bg-fill-secondary-hover": "rgba(235, 235, 235, 1)",
      "color-bg-fill-secondary-active": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary": "rgba(227, 227, 227, 1)",
      "color-bg-fill-tertiary-hover": "rgba(212, 212, 212, 1)",
      "color-bg-fill-tertiary-active": "rgba(204, 204, 204, 1)",
      "color-bg-fill-brand": "rgba(255, 255, 255, 1)",
      "color-bg-fill-brand-hover": "rgba(243, 243, 243, 1)",
      "color-bg-fill-brand-active": "rgba(247, 247, 247, 1)",
      "color-bg-fill-brand-selected": "rgba(212, 212, 212, 1)",
      "color-bg-fill-brand-disabled": "rgba(0, 0, 0, 0.17)",
      "color-bg-fill-info": "rgba(145, 208, 255, 1)",
      "color-bg-fill-info-hover": "rgba(81, 192, 255, 1)",
      "color-bg-fill-info-active": "rgba(0, 148, 213, 1)",
      "color-bg-fill-info-secondary": "rgba(213, 235, 255, 1)",
      "color-bg-fill-success": "rgba(41, 132, 90, 1)",
      "color-bg-fill-success-hover": "rgba(19, 111, 69, 1)",
      "color-bg-fill-success-active": "rgba(12, 81, 50, 1)",
      "color-bg-fill-success-secondary": "rgba(180, 254, 210, 1)",
      "color-bg-fill-warning": "rgba(255, 184, 0, 1)",
      "color-bg-fill-warning-hover": "rgba(229, 165, 0, 1)",
      "color-bg-fill-warning-active": "rgba(178, 132, 0, 1)",
      "color-bg-fill-warning-secondary": "rgba(255, 214, 164, 1)",
      "color-bg-fill-caution": "rgba(255, 230, 0, 1)",
      "color-bg-fill-caution-hover": "rgba(234, 211, 0, 1)",
      "color-bg-fill-caution-active": "rgba(225, 203, 0, 1)",
      "color-bg-fill-caution-secondary": "rgba(255, 235, 120, 1)",
      "color-bg-fill-critical": "rgba(229, 28, 0, 1)",
      "color-bg-fill-critical-hover": "rgba(181, 38, 11, 1)",
      "color-bg-fill-critical-active": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-selected": "rgba(142, 31, 11, 1)",
      "color-bg-fill-critical-secondary": "rgba(254, 211, 209, 1)",
      "color-bg-fill-emphasis": "rgba(0, 91, 211, 1)",
      "color-bg-fill-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-bg-fill-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-bg-fill-magic": "rgba(128, 81, 255, 1)",
      "color-bg-fill-magic-secondary": "rgba(233, 229, 255, 1)",
      "color-bg-fill-magic-secondary-hover": "rgba(228, 222, 255, 1)",
      "color-bg-fill-magic-secondary-active": "rgba(223, 217, 255, 1)",
      "color-bg-fill-inverse": "rgba(48, 48, 48, 1)",
      "color-bg-fill-inverse-hover": "rgba(74, 74, 74, 1)",
      "color-bg-fill-inverse-active": "rgba(97, 97, 97, 1)",
      "color-bg-fill-transparent": "rgba(255, 255, 255, 0.11)",
      "color-bg-fill-transparent-hover": "rgba(255, 255, 255, 0.17)",
      "color-bg-fill-transparent-active": "rgba(255, 255, 255, 0.20)",
      "color-bg-fill-transparent-selected": "rgba(255, 255, 255, 0.28)",
      "color-bg-fill-transparent-secondary": "rgba(0, 0, 0, 0.06)",
      "color-bg-fill-transparent-secondary-hover": "rgba(0, 0, 0, 0.08)",
      "color-bg-fill-transparent-secondary-active": "rgba(0, 0, 0, 0.11)",
      "color-text": "rgba(227, 227, 227, 1)",
      "color-text-secondary": "rgba(181, 181, 181, 1)",
      "color-text-disabled": "rgba(181, 181, 181, 1)",
      "color-text-link": "rgba(0, 91, 211, 1)",
      "color-text-link-hover": "rgba(0, 66, 153, 1)",
      "color-text-link-active": "rgba(0, 46, 106, 1)",
      "color-text-brand": "rgba(74, 74, 74, 1)",
      "color-text-brand-hover": "rgba(48, 48, 48, 1)",
      "color-text-brand-on-bg-fill": "rgba(48, 48, 48, 1)",
      "color-text-brand-on-bg-fill-hover": "rgba(227, 227, 227, 1)",
      "color-text-brand-on-bg-fill-active": "rgba(204, 204, 204, 1)",
      "color-text-brand-on-bg-fill-disabled": "rgba(255, 255, 255, 1)",
      "color-text-info": "rgba(0, 58, 90, 1)",
      "color-text-info-hover": "rgba(0, 58, 90, 1)",
      "color-text-info-active": "rgba(0, 33, 51, 1)",
      "color-text-info-secondary": "rgba(0, 124, 180, 1)",
      "color-text-info-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-text-success": "rgba(12, 81, 50, 1)",
      "color-text-success-hover": "rgba(8, 61, 37, 1)",
      "color-text-success-active": "rgba(9, 42, 27, 1)",
      "color-text-success-secondary": "rgba(41, 132, 90, 1)",
      "color-text-success-on-bg-fill": "rgba(248, 255, 251, 1)",
      "color-text-caution": "rgba(79, 71, 0, 1)",
      "color-text-caution-hover": "rgba(51, 46, 0, 1)",
      "color-text-caution-active": "rgba(31, 28, 0, 1)",
      "color-text-caution-secondary": "rgba(130, 117, 0, 1)",
      "color-text-caution-on-bg-fill": "rgba(51, 46, 0, 1)",
      "color-text-warning": "rgba(94, 66, 0, 1)",
      "color-text-warning-hover": "rgba(65, 45, 0, 1)",
      "color-text-warning-active": "rgba(37, 26, 0, 1)",
      "color-text-warning-secondary": "rgba(149, 111, 0, 1)",
      "color-text-warning-on-bg-fill": "rgba(37, 26, 0, 1)",
      "color-text-critical": "rgba(142, 31, 11, 1)",
      "color-text-critical-hover": "rgba(95, 21, 7, 1)",
      "color-text-critical-active": "rgba(47, 10, 4, 1)",
      "color-text-critical-secondary": "rgba(229, 28, 0, 1)",
      "color-text-critical-on-bg-fill": "rgba(255, 251, 251, 1)",
      "color-text-emphasis": "rgba(0, 91, 211, 1)",
      "color-text-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-text-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-text-emphasis-on-bg-fill": "rgba(252, 253, 255, 1)",
      "color-text-emphasis-on-bg-fill-hover": "rgba(226, 231, 255, 1)",
      "color-text-emphasis-on-bg-fill-active": "rgba(213, 220, 255, 1)",
      "color-text-magic": "rgba(87, 0, 209, 1)",
      "color-text-magic-secondary": "rgba(113, 38, 255, 1)",
      "color-text-magic-on-bg-fill": "rgba(253, 253, 255, 1)",
      "color-text-inverse": "rgba(227, 227, 227, 1)",
      "color-text-inverse-secondary": "rgba(181, 181, 181, 1)",
      "color-text-link-inverse": "rgba(197, 208, 255, 1)",
      "color-border": "rgba(227, 227, 227, 1)",
      "color-border-hover": "rgba(204, 204, 204, 1)",
      "color-border-disabled": "rgba(235, 235, 235, 1)",
      "color-border-secondary": "rgba(97, 97, 97, 1)",
      "color-border-tertiary": "rgba(204, 204, 204, 1)",
      "color-border-focus": "rgba(0, 91, 211, 1)",
      "color-border-brand": "rgba(227, 227, 227, 1)",
      "color-border-info": "rgba(168, 216, 255, 1)",
      "color-border-success": "rgba(146, 254, 194, 1)",
      "color-border-caution": "rgba(255, 235, 120, 1)",
      "color-border-warning": "rgba(255, 200, 121, 1)",
      "color-border-critical": "rgba(254, 195, 193, 1)",
      "color-border-critical-secondary": "rgba(142, 31, 11, 1)",
      "color-border-emphasis": "rgba(0, 91, 211, 1)",
      "color-border-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-border-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-border-magic": "rgba(228, 222, 255, 1)",
      "color-border-magic-secondary": "rgba(148, 116, 255, 1)",
      "color-border-magic-secondary-hover": "rgba(128, 81, 255, 1)",
      "color-border-inverse": "rgba(97, 97, 97, 1)",
      "color-border-inverse-hover": "rgba(204, 204, 204, 1)",
      "color-border-inverse-active": "rgba(227, 227, 227, 1)",
      "color-tooltip-tail-down-border-experimental": "rgba(60, 60, 60, 1)",
      "color-tooltip-tail-up-border-experimental": "rgba(71, 71, 71, 1)",
      "color-border-gradient-experimental": "linear-gradient(to bottom, rgba(255, 255, 255, 0.17), rgba(255, 255, 255, 0.03))",
      "color-border-gradient-hover-experimental": "linear-gradient(to bottom, rgba(255, 255, 255, 0.17), rgba(255, 255, 255, 0.03))",
      "color-border-gradient-selected-experimental": "linear-gradient(to bottom, rgba(0, 0, 0, 0.20), rgba(255, 255, 255, 0.20))",
      "color-border-gradient-active-experimental": "linear-gradient(to bottom, rgba(255, 255, 255, 0.20), rgba(255, 255, 255, 0.03))",
      "color-icon": "rgba(227, 227, 227, 1)",
      "color-icon-hover": "rgba(48, 48, 48, 1)",
      "color-icon-active": "rgba(26, 26, 26, 1)",
      "color-icon-disabled": "rgba(204, 204, 204, 1)",
      "color-icon-secondary": "rgba(138, 138, 138, 1)",
      "color-icon-secondary-hover": "rgba(97, 97, 97, 1)",
      "color-icon-secondary-active": "rgba(74, 74, 74, 1)",
      "color-icon-brand": "rgba(26, 26, 26, 1)",
      "color-icon-info": "rgba(0, 148, 213, 1)",
      "color-icon-success": "rgba(41, 132, 90, 1)",
      "color-icon-caution": "rgba(153, 138, 0, 1)",
      "color-icon-warning": "rgba(178, 132, 0, 1)",
      "color-icon-critical": "rgba(239, 77, 47, 1)",
      "color-icon-emphasis": "rgba(0, 91, 211, 1)",
      "color-icon-emphasis-hover": "rgba(0, 66, 153, 1)",
      "color-icon-emphasis-active": "rgba(0, 46, 106, 1)",
      "color-icon-magic": "rgba(128, 81, 255, 1)",
      "color-icon-inverse": "rgba(227, 227, 227, 1)",
      "color-avatar-bg-fill": "rgba(181, 181, 181, 1)",
      "color-avatar-five-bg-fill": "rgba(253, 75, 146, 1)",
      "color-avatar-five-text-on-bg-fill": "rgba(255, 246, 248, 1)",
      "color-avatar-four-bg-fill": "rgba(81, 192, 255, 1)",
      "color-avatar-four-text-on-bg-fill": "rgba(0, 33, 51, 1)",
      "color-avatar-one-bg-fill": "rgba(197, 48, 197, 1)",
      "color-avatar-one-text-on-bg-fill": "rgba(253, 239, 253, 1)",
      "color-avatar-seven-bg-fill": "rgba(148, 116, 255, 1)",
      "color-avatar-seven-text-on-bg-fill": "rgba(248, 247, 255, 1)",
      "color-avatar-six-bg-fill": "rgba(37, 232, 43, 1)",
      "color-avatar-six-text-on-bg-fill": "rgba(3, 61, 5, 1)",
      "color-avatar-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-avatar-three-bg-fill": "rgba(44, 224, 212, 1)",
      "color-avatar-three-text-on-bg-fill": "rgba(3, 60, 57, 1)",
      "color-avatar-two-bg-fill": "rgba(56, 250, 163, 1)",
      "color-avatar-two-text-on-bg-fill": "rgba(12, 81, 50, 1)",
      "color-backdrop-bg": "rgba(0, 0, 0, 0.71)",
      "color-button-gradient-bg-fill": "linear-gradient(180deg, rgba(48, 48, 48, 0) 63.53%, rgba(255, 255, 255, 0.15) 100%)",
      "color-checkbox-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-checkbox-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-input-bg-surface": "rgba(253, 253, 253, 1)",
      "color-input-bg-surface-hover": "rgba(250, 250, 250, 1)",
      "color-input-bg-surface-active": "rgba(247, 247, 247, 1)",
      "color-input-border": "rgba(138, 138, 138, 1)",
      "color-input-border-hover": "rgba(97, 97, 97, 1)",
      "color-input-border-active": "rgba(26, 26, 26, 1)",
      "color-nav-bg": "rgba(235, 235, 235, 1)",
      "color-nav-bg-surface": "rgba(0, 0, 0, 0.02)",
      "color-nav-bg-surface-hover": "rgba(241, 241, 241, 1)",
      "color-nav-bg-surface-active": "rgba(250, 250, 250, 1)",
      "color-nav-bg-surface-selected": "rgba(250, 250, 250, 1)",
      "color-radio-button-bg-surface-disabled": "rgba(0, 0, 0, 0.08)",
      "color-radio-button-icon-disabled": "rgba(255, 255, 255, 1)",
      "color-video-thumbnail-play-button-bg-fill-hover": "rgba(0, 0, 0, 0.81)",
      "color-video-thumbnail-play-button-bg-fill": "rgba(0, 0, 0, 0.71)",
      "color-video-thumbnail-play-button-text-on-bg-fill": "rgba(255, 255, 255, 1)",
      "color-scrollbar-thumb-bg-hover": "rgba(138, 138, 138, 1)"
    },
    font: {
      "font-family-sans": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "font-family-mono": "ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace",
      "font-size-275": "0.6875rem",
      "font-size-300": "0.75rem",
      "font-size-325": "0.8125rem",
      "font-size-350": "0.875rem",
      "font-size-400": "1rem",
      "font-size-450": "1.125rem",
      "font-size-500": "1.25rem",
      "font-size-550": "1.375rem",
      "font-size-600": "1.5rem",
      "font-size-750": "1.875rem",
      "font-size-800": "2rem",
      "font-size-900": "2.25rem",
      "font-size-1000": "2.5rem",
      "font-weight-regular": "450",
      "font-weight-medium": "550",
      "font-weight-semibold": "650",
      "font-weight-bold": "700",
      "font-letter-spacing-densest": "-0.03375rem",
      "font-letter-spacing-denser": "-0.01875rem",
      "font-letter-spacing-dense": "-0.0125rem",
      "font-letter-spacing-normal": "0rem",
      "font-line-height-300": "0.75rem",
      "font-line-height-400": "1rem",
      "font-line-height-500": "1.25rem",
      "font-line-height-600": "1.5rem",
      "font-line-height-700": "1.75rem",
      "font-line-height-800": "2rem",
      "font-line-height-1000": "2.5rem",
      "font-line-height-1200": "3rem"
    },
    height: {
      "height-0": "0rem",
      "height-025": "0.0625rem",
      "height-050": "0.125rem",
      "height-100": "0.25rem",
      "height-150": "0.375rem",
      "height-200": "0.5rem",
      "height-300": "0.75rem",
      "height-400": "1rem",
      "height-500": "1.25rem",
      "height-600": "1.5rem",
      "height-700": "1.75rem",
      "height-800": "2rem",
      "height-900": "2.25rem",
      "height-1000": "2.5rem",
      "height-1200": "3rem",
      "height-1600": "4rem",
      "height-2000": "5rem",
      "height-2400": "6rem",
      "height-2800": "7rem",
      "height-3200": "8rem"
    },
    motion: {
      "motion-duration-0": "0ms",
      "motion-duration-50": "50ms",
      "motion-duration-100": "100ms",
      "motion-duration-150": "150ms",
      "motion-duration-200": "200ms",
      "motion-duration-250": "250ms",
      "motion-duration-300": "300ms",
      "motion-duration-350": "350ms",
      "motion-duration-400": "400ms",
      "motion-duration-450": "450ms",
      "motion-duration-500": "500ms",
      "motion-duration-5000": "5000ms",
      "motion-ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
      "motion-ease-in": "cubic-bezier(0.42, 0, 1, 1)",
      "motion-ease-out": "cubic-bezier(0.19, 0.91, 0.38, 1)",
      "motion-ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
      "motion-linear": "cubic-bezier(0, 0, 1, 1)",
      "motion-keyframes-bounce": "{ from, 65%, 85% { transform: scale(1) } 75% { transform: scale(0.85) } 82.5% { transform: scale(1.05) } }",
      "motion-keyframes-fade-in": "{ to { opacity: 1 } }",
      "motion-keyframes-pulse": "{ from, 75% { transform: scale(0.85); opacity: 1; } to { transform: scale(2.5); opacity: 0; } }",
      "motion-keyframes-spin": "{ to { transform: rotate(1turn) } }",
      "motion-keyframes-appear-above": "{ from { transform: translateY(var(--p-space-100)); opacity: 0; } to { transform: none; opacity: 1; } }",
      "motion-keyframes-appear-below": "{ from { transform: translateY(calc(var(--p-space-100) * -1)); opacity: 0; } to { transform: none; opacity: 1; } }"
    },
    shadow: {
      "shadow-0": "none",
      "shadow-100": "0rem 0.0625rem 0rem 0rem rgba(26, 26, 26, 0.07)",
      "shadow-200": "0rem 0.1875rem 0.0625rem -0.0625rem rgba(26, 26, 26, 0.07)",
      "shadow-300": "0rem 0.25rem 0.375rem -0.125rem rgba(26, 26, 26, 0.20)",
      "shadow-400": "0rem 0.5rem 1rem -0.25rem rgba(26, 26, 26, 0.22)",
      "shadow-500": "0rem 0.75rem 1.25rem -0.5rem rgba(26, 26, 26, 0.24)",
      "shadow-600": "0rem 1.25rem 1.25rem -0.5rem rgba(26, 26, 26, 0.28)",
      "shadow-bevel-100": "0.0625rem 0rem 0rem 0rem rgba(204, 204, 204, 0.08) inset, -0.0625rem 0rem 0rem 0rem rgba(204, 204, 204, 0.08) inset, 0rem -0.0625rem 0rem 0rem rgba(204, 204, 204, 0.08) inset, 0rem 0.0625rem 0rem 0rem rgba(204, 204, 204, 0.16) inset",
      "shadow-inset-100": "0rem 0.0625rem 0.125rem 0rem rgba(26, 26, 26, 0.15) inset, 0rem 0.0625rem 0.0625rem 0rem rgba(26, 26, 26, 0.15) inset",
      "shadow-inset-200": "0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.20) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset, -0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.12) inset",
      "shadow-button": "0rem -0.0625rem 0rem 0rem #b5b5b5 inset, 0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.1) inset, 0rem 0.03125rem 0rem 0.09375rem #FFF inset",
      "shadow-button-hover": "0rem 0.0625rem 0rem 0rem #EBEBEB inset, -0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0.0625rem 0rem 0rem 0rem #EBEBEB inset, 0rem -0.0625rem 0rem 0rem #CCC inset",
      "shadow-button-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(26, 26, 26, 0.122) inset, 0rem 0.125rem 0.0625rem 0rem rgba(26, 26, 26, 0.2) inset",
      "shadow-button-primary": "0rem -0.0625rem 0rem 0.0625rem rgba(0, 0, 0, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(48, 48, 48, 1) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.25) inset;",
      "shadow-button-primary-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.24) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.0625rem 0rem 0rem #000 inset, 0rem -0.0625rem 0rem 0.0625rem #1A1A1A",
      "shadow-button-primary-inset": "0rem 0.1875rem 0rem 0rem rgb(0, 0, 0) inset",
      "shadow-button-primary-critical": "0rem -0.0625rem 0rem 0.0625rem rgba(142, 31, 11, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(181, 38, 11, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.349) inset",
      "shadow-button-primary-critical-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-critical-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-button-primary-success": "0rem -0.0625rem 0rem 0.0625rem rgba(12, 81, 50, 0.8) inset, 0rem 0rem 0rem 0.0625rem rgba(19, 111, 69, 0.8) inset, 0rem 0.03125rem 0rem 0.09375rem rgba(255, 255, 255, 0.251) inset",
      "shadow-button-primary-success-hover": "0rem 0.0625rem 0rem 0rem rgba(255, 255, 255, 0.48) inset, 0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, -0.0625rem 0rem 0rem 0rem rgba(255, 255, 255, 0.20) inset, 0rem -0.09375rem 0rem 0rem rgba(0, 0, 0, 0.25) inset",
      "shadow-button-primary-success-inset": "-0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0.0625rem 0rem 0.0625rem 0rem rgba(0, 0, 0, 0.2) inset, 0rem 0.125rem 0rem 0rem rgba(0, 0, 0, 0.6) inset",
      "shadow-border-inset": "0rem 0rem 0rem 0.0625rem rgba(0, 0, 0, 0.08) inset"
    },
    space: {
      "space-0": "0rem",
      "space-025": "0.0625rem",
      "space-050": "0.125rem",
      "space-100": "0.25rem",
      "space-150": "0.375rem",
      "space-200": "0.5rem",
      "space-300": "0.75rem",
      "space-400": "1rem",
      "space-500": "1.25rem",
      "space-600": "1.5rem",
      "space-800": "2rem",
      "space-1000": "2.5rem",
      "space-1200": "3rem",
      "space-1600": "4rem",
      "space-2000": "5rem",
      "space-2400": "6rem",
      "space-2800": "7rem",
      "space-3200": "8rem",
      "space-button-group-gap": "0.5rem",
      "space-card-gap": "1rem",
      "space-card-padding": "1rem",
      "space-table-cell-padding": "0.375rem"
    },
    text: {
      "text-heading-3xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-3xl-font-size": "2.25rem",
      "text-heading-3xl-font-weight": "700",
      "text-heading-3xl-font-letter-spacing": "-0.03375rem",
      "text-heading-3xl-font-line-height": "3rem",
      "text-heading-2xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-2xl-font-size": "1.875rem",
      "text-heading-2xl-font-weight": "700",
      "text-heading-2xl-font-letter-spacing": "-0.01875rem",
      "text-heading-2xl-font-line-height": "2.5rem",
      "text-heading-xl-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xl-font-size": "1.5rem",
      "text-heading-xl-font-weight": "700",
      "text-heading-xl-font-letter-spacing": "-0.0125rem",
      "text-heading-xl-font-line-height": "2rem",
      "text-heading-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-lg-font-size": "1.25rem",
      "text-heading-lg-font-weight": "650",
      "text-heading-lg-font-letter-spacing": "-0.0125rem",
      "text-heading-lg-font-line-height": "1.5rem",
      "text-heading-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-md-font-size": "0.875rem",
      "text-heading-md-font-weight": "650",
      "text-heading-md-font-letter-spacing": "0rem",
      "text-heading-md-font-line-height": "1.25rem",
      "text-heading-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-sm-font-size": "0.8125rem",
      "text-heading-sm-font-weight": "650",
      "text-heading-sm-font-letter-spacing": "0rem",
      "text-heading-sm-font-line-height": "1.25rem",
      "text-heading-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-heading-xs-font-size": "0.75rem",
      "text-heading-xs-font-weight": "650",
      "text-heading-xs-font-letter-spacing": "0rem",
      "text-heading-xs-font-line-height": "1rem",
      "text-body-lg-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-lg-font-size": "0.875rem",
      "text-body-lg-font-weight": "450",
      "text-body-lg-font-letter-spacing": "0rem",
      "text-body-lg-font-line-height": "1.25rem",
      "text-body-md-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-md-font-size": "0.8125rem",
      "text-body-md-font-weight": "450",
      "text-body-md-font-letter-spacing": "0rem",
      "text-body-md-font-line-height": "1.25rem",
      "text-body-sm-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-sm-font-size": "0.75rem",
      "text-body-sm-font-weight": "450",
      "text-body-sm-font-letter-spacing": "0rem",
      "text-body-sm-font-line-height": "1rem",
      "text-body-xs-font-family": "'Inter', -apple-system, BlinkMacSystemFont, 'San Francisco', 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif",
      "text-body-xs-font-size": "0.6875rem",
      "text-body-xs-font-weight": "450",
      "text-body-xs-font-letter-spacing": "0rem",
      "text-body-xs-font-line-height": "0.75rem"
    },
    width: {
      "width-0": "0rem",
      "width-025": "0.0625rem",
      "width-050": "0.125rem",
      "width-100": "0.25rem",
      "width-150": "0.375rem",
      "width-200": "0.5rem",
      "width-300": "0.75rem",
      "width-400": "1rem",
      "width-500": "1.25rem",
      "width-600": "1.5rem",
      "width-700": "1.75rem",
      "width-800": "2rem",
      "width-900": "2.25rem",
      "width-1000": "2.5rem",
      "width-1200": "3rem",
      "width-1600": "4rem",
      "width-2000": "5rem",
      "width-2400": "6rem",
      "width-2800": "7rem",
      "width-3200": "8rem"
    },
    zIndex: {
      "z-index-0": "auto",
      "z-index-1": "100",
      "z-index-2": "400",
      "z-index-3": "510",
      "z-index-4": "512",
      "z-index-5": "513",
      "z-index-6": "514",
      "z-index-7": "515",
      "z-index-8": "516",
      "z-index-9": "517",
      "z-index-10": "518",
      "z-index-11": "519",
      "z-index-12": "520"
    }
  }
}, themeDefault = themes[themeNameDefault], isTokenName = createIsTokenName(themes[themeNameDefault]);

// node_modules/@shopify/polaris/build/esm/utilities/use-theme.js
var import_react2 = __toESM(require_react());
var ThemeContext = /* @__PURE__ */ (0, import_react2.createContext)(null), ThemeNameContext = /* @__PURE__ */ (0, import_react2.createContext)(null);
function getTheme(themeName) {
  return themes[themeName];
}
function useTheme() {
  let theme = (0, import_react2.useContext)(ThemeContext);
  if (!theme)
    throw new Error("No theme was provided. Your application must be wrapped in an <AppProvider> or <ThemeProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.");
  return theme;
}
function useThemeName() {
  let themeName = (0, import_react2.useContext)(ThemeNameContext);
  if (!themeName)
    throw new Error("No themeName was provided. Your application must be wrapped in an <AppProvider> or <ThemeProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.");
  return themeName;
}
function UseTheme(props) {
  let theme = useTheme();
  return props.children(theme);
}

// node_modules/@shopify/polaris/build/esm/utilities/is-object.js
function isObject(value) {
  let type = typeof value;
  return value != null && (type === "object" || type === "function");
}

// node_modules/@shopify/polaris/build/esm/utilities/css.js
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
function variationName(name, value) {
  return `${name}${value.charAt(0).toUpperCase()}${value.slice(1)}`;
}
function sanitizeCustomProperties(styles52) {
  let nonNullValues = Object.entries(styles52).filter(([_, value]) => value != null);
  return nonNullValues.length ? Object.fromEntries(nonNullValues) : void 0;
}
function getResponsiveProps(componentName, componentProp, tokenSubgroup, responsiveProp) {
  if (!responsiveProp)
    return {};
  let result;
  return isObject(responsiveProp) ? result = Object.fromEntries(Object.entries(responsiveProp).map(([breakpointAlias, aliasOrScale]) => [breakpointAlias, `var(--p-${tokenSubgroup}-${aliasOrScale})`])) : result = {
    [breakpointsAliases[0]]: `var(--p-${tokenSubgroup}-${responsiveProp})`
  }, Object.fromEntries(Object.entries(result).map(([breakpointAlias, value]) => [`--pc-${componentName}-${componentProp}-${breakpointAlias}`, value]));
}
function getResponsiveValue(componentName, componentProp, responsiveProp) {
  return responsiveProp ? isObject(responsiveProp) ? Object.fromEntries(Object.entries(responsiveProp).map(([breakpointAlias, responsiveValue]) => [`--pc-${componentName}-${componentProp}-${breakpointAlias}`, responsiveValue])) : {
    [`--pc-${componentName}-${componentProp}-${breakpointsAliases[0]}`]: responsiveProp
  } : {};
}

// node_modules/@shopify/polaris/build/esm/components/ThemeProvider/ThemeProvider.css.js
var styles = {
  themeContainer: "Polaris-ThemeProvider--themeContainer"
};

// node_modules/@shopify/polaris/build/esm/components/ThemeProvider/ThemeProvider.js
var themeNamesLocal = ["light", "dark-experimental"], isThemeNameLocal = (name) => themeNamesLocal.includes(name);
function ThemeProvider(props) {
  let {
    as: ThemeContainer = "div",
    children,
    className,
    theme: themeName = themeNameDefault
  } = props;
  return /* @__PURE__ */ import_react3.default.createElement(ThemeNameContext.Provider, {
    value: themeName
  }, /* @__PURE__ */ import_react3.default.createElement(ThemeContext.Provider, {
    value: getTheme(themeName)
  }, /* @__PURE__ */ import_react3.default.createElement(ThemeContainer, {
    "data-portal-id": props["data-portal-id"],
    className: classNames(createThemeClassName(themeName), styles.themeContainer, className)
  }, children)));
}

// node_modules/@shopify/polaris/build/esm/utilities/within-content-context.js
var import_react4 = __toESM(require_react()), WithinContentContext = /* @__PURE__ */ (0, import_react4.createContext)(!1);

// node_modules/@shopify/polaris/build/esm/utilities/use-event-listener.js
var import_react6 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-isomorphic-layout-effect.js
var import_react5 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/target.js
var isServer = typeof window > "u" || typeof document > "u";

// node_modules/@shopify/polaris/build/esm/utilities/use-isomorphic-layout-effect.js
var useIsomorphicLayoutEffect2 = isServer ? import_react5.useEffect : import_react5.useLayoutEffect;

// node_modules/@shopify/polaris/build/esm/utilities/use-event-listener.js
function useEventListener(eventName, handler, target, options) {
  let handlerRef = (0, import_react6.useRef)(handler), optionsRef = (0, import_react6.useRef)(options);
  useIsomorphicLayoutEffect2(() => {
    handlerRef.current = handler;
  }, [handler]), useIsomorphicLayoutEffect2(() => {
    optionsRef.current = options;
  }, [options]), (0, import_react6.useEffect)(() => {
    if (!(typeof eventName == "string" && target !== null))
      return;
    let targetElement;
    if (typeof target > "u")
      targetElement = window;
    else if ("current" in target) {
      if (target.current === null)
        return;
      targetElement = target.current;
    } else
      targetElement = target;
    let eventOptions = optionsRef.current, eventListener = (event) => handlerRef.current(event);
    return targetElement.addEventListener(eventName, eventListener, eventOptions), () => {
      targetElement.removeEventListener(eventName, eventListener, eventOptions);
    };
  }, [eventName, target]);
}

// node_modules/@shopify/polaris/build/esm/utilities/breakpoints.js
var import_react7 = __toESM(require_react());
var Breakpoints = {
  // TODO: Update to smDown
  navigationBarCollapsed: "767.95px",
  // TODO: Update to lgDown
  stackedContent: "1039.95px"
}, noWindowMatches = {
  media: "",
  addListener: noop,
  removeListener: noop,
  matches: !1,
  onchange: noop,
  addEventListener: noop,
  removeEventListener: noop,
  dispatchEvent: (_) => !0
};
function noop() {
}
function navigationBarCollapsed() {
  return typeof window > "u" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.navigationBarCollapsed})`);
}
function stackedContent() {
  return typeof window > "u" ? noWindowMatches : window.matchMedia(`(max-width: ${Breakpoints.stackedContent})`);
}
var breakpointsQueryEntries = getBreakpointsQueryEntries(themeDefault.breakpoints);
function getMatches(defaults, forceDefaults) {
  return Object.fromEntries(!isServer && !forceDefaults ? breakpointsQueryEntries.map(([directionAlias, query]) => [directionAlias, window.matchMedia(query).matches]) : typeof defaults == "object" && defaults !== null ? breakpointsQueryEntries.map(([directionAlias]) => [directionAlias, defaults[directionAlias] ?? !1]) : breakpointsQueryEntries.map(([directionAlias]) => [directionAlias, defaults ?? !1]));
}
function useBreakpoints(options) {
  let [breakpoints2, setBreakpoints] = (0, import_react7.useState)(getMatches(options?.defaults, !0));
  return useIsomorphicLayoutEffect2(() => {
    let mediaQueryLists = breakpointsQueryEntries.map(([_, query]) => window.matchMedia(query)), handler = () => setBreakpoints(getMatches());
    return mediaQueryLists.forEach((mql) => {
      mql.addListener ? mql.addListener(handler) : mql.addEventListener("change", handler);
    }), handler(), () => {
      mediaQueryLists.forEach((mql) => {
        mql.removeListener ? mql.removeListener(handler) : mql.removeEventListener("change", handler);
      });
    };
  }, []), breakpoints2;
}
function getBreakpointsQueryEntries(breakpoints2) {
  return Object.entries(getMediaConditions(breakpoints2)).map(([breakpointsToken, mediaConditions]) => Object.entries(mediaConditions).map(([direction, mediaCondition]) => [`${breakpointsToken.split("-")[1]}${capitalize(direction)}`, mediaCondition])).flat();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// node_modules/@shopify/polaris/build/esm/components/AppProvider/AppProvider.js
var import_react24 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/debounce.js
function debounce(func, waitArg, options) {
  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0, useRAF = !waitArg && waitArg !== 0;
  if (typeof func != "function")
    throw new TypeError("Expected a function");
  let wait = waitArg || 0;
  typeof options == "object" && (leading = Boolean(options.leading), maxing = "maxWait" in options, maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : void 0, trailing = "trailing" in options ? Boolean(options.trailing) : trailing);
  function invokeFunc(time) {
    let args = lastArgs, thisArg = lastThis;
    return lastArgs = void 0, lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args), result;
  }
  function startTimer(pendingFunc, wait2) {
    return useRAF ? (cancelAnimationFrame(timerId), requestAnimationFrame(pendingFunc)) : setTimeout(pendingFunc, wait2);
  }
  function cancelTimer(id) {
    if (useRAF)
      return cancelAnimationFrame(id);
    clearTimeout(id);
  }
  function leadingEdge(time) {
    return lastInvokeTime = time, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    let timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    let timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    let time = Date.now();
    if (shouldInvoke(time))
      return trailingEdge(time);
    timerId = startTimer(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result);
  }
  function cancel2() {
    timerId !== void 0 && cancelTimer(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(Date.now());
  }
  function pending() {
    return timerId !== void 0;
  }
  function debounced(...args) {
    let time = Date.now(), isInvoking = shouldInvoke(time);
    if (lastArgs = args, lastThis = this, lastCallTime = time, isInvoking) {
      if (timerId === void 0)
        return leadingEdge(lastCallTime);
      if (maxing)
        return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
    }
    return timerId === void 0 && (timerId = startTimer(timerExpired, wait)), result;
  }
  return debounced.cancel = cancel2, debounced.flush = flush, debounced.pending = pending, debounced;
}

// node_modules/@shopify/polaris/build/esm/utilities/geometry.js
var Rect = class {
  static get zero() {
    return new Rect();
  }
  constructor({
    top = 0,
    left = 0,
    width: width2 = 0,
    height: height2 = 0
  } = {}) {
    this.top = top, this.left = left, this.width = width2, this.height = height2;
  }
  get center() {
    return {
      x: this.left + this.width / 2,
      y: this.top + this.height / 2
    };
  }
};
function getRectForNode(node) {
  if (!(node instanceof Element))
    return new Rect({
      width: window.innerWidth,
      height: window.innerHeight
    });
  let rect = node.getBoundingClientRect();
  return new Rect({
    top: rect.top,
    left: rect.left,
    width: rect.width,
    height: rect.height
  });
}

// node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js
var SIXTY_FPS = 1e3 / 60, StickyManager = class {
  constructor(container) {
    this.stickyItems = [], this.stuckItems = [], this.container = null, this.topBarOffset = 0, this.handleResize = debounce(() => {
      this.manageStickyItems();
    }, SIXTY_FPS, {
      leading: !0,
      trailing: !0,
      maxWait: SIXTY_FPS
    }), this.handleScroll = debounce(() => {
      this.manageStickyItems();
    }, SIXTY_FPS, {
      leading: !0,
      trailing: !0,
      maxWait: SIXTY_FPS
    }), container && this.setContainer(container);
  }
  registerStickyItem(stickyItem) {
    this.stickyItems.push(stickyItem);
  }
  unregisterStickyItem(nodeToRemove) {
    let nodeIndex = this.stickyItems.findIndex(({
      stickyNode
    }) => nodeToRemove === stickyNode);
    this.stickyItems.splice(nodeIndex, 1);
  }
  setContainer(el) {
    this.container = el, isDocument(el) && this.setTopBarOffset(el), this.container.addEventListener("scroll", this.handleScroll), window.addEventListener("resize", this.handleResize), this.manageStickyItems();
  }
  removeScrollListener() {
    this.container && (this.container.removeEventListener("scroll", this.handleScroll), window.removeEventListener("resize", this.handleResize));
  }
  manageStickyItems() {
    if (this.stickyItems.length <= 0)
      return;
    let scrollTop = this.container ? scrollTopFor(this.container) : 0, containerTop = getRectForNode(this.container).top + this.topBarOffset;
    this.stickyItems.forEach((stickyItem) => {
      let {
        handlePositioning
      } = stickyItem, {
        sticky,
        top,
        left,
        width: width2
      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);
      this.updateStuckItems(stickyItem, sticky), handlePositioning(sticky, top, left, width2);
    });
  }
  evaluateStickyItem(stickyItem, scrollTop, containerTop) {
    let {
      stickyNode,
      placeHolderNode,
      boundingElement,
      offset,
      disableWhenStacked
    } = stickyItem;
    if (disableWhenStacked && stackedContent().matches)
      return {
        sticky: !1,
        top: 0,
        left: 0,
        width: "auto"
      };
    let stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(
      // Important: This will not update when the active theme changes.
      // Update this to `useTheme` once converted to a function component.
      themeDefault.space["space-500"],
      10
    ) : this.getOffset(stickyNode), scrollPosition2 = scrollTop + stickyOffset, placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop, top = containerTop + stickyOffset, width2 = placeHolderNode.getBoundingClientRect().width, left = placeHolderNode.getBoundingClientRect().left, sticky;
    if (boundingElement == null)
      sticky = scrollPosition2 >= placeHolderNodeCurrentTop;
    else {
      let stickyItemHeight = stickyNode.getBoundingClientRect().height || stickyNode.firstElementChild?.getBoundingClientRect().height || 0, stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;
      sticky = scrollPosition2 >= placeHolderNodeCurrentTop && scrollPosition2 < stickyItemBottomPosition;
    }
    return {
      sticky,
      top,
      left,
      width: width2
    };
  }
  updateStuckItems(item, sticky) {
    let {
      stickyNode
    } = item;
    sticky && !this.isNodeStuck(stickyNode) ? this.addStuckItem(item) : !sticky && this.isNodeStuck(stickyNode) && this.removeStuckItem(item);
  }
  addStuckItem(stickyItem) {
    this.stuckItems.push(stickyItem);
  }
  removeStuckItem(stickyItem) {
    let {
      stickyNode: nodeToRemove
    } = stickyItem, nodeIndex = this.stuckItems.findIndex(({
      stickyNode
    }) => nodeToRemove === stickyNode);
    this.stuckItems.splice(nodeIndex, 1);
  }
  getOffset(node) {
    if (this.stuckItems.length === 0)
      return 0;
    let offset = 0, count = 0, stuckNodesLength = this.stuckItems.length, nodeRect = getRectForNode(node);
    for (; count < stuckNodesLength; ) {
      let stuckNode = this.stuckItems[count].stickyNode;
      if (stuckNode !== node) {
        let stuckNodeRect = getRectForNode(stuckNode);
        horizontallyOverlaps(nodeRect, stuckNodeRect) || (offset += getRectForNode(stuckNode).height);
      } else
        break;
      count++;
    }
    return offset;
  }
  isNodeStuck(node) {
    return this.stuckItems.findIndex(({
      stickyNode
    }) => node === stickyNode) >= 0;
  }
  setTopBarOffset(container) {
    let topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);
    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;
  }
};
function isDocument(node) {
  return node === document;
}
function scrollTopFor(container) {
  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;
}
function horizontallyOverlaps(rect1, rect2) {
  let rect1Left = rect1.left, rect1Right = rect1.left + rect1.width, rect2Left = rect2.left;
  return rect2.left + rect2.width < rect1Left || rect1Right < rect2Left;
}

// node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/scroll-lock-manager.js
var SCROLL_LOCKING_ATTRIBUTE = "data-lock-scrolling", SCROLL_LOCKING_HIDDEN_ATTRIBUTE = "data-lock-scrolling-hidden", SCROLL_LOCKING_WRAPPER_ATTRIBUTE = "data-lock-scrolling-wrapper", scrollPosition = 0;
function isScrollBarVisible() {
  let {
    body
  } = document;
  return body.scrollHeight > body.clientHeight;
}
var ScrollLockManager = class {
  constructor() {
    this.scrollLocks = 0, this.locked = !1;
  }
  registerScrollLock() {
    this.scrollLocks += 1, this.handleScrollLocking();
  }
  unregisterScrollLock() {
    this.scrollLocks -= 1, this.handleScrollLocking();
  }
  handleScrollLocking() {
    if (isServer)
      return;
    let {
      scrollLocks
    } = this, {
      body
    } = document, wrapper = body.firstElementChild;
    scrollLocks === 0 ? (body.removeAttribute(SCROLL_LOCKING_ATTRIBUTE), body.removeAttribute(SCROLL_LOCKING_HIDDEN_ATTRIBUTE), wrapper && wrapper.removeAttribute(SCROLL_LOCKING_WRAPPER_ATTRIBUTE), window.scroll(0, scrollPosition), this.locked = !1) : scrollLocks > 0 && !this.locked && (scrollPosition = window.pageYOffset, body.setAttribute(SCROLL_LOCKING_ATTRIBUTE, ""), isScrollBarVisible() || body.setAttribute(SCROLL_LOCKING_HIDDEN_ATTRIBUTE, ""), wrapper && (wrapper.setAttribute(SCROLL_LOCKING_WRAPPER_ATTRIBUTE, ""), wrapper.scrollTop = scrollPosition), this.locked = !0);
  }
  resetScrollPosition() {
    scrollPosition = 0;
  }
};

// node_modules/@shopify/polaris/build/esm/utilities/get.js
var OBJECT_NOTATION_MATCHER = /\[(.*?)\]|(\w+)/g;
function get(obj, keypath, defaultValue) {
  if (obj == null)
    return;
  let keys = Array.isArray(keypath) ? keypath : getKeypath(keypath), acc = obj;
  for (let i = 0; i < keys.length; i++) {
    let val = acc[keys[i]];
    if (val === void 0)
      return defaultValue;
    acc = val;
  }
  return acc;
}
function getKeypath(str) {
  let path = [], result;
  for (; result = OBJECT_NOTATION_MATCHER.exec(str); ) {
    let [, first, second] = result;
    path.push(first || second);
  }
  return path;
}

// node_modules/@shopify/polaris/build/esm/utilities/merge.js
function merge(...objs) {
  let final = {};
  for (let obj of objs)
    final = mergeRecursively(final, obj);
  return final;
}
function mergeRecursively(inputObjA, objB) {
  let objA = Array.isArray(inputObjA) ? [...inputObjA] : {
    ...inputObjA
  };
  for (let key in objB)
    if (Object.prototype.hasOwnProperty.call(objB, key))
      isMergeableValue(objB[key]) && isMergeableValue(objA[key]) ? objA[key] = mergeRecursively(objA[key], objB[key]) : objA[key] = objB[key];
    else
      continue;
  return objA;
}
function isMergeableValue(value) {
  return value !== null && typeof value == "object";
}

// node_modules/@shopify/polaris/build/esm/utilities/i18n/I18n.js
var REPLACE_REGEX = /{([^}]*)}/g, I18n = class {
  /**
   * @param translation A locale object or array of locale objects that overrides default translations. If specifying an array then your desired language dictionary should come first, followed by your fallback language dictionaries
   */
  constructor(translation) {
    this.translation = {}, this.translation = Array.isArray(translation) ? merge(...translation.slice().reverse()) : translation;
  }
  translate(id, replacements) {
    let text2 = get(this.translation, id, "");
    return text2 ? replacements ? text2.replace(REPLACE_REGEX, (match) => {
      let replacement = match.substring(1, match.length - 1);
      if (replacements[replacement] === void 0) {
        let replacementData = JSON.stringify(replacements);
        throw new Error(`Error in translation for key '${id}'. No replacement found for key '${replacement}'. The following replacements were passed: '${replacementData}'`);
      }
      return replacements[replacement];
    }) : text2 : "";
  }
  translationKeyExists(path) {
    return Boolean(get(this.translation, path));
  }
};

// node_modules/@shopify/polaris/build/esm/utilities/features/context.js
var import_react8 = __toESM(require_react()), FeaturesContext = /* @__PURE__ */ (0, import_react8.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/utilities/i18n/context.js
var import_react9 = __toESM(require_react()), I18nContext = /* @__PURE__ */ (0, import_react9.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/context.js
var import_react10 = __toESM(require_react()), ScrollLockManagerContext = /* @__PURE__ */ (0, import_react10.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/context.js
var import_react11 = __toESM(require_react()), StickyManagerContext = /* @__PURE__ */ (0, import_react11.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/utilities/link/context.js
var import_react12 = __toESM(require_react()), LinkContext = /* @__PURE__ */ (0, import_react12.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/MediaQueryProvider/MediaQueryProvider.js
var import_react15 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/media-query/context.js
var import_react13 = __toESM(require_react()), MediaQueryContext = /* @__PURE__ */ (0, import_react13.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/EventListener/EventListener.js
var import_react14 = __toESM(require_react()), EventListener = class extends import_react14.PureComponent {
  componentDidMount() {
    this.attachListener();
  }
  componentDidUpdate({
    passive,
    ...detachProps
  }) {
    this.detachListener(detachProps), this.attachListener();
  }
  componentWillUnmount() {
    this.detachListener();
  }
  render() {
    return null;
  }
  attachListener() {
    let {
      event,
      handler,
      capture,
      passive
    } = this.props;
    window.addEventListener(event, handler, {
      capture,
      passive
    });
  }
  detachListener(prevProps) {
    let {
      event,
      handler,
      capture
    } = prevProps || this.props;
    window.removeEventListener(event, handler, capture);
  }
};

// node_modules/@shopify/polaris/build/esm/components/MediaQueryProvider/MediaQueryProvider.js
var MediaQueryProvider = function({
  children
}) {
  let [isNavigationCollapsed, setIsNavigationCollapsed] = (0, import_react15.useState)(navigationBarCollapsed().matches), handleResize = (0, import_react15.useCallback)(debounce(() => {
    isNavigationCollapsed !== navigationBarCollapsed().matches && setIsNavigationCollapsed(!isNavigationCollapsed);
  }, 40, {
    trailing: !0,
    leading: !0,
    maxWait: 40
  }), [isNavigationCollapsed]);
  (0, import_react15.useEffect)(() => {
    setIsNavigationCollapsed(navigationBarCollapsed().matches);
  }, []);
  let context = (0, import_react15.useMemo)(() => ({
    isNavigationCollapsed
  }), [isNavigationCollapsed]);
  return /* @__PURE__ */ import_react15.default.createElement(MediaQueryContext.Provider, {
    value: context
  }, /* @__PURE__ */ import_react15.default.createElement(EventListener, {
    event: "resize",
    handler: handleResize
  }), children);
};

// node_modules/@shopify/polaris/build/esm/components/PortalsManager/PortalsManager.js
var import_react19 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-is-after-initial-mount.js
var import_react16 = __toESM(require_react());
function useIsAfterInitialMount() {
  let [isAfterInitialMount, setIsAfterInitialMount] = (0, import_react16.useState)(!1);
  return (0, import_react16.useEffect)(() => {
    setIsAfterInitialMount(!0);
  }, []), isAfterInitialMount;
}

// node_modules/@shopify/polaris/build/esm/utilities/portals/context.js
var import_react17 = __toESM(require_react()), PortalsManagerContext = /* @__PURE__ */ (0, import_react17.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/PortalsManager/components/PortalsContainer/PortalsContainer.js
var import_react18 = __toESM(require_react());
function PortalsContainerComponent(_props, ref) {
  return /* @__PURE__ */ import_react18.default.createElement("div", {
    id: "PolarisPortalsContainer",
    ref
  });
}
var PortalsContainer = /* @__PURE__ */ (0, import_react18.forwardRef)(PortalsContainerComponent);

// node_modules/@shopify/polaris/build/esm/components/PortalsManager/PortalsManager.js
function PortalsManager({
  children,
  container
}) {
  let isMounted = useIsAfterInitialMount(), ref = (0, import_react19.useRef)(null), contextValue = (0, import_react19.useMemo)(() => container ? {
    container
  } : isMounted ? {
    container: ref.current
  } : {
    container: null
  }, [container, isMounted]);
  return /* @__PURE__ */ import_react19.default.createElement(PortalsManagerContext.Provider, {
    value: contextValue
  }, children, container ? null : /* @__PURE__ */ import_react19.default.createElement(PortalsContainer, {
    ref
  }));
}

// node_modules/@shopify/polaris/build/esm/components/FocusManager/FocusManager.js
var import_react21 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/focus-manager/context.js
var import_react20 = __toESM(require_react()), FocusManagerContext = /* @__PURE__ */ (0, import_react20.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/FocusManager/FocusManager.js
function FocusManager({
  children
}) {
  let [trapFocusList, setTrapFocusList] = (0, import_react21.useState)([]), add = (0, import_react21.useCallback)((id) => {
    setTrapFocusList((list) => [...list, id]);
  }, []), remove = (0, import_react21.useCallback)((id) => {
    let removed = !0;
    return setTrapFocusList((list) => {
      let clone = [...list], index = clone.indexOf(id);
      return index === -1 ? removed = !1 : clone.splice(index, 1), clone;
    }), removed;
  }, []), value = (0, import_react21.useMemo)(() => ({
    trapFocusList,
    add,
    remove
  }), [add, trapFocusList, remove]);
  return /* @__PURE__ */ import_react21.default.createElement(FocusManagerContext.Provider, {
    value
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/EphemeralPresenceManager/EphemeralPresenceManager.js
var import_react23 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/ephemeral-presence-manager/context.js
var import_react22 = __toESM(require_react()), EphemeralPresenceManagerContext = /* @__PURE__ */ (0, import_react22.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/EphemeralPresenceManager/EphemeralPresenceManager.js
var defaultState = {
  tooltip: 0,
  hovercard: 0
};
function EphemeralPresenceManager({
  children
}) {
  let [presenceCounter, setPresenceCounter] = (0, import_react23.useState)(defaultState), addPresence = (0, import_react23.useCallback)((key) => {
    setPresenceCounter((prevList) => ({
      ...prevList,
      [key]: prevList[key] + 1
    }));
  }, []), removePresence = (0, import_react23.useCallback)((key) => {
    setPresenceCounter((prevList) => ({
      ...prevList,
      [key]: prevList[key] - 1
    }));
  }, []), value = (0, import_react23.useMemo)(() => ({
    presenceList: Object.entries(presenceCounter).reduce((previousValue, currentValue) => {
      let [key, value2] = currentValue;
      return {
        ...previousValue,
        [key]: value2 >= 1
      };
    }, {}),
    presenceCounter,
    addPresence,
    removePresence
  }), [addPresence, removePresence, presenceCounter]);
  return /* @__PURE__ */ import_react23.default.createElement(EphemeralPresenceManagerContext.Provider, {
    value
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/AppProvider/AppProvider.js
var MAX_SCROLLBAR_WIDTH = 20, SCROLLBAR_TEST_ELEMENT_PARENT_SIZE = 30, SCROLLBAR_TEST_ELEMENT_CHILD_SIZE = SCROLLBAR_TEST_ELEMENT_PARENT_SIZE + 10;
function measureScrollbars() {
  let parentEl = document.createElement("div");
  parentEl.setAttribute("style", `position: absolute; opacity: 0; transform: translate3d(-9999px, -9999px, 0); pointer-events: none; width:${SCROLLBAR_TEST_ELEMENT_PARENT_SIZE}px; height:${SCROLLBAR_TEST_ELEMENT_PARENT_SIZE}px;`);
  let child = document.createElement("div");
  child.setAttribute("style", `width:100%; height: ${SCROLLBAR_TEST_ELEMENT_CHILD_SIZE}; overflow:scroll; scrollbar-width: thin;`), parentEl.appendChild(child), document.body.appendChild(parentEl);
  let scrollbarWidth = SCROLLBAR_TEST_ELEMENT_PARENT_SIZE - (parentEl.firstElementChild?.clientWidth ?? 0), scrollbarWidthWithSafetyHatch = Math.min(scrollbarWidth, MAX_SCROLLBAR_WIDTH);
  document.documentElement.style.setProperty("--pc-app-provider-scrollbar-width", `${scrollbarWidthWithSafetyHatch}px`), document.body.removeChild(parentEl);
}
var AppProvider = class extends import_react24.Component {
  constructor(props) {
    super(props), this.setBodyStyles = () => {
      document.body.style.backgroundColor = "var(--p-color-bg)", document.body.style.color = "var(--p-color-text)";
    }, this.setRootAttributes = () => {
      let activeThemeName = this.getThemeName();
      themeNames.forEach((themeName) => {
        document.documentElement.classList.toggle(createThemeClassName(themeName), themeName === activeThemeName);
      });
    }, this.getThemeName = () => this.props.theme ?? themeNameDefault, this.stickyManager = new StickyManager(), this.scrollLockManager = new ScrollLockManager();
    let {
      i18n,
      linkComponent
    } = this.props;
    this.state = {
      link: linkComponent,
      intl: new I18n(i18n)
    };
  }
  componentDidMount() {
    if (document != null) {
      this.stickyManager.setContainer(document), this.setBodyStyles(), this.setRootAttributes();
      let isSafari16 = navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") && (navigator.userAgent.includes("Version/16.1") || navigator.userAgent.includes("Version/16.2") || navigator.userAgent.includes("Version/16.3")), isMobileApp16 = navigator.userAgent.includes("Shopify Mobile/iOS") && (navigator.userAgent.includes("OS 16_1") || navigator.userAgent.includes("OS 16_2") || navigator.userAgent.includes("OS 16_3"));
      (isSafari16 || isMobileApp16) && document.documentElement.classList.add("Polaris-Safari-16-Font-Optical-Sizing-Patch");
    }
    measureScrollbars();
  }
  componentDidUpdate({
    i18n: prevI18n,
    linkComponent: prevLinkComponent
  }) {
    let {
      i18n,
      linkComponent
    } = this.props;
    this.setRootAttributes(), !(i18n === prevI18n && linkComponent === prevLinkComponent) && this.setState({
      link: linkComponent,
      intl: new I18n(i18n)
    });
  }
  render() {
    let {
      children,
      features
    } = this.props, themeName = this.getThemeName(), {
      intl,
      link
    } = this.state;
    return /* @__PURE__ */ import_react24.default.createElement(ThemeNameContext.Provider, {
      value: themeName
    }, /* @__PURE__ */ import_react24.default.createElement(ThemeContext.Provider, {
      value: getTheme(themeName)
    }, /* @__PURE__ */ import_react24.default.createElement(FeaturesContext.Provider, {
      value: features
    }, /* @__PURE__ */ import_react24.default.createElement(I18nContext.Provider, {
      value: intl
    }, /* @__PURE__ */ import_react24.default.createElement(ScrollLockManagerContext.Provider, {
      value: this.scrollLockManager
    }, /* @__PURE__ */ import_react24.default.createElement(StickyManagerContext.Provider, {
      value: this.stickyManager
    }, /* @__PURE__ */ import_react24.default.createElement(LinkContext.Provider, {
      value: link
    }, /* @__PURE__ */ import_react24.default.createElement(MediaQueryProvider, null, /* @__PURE__ */ import_react24.default.createElement(PortalsManager, null, /* @__PURE__ */ import_react24.default.createElement(FocusManager, null, /* @__PURE__ */ import_react24.default.createElement(EphemeralPresenceManager, null, children)))))))))));
  }
};

// node_modules/@shopify/polaris/build/esm/components/Button/utils.js
var import_react53 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Button/Button.js
var import_react52 = __toESM(require_react());

// node_modules/@shopify/polaris-icons/dist/icons/AlertCircleIcon.svg.mjs
var import_react25 = __toESM(require_react(), 1), SvgAlertCircleIcon = function(props) {
  return /* @__PURE__ */ import_react25.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react25.default.createElement("path", {
    d: "M10 6a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5a.75.75 0 0 1 .75-.75Z"
  }), /* @__PURE__ */ import_react25.default.createElement("path", {
    d: "M11 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
  }), /* @__PURE__ */ import_react25.default.createElement("path", {
    fillRule: "evenodd",
    d: "M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm-1.5 0a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
  }));
};
SvgAlertCircleIcon.displayName = "AlertCircleIcon";

// node_modules/@shopify/polaris-icons/dist/icons/AlertTriangleIcon.svg.mjs
var import_react26 = __toESM(require_react(), 1), SvgAlertTriangleIcon = function(props) {
  return /* @__PURE__ */ import_react26.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react26.default.createElement("path", {
    d: "M10 6.75a.75.75 0 0 1 .75.75v3.5a.75.75 0 1 1-1.5 0v-3.5a.75.75 0 0 1 .75-.75Z"
  }), /* @__PURE__ */ import_react26.default.createElement("path", {
    d: "M11 13.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
  }), /* @__PURE__ */ import_react26.default.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3.5c-1.045 0-1.784.702-2.152 1.447a449.26 449.26 0 0 1-2.005 3.847l-.028.052a403.426 403.426 0 0 0-2.008 3.856c-.372.752-.478 1.75.093 2.614.57.863 1.542 1.184 2.464 1.184h7.272c.922 0 1.895-.32 2.464-1.184.57-.864.465-1.862.093-2.614-.21-.424-1.113-2.147-2.004-3.847l-.032-.061a429.497 429.497 0 0 1-2.005-3.847c-.368-.745-1.107-1.447-2.152-1.447Zm-.808 2.112c.404-.816 1.212-.816 1.616 0 .202.409 1.112 2.145 2.022 3.88a418.904 418.904 0 0 1 2.018 3.875c.404.817 0 1.633-1.212 1.633h-7.272c-1.212 0-1.617-.816-1.212-1.633.202-.408 1.113-2.147 2.023-3.883a421.932 421.932 0 0 0 2.017-3.872Z"
  }));
};
SvgAlertTriangleIcon.displayName = "AlertTriangleIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ArrowDownIcon.svg.mjs
var import_react27 = __toESM(require_react(), 1), SvgArrowDownIcon = function(props) {
  return /* @__PURE__ */ import_react27.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react27.default.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3.5a.75.75 0 0 1 .75.75v9.69l2.72-2.72a.75.75 0 0 1 1.06 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 1.06-1.06l2.72 2.72v-9.69a.75.75 0 0 1 .75-.75Z"
  }));
};
SvgArrowDownIcon.displayName = "ArrowDownIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ArrowLeftIcon.svg.mjs
var import_react28 = __toESM(require_react(), 1), SvgArrowLeftIcon = function(props) {
  return /* @__PURE__ */ import_react28.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react28.default.createElement("path", {
    fillRule: "evenodd",
    d: "M16.5 10a.75.75 0 0 1-.75.75h-9.69l2.72 2.72a.75.75 0 0 1-1.06 1.06l-4-4a.75.75 0 0 1 0-1.06l4-4a.75.75 0 1 1 1.06 1.06l-2.72 2.72h9.69a.75.75 0 0 1 .75.75Z"
  }));
};
SvgArrowLeftIcon.displayName = "ArrowLeftIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ArrowUpIcon.svg.mjs
var import_react29 = __toESM(require_react(), 1), SvgArrowUpIcon = function(props) {
  return /* @__PURE__ */ import_react29.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react29.default.createElement("path", {
    fillRule: "evenodd",
    d: "M10 16.5a.75.75 0 0 1-.75-.75v-9.69l-2.72 2.72a.75.75 0 1 1-1.06-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06l-2.72-2.72v9.69a.75.75 0 0 1-.75.75Z"
  }));
};
SvgArrowUpIcon.displayName = "ArrowUpIcon";

// node_modules/@shopify/polaris-icons/dist/icons/CheckCircleIcon.svg.mjs
var import_react30 = __toESM(require_react(), 1), SvgCheckCircleIcon = function(props) {
  return /* @__PURE__ */ import_react30.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react30.default.createElement("path", {
    d: "M13.28 9.03a.75.75 0 0 0-1.06-1.06l-2.97 2.97-1.22-1.22a.75.75 0 0 0-1.06 1.06l1.75 1.75a.75.75 0 0 0 1.06 0l3.5-3.5Z"
  }), /* @__PURE__ */ import_react30.default.createElement("path", {
    fillRule: "evenodd",
    d: "M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm-1.5 0a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
  }));
};
SvgCheckCircleIcon.displayName = "CheckCircleIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ChevronDownIcon.svg.mjs
var import_react31 = __toESM(require_react(), 1), SvgChevronDownIcon = function(props) {
  return /* @__PURE__ */ import_react31.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react31.default.createElement("path", {
    fillRule: "evenodd",
    d: "M5.72 8.47a.75.75 0 0 1 1.06 0l3.47 3.47 3.47-3.47a.75.75 0 1 1 1.06 1.06l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 0 1 0-1.06Z"
  }));
};
SvgChevronDownIcon.displayName = "ChevronDownIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ChevronLeftIcon.svg.mjs
var import_react32 = __toESM(require_react(), 1), SvgChevronLeftIcon = function(props) {
  return /* @__PURE__ */ import_react32.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react32.default.createElement("path", {
    fillRule: "evenodd",
    d: "M11.764 5.204a.75.75 0 0 1 .032 1.06l-3.516 3.736 3.516 3.736a.75.75 0 1 1-1.092 1.028l-4-4.25a.75.75 0 0 1 0-1.028l4-4.25a.75.75 0 0 1 1.06-.032Z"
  }));
};
SvgChevronLeftIcon.displayName = "ChevronLeftIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ChevronRightIcon.svg.mjs
var import_react33 = __toESM(require_react(), 1), SvgChevronRightIcon = function(props) {
  return /* @__PURE__ */ import_react33.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react33.default.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 14.53a.75.75 0 0 1 0-1.06l3.47-3.47-3.47-3.47a.75.75 0 0 1 1.06-1.06l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 0 1-1.06 0Z"
  }));
};
SvgChevronRightIcon.displayName = "ChevronRightIcon";

// node_modules/@shopify/polaris-icons/dist/icons/ChevronUpIcon.svg.mjs
var import_react34 = __toESM(require_react(), 1), SvgChevronUpIcon = function(props) {
  return /* @__PURE__ */ import_react34.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react34.default.createElement("path", {
    fillRule: "evenodd",
    d: "M14.53 12.28a.75.75 0 0 1-1.06 0l-3.47-3.47-3.47 3.47a.75.75 0 0 1-1.06-1.06l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06Z"
  }));
};
SvgChevronUpIcon.displayName = "ChevronUpIcon";

// node_modules/@shopify/polaris-icons/dist/icons/MenuHorizontalIcon.svg.mjs
var import_react35 = __toESM(require_react(), 1), SvgMenuHorizontalIcon = function(props) {
  return /* @__PURE__ */ import_react35.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react35.default.createElement("path", {
    d: "M6 10a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z"
  }), /* @__PURE__ */ import_react35.default.createElement("path", {
    d: "M11.5 10a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z"
  }), /* @__PURE__ */ import_react35.default.createElement("path", {
    d: "M17 10a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z"
  }));
};
SvgMenuHorizontalIcon.displayName = "MenuHorizontalIcon";

// node_modules/@shopify/polaris-icons/dist/icons/SearchIcon.svg.mjs
var import_react36 = __toESM(require_react(), 1), SvgSearchIcon = function(props) {
  return /* @__PURE__ */ import_react36.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react36.default.createElement("path", {
    fillRule: "evenodd",
    d: "M12.323 13.383a5.5 5.5 0 1 1 1.06-1.06l2.897 2.897a.75.75 0 1 1-1.06 1.06l-2.897-2.897Zm.677-4.383a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"
  }));
};
SvgSearchIcon.displayName = "SearchIcon";

// node_modules/@shopify/polaris-icons/dist/icons/SelectIcon.svg.mjs
var import_react37 = __toESM(require_react(), 1), SvgSelectIcon = function(props) {
  return /* @__PURE__ */ import_react37.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react37.default.createElement("path", {
    d: "M10.884 4.323a1.25 1.25 0 0 0-1.768 0l-2.646 2.647a.75.75 0 0 0 1.06 1.06l2.47-2.47 2.47 2.47a.75.75 0 1 0 1.06-1.06l-2.646-2.647Z"
  }), /* @__PURE__ */ import_react37.default.createElement("path", {
    d: "m13.53 13.03-2.646 2.647a1.25 1.25 0 0 1-1.768 0l-2.646-2.647a.75.75 0 0 1 1.06-1.06l2.47 2.47 2.47-2.47a.75.75 0 0 1 1.06 1.06Z"
  }));
};
SvgSelectIcon.displayName = "SelectIcon";

// node_modules/@shopify/polaris-icons/dist/icons/SortAscendingIcon.svg.mjs
var import_react38 = __toESM(require_react(), 1), SvgSortAscendingIcon = function(props) {
  return /* @__PURE__ */ import_react38.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react38.default.createElement("path", {
    fillRule: "evenodd",
    d: "M9.116 4.323a1.25 1.25 0 0 1 1.768 0l2.646 2.647a.75.75 0 0 1-1.06 1.06l-2.47-2.47-2.47 2.47a.75.75 0 1 1-1.06-1.06l2.646-2.647Z"
  }), /* @__PURE__ */ import_react38.default.createElement("path", {
    fillOpacity: 0.33,
    fillRule: "evenodd",
    d: "M9.116 15.677a1.25 1.25 0 0 0 1.768 0l2.646-2.647a.75.75 0 0 0-1.06-1.06l-2.47 2.47-2.47-2.47a.75.75 0 0 0-1.06 1.06l2.646 2.647Z"
  }));
};
SvgSortAscendingIcon.displayName = "SortAscendingIcon";

// node_modules/@shopify/polaris-icons/dist/icons/SortDescendingIcon.svg.mjs
var import_react39 = __toESM(require_react(), 1), SvgSortDescendingIcon = function(props) {
  return /* @__PURE__ */ import_react39.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react39.default.createElement("path", {
    fillOpacity: 0.33,
    fillRule: "evenodd",
    d: "M9.116 4.823a1.25 1.25 0 0 1 1.768 0l2.646 2.647a.75.75 0 0 1-1.06 1.06l-2.47-2.47-2.47 2.47a.75.75 0 1 1-1.06-1.06l2.646-2.647Z"
  }), /* @__PURE__ */ import_react39.default.createElement("path", {
    fillRule: "evenodd",
    d: "M9.116 15.177a1.25 1.25 0 0 0 1.768 0l2.646-2.647a.75.75 0 0 0-1.06-1.06l-2.47 2.47-2.47-2.47a.75.75 0 0 0-1.06 1.06l2.646 2.647Z"
  }));
};
SvgSortDescendingIcon.displayName = "SortDescendingIcon";

// node_modules/@shopify/polaris-icons/dist/icons/XCircleIcon.svg.mjs
var import_react40 = __toESM(require_react(), 1), SvgXCircleIcon = function(props) {
  return /* @__PURE__ */ import_react40.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react40.default.createElement("path", {
    d: "M13.03 6.97a.75.75 0 0 1 0 1.06l-1.97 1.97 1.97 1.97a.75.75 0 1 1-1.06 1.06l-1.97-1.97-1.97 1.97a.75.75 0 0 1-1.06-1.06l1.97-1.97-1.97-1.97a.75.75 0 0 1 1.06-1.06l1.97 1.97 1.97-1.97a.75.75 0 0 1 1.06 0Z"
  }), /* @__PURE__ */ import_react40.default.createElement("path", {
    fillRule: "evenodd",
    d: "M10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11Z"
  }));
};
SvgXCircleIcon.displayName = "XCircleIcon";

// node_modules/@shopify/polaris-icons/dist/icons/XIcon.svg.mjs
var import_react41 = __toESM(require_react(), 1), SvgXIcon = function(props) {
  return /* @__PURE__ */ import_react41.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react41.default.createElement("path", {
    d: "M12.72 13.78a.75.75 0 1 0 1.06-1.06l-2.72-2.72 2.72-2.72a.75.75 0 0 0-1.06-1.06l-2.72 2.72-2.72-2.72a.75.75 0 0 0-1.06 1.06l2.72 2.72-2.72 2.72a.75.75 0 1 0 1.06 1.06l2.72-2.72 2.72 2.72Z"
  }));
};
SvgXIcon.displayName = "XIcon";

// node_modules/@shopify/polaris-icons/dist/icons/XSmallIcon.svg.mjs
var import_react42 = __toESM(require_react(), 1), SvgXSmallIcon = function(props) {
  return /* @__PURE__ */ import_react42.default.createElement("svg", Object.assign({
    viewBox: "0 0 20 20"
  }, props), /* @__PURE__ */ import_react42.default.createElement("path", {
    d: "M12.72 13.78a.75.75 0 1 0 1.06-1.06l-2.72-2.72 2.72-2.72a.75.75 0 0 0-1.06-1.06l-2.72 2.72-2.72-2.72a.75.75 0 0 0-1.06 1.06l2.72 2.72-2.72 2.72a.75.75 0 1 0 1.06 1.06l2.72-2.72 2.72 2.72Z"
  }));
};
SvgXSmallIcon.displayName = "XSmallIcon";

// node_modules/@shopify/polaris-icons/dist/index.mjs
var import_react43 = __toESM(require_react(), 1);

// node_modules/@shopify/polaris/build/esm/utilities/is-element-in-viewport.js
function isElementInViewport(element) {
  let {
    top,
    left,
    bottom,
    right
  } = element.getBoundingClientRect();
  return top >= 0 && right <= window.innerWidth && bottom <= window.innerHeight && left >= 0;
}

// node_modules/@shopify/polaris/build/esm/utilities/focus.js
var FOCUSABLE_SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]', KEYBOARD_FOCUSABLE_SELECTORS = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not([aria-disabled="true"]):not([tabindex="-1"]):not(:disabled),*[tabindex]:not([tabindex="-1"])', MENUITEM_FOCUSABLE_SELECTORS = 'a[role="menuitem"],frame[role="menuitem"],iframe[role="menuitem"],input[role="menuitem"]:not([type=hidden]):not(:disabled),select[role="menuitem"]:not(:disabled),textarea[role="menuitem"]:not(:disabled),button[role="menuitem"]:not(:disabled),*[tabindex]:not([tabindex="-1"])', handleMouseUpByBlurring = ({
  currentTarget
}) => currentTarget.blur();
function nextFocusableNode(node, filter) {
  let allFocusableElements = [...document.querySelectorAll(FOCUSABLE_SELECTOR)], sliceLocation = allFocusableElements.indexOf(node) + 1, focusableElementsAfterNode = allFocusableElements.slice(sliceLocation);
  for (let focusableElement of focusableElementsAfterNode)
    if (isElementInViewport(focusableElement) && (!filter || filter && filter(focusableElement)))
      return focusableElement;
  return null;
}
function findFirstFocusableNode(element, onlyDescendants = !0) {
  return !onlyDescendants && matches(element, FOCUSABLE_SELECTOR) ? element : element.querySelector(FOCUSABLE_SELECTOR);
}
function findFirstFocusableNodeIncludingDisabled(element) {
  let focusableSelector = "a,button,frame,iframe,input:not([type=hidden]),select,textarea,*[tabindex]";
  return matches(element, focusableSelector) ? element : element.querySelector(focusableSelector);
}
function focusFirstFocusableNode(element, onlyDescendants = !0) {
  findFirstFocusableNode(element, onlyDescendants)?.focus();
}
function focusNextFocusableNode(node, filter) {
  let nextFocusable = nextFocusableNode(node, filter);
  return nextFocusable && nextFocusable instanceof HTMLElement ? (nextFocusable.focus(), !0) : !1;
}
function findFirstKeyboardFocusableNode(element, onlyDescendants = !0) {
  return !onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS) ? element : element.querySelector(KEYBOARD_FOCUSABLE_SELECTORS);
}
function focusFirstKeyboardFocusableNode(element, onlyDescendants = !0) {
  let firstFocusable = findFirstKeyboardFocusableNode(element, onlyDescendants);
  return firstFocusable ? (firstFocusable.focus(), !0) : !1;
}
function findLastKeyboardFocusableNode(element, onlyDescendants = !0) {
  if (!onlyDescendants && matches(element, KEYBOARD_FOCUSABLE_SELECTORS))
    return element;
  let allFocusable = element.querySelectorAll(KEYBOARD_FOCUSABLE_SELECTORS);
  return allFocusable[allFocusable.length - 1];
}
function focusLastKeyboardFocusableNode(element, onlyDescendants = !0) {
  let lastFocusable = findLastKeyboardFocusableNode(element, onlyDescendants);
  return lastFocusable ? (lastFocusable.focus(), !0) : !1;
}
function wrapFocusPreviousFocusableMenuItem(parentElement, currentFocusedElement) {
  let allFocusableChildren = getMenuFocusableDescendants(parentElement), currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);
  currentItemIdx === -1 ? allFocusableChildren[0].focus() : allFocusableChildren[(currentItemIdx - 1 + allFocusableChildren.length) % allFocusableChildren.length].focus();
}
function wrapFocusNextFocusableMenuItem(parentElement, currentFocusedElement) {
  let allFocusableChildren = getMenuFocusableDescendants(parentElement), currentItemIdx = getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement);
  currentItemIdx === -1 ? allFocusableChildren[0].focus() : allFocusableChildren[(currentItemIdx + 1) % allFocusableChildren.length].focus();
}
function getMenuFocusableDescendants(element) {
  return element.querySelectorAll(MENUITEM_FOCUSABLE_SELECTORS);
}
function getCurrentFocusedElementIndex(allFocusableChildren, currentFocusedElement) {
  let currentItemIdx = 0;
  for (let focusableChild of allFocusableChildren) {
    if (focusableChild === currentFocusedElement)
      break;
    currentItemIdx++;
  }
  return currentItemIdx === allFocusableChildren.length ? -1 : currentItemIdx;
}
function matches(node, selector) {
  if (node.matches)
    return node.matches(selector);
  let matches2 = (node.ownerDocument || document).querySelectorAll(selector), i = matches2.length;
  for (; --i >= 0 && matches2.item(i) !== node; )
    return i > -1;
}

// node_modules/@shopify/polaris/build/esm/components/Button/Button.css.js
var styles2 = {
  Button: "Polaris-Button",
  disabled: "Polaris-Button--disabled",
  pressed: "Polaris-Button--pressed",
  variantPrimary: "Polaris-Button--variantPrimary",
  variantSecondary: "Polaris-Button--variantSecondary",
  variantTertiary: "Polaris-Button--variantTertiary",
  variantPlain: "Polaris-Button--variantPlain",
  removeUnderline: "Polaris-Button--removeUnderline",
  variantMonochromePlain: "Polaris-Button--variantMonochromePlain",
  toneSuccess: "Polaris-Button--toneSuccess",
  toneCritical: "Polaris-Button--toneCritical",
  sizeMicro: "Polaris-Button--sizeMicro",
  sizeSlim: "Polaris-Button--sizeSlim",
  sizeMedium: "Polaris-Button--sizeMedium",
  sizeLarge: "Polaris-Button--sizeLarge",
  textAlignCenter: "Polaris-Button--textAlignCenter",
  textAlignStart: "Polaris-Button--textAlignStart",
  textAlignLeft: "Polaris-Button--textAlignLeft",
  textAlignEnd: "Polaris-Button--textAlignEnd",
  textAlignRight: "Polaris-Button--textAlignRight",
  fullWidth: "Polaris-Button--fullWidth",
  iconOnly: "Polaris-Button--iconOnly",
  iconWithText: "Polaris-Button--iconWithText",
  disclosure: "Polaris-Button--disclosure",
  loading: "Polaris-Button--loading",
  pressable: "Polaris-Button--pressable",
  hidden: "Polaris-Button--hidden",
  Icon: "Polaris-Button__Icon",
  Spinner: "Polaris-Button__Spinner"
};

// node_modules/@shopify/polaris/build/esm/components/Icon/Icon.js
var import_react45 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Icon/Icon.css.js
var styles3 = {
  Icon: "Polaris-Icon",
  toneInherit: "Polaris-Icon--toneInherit",
  toneBase: "Polaris-Icon--toneBase",
  toneSubdued: "Polaris-Icon--toneSubdued",
  toneCaution: "Polaris-Icon--toneCaution",
  toneWarning: "Polaris-Icon--toneWarning",
  toneCritical: "Polaris-Icon--toneCritical",
  toneInteractive: "Polaris-Icon--toneInteractive",
  toneInfo: "Polaris-Icon--toneInfo",
  toneSuccess: "Polaris-Icon--toneSuccess",
  tonePrimary: "Polaris-Icon--tonePrimary",
  toneEmphasis: "Polaris-Icon--toneEmphasis",
  toneMagic: "Polaris-Icon--toneMagic",
  toneTextCaution: "Polaris-Icon--toneTextCaution",
  toneTextWarning: "Polaris-Icon--toneTextWarning",
  toneTextCritical: "Polaris-Icon--toneTextCritical",
  toneTextInfo: "Polaris-Icon--toneTextInfo",
  toneTextPrimary: "Polaris-Icon--toneTextPrimary",
  toneTextSuccess: "Polaris-Icon--toneTextSuccess",
  toneTextMagic: "Polaris-Icon--toneTextMagic",
  Svg: "Polaris-Icon__Svg",
  Img: "Polaris-Icon__Img",
  Placeholder: "Polaris-Icon__Placeholder"
};

// node_modules/@shopify/polaris/build/esm/components/Text/Text.js
var import_react44 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Text/Text.css.js
var styles4 = {
  root: "Polaris-Text--root",
  block: "Polaris-Text--block",
  truncate: "Polaris-Text--truncate",
  visuallyHidden: "Polaris-Text--visuallyHidden",
  start: "Polaris-Text--start",
  center: "Polaris-Text--center",
  end: "Polaris-Text--end",
  justify: "Polaris-Text--justify",
  base: "Polaris-Text--base",
  inherit: "Polaris-Text--inherit",
  disabled: "Polaris-Text--disabled",
  success: "Polaris-Text--success",
  critical: "Polaris-Text--critical",
  caution: "Polaris-Text--caution",
  subdued: "Polaris-Text--subdued",
  magic: "Polaris-Text--magic",
  "magic-subdued": "Polaris-Text__magic--subdued",
  "text-inverse": "Polaris-Text__text--inverse",
  "text-inverse-secondary": "Polaris-Text--textInverseSecondary",
  headingXs: "Polaris-Text--headingXs",
  headingSm: "Polaris-Text--headingSm",
  headingMd: "Polaris-Text--headingMd",
  headingLg: "Polaris-Text--headingLg",
  headingXl: "Polaris-Text--headingXl",
  heading2xl: "Polaris-Text--heading2xl",
  heading3xl: "Polaris-Text--heading3xl",
  bodyXs: "Polaris-Text--bodyXs",
  bodySm: "Polaris-Text--bodySm",
  bodyMd: "Polaris-Text--bodyMd",
  bodyLg: "Polaris-Text--bodyLg",
  regular: "Polaris-Text--regular",
  medium: "Polaris-Text--medium",
  semibold: "Polaris-Text--semibold",
  bold: "Polaris-Text--bold",
  break: "Polaris-Text--break",
  numeric: "Polaris-Text--numeric",
  "line-through": "Polaris-Text__line--through"
};

// node_modules/@shopify/polaris/build/esm/components/Text/Text.js
var Text = ({
  alignment,
  as,
  breakWord,
  children,
  tone,
  fontWeight,
  id,
  numeric = !1,
  truncate = !1,
  variant,
  visuallyHidden = !1,
  textDecorationLine
}) => {
  let Component5 = as || (visuallyHidden ? "span" : "p"), className = classNames(styles4.root, variant && styles4[variant], fontWeight && styles4[fontWeight], (alignment || truncate) && styles4.block, alignment && styles4[alignment], breakWord && styles4.break, tone && styles4[tone], numeric && styles4.numeric, truncate && styles4.truncate, visuallyHidden && styles4.visuallyHidden, textDecorationLine && styles4[textDecorationLine]);
  return /* @__PURE__ */ import_react44.default.createElement(Component5, Object.assign({
    className
  }, id && {
    id
  }), children);
};

// node_modules/@shopify/polaris/build/esm/components/Icon/Icon.js
function Icon({
  source,
  tone,
  accessibilityLabel
}) {
  let sourceType;
  typeof source == "function" ? sourceType = "function" : source === "placeholder" ? sourceType = "placeholder" : sourceType = "external";
  let className = classNames(styles3.Icon, tone && styles3[variationName("tone", tone)]), {
    mdDown
  } = useBreakpoints(), SourceComponent = source, contentMarkup = {
    function: /* @__PURE__ */ import_react45.default.createElement(SourceComponent, Object.assign({
      className: styles3.Svg,
      focusable: "false",
      "aria-hidden": "true"
      // On Mobile we're scaling the viewBox to 18x18 to make the icons bigger
      // Also, we're setting the viewport origin to 1x1 to center the icon
      // We use this syntax so we don't override the existing viewBox value if we don't need to.
    }, mdDown ? {
      viewBox: "1 1 18 18"
    } : {})),
    placeholder: /* @__PURE__ */ import_react45.default.createElement("div", {
      className: styles3.Placeholder
    }),
    external: /* @__PURE__ */ import_react45.default.createElement("img", {
      className: styles3.Img,
      src: `data:image/svg+xml;utf8,${source}`,
      alt: "",
      "aria-hidden": "true"
    })
  };
  return /* @__PURE__ */ import_react45.default.createElement("span", {
    className
  }, accessibilityLabel && /* @__PURE__ */ import_react45.default.createElement(Text, {
    as: "span",
    visuallyHidden: !0
  }, accessibilityLabel), contentMarkup[sourceType]);
}

// node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.js
var import_react46 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.css.js
var styles5 = {
  Spinner: "Polaris-Spinner",
  sizeSmall: "Polaris-Spinner--sizeSmall",
  sizeLarge: "Polaris-Spinner--sizeLarge"
};

// node_modules/@shopify/polaris/build/esm/components/Spinner/Spinner.js
function Spinner({
  size: size2 = "large",
  accessibilityLabel,
  hasFocusableParent
}) {
  let isAfterInitialMount = useIsAfterInitialMount(), className = classNames(styles5.Spinner, size2 && styles5[variationName("size", size2)]), spinnerSVGMarkup = size2 === "large" ? /* @__PURE__ */ import_react46.default.createElement("svg", {
    viewBox: "0 0 44 44",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react46.default.createElement("path", {
    d: "M15.542 1.487A21.507 21.507 0 00.5 22c0 11.874 9.626 21.5 21.5 21.5 9.847 0 18.364-6.675 20.809-16.072a1.5 1.5 0 00-2.904-.756C37.803 34.755 30.473 40.5 22 40.5 11.783 40.5 3.5 32.217 3.5 22c0-8.137 5.3-15.247 12.942-17.65a1.5 1.5 0 10-.9-2.863z"
  })) : /* @__PURE__ */ import_react46.default.createElement("svg", {
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ import_react46.default.createElement("path", {
    d: "M7.229 1.173a9.25 9.25 0 1011.655 11.412 1.25 1.25 0 10-2.4-.698 6.75 6.75 0 11-8.506-8.329 1.25 1.25 0 10-.75-2.385z"
  })), spanAttributes = {
    ...!hasFocusableParent && {
      role: "status"
    }
  }, accessibilityLabelMarkup = (isAfterInitialMount || !hasFocusableParent) && /* @__PURE__ */ import_react46.default.createElement(Text, {
    as: "span",
    visuallyHidden: !0
  }, accessibilityLabel);
  return /* @__PURE__ */ import_react46.default.createElement(import_react46.default.Fragment, null, /* @__PURE__ */ import_react46.default.createElement("span", {
    className
  }, spinnerSVGMarkup), /* @__PURE__ */ import_react46.default.createElement("span", spanAttributes, accessibilityLabelMarkup));
}

// node_modules/@shopify/polaris/build/esm/components/UnstyledButton/UnstyledButton.js
var import_react50 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-disable-interaction.js
var import_react47 = __toESM(require_react());
function useDisableClick(disabled, handleClick) {
  let handleClickWrapper = (0, import_react47.useCallback)((event) => {
    disabled && (event.preventDefault(), event.stopPropagation());
  }, [disabled]);
  return disabled ? handleClickWrapper : handleClick;
}

// node_modules/@shopify/polaris/build/esm/components/UnstyledLink/UnstyledLink.js
var import_react49 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/link/hooks.js
var import_react48 = __toESM(require_react());
function useLink() {
  return (0, import_react48.useContext)(LinkContext);
}

// node_modules/@shopify/polaris/build/esm/components/UnstyledLink/UnstyledLink.js
var UnstyledLink = /* @__PURE__ */ (0, import_react49.memo)(/* @__PURE__ */ (0, import_react49.forwardRef)(function(props, _ref) {
  let LinkComponent = useLink();
  if (LinkComponent)
    return /* @__PURE__ */ import_react49.default.createElement(LinkComponent, Object.assign({}, unstyled.props, props, {
      ref: _ref
    }));
  let {
    external,
    url,
    target: targetProp,
    ...rest
  } = props, target;
  external ? target = "_blank" : target = targetProp ?? void 0;
  let rel = target === "_blank" ? "noopener noreferrer" : void 0;
  return /* @__PURE__ */ import_react49.default.createElement("a", Object.assign({
    target
  }, rest, {
    href: url,
    rel
  }, unstyled.props, {
    ref: _ref
  }));
}));

// node_modules/@shopify/polaris/build/esm/components/UnstyledButton/UnstyledButton.js
function UnstyledButton({
  id,
  children,
  className,
  url,
  external,
  target,
  download,
  submit,
  disabled,
  loading,
  pressed,
  accessibilityLabel,
  role,
  ariaControls,
  ariaExpanded,
  ariaDescribedBy,
  ariaChecked,
  onClick,
  onFocus,
  onBlur,
  onKeyDown,
  onKeyPress,
  onKeyUp,
  onMouseEnter,
  onTouchStart,
  ...rest
}) {
  let buttonMarkup, commonProps = {
    id,
    className,
    "aria-label": accessibilityLabel
  }, interactiveProps = {
    ...commonProps,
    role,
    onClick,
    onFocus,
    onBlur,
    onMouseUp: handleMouseUpByBlurring,
    onMouseEnter,
    onTouchStart
  }, handleClick = useDisableClick(disabled, onClick);
  return url ? buttonMarkup = disabled ? (
    // Render an `<a>` so toggling disabled/enabled state changes only the
    // `href` attribute instead of replacing the whole element.
    /* @__PURE__ */ import_react50.default.createElement("a", commonProps, children)
  ) : /* @__PURE__ */ import_react50.default.createElement(UnstyledLink, Object.assign({}, interactiveProps, {
    url,
    external,
    target,
    download
  }, rest), children) : buttonMarkup = /* @__PURE__ */ import_react50.default.createElement("button", Object.assign({}, interactiveProps, {
    "aria-disabled": disabled,
    type: submit ? "submit" : "button",
    "aria-busy": loading ? !0 : void 0,
    "aria-controls": ariaControls,
    "aria-expanded": ariaExpanded,
    "aria-describedby": ariaDescribedBy,
    "aria-checked": ariaChecked,
    "aria-pressed": pressed,
    onKeyDown,
    onKeyUp,
    onKeyPress,
    onClick: handleClick,
    tabIndex: disabled ? -1 : void 0
  }, rest), children), buttonMarkup;
}

// node_modules/@shopify/polaris/build/esm/utilities/i18n/hooks.js
var import_react51 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/errors.js
var MissingAppProviderError = class extends Error {
  constructor(message = "") {
    super(`${message && `${message} `}Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.`), this.name = "MissingAppProviderError";
  }
};

// node_modules/@shopify/polaris/build/esm/utilities/i18n/hooks.js
function useI18n() {
  let i18n = (0, import_react51.useContext)(I18nContext);
  if (!i18n)
    throw new MissingAppProviderError("No i18n was provided.");
  return i18n;
}

// node_modules/@shopify/polaris/build/esm/components/Button/Button.js
function Button({
  id,
  children,
  url,
  disabled,
  external,
  download,
  target,
  submit,
  loading,
  pressed,
  accessibilityLabel,
  role,
  ariaControls,
  ariaExpanded,
  ariaDescribedBy,
  ariaChecked,
  onClick,
  onFocus,
  onBlur,
  onKeyDown,
  onKeyPress,
  onKeyUp,
  onMouseEnter,
  onTouchStart,
  onPointerDown,
  icon,
  disclosure,
  removeUnderline,
  size: size2 = "medium",
  textAlign = "center",
  fullWidth,
  dataPrimaryLink,
  tone,
  variant = "secondary"
}) {
  let i18n = useI18n(), isDisabled = disabled || loading, {
    mdUp
  } = useBreakpoints(), className = classNames(styles2.Button, styles2.pressable, styles2[variationName("variant", variant)], styles2[variationName("size", size2)], styles2[variationName("textAlign", textAlign)], fullWidth && styles2.fullWidth, disclosure && styles2.disclosure, icon && children && styles2.iconWithText, icon && children == null && styles2.iconOnly, isDisabled && styles2.disabled, loading && styles2.loading, pressed && !disabled && !url && styles2.pressed, removeUnderline && styles2.removeUnderline, tone && styles2[variationName("tone", tone)]), disclosureMarkup = disclosure ? /* @__PURE__ */ import_react52.default.createElement("span", {
    className: loading ? styles2.hidden : styles2.Icon
  }, /* @__PURE__ */ import_react52.default.createElement(Icon, {
    source: loading ? "placeholder" : getDisclosureIconSource(disclosure, SvgChevronUpIcon, SvgChevronDownIcon)
  })) : null, iconSource = isIconSource(icon) ? /* @__PURE__ */ import_react52.default.createElement(Icon, {
    source: loading ? "placeholder" : icon
  }) : icon, iconMarkup = iconSource ? /* @__PURE__ */ import_react52.default.createElement("span", {
    className: loading ? styles2.hidden : styles2.Icon
  }, iconSource) : null, hasPlainText = ["plain", "monochromePlain"].includes(variant), textFontWeight = "medium";
  hasPlainText ? textFontWeight = "regular" : variant === "primary" && (textFontWeight = mdUp ? "medium" : "semibold");
  let textVariant = "bodySm";
  (size2 === "large" || hasPlainText && size2 !== "micro") && (textVariant = "bodyMd");
  let childMarkup = children ? /* @__PURE__ */ import_react52.default.createElement(Text, {
    as: "span",
    variant: textVariant,
    fontWeight: textFontWeight,
    key: disabled ? "text-disabled" : "text"
  }, children) : null, spinnerSVGMarkup = loading ? /* @__PURE__ */ import_react52.default.createElement("span", {
    className: styles2.Spinner
  }, /* @__PURE__ */ import_react52.default.createElement(Spinner, {
    size: "small",
    accessibilityLabel: i18n.translate("Polaris.Button.spinnerAccessibilityLabel")
  })) : null, commonProps = {
    id,
    className,
    accessibilityLabel,
    ariaDescribedBy,
    role,
    onClick,
    onFocus,
    onBlur,
    onMouseUp: handleMouseUpByBlurring,
    onMouseEnter,
    onTouchStart,
    "data-primary-link": dataPrimaryLink
  }, linkProps = {
    url,
    external,
    download,
    target
  }, actionProps = {
    submit,
    disabled: isDisabled,
    loading,
    ariaControls,
    ariaExpanded,
    ariaChecked,
    pressed,
    onKeyDown,
    onKeyUp,
    onKeyPress,
    onPointerDown
  };
  return /* @__PURE__ */ import_react52.default.createElement(UnstyledButton, Object.assign({}, commonProps, linkProps, actionProps), spinnerSVGMarkup, iconMarkup, childMarkup, disclosureMarkup);
}
function isIconSource(x) {
  return typeof x == "string" || typeof x == "object" && x.body || typeof x == "function";
}
function getDisclosureIconSource(disclosure, upIcon, downIcon) {
  return disclosure === "select" ? SvgSelectIcon : disclosure === "up" ? upIcon : downIcon;
}

// node_modules/@shopify/polaris/build/esm/components/Button/utils.js
function buttonsFrom(actions, overrides = {}) {
  return Array.isArray(actions) ? actions.map((action8, index) => buttonFrom(action8, overrides, index)) : buttonFrom(actions, overrides);
}
function buttonFrom({
  content,
  onAction,
  plain,
  destructive,
  ...action8
}, overrides, key) {
  let plainVariant = plain ? "plain" : void 0, destructiveVariant = destructive ? "primary" : void 0, tone = !overrides?.tone && destructive ? "critical" : overrides?.tone;
  return /* @__PURE__ */ import_react53.default.createElement(Button, Object.assign({
    key,
    onClick: onAction,
    tone,
    variant: plainVariant || destructiveVariant
  }, action8, overrides), content);
}

// node_modules/@shopify/polaris/build/esm/components/Card/Card.js
var import_react56 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ShadowBevel/ShadowBevel.js
var import_react54 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ShadowBevel/ShadowBevel.css.js
var styles6 = {
  ShadowBevel: "Polaris-ShadowBevel"
};

// node_modules/@shopify/polaris/build/esm/components/ShadowBevel/ShadowBevel.js
function ShadowBevel(props) {
  let {
    as = "div",
    bevel = !0,
    borderRadius,
    boxShadow,
    children,
    zIndex: zIndex2 = "0"
  } = props, Component5 = as;
  return /* @__PURE__ */ import_react54.default.createElement(Component5, {
    className: styles6.ShadowBevel,
    style: {
      "--pc-shadow-bevel-z-index": zIndex2,
      ...getResponsiveValue("shadow-bevel", "content", mapResponsiveProp(bevel, (bevel2) => bevel2 ? '""' : "none")),
      ...getResponsiveValue("shadow-bevel", "box-shadow", mapResponsiveProp(bevel, (bevel2) => bevel2 ? `var(--p-shadow-${boxShadow})` : "none")),
      ...getResponsiveValue("shadow-bevel", "border-radius", mapResponsiveProp(bevel, (bevel2) => bevel2 ? `var(--p-border-radius-${borderRadius})` : "var(--p-border-radius-0)"))
    }
  }, children);
}
function mapResponsiveProp(responsiveProp, callback2) {
  return typeof responsiveProp == "boolean" ? callback2(responsiveProp) : Object.fromEntries(Object.entries(responsiveProp).map(([breakpointsAlias, value]) => [breakpointsAlias, callback2(value)]));
}

// node_modules/@shopify/polaris/build/esm/components/Box/Box.js
var import_react55 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Box/Box.css.js
var styles7 = {
  listReset: "Polaris-Box--listReset",
  Box: "Polaris-Box",
  visuallyHidden: "Polaris-Box--visuallyHidden",
  printHidden: "Polaris-Box--printHidden"
};

// node_modules/@shopify/polaris/build/esm/components/Box/Box.js
var Box = /* @__PURE__ */ (0, import_react55.forwardRef)(({
  as = "div",
  background,
  borderColor,
  borderStyle,
  borderWidth,
  borderBlockStartWidth,
  borderBlockEndWidth,
  borderInlineStartWidth,
  borderInlineEndWidth,
  borderRadius,
  borderEndStartRadius,
  borderEndEndRadius,
  borderStartStartRadius,
  borderStartEndRadius,
  children,
  color: color2,
  id,
  minHeight,
  minWidth,
  maxWidth,
  overflowX,
  overflowY,
  outlineColor,
  outlineStyle,
  outlineWidth,
  padding,
  paddingBlock,
  paddingBlockStart,
  paddingBlockEnd,
  paddingInline,
  paddingInlineStart,
  paddingInlineEnd,
  role,
  shadow: shadow2,
  tabIndex,
  width: width2,
  printHidden,
  visuallyHidden,
  position,
  insetBlockStart,
  insetBlockEnd,
  insetInlineStart,
  insetInlineEnd,
  zIndex: zIndex2,
  opacity,
  ...restProps
}, ref) => {
  let borderStyleValue = borderStyle || (borderColor || borderWidth || borderBlockStartWidth || borderBlockEndWidth || borderInlineStartWidth || borderInlineEndWidth ? "solid" : void 0), outlineStyleValue = outlineStyle || (outlineColor || outlineWidth ? "solid" : void 0), style = {
    "--pc-box-color": color2 ? `var(--p-color-${color2})` : void 0,
    "--pc-box-background": background ? `var(--p-color-${background})` : void 0,
    // eslint-disable-next-line no-nested-ternary
    "--pc-box-border-color": borderColor ? borderColor === "transparent" ? "transparent" : `var(--p-color-${borderColor})` : void 0,
    "--pc-box-border-style": borderStyleValue,
    "--pc-box-border-radius": borderRadius ? `var(--p-border-radius-${borderRadius})` : void 0,
    "--pc-box-border-end-start-radius": borderEndStartRadius ? `var(--p-border-radius-${borderEndStartRadius})` : void 0,
    "--pc-box-border-end-end-radius": borderEndEndRadius ? `var(--p-border-radius-${borderEndEndRadius})` : void 0,
    "--pc-box-border-start-start-radius": borderStartStartRadius ? `var(--p-border-radius-${borderStartStartRadius})` : void 0,
    "--pc-box-border-start-end-radius": borderStartEndRadius ? `var(--p-border-radius-${borderStartEndRadius})` : void 0,
    "--pc-box-border-width": borderWidth ? `var(--p-border-width-${borderWidth})` : void 0,
    "--pc-box-border-block-start-width": borderBlockStartWidth ? `var(--p-border-width-${borderBlockStartWidth})` : void 0,
    "--pc-box-border-block-end-width": borderBlockEndWidth ? `var(--p-border-width-${borderBlockEndWidth})` : void 0,
    "--pc-box-border-inline-start-width": borderInlineStartWidth ? `var(--p-border-width-${borderInlineStartWidth})` : void 0,
    "--pc-box-border-inline-end-width": borderInlineEndWidth ? `var(--p-border-width-${borderInlineEndWidth})` : void 0,
    "--pc-box-min-height": minHeight,
    "--pc-box-min-width": minWidth,
    "--pc-box-max-width": maxWidth,
    "--pc-box-outline-color": outlineColor ? `var(--p-color-${outlineColor})` : void 0,
    "--pc-box-outline-style": outlineStyleValue,
    "--pc-box-outline-width": outlineWidth ? `var(--p-border-width-${outlineWidth})` : void 0,
    "--pc-box-overflow-x": overflowX,
    "--pc-box-overflow-y": overflowY,
    ...getResponsiveProps("box", "padding-block-start", "space", paddingBlockStart || paddingBlock || padding),
    ...getResponsiveProps("box", "padding-block-end", "space", paddingBlockEnd || paddingBlock || padding),
    ...getResponsiveProps("box", "padding-inline-start", "space", paddingInlineStart || paddingInline || padding),
    ...getResponsiveProps("box", "padding-inline-end", "space", paddingInlineEnd || paddingInline || padding),
    "--pc-box-shadow": shadow2 ? `var(--p-shadow-${shadow2})` : void 0,
    "--pc-box-width": width2,
    position,
    "--pc-box-inset-block-start": insetBlockStart ? `var(--p-space-${insetBlockStart})` : void 0,
    "--pc-box-inset-block-end": insetBlockEnd ? `var(--p-space-${insetBlockEnd})` : void 0,
    "--pc-box-inset-inline-start": insetInlineStart ? `var(--p-space-${insetInlineStart})` : void 0,
    "--pc-box-inset-inline-end": insetInlineEnd ? `var(--p-space-${insetInlineEnd})` : void 0,
    zIndex: zIndex2,
    opacity
  }, className = classNames(styles7.Box, visuallyHidden && styles7.visuallyHidden, printHidden && styles7.printHidden, as === "ul" && styles7.listReset);
  return /* @__PURE__ */ import_react55.default.createElement(as, {
    className,
    id,
    ref,
    style: sanitizeCustomProperties(style),
    role,
    tabIndex,
    ...restProps
  }, children);
});
Box.displayName = "Box";

// node_modules/@shopify/polaris/build/esm/components/Card/Card.js
var Card = ({
  children,
  background = "bg-surface",
  padding = {
    xs: "400"
  },
  roundedAbove = "sm"
}) => {
  let breakpoints2 = useBreakpoints(), defaultBorderRadius = "300", hasBorderRadius = Boolean(breakpoints2[`${roundedAbove}Up`]);
  return /* @__PURE__ */ import_react56.default.createElement(WithinContentContext.Provider, {
    value: !0
  }, /* @__PURE__ */ import_react56.default.createElement(ShadowBevel, {
    boxShadow: "100",
    borderRadius: hasBorderRadius ? defaultBorderRadius : "0",
    zIndex: "32"
  }, /* @__PURE__ */ import_react56.default.createElement(Box, {
    background,
    padding,
    overflowX: "clip",
    overflowY: "clip",
    minHeight: "100%"
  }, children)));
};

// node_modules/@shopify/polaris/build/esm/components/InlineStack/InlineStack.js
var import_react57 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/InlineStack/InlineStack.css.js
var styles8 = {
  InlineStack: "Polaris-InlineStack"
};

// node_modules/@shopify/polaris/build/esm/components/InlineStack/InlineStack.js
var InlineStack = function({
  as: Element2 = "div",
  align,
  direction = "row",
  blockAlign,
  gap,
  wrap = !0,
  children
}) {
  let style = {
    "--pc-inline-stack-align": align,
    "--pc-inline-stack-block-align": blockAlign,
    "--pc-inline-stack-wrap": wrap ? "wrap" : "nowrap",
    ...getResponsiveProps("inline-stack", "gap", "space", gap),
    ...getResponsiveValue("inline-stack", "flex-direction", direction)
  };
  return /* @__PURE__ */ import_react57.default.createElement(Element2, {
    className: styles8.InlineStack,
    style
  }, children);
};

// node_modules/@shopify/polaris/build/esm/components/BlockStack/BlockStack.js
var import_react58 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/BlockStack/BlockStack.css.js
var styles9 = {
  BlockStack: "Polaris-BlockStack",
  listReset: "Polaris-BlockStack--listReset",
  fieldsetReset: "Polaris-BlockStack--fieldsetReset"
};

// node_modules/@shopify/polaris/build/esm/components/BlockStack/BlockStack.js
var BlockStack = ({
  as = "div",
  children,
  align,
  inlineAlign,
  gap,
  id,
  reverseOrder = !1,
  ...restProps
}) => {
  let className = classNames(styles9.BlockStack, (as === "ul" || as === "ol") && styles9.listReset, as === "fieldset" && styles9.fieldsetReset), style = {
    "--pc-block-stack-align": align ? `${align}` : null,
    "--pc-block-stack-inline-align": inlineAlign ? `${inlineAlign}` : null,
    "--pc-block-stack-order": reverseOrder ? "column-reverse" : "column",
    ...getResponsiveProps("block-stack", "gap", "space", gap)
  };
  return /* @__PURE__ */ import_react58.default.createElement(as, {
    className,
    id,
    style: sanitizeCustomProperties(style),
    ...restProps
  }, children);
};

// node_modules/@shopify/polaris/build/esm/components/Image/Image.js
var import_react59 = __toESM(require_react());
function Image({
  alt,
  sourceSet,
  source,
  crossOrigin,
  onLoad,
  className,
  ...rest
}) {
  let finalSourceSet = sourceSet ? sourceSet.map(({
    source: subSource,
    descriptor
  }) => `${subSource} ${descriptor}`).join(",") : null, handleLoad = (0, import_react59.useCallback)(() => {
    onLoad && onLoad();
  }, [onLoad]);
  return /* @__PURE__ */ import_react59.default.createElement("img", Object.assign({
    alt,
    src: source,
    crossOrigin,
    className,
    onLoad: handleLoad
  }, finalSourceSet ? {
    srcSet: finalSourceSet
  } : {}, rest));
}

// node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.js
var import_react87 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/FilterActionsProvider/FilterActionsProvider.js
var import_react60 = __toESM(require_react()), FilterActionsContext = /* @__PURE__ */ (0, import_react60.createContext)(!1);
function FilterActionsProvider({
  children,
  filterActions
}) {
  return /* @__PURE__ */ import_react60.default.createElement(FilterActionsContext.Provider, {
    value: filterActions
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/ActionList/components/Section/Section.js
var import_react77 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionList/components/Item/Item.js
var import_react76 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.css.js
var styles10 = {
  Item: "Polaris-ActionList__Item",
  default: "Polaris-ActionList--default",
  active: "Polaris-ActionList--active",
  destructive: "Polaris-ActionList--destructive",
  disabled: "Polaris-ActionList--disabled",
  Prefix: "Polaris-ActionList__Prefix",
  Suffix: "Polaris-ActionList__Suffix",
  indented: "Polaris-ActionList--indented",
  menu: "Polaris-ActionList--menu",
  Text: "Polaris-ActionList__Text"
};

// node_modules/@shopify/polaris/build/esm/components/Badge/Badge.js
var import_react63 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/within-filter-context.js
var import_react61 = __toESM(require_react()), WithinFilterContext = /* @__PURE__ */ (0, import_react61.createContext)(!1);

// node_modules/@shopify/polaris/build/esm/components/Badge/Badge.css.js
var styles11 = {
  Badge: "Polaris-Badge",
  toneSuccess: "Polaris-Badge--toneSuccess",
  "toneSuccess-strong": "Polaris-Badge__toneSuccess--strong",
  toneInfo: "Polaris-Badge--toneInfo",
  "toneInfo-strong": "Polaris-Badge__toneInfo--strong",
  toneAttention: "Polaris-Badge--toneAttention",
  "toneAttention-strong": "Polaris-Badge__toneAttention--strong",
  toneWarning: "Polaris-Badge--toneWarning",
  "toneWarning-strong": "Polaris-Badge__toneWarning--strong",
  toneCritical: "Polaris-Badge--toneCritical",
  "toneCritical-strong": "Polaris-Badge__toneCritical--strong",
  toneNew: "Polaris-Badge--toneNew",
  toneMagic: "Polaris-Badge--toneMagic",
  "toneRead-only": "Polaris-Badge__toneRead--only",
  toneEnabled: "Polaris-Badge--toneEnabled",
  sizeLarge: "Polaris-Badge--sizeLarge",
  withinFilter: "Polaris-Badge--withinFilter",
  Icon: "Polaris-Badge__Icon",
  PipContainer: "Polaris-Badge__PipContainer"
};

// node_modules/@shopify/polaris/build/esm/components/Badge/types.js
var ToneValue;
(function(ToneValue2) {
  ToneValue2.Info = "info", ToneValue2.Success = "success", ToneValue2.Warning = "warning", ToneValue2.Critical = "critical", ToneValue2.Attention = "attention", ToneValue2.New = "new", ToneValue2.Magic = "magic", ToneValue2.InfoStrong = "info-strong", ToneValue2.SuccessStrong = "success-strong", ToneValue2.WarningStrong = "warning-strong", ToneValue2.CriticalStrong = "critical-strong", ToneValue2.AttentionStrong = "attention-strong", ToneValue2.ReadOnly = "read-only", ToneValue2.Enabled = "enabled";
})(ToneValue || (ToneValue = {}));
var ProgressValue;
(function(ProgressValue2) {
  ProgressValue2.Incomplete = "incomplete", ProgressValue2.PartiallyComplete = "partiallyComplete", ProgressValue2.Complete = "complete";
})(ProgressValue || (ProgressValue = {}));

// node_modules/@shopify/polaris/build/esm/components/Badge/utils.js
function getDefaultAccessibilityLabel(i18n, progress, tone) {
  let progressLabel = "", toneLabel = "";
  if (!progress && !tone)
    return "";
  switch (progress) {
    case ProgressValue.Incomplete:
      progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.incomplete");
      break;
    case ProgressValue.PartiallyComplete:
      progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.partiallyComplete");
      break;
    case ProgressValue.Complete:
      progressLabel = i18n.translate("Polaris.Badge.PROGRESS_LABELS.complete");
      break;
  }
  switch (tone) {
    case ToneValue.Info:
    case ToneValue.InfoStrong:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.info");
      break;
    case ToneValue.Success:
    case ToneValue.SuccessStrong:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.success");
      break;
    case ToneValue.Warning:
    case ToneValue.WarningStrong:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.warning");
      break;
    case ToneValue.Critical:
    case ToneValue.CriticalStrong:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.critical");
      break;
    case ToneValue.Attention:
    case ToneValue.AttentionStrong:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.attention");
      break;
    case ToneValue.New:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.new");
      break;
    case ToneValue.ReadOnly:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.readOnly");
      break;
    case ToneValue.Enabled:
      toneLabel = i18n.translate("Polaris.Badge.TONE_LABELS.enabled");
      break;
  }
  return !tone && progress ? progressLabel : tone && !progress ? toneLabel : i18n.translate("Polaris.Badge.progressAndTone", {
    progressLabel,
    toneLabel
  });
}

// node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.js
var import_react62 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.css.js
var styles12 = {
  Pip: "Polaris-Badge-Pip",
  toneInfo: "Polaris-Badge-Pip--toneInfo",
  toneSuccess: "Polaris-Badge-Pip--toneSuccess",
  toneNew: "Polaris-Badge-Pip--toneNew",
  toneAttention: "Polaris-Badge-Pip--toneAttention",
  toneWarning: "Polaris-Badge-Pip--toneWarning",
  toneCritical: "Polaris-Badge-Pip--toneCritical",
  progressIncomplete: "Polaris-Badge-Pip--progressIncomplete",
  progressPartiallyComplete: "Polaris-Badge-Pip--progressPartiallyComplete",
  progressComplete: "Polaris-Badge-Pip--progressComplete"
};

// node_modules/@shopify/polaris/build/esm/components/Badge/components/Pip/Pip.js
function Pip({
  tone,
  progress = "complete",
  accessibilityLabelOverride
}) {
  let i18n = useI18n(), className = classNames(styles12.Pip, tone && styles12[variationName("tone", tone)], progress && styles12[variationName("progress", progress)]), accessibilityLabel = accessibilityLabelOverride || getDefaultAccessibilityLabel(i18n, progress, tone);
  return /* @__PURE__ */ import_react62.default.createElement("span", {
    className
  }, /* @__PURE__ */ import_react62.default.createElement(Text, {
    as: "span",
    visuallyHidden: !0
  }, accessibilityLabel));
}

// node_modules/@shopify/polaris/build/esm/components/Badge/Badge.js
var DEFAULT_SIZE = "medium", progressIconMap = {
  complete: () => /* @__PURE__ */ import_react63.default.createElement("svg", {
    viewBox: "0 0 20 20"
  }, /* @__PURE__ */ import_react63.default.createElement("path", {
    d: "M6 10c0-.93 0-1.395.102-1.776a3 3 0 0 1 2.121-2.122C8.605 6 9.07 6 10 6c.93 0 1.395 0 1.776.102a3 3 0 0 1 2.122 2.122C14 8.605 14 9.07 14 10s0 1.395-.102 1.777a3 3 0 0 1-2.122 2.12C11.395 14 10.93 14 10 14s-1.395 0-1.777-.102a3 3 0 0 1-2.12-2.121C6 11.395 6 10.93 6 10Z"
  })),
  partiallyComplete: () => /* @__PURE__ */ import_react63.default.createElement("svg", {
    viewBox: "0 0 20 20"
  }, /* @__PURE__ */ import_react63.default.createElement("path", {
    fillRule: "evenodd",
    d: "m8.888 6.014-.017-.018-.02.02c-.253.013-.45.038-.628.086a3 3 0 0 0-2.12 2.122C6 8.605 6 9.07 6 10s0 1.395.102 1.777a3 3 0 0 0 2.121 2.12C8.605 14 9.07 14 10 14c.93 0 1.395 0 1.776-.102a3 3 0 0 0 2.122-2.121C14 11.395 14 10.93 14 10c0-.93 0-1.395-.102-1.776a3 3 0 0 0-2.122-2.122C11.395 6 10.93 6 10 6c-.475 0-.829 0-1.112.014ZM8.446 7.34a1.75 1.75 0 0 0-1.041.94l4.314 4.315c.443-.2.786-.576.941-1.042L8.446 7.34Zm4.304 2.536L10.124 7.25c.908.001 1.154.013 1.329.06a1.75 1.75 0 0 1 1.237 1.237c.047.175.059.42.06 1.329ZM8.547 12.69c.182.05.442.06 1.453.06h.106L7.25 9.894V10c0 1.01.01 1.27.06 1.453a1.75 1.75 0 0 0 1.237 1.237Z"
  })),
  incomplete: () => /* @__PURE__ */ import_react63.default.createElement("svg", {
    viewBox: "0 0 20 20"
  }, /* @__PURE__ */ import_react63.default.createElement("path", {
    fillRule: "evenodd",
    d: "M8.547 12.69c.183.05.443.06 1.453.06s1.27-.01 1.453-.06a1.75 1.75 0 0 0 1.237-1.237c.05-.182.06-.443.06-1.453s-.01-1.27-.06-1.453a1.75 1.75 0 0 0-1.237-1.237c-.182-.05-.443-.06-1.453-.06s-1.27.01-1.453.06A1.75 1.75 0 0 0 7.31 8.547c-.05.183-.06.443-.06 1.453s.01 1.27.06 1.453a1.75 1.75 0 0 0 1.237 1.237ZM6.102 8.224C6 8.605 6 9.07 6 10s0 1.395.102 1.777a3 3 0 0 0 2.122 2.12C8.605 14 9.07 14 10 14s1.395 0 1.777-.102a3 3 0 0 0 2.12-2.121C14 11.395 14 10.93 14 10c0-.93 0-1.395-.102-1.776a3 3 0 0 0-2.121-2.122C11.395 6 10.93 6 10 6c-.93 0-1.395 0-1.776.102a3 3 0 0 0-2.122 2.122Z"
  }))
};
function Badge({
  children,
  tone,
  progress,
  icon,
  size: size2 = DEFAULT_SIZE,
  toneAndProgressLabelOverride
}) {
  let i18n = useI18n(), withinFilter = (0, import_react63.useContext)(WithinFilterContext), className = classNames(styles11.Badge, tone && styles11[variationName("tone", tone)], size2 && size2 !== DEFAULT_SIZE && styles11[variationName("size", size2)], withinFilter && styles11.withinFilter), accessibilityLabel = toneAndProgressLabelOverride || getDefaultAccessibilityLabel(i18n, progress, tone), accessibilityMarkup = Boolean(accessibilityLabel) && /* @__PURE__ */ import_react63.default.createElement(Text, {
    as: "span",
    visuallyHidden: !0
  }, accessibilityLabel);
  return progress && !icon && (accessibilityMarkup = /* @__PURE__ */ import_react63.default.createElement("span", {
    className: styles11.Icon
  }, /* @__PURE__ */ import_react63.default.createElement(Icon, {
    accessibilityLabel,
    source: progressIconMap[progress]
  }))), /* @__PURE__ */ import_react63.default.createElement("span", {
    className
  }, accessibilityMarkup, icon && /* @__PURE__ */ import_react63.default.createElement("span", {
    className: styles11.Icon
  }, /* @__PURE__ */ import_react63.default.createElement(Icon, {
    source: icon
  })), children && /* @__PURE__ */ import_react63.default.createElement(Text, {
    as: "span",
    variant: "bodySm",
    fontWeight: tone === "new" ? "medium" : void 0
  }, children));
}
Badge.Pip = Pip;

// node_modules/@shopify/polaris/build/esm/components/Tooltip/Tooltip.js
var import_react75 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-toggle.js
var import_react64 = __toESM(require_react());
function useToggle(initialState) {
  let [value, setState] = (0, import_react64.useState)(initialState);
  return {
    value,
    toggle: (0, import_react64.useCallback)(() => setState((state) => !state), []),
    setTrue: (0, import_react64.useCallback)(() => setState(!0), []),
    setFalse: (0, import_react64.useCallback)(() => setState(!1), [])
  };
}

// node_modules/@shopify/polaris/build/esm/components/Tooltip/Tooltip.css.js
var styles13 = {
  TooltipContainer: "Polaris-Tooltip__TooltipContainer",
  HasUnderline: "Polaris-Tooltip__HasUnderline"
};

// node_modules/@shopify/polaris/build/esm/utilities/ephemeral-presence-manager/hooks.js
var import_react65 = __toESM(require_react());
function useEphemeralPresenceManager() {
  let ephemeralPresenceManager = (0, import_react65.useContext)(EphemeralPresenceManagerContext);
  if (!ephemeralPresenceManager)
    throw new Error("No ephemeral presence manager was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.");
  return ephemeralPresenceManager;
}

// node_modules/@shopify/polaris/build/esm/components/Portal/Portal.js
var import_react67 = __toESM(require_react()), import_react_dom = __toESM(require_react_dom());

// node_modules/@shopify/polaris/build/esm/utilities/portals/hooks.js
var import_react66 = __toESM(require_react());
function usePortalsManager() {
  let portalsManager = (0, import_react66.useContext)(PortalsManagerContext);
  if (!portalsManager)
    throw new Error("No portals manager was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.");
  return portalsManager;
}

// node_modules/@shopify/polaris/build/esm/components/Portal/Portal.js
function Portal({
  children,
  idPrefix = "",
  onPortalCreated = noop2
}) {
  let themeName = useThemeName(), {
    container
  } = usePortalsManager(), uniqueId = (0, import_react67.useId)(), portalId = idPrefix !== "" ? `${idPrefix}-${uniqueId}` : uniqueId;
  return (0, import_react67.useEffect)(() => {
    onPortalCreated();
  }, [onPortalCreated]), container ? /* @__PURE__ */ (0, import_react_dom.createPortal)(/* @__PURE__ */ import_react67.default.createElement(ThemeProvider, {
    theme: isThemeNameLocal(themeName) ? themeName : themeNameDefault,
    "data-portal-id": portalId
  }, children), container) : null;
}
function noop2() {
}

// node_modules/@shopify/polaris/build/esm/components/Tooltip/components/TooltipOverlay/TooltipOverlay.js
var import_react74 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Tooltip/components/TooltipOverlay/TooltipOverlay.css.js
var styles14 = {
  TooltipOverlay: "Polaris-Tooltip-TooltipOverlay",
  Tail: "Polaris-Tooltip-TooltipOverlay__Tail",
  positionedAbove: "Polaris-Tooltip-TooltipOverlay--positionedAbove",
  measuring: "Polaris-Tooltip-TooltipOverlay--measuring",
  measured: "Polaris-Tooltip-TooltipOverlay--measured",
  instant: "Polaris-Tooltip-TooltipOverlay--instant",
  Content: "Polaris-Tooltip-TooltipOverlay__Content",
  default: "Polaris-Tooltip-TooltipOverlay--default",
  wide: "Polaris-Tooltip-TooltipOverlay--wide"
};

// node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js
var import_react73 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/utilities/math.js
function calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset = 0) {
  let activatorTop = activatorRect.top, activatorBottom = activatorTop + activatorRect.height, spaceAbove = activatorRect.top - topBarOffset, spaceBelow = containerRect.height - activatorRect.top - activatorRect.height, desiredHeight = overlayRect.height, verticalMargins = overlayMargins.activator + overlayMargins.container, minimumSpaceToScroll = overlayMargins.container, distanceToTopScroll = activatorRect.top - Math.max(scrollableContainerRect.top, 0), distanceToBottomScroll = containerRect.top + Math.min(containerRect.height, scrollableContainerRect.top + scrollableContainerRect.height) - (activatorRect.top + activatorRect.height), enoughSpaceFromTopScroll = distanceToTopScroll >= minimumSpaceToScroll, enoughSpaceFromBottomScroll = distanceToBottomScroll >= minimumSpaceToScroll, heightIfAbove = Math.min(spaceAbove, desiredHeight), heightIfBelow = Math.min(spaceBelow, desiredHeight), heightIfAboveCover = Math.min(spaceAbove + activatorRect.height, desiredHeight), heightIfBelowCover = Math.min(spaceBelow + activatorRect.height, desiredHeight), containerRectTop = fixed ? 0 : containerRect.top, positionIfAbove = {
    height: heightIfAbove - verticalMargins,
    top: activatorTop + containerRectTop - heightIfAbove,
    positioning: "above"
  }, positionIfBelow = {
    height: heightIfBelow - verticalMargins,
    top: activatorBottom + containerRectTop,
    positioning: "below"
  }, positionIfCoverBelow = {
    height: heightIfBelowCover - verticalMargins,
    top: activatorTop + containerRectTop,
    positioning: "cover"
  }, positionIfCoverAbove = {
    height: heightIfAboveCover - verticalMargins,
    top: activatorTop + containerRectTop - heightIfAbove + activatorRect.height + verticalMargins,
    positioning: "cover"
  };
  return preferredPosition === "above" ? (enoughSpaceFromTopScroll || distanceToTopScroll >= distanceToBottomScroll && !enoughSpaceFromBottomScroll) && (spaceAbove > desiredHeight || spaceAbove > spaceBelow) ? positionIfAbove : positionIfBelow : preferredPosition === "below" ? (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow > desiredHeight || spaceBelow > spaceAbove) ? positionIfBelow : positionIfAbove : preferredPosition === "cover" ? (enoughSpaceFromBottomScroll || distanceToBottomScroll >= distanceToTopScroll && !enoughSpaceFromTopScroll) && (spaceBelow + activatorRect.height > desiredHeight || spaceBelow > spaceAbove) ? positionIfCoverBelow : positionIfCoverAbove : enoughSpaceFromTopScroll && enoughSpaceFromBottomScroll ? spaceAbove > spaceBelow ? positionIfAbove : positionIfBelow : distanceToTopScroll > minimumSpaceToScroll ? positionIfAbove : positionIfBelow;
}
function calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment) {
  let maximum = containerRect.width - overlayRect.width;
  if (preferredAlignment === "left")
    return Math.min(maximum, Math.max(0, activatorRect.left - overlayMargins.horizontal));
  if (preferredAlignment === "right") {
    let activatorRight = containerRect.width - (activatorRect.left + activatorRect.width);
    return Math.min(maximum, Math.max(0, activatorRight - overlayMargins.horizontal));
  }
  return Math.min(maximum, Math.max(0, activatorRect.center.x - overlayRect.width / 2));
}
function rectIsOutsideOfRect(inner, outer) {
  let {
    center
  } = inner;
  return center.y < outer.top || center.y > outer.top + outer.height;
}
function intersectionWithViewport(rect, viewport = windowRect()) {
  let top = Math.max(rect.top, 0), left = Math.max(rect.left, 0), bottom = Math.min(rect.top + rect.height, viewport.height), right = Math.min(rect.left + rect.width, viewport.width);
  return new Rect({
    top,
    left,
    height: bottom - top,
    width: right - left
  });
}
function windowRect() {
  return new Rect({
    top: window.scrollY,
    left: window.scrollX,
    height: window.innerHeight,
    width: document.body.clientWidth
  });
}

// node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.css.js
var styles15 = {
  PositionedOverlay: "Polaris-PositionedOverlay",
  fixed: "Polaris-PositionedOverlay--fixed",
  calculating: "Polaris-PositionedOverlay--calculating",
  preventInteraction: "Polaris-PositionedOverlay--preventInteraction"
};

// node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.js
var import_react72 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-lazy-ref.js
var import_react68 = __toESM(require_react()), UNIQUE_IDENTIFIER = Symbol("unique_identifier");
function useLazyRef(initialValue) {
  let lazyRef = (0, import_react68.useRef)(UNIQUE_IDENTIFIER);
  return lazyRef.current === UNIQUE_IDENTIFIER && (lazyRef.current = initialValue()), lazyRef;
}

// node_modules/@shopify/polaris/build/esm/utilities/use-component-did-mount.js
var import_react69 = __toESM(require_react());
function useComponentDidMount(callback2) {
  let isAfterInitialMount = useIsAfterInitialMount(), hasInvokedLifeCycle = (0, import_react69.useRef)(!1);
  if (isAfterInitialMount && !hasInvokedLifeCycle.current)
    return hasInvokedLifeCycle.current = !0, callback2();
}

// node_modules/@shopify/polaris/build/esm/components/Scrollable/context.js
var import_react70 = __toESM(require_react()), ScrollableContext = /* @__PURE__ */ (0, import_react70.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.css.js
var styles16 = {
  Scrollable: "Polaris-Scrollable",
  hasTopShadow: "Polaris-Scrollable--hasTopShadow",
  hasBottomShadow: "Polaris-Scrollable--hasBottomShadow",
  horizontal: "Polaris-Scrollable--horizontal",
  vertical: "Polaris-Scrollable--vertical",
  scrollbarWidthThin: "Polaris-Scrollable--scrollbarWidthThin",
  scrollbarWidthNone: "Polaris-Scrollable--scrollbarWidthNone",
  scrollbarWidthAuto: "Polaris-Scrollable--scrollbarWidthAuto",
  scrollbarGutterStable: "Polaris-Scrollable--scrollbarGutterStable",
  "scrollbarGutterStableboth-edges": "Polaris-Scrollable__scrollbarGutterStableboth--edges"
};

// node_modules/@shopify/polaris/build/esm/components/Scrollable/components/ScrollTo/ScrollTo.js
var import_react71 = __toESM(require_react());
function ScrollTo() {
  let anchorNode = (0, import_react71.useRef)(null), scrollToPosition = (0, import_react71.useContext)(ScrollableContext);
  (0, import_react71.useEffect)(() => {
    !scrollToPosition || !anchorNode.current || scrollToPosition(anchorNode.current.offsetTop);
  }, [scrollToPosition]);
  let id = (0, import_react71.useId)();
  return /* @__PURE__ */ import_react71.default.createElement("a", {
    id,
    ref: anchorNode
  });
}

// node_modules/@shopify/polaris/build/esm/components/Scrollable/Scrollable.js
var MAX_SCROLL_HINT_DISTANCE = 100, LOW_RES_BUFFER = 2, ScrollableComponent = /* @__PURE__ */ (0, import_react72.forwardRef)(({
  children,
  className,
  horizontal = !0,
  vertical = !0,
  shadow: shadow2,
  hint,
  focusable,
  scrollbarWidth = "thin",
  scrollbarGutter,
  onScrolledToBottom,
  ...rest
}, forwardedRef) => {
  let [topShadow, setTopShadow] = (0, import_react72.useState)(!1), [bottomShadow, setBottomShadow] = (0, import_react72.useState)(!1), stickyManager = useLazyRef(() => new StickyManager()), scrollArea = (0, import_react72.useRef)(null), scrollTo = (0, import_react72.useCallback)((scrollY, options = {}) => {
    let optionsBehavior = options.behavior || "smooth", behavior = prefersReducedMotion() ? "auto" : optionsBehavior;
    scrollArea.current?.scrollTo({
      top: scrollY,
      behavior
    });
  }, []), defaultRef = (0, import_react72.useRef)();
  (0, import_react72.useImperativeHandle)(forwardedRef || defaultRef, () => ({
    scrollTo
  }));
  let handleScroll = (0, import_react72.useCallback)(() => {
    let currentScrollArea = scrollArea.current;
    currentScrollArea && requestAnimationFrame(() => {
      let {
        scrollTop,
        clientHeight,
        scrollHeight
      } = currentScrollArea, canScroll = Boolean(scrollHeight > clientHeight), isBelowTopOfScroll = Boolean(scrollTop > 0), isAtBottomOfScroll = Boolean(scrollTop + clientHeight >= scrollHeight - LOW_RES_BUFFER);
      setTopShadow(isBelowTopOfScroll), setBottomShadow(!isAtBottomOfScroll), canScroll && isAtBottomOfScroll && onScrolledToBottom && onScrolledToBottom();
    });
  }, [onScrolledToBottom]);
  useComponentDidMount(() => {
    handleScroll(), hint && requestAnimationFrame(() => performScrollHint(scrollArea.current));
  }), (0, import_react72.useEffect)(() => {
    let currentScrollArea = scrollArea.current;
    if (!currentScrollArea)
      return;
    let handleResize = debounce(handleScroll, 50, {
      trailing: !0
    });
    return stickyManager.current?.setContainer(currentScrollArea), currentScrollArea.addEventListener("scroll", handleScroll), globalThis.addEventListener("resize", handleResize), () => {
      currentScrollArea.removeEventListener("scroll", handleScroll), globalThis.removeEventListener("resize", handleResize);
    };
  }, [stickyManager, handleScroll]);
  let finalClassName = classNames(className, styles16.Scrollable, vertical && styles16.vertical, horizontal && styles16.horizontal, shadow2 && topShadow && styles16.hasTopShadow, shadow2 && bottomShadow && styles16.hasBottomShadow, scrollbarWidth && styles16[variationName("scrollbarWidth", scrollbarWidth)], scrollbarGutter && styles16[variationName("scrollbarGutter", scrollbarGutter.replace(" ", ""))]);
  return /* @__PURE__ */ import_react72.default.createElement(ScrollableContext.Provider, {
    value: scrollTo
  }, /* @__PURE__ */ import_react72.default.createElement(StickyManagerContext.Provider, {
    value: stickyManager.current
  }, /* @__PURE__ */ import_react72.default.createElement("div", Object.assign({
    className: finalClassName
  }, scrollable.props, rest, {
    ref: scrollArea,
    tabIndex: focusable ? 0 : void 0
  }), children)));
});
ScrollableComponent.displayName = "Scrollable";
function prefersReducedMotion() {
  try {
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  } catch {
    return !1;
  }
}
function performScrollHint(elem) {
  if (!elem || prefersReducedMotion())
    return;
  let scrollableDistance = elem.scrollHeight - elem.clientHeight, distanceToPeek = Math.min(MAX_SCROLL_HINT_DISTANCE, scrollableDistance) - LOW_RES_BUFFER, goBackToTop = () => {
    requestAnimationFrame(() => {
      elem.scrollTop >= distanceToPeek && (elem.removeEventListener("scroll", goBackToTop), elem.scrollTo({
        top: 0,
        behavior: "smooth"
      }));
    });
  };
  elem.addEventListener("scroll", goBackToTop), elem.scrollTo({
    top: MAX_SCROLL_HINT_DISTANCE,
    behavior: "smooth"
  });
}
var forNode = (node) => {
  let closestElement = node.closest(scrollable.selector);
  return closestElement instanceof HTMLElement ? closestElement : document;
}, Scrollable = ScrollableComponent;
Scrollable.ScrollTo = ScrollTo;
Scrollable.forNode = forNode;

// node_modules/@shopify/polaris/build/esm/components/PositionedOverlay/PositionedOverlay.js
var OBSERVER_CONFIG = {
  childList: !0,
  subtree: !0,
  characterData: !0,
  attributeFilter: ["style"]
}, PositionedOverlay = class extends import_react73.PureComponent {
  constructor(props) {
    super(props), this.state = {
      measuring: !0,
      activatorRect: getRectForNode(this.props.activator),
      right: void 0,
      left: void 0,
      top: 0,
      height: 0,
      width: null,
      positioning: "below",
      zIndex: null,
      outsideScrollableContainer: !1,
      lockPosition: !1,
      chevronOffset: 0
    }, this.overlay = null, this.scrollableContainers = [], this.overlayDetails = () => {
      let {
        measuring,
        left,
        right,
        positioning,
        height: height2,
        activatorRect,
        chevronOffset
      } = this.state;
      return {
        measuring,
        left,
        right,
        desiredHeight: height2,
        positioning,
        activatorRect,
        chevronOffset
      };
    }, this.setOverlay = (node) => {
      this.overlay = node;
    }, this.setScrollableContainers = () => {
      let containers = [], scrollableContainer = Scrollable.forNode(this.props.activator);
      if (scrollableContainer)
        for (containers.push(scrollableContainer); scrollableContainer?.parentElement; )
          scrollableContainer = Scrollable.forNode(scrollableContainer.parentElement), containers.push(scrollableContainer);
      this.scrollableContainers = containers;
    }, this.registerScrollHandlers = () => {
      this.scrollableContainers.forEach((node) => {
        node.addEventListener("scroll", this.handleMeasurement);
      });
    }, this.unregisterScrollHandlers = () => {
      this.scrollableContainers.forEach((node) => {
        node.removeEventListener("scroll", this.handleMeasurement);
      });
    }, this.handleMeasurement = () => {
      let {
        lockPosition,
        top
      } = this.state;
      this.observer.disconnect(), this.setState(({
        left,
        top: top2,
        right
      }) => ({
        left,
        right,
        top: top2,
        height: 0,
        positioning: "below",
        measuring: !0
      }), () => {
        if (this.overlay == null || this.firstScrollableContainer == null)
          return;
        let {
          activator,
          preferredPosition = "below",
          preferredAlignment = "center",
          onScrollOut,
          fullWidth,
          fixed,
          preferInputActivator = !0
        } = this.props, preferredActivator = preferInputActivator && activator.querySelector("input") || activator, activatorRect = getRectForNode(preferredActivator), currentOverlayRect = getRectForNode(this.overlay), scrollableElement = isDocument2(this.firstScrollableContainer) ? document.body : this.firstScrollableContainer, scrollableContainerRect = getRectForNode(scrollableElement), overlayRect = fullWidth || preferredPosition === "cover" ? new Rect({
          ...currentOverlayRect,
          width: activatorRect.width
        }) : currentOverlayRect;
        scrollableElement === document.body && (scrollableContainerRect.height = document.body.scrollHeight);
        let topBarOffset = 0, topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);
        topBarElement && (topBarOffset = topBarElement.clientHeight);
        let overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {
          activator: 0,
          container: 0,
          horizontal: 0
        }, containerRect = windowRect(), zIndexForLayer = getZIndexForLayerFromNode(activator), zIndex2 = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1, verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset), horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment), chevronOffset = activatorRect.center.x - horizontalPosition + overlayMargins.horizontal * 2;
        this.setState({
          measuring: !1,
          activatorRect: getRectForNode(activator),
          left: preferredAlignment !== "right" ? horizontalPosition : void 0,
          right: preferredAlignment === "right" ? horizontalPosition : void 0,
          top: lockPosition ? top : verticalPosition.top,
          lockPosition: Boolean(fixed),
          height: verticalPosition.height || 0,
          width: fullWidth || preferredPosition === "cover" ? overlayRect.width : null,
          positioning: verticalPosition.positioning,
          outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
          zIndex: zIndex2,
          chevronOffset
        }, () => {
          this.overlay && (this.observer.observe(this.overlay, OBSERVER_CONFIG), this.observer.observe(activator, OBSERVER_CONFIG));
        });
      });
    }, this.observer = new MutationObserver(this.handleMeasurement);
  }
  componentDidMount() {
    this.setScrollableContainers(), this.scrollableContainers.length && !this.props.fixed && this.registerScrollHandlers(), this.handleMeasurement();
  }
  componentWillUnmount() {
    this.observer.disconnect(), this.scrollableContainers.length && !this.props.fixed && this.unregisterScrollHandlers();
  }
  componentDidUpdate() {
    let {
      outsideScrollableContainer,
      top
    } = this.state, {
      onScrollOut,
      active
    } = this.props;
    active && onScrollOut != null && top !== 0 && outsideScrollableContainer && onScrollOut();
  }
  render() {
    let {
      left,
      right,
      top,
      zIndex: zIndex2,
      width: width2
    } = this.state, {
      render,
      fixed,
      preventInteraction,
      classNames: propClassNames,
      zIndexOverride
    } = this.props, style = {
      top: top == null || isNaN(top) ? void 0 : top,
      left: left == null || isNaN(left) ? void 0 : left,
      right: right == null || isNaN(right) ? void 0 : right,
      width: width2 == null || isNaN(width2) ? void 0 : width2,
      zIndex: zIndexOverride || zIndex2 || void 0
    }, className = classNames(styles15.PositionedOverlay, fixed && styles15.fixed, preventInteraction && styles15.preventInteraction, propClassNames);
    return /* @__PURE__ */ import_react73.default.createElement("div", {
      className,
      style,
      ref: this.setOverlay
    }, /* @__PURE__ */ import_react73.default.createElement(EventListener, {
      event: "resize",
      handler: this.handleMeasurement
    }), render(this.overlayDetails()));
  }
  get firstScrollableContainer() {
    return this.scrollableContainers[0] ?? null;
  }
  forceUpdatePosition() {
    requestAnimationFrame(this.handleMeasurement);
  }
};
function getMarginsForNode(node) {
  let nodeStyles = window.getComputedStyle(node);
  return {
    activator: parseFloat(nodeStyles.marginTop || "0"),
    container: parseFloat(nodeStyles.marginBottom || "0"),
    horizontal: parseFloat(nodeStyles.marginLeft || "0")
  };
}
function getZIndexForLayerFromNode(node) {
  let layerNode = node.closest(layer.selector) || document.body, zIndex2 = layerNode === document.body ? "auto" : parseInt(window.getComputedStyle(layerNode).zIndex || "0", 10);
  return zIndex2 === "auto" || isNaN(zIndex2) ? null : zIndex2;
}
function isDocument2(node) {
  return node === document;
}

// node_modules/@shopify/polaris/build/esm/components/Tooltip/components/TooltipOverlay/TooltipOverlay.js
var tailUpPaths = /* @__PURE__ */ import_react74.default.createElement(import_react74.default.Fragment, null, /* @__PURE__ */ import_react74.default.createElement("path", {
  d: "M18.829 8.171 11.862.921A3 3 0 0 0 7.619.838L0 8.171h1.442l6.87-6.612a2 2 0 0 1 2.83.055l6.3 6.557h1.387Z",
  fill: "var(--p-color-tooltip-tail-up-border-experimental)"
}), /* @__PURE__ */ import_react74.default.createElement("path", {
  d: "M17.442 10.171h-16v-2l6.87-6.612a2 2 0 0 1 2.83.055l6.3 6.557v2Z",
  fill: "var(--p-color-bg-surface)"
})), tailDownPaths = /* @__PURE__ */ import_react74.default.createElement(import_react74.default.Fragment, null, /* @__PURE__ */ import_react74.default.createElement("path", {
  d: "m0 2 6.967 7.25a3 3 0 0 0 4.243.083L18.829 2h-1.442l-6.87 6.612a2 2 0 0 1-2.83-.055L1.387 2H0Z",
  fill: "var(--p-color-tooltip-tail-down-border-experimental)"
}), /* @__PURE__ */ import_react74.default.createElement("path", {
  d: "M1.387 0h16v2l-6.87 6.612a2 2 0 0 1-2.83-.055L1.387 2V0Z",
  fill: "var(--p-color-bg-surface)"
}));
function TooltipOverlay({
  active,
  activator,
  preferredPosition = "above",
  preventInteraction,
  id,
  children,
  accessibilityLabel,
  width: width2,
  padding,
  borderRadius,
  zIndexOverride,
  instant
}) {
  let i18n = useI18n();
  return active ? /* @__PURE__ */ import_react74.default.createElement(PositionedOverlay, {
    active,
    activator,
    preferredPosition,
    preventInteraction,
    render: renderTooltip,
    zIndexOverride
  }) : null;
  function renderTooltip(overlayDetails) {
    let {
      measuring,
      desiredHeight,
      positioning,
      chevronOffset
    } = overlayDetails, containerClassName = classNames(styles14.TooltipOverlay, measuring && styles14.measuring, !measuring && styles14.measured, instant && styles14.instant, positioning === "above" && styles14.positionedAbove), contentClassName = classNames(styles14.Content, width2 && styles14[width2]), contentStyles = measuring ? void 0 : {
      minHeight: desiredHeight
    }, style = {
      "--pc-tooltip-chevron-x-pos": `${chevronOffset}px`,
      "--pc-tooltip-border-radius": borderRadius ? `var(--p-border-radius-${borderRadius})` : void 0,
      "--pc-tooltip-padding": padding && padding === "default" ? "var(--p-space-100) var(--p-space-200)" : `var(--p-space-${padding})`
    };
    return /* @__PURE__ */ import_react74.default.createElement("div", Object.assign({
      style,
      className: containerClassName
    }, layer.props), /* @__PURE__ */ import_react74.default.createElement("svg", {
      className: styles14.Tail,
      width: "19",
      height: "11",
      fill: "none"
    }, positioning === "above" ? tailDownPaths : tailUpPaths), /* @__PURE__ */ import_react74.default.createElement("div", {
      id,
      role: "tooltip",
      className: contentClassName,
      style: {
        ...contentStyles,
        ...style
      },
      "aria-label": accessibilityLabel ? i18n.translate("Polaris.TooltipOverlay.accessibilityLabel", {
        label: accessibilityLabel
      }) : void 0
    }, children));
  }
}

// node_modules/@shopify/polaris/build/esm/components/Tooltip/Tooltip.js
var HOVER_OUT_TIMEOUT = 150;
function Tooltip({
  children,
  content,
  dismissOnMouseOut,
  active: originalActive,
  hoverDelay,
  preferredPosition = "above",
  activatorWrapper = "span",
  accessibilityLabel,
  width: width2 = "default",
  padding = "default",
  borderRadius: borderRadiusProp,
  zIndexOverride,
  hasUnderline,
  persistOnClick,
  onOpen,
  onClose
}) {
  let borderRadius = borderRadiusProp || "200", WrapperComponent = activatorWrapper, {
    value: active,
    setTrue: setActiveTrue,
    setFalse: handleBlur
  } = useToggle(Boolean(originalActive)), {
    value: persist,
    toggle: togglePersisting
  } = useToggle(Boolean(originalActive) && Boolean(persistOnClick)), [activatorNode, setActivatorNode] = (0, import_react75.useState)(null), {
    presenceList,
    addPresence,
    removePresence
  } = useEphemeralPresenceManager(), id = (0, import_react75.useId)(), activatorContainer = (0, import_react75.useRef)(null), mouseEntered = (0, import_react75.useRef)(!1), [shouldAnimate, setShouldAnimate] = (0, import_react75.useState)(Boolean(!originalActive)), hoverDelayTimeout = (0, import_react75.useRef)(null), hoverOutTimeout = (0, import_react75.useRef)(null), handleFocus = (0, import_react75.useCallback)(() => {
    originalActive !== !1 && setActiveTrue();
  }, [originalActive, setActiveTrue]);
  (0, import_react75.useEffect)(() => {
    let accessibilityNode = (activatorContainer.current ? findFirstFocusableNode(activatorContainer.current) : null) || activatorContainer.current;
    accessibilityNode && (accessibilityNode.tabIndex = 0, accessibilityNode.setAttribute("aria-describedby", id), accessibilityNode.setAttribute("data-polaris-tooltip-activator", "true"));
  }, [id, children]), (0, import_react75.useEffect)(() => () => {
    hoverDelayTimeout.current && clearTimeout(hoverDelayTimeout.current), hoverOutTimeout.current && clearTimeout(hoverOutTimeout.current);
  }, []);
  let handleOpen = (0, import_react75.useCallback)(() => {
    setShouldAnimate(!presenceList.tooltip && !active), onOpen?.(), addPresence("tooltip");
  }, [addPresence, presenceList.tooltip, onOpen, active]), handleClose = (0, import_react75.useCallback)(() => {
    onClose?.(), setShouldAnimate(!1), hoverOutTimeout.current = setTimeout(() => {
      removePresence("tooltip");
    }, HOVER_OUT_TIMEOUT);
  }, [removePresence, onClose]), handleKeyUp = (0, import_react75.useCallback)((event) => {
    event.key === "Escape" && (handleClose?.(), handleBlur(), persistOnClick && togglePersisting());
  }, [handleBlur, handleClose, persistOnClick, togglePersisting]);
  (0, import_react75.useEffect)(() => {
    originalActive === !1 && active && (handleClose(), handleBlur());
  }, [originalActive, active, handleClose, handleBlur]);
  let portal2 = activatorNode ? /* @__PURE__ */ import_react75.default.createElement(Portal, {
    idPrefix: "tooltip"
  }, /* @__PURE__ */ import_react75.default.createElement(TooltipOverlay, {
    id,
    preferredPosition,
    activator: activatorNode,
    active,
    accessibilityLabel,
    onClose: noop3,
    preventInteraction: dismissOnMouseOut,
    width: width2,
    padding,
    borderRadius,
    zIndexOverride,
    instant: !shouldAnimate
  }, /* @__PURE__ */ import_react75.default.createElement(Text, {
    as: "span",
    variant: "bodyMd"
  }, content))) : null, wrapperClassNames = classNames(activatorWrapper === "div" && styles13.TooltipContainer, hasUnderline && styles13.HasUnderline);
  return /* @__PURE__ */ import_react75.default.createElement(WrapperComponent, {
    onFocus: () => {
      handleOpen(), handleFocus();
    },
    onBlur: () => {
      handleClose(), handleBlur(), persistOnClick && togglePersisting();
    },
    onMouseLeave: handleMouseLeave,
    onMouseOver: handleMouseEnterFix,
    onMouseDown: persistOnClick ? togglePersisting : void 0,
    ref: setActivator,
    onKeyUp: handleKeyUp,
    className: wrapperClassNames
  }, children, portal2);
  function setActivator(node) {
    let activatorContainerRef = activatorContainer;
    if (node == null) {
      activatorContainerRef.current = null, setActivatorNode(null);
      return;
    }
    node.firstElementChild instanceof HTMLElement && setActivatorNode(node.firstElementChild), activatorContainerRef.current = node;
  }
  function handleMouseEnter() {
    mouseEntered.current = !0, hoverDelay && !presenceList.tooltip ? hoverDelayTimeout.current = setTimeout(() => {
      handleOpen(), handleFocus();
    }, hoverDelay) : (handleOpen(), handleFocus());
  }
  function handleMouseLeave() {
    hoverDelayTimeout.current && (clearTimeout(hoverDelayTimeout.current), hoverDelayTimeout.current = null), mouseEntered.current = !1, handleClose(), persist || handleBlur();
  }
  function handleMouseEnterFix() {
    !mouseEntered.current && handleMouseEnter();
  }
}
function noop3() {
}

// node_modules/@shopify/polaris/build/esm/components/ActionList/components/Item/Item.js
function Item({
  id,
  badge,
  content,
  accessibilityLabel,
  helpText,
  url,
  onAction,
  onMouseEnter,
  icon,
  image,
  prefix,
  suffix,
  disabled,
  external,
  destructive,
  ellipsis,
  truncate,
  active,
  role,
  variant = "default"
}) {
  let className = classNames(styles10.Item, disabled && styles10.disabled, destructive && styles10.destructive, active && styles10.active, variant === "default" && styles10.default, variant === "indented" && styles10.indented, variant === "menu" && styles10.menu), prefixMarkup = null;
  prefix ? prefixMarkup = /* @__PURE__ */ import_react76.default.createElement("span", {
    className: styles10.Prefix
  }, prefix) : icon ? prefixMarkup = /* @__PURE__ */ import_react76.default.createElement("span", {
    className: styles10.Prefix
  }, /* @__PURE__ */ import_react76.default.createElement(Icon, {
    source: icon
  })) : image && (prefixMarkup = /* @__PURE__ */ import_react76.default.createElement("span", {
    role: "presentation",
    className: styles10.Prefix,
    style: {
      backgroundImage: `url(${image}`
    }
  }));
  let contentText = content || "";
  truncate && content ? contentText = /* @__PURE__ */ import_react76.default.createElement(TruncateText, null, content) : ellipsis && (contentText = `${content}\u2026`);
  let contentMarkup = helpText ? /* @__PURE__ */ import_react76.default.createElement(import_react76.default.Fragment, null, /* @__PURE__ */ import_react76.default.createElement(Box, null, contentText), /* @__PURE__ */ import_react76.default.createElement(Text, {
    as: "span",
    variant: "bodySm",
    tone: active || disabled ? void 0 : "subdued"
  }, helpText)) : /* @__PURE__ */ import_react76.default.createElement(Text, {
    as: "span",
    variant: "bodyMd",
    fontWeight: active ? "semibold" : "regular"
  }, contentText), badgeMarkup = badge && /* @__PURE__ */ import_react76.default.createElement("span", {
    className: styles10.Suffix
  }, /* @__PURE__ */ import_react76.default.createElement(Badge, {
    tone: badge.tone
  }, badge.content)), suffixMarkup = suffix && /* @__PURE__ */ import_react76.default.createElement(Box, null, /* @__PURE__ */ import_react76.default.createElement("span", {
    className: styles10.Suffix
  }, suffix)), textMarkup = /* @__PURE__ */ import_react76.default.createElement("span", {
    className: styles10.Text
  }, /* @__PURE__ */ import_react76.default.createElement(Text, {
    as: "span",
    variant: "bodyMd",
    fontWeight: active ? "semibold" : "regular"
  }, contentMarkup)), contentElement = /* @__PURE__ */ import_react76.default.createElement(InlineStack, {
    blockAlign: "center",
    gap: "150",
    wrap: !1
  }, prefixMarkup, textMarkup, badgeMarkup, suffixMarkup), contentWrapper = /* @__PURE__ */ import_react76.default.createElement(Box, {
    width: "100%"
  }, contentElement), scrollMarkup = active ? /* @__PURE__ */ import_react76.default.createElement(Scrollable.ScrollTo, null) : null, control = url ? /* @__PURE__ */ import_react76.default.createElement(UnstyledLink, {
    id,
    url: disabled ? null : url,
    className,
    external,
    "aria-label": accessibilityLabel,
    onClick: disabled ? null : onAction,
    role
  }, contentWrapper) : /* @__PURE__ */ import_react76.default.createElement("button", {
    id,
    type: "button",
    className,
    disabled,
    "aria-label": accessibilityLabel,
    onClick: onAction,
    onMouseUp: handleMouseUpByBlurring,
    role,
    onMouseEnter
  }, contentWrapper);
  return /* @__PURE__ */ import_react76.default.createElement(import_react76.default.Fragment, null, scrollMarkup, control);
}
var TruncateText = ({
  children
}) => {
  let theme = useTheme(), textRef = (0, import_react76.useRef)(null), [isOverflowing, setIsOverflowing] = (0, import_react76.useState)(!1);
  return useIsomorphicLayoutEffect2(() => {
    textRef.current && setIsOverflowing(textRef.current.scrollWidth > textRef.current.offsetWidth);
  }, [children]), isOverflowing ? /* @__PURE__ */ import_react76.default.createElement(Tooltip, {
    zIndexOverride: Number(theme.zIndex["z-index-11"]),
    preferredPosition: "above",
    hoverDelay: 1e3,
    content: children,
    dismissOnMouseOut: !0
  }, /* @__PURE__ */ import_react76.default.createElement(Text, {
    as: "span",
    truncate: !0
  }, children)) : /* @__PURE__ */ import_react76.default.createElement(Text, {
    as: "span",
    truncate: !0
  }, /* @__PURE__ */ import_react76.default.createElement(Box, {
    width: "100%",
    ref: textRef
  }, children));
};

// node_modules/@shopify/polaris/build/esm/components/ActionList/components/Section/Section.js
function Section({
  section,
  hasMultipleSections,
  isFirst,
  actionRole,
  onActionAnyItem
}) {
  let handleAction = (itemOnAction) => () => {
    itemOnAction && itemOnAction(), onActionAnyItem && onActionAnyItem();
  }, actionMarkup = section.items.map(({
    content,
    helpText,
    onAction,
    ...item
  }, index) => {
    let itemMarkup = /* @__PURE__ */ import_react77.default.createElement(Item, Object.assign({
      content,
      helpText,
      role: actionRole,
      onAction: handleAction(onAction)
    }, item));
    return /* @__PURE__ */ import_react77.default.createElement(Box, {
      as: "li",
      key: `${content}-${index}`,
      role: actionRole === "menuitem" ? "presentation" : void 0
    }, /* @__PURE__ */ import_react77.default.createElement(InlineStack, {
      wrap: !1
    }, itemMarkup));
  }), titleMarkup = null;
  section.title && (titleMarkup = typeof section.title == "string" ? /* @__PURE__ */ import_react77.default.createElement(Box, {
    paddingBlockStart: "300",
    paddingBlockEnd: "100",
    paddingInlineStart: "300",
    paddingInlineEnd: "300"
  }, /* @__PURE__ */ import_react77.default.createElement(Text, {
    as: "p",
    variant: "headingSm"
  }, section.title)) : /* @__PURE__ */ import_react77.default.createElement(Box, {
    padding: "200",
    paddingInlineEnd: "150"
  }, section.title));
  let sectionRole;
  switch (actionRole) {
    case "option":
      sectionRole = "presentation";
      break;
    case "menuitem":
      sectionRole = hasMultipleSections ? "presentation" : "menu";
      break;
    default:
      sectionRole = void 0;
      break;
  }
  let sectionMarkup = /* @__PURE__ */ import_react77.default.createElement(import_react77.default.Fragment, null, titleMarkup, /* @__PURE__ */ import_react77.default.createElement(Box, Object.assign({
    as: "div",
    padding: "150"
  }, hasMultipleSections && {
    paddingBlockStart: "0"
  }, {
    tabIndex: hasMultipleSections ? void 0 : -1
  }), /* @__PURE__ */ import_react77.default.createElement(BlockStack, Object.assign({
    gap: "050",
    as: "ul"
  }, sectionRole && {
    role: sectionRole
  }), actionMarkup)));
  return hasMultipleSections ? /* @__PURE__ */ import_react77.default.createElement(Box, Object.assign({
    as: "li",
    role: "presentation",
    borderColor: "border-secondary"
  }, !isFirst && {
    borderBlockStartWidth: "025"
  }, !section.title && {
    paddingBlockStart: "150"
  }), sectionMarkup) : sectionMarkup;
}

// node_modules/@shopify/polaris/build/esm/components/KeypressListener/KeypressListener.js
var import_react78 = __toESM(require_react());
function KeypressListener({
  keyCode,
  handler,
  keyEvent = "keyup",
  options,
  useCapture
}) {
  let tracked = (0, import_react78.useRef)({
    handler,
    keyCode
  });
  useIsomorphicLayoutEffect2(() => {
    tracked.current = {
      handler,
      keyCode
    };
  }, [handler, keyCode]);
  let handleKeyEvent = (0, import_react78.useCallback)((event) => {
    let {
      handler: handler2,
      keyCode: keyCode2
    } = tracked.current;
    event.keyCode === keyCode2 && handler2(event);
  }, []);
  return (0, import_react78.useEffect)(() => (document.addEventListener(keyEvent, handleKeyEvent, useCapture || options), () => {
    document.removeEventListener(keyEvent, handleKeyEvent, useCapture || options);
  }), [keyEvent, handleKeyEvent, useCapture, options]), null;
}

// node_modules/@shopify/polaris/build/esm/components/TextField/TextField.js
var import_react86 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/TextField/TextField.css.js
var styles17 = {
  TextField: "Polaris-TextField",
  ClearButton: "Polaris-TextField__ClearButton",
  Loading: "Polaris-TextField__Loading",
  disabled: "Polaris-TextField--disabled",
  error: "Polaris-TextField--error",
  readOnly: "Polaris-TextField--readOnly",
  Input: "Polaris-TextField__Input",
  Backdrop: "Polaris-TextField__Backdrop",
  multiline: "Polaris-TextField--multiline",
  hasValue: "Polaris-TextField--hasValue",
  focus: "Polaris-TextField--focus",
  VerticalContent: "Polaris-TextField__VerticalContent",
  InputAndSuffixWrapper: "Polaris-TextField__InputAndSuffixWrapper",
  toneMagic: "Polaris-TextField--toneMagic",
  Prefix: "Polaris-TextField__Prefix",
  Suffix: "Polaris-TextField__Suffix",
  AutoSizeWrapper: "Polaris-TextField__AutoSizeWrapper",
  AutoSizeWrapperWithSuffix: "Polaris-TextField__AutoSizeWrapperWithSuffix",
  suggestion: "Polaris-TextField--suggestion",
  borderless: "Polaris-TextField--borderless",
  slim: "Polaris-TextField--slim",
  "Input-hasClearButton": "Polaris-TextField__Input--hasClearButton",
  "Input-suffixed": "Polaris-TextField__Input--suffixed",
  "Input-alignRight": "Polaris-TextField__Input--alignRight",
  "Input-alignLeft": "Polaris-TextField__Input--alignLeft",
  "Input-alignCenter": "Polaris-TextField__Input--alignCenter",
  "Input-autoSize": "Polaris-TextField__Input--autoSize",
  PrefixIcon: "Polaris-TextField__PrefixIcon",
  CharacterCount: "Polaris-TextField__CharacterCount",
  AlignFieldBottom: "Polaris-TextField__AlignFieldBottom",
  Spinner: "Polaris-TextField__Spinner",
  SpinnerIcon: "Polaris-TextField__SpinnerIcon",
  Resizer: "Polaris-TextField__Resizer",
  DummyInput: "Polaris-TextField__DummyInput",
  Segment: "Polaris-TextField__Segment",
  monospaced: "Polaris-TextField--monospaced"
};

// node_modules/@shopify/polaris/build/esm/components/TextField/components/Spinner/Spinner.js
var import_react79 = __toESM(require_react());
var Spinner2 = /* @__PURE__ */ import_react79.default.forwardRef(function({
  onChange,
  onClick,
  onMouseDown,
  onMouseUp,
  onBlur
}, ref) {
  function handleStep(step) {
    return () => onChange(step);
  }
  function handleMouseDown(onChange2) {
    return (event) => {
      event.button === 0 && onMouseDown?.(onChange2);
    };
  }
  return /* @__PURE__ */ import_react79.default.createElement("div", {
    className: styles17.Spinner,
    onClick,
    "aria-hidden": !0,
    ref
  }, /* @__PURE__ */ import_react79.default.createElement("div", {
    role: "button",
    className: styles17.Segment,
    tabIndex: -1,
    onClick: handleStep(1),
    onMouseDown: handleMouseDown(handleStep(1)),
    onMouseUp,
    onBlur
  }, /* @__PURE__ */ import_react79.default.createElement("div", {
    className: styles17.SpinnerIcon
  }, /* @__PURE__ */ import_react79.default.createElement(Icon, {
    source: SvgChevronUpIcon
  }))), /* @__PURE__ */ import_react79.default.createElement("div", {
    role: "button",
    className: styles17.Segment,
    tabIndex: -1,
    onClick: handleStep(-1),
    onMouseDown: handleMouseDown(handleStep(-1)),
    onMouseUp,
    onBlur
  }, /* @__PURE__ */ import_react79.default.createElement("div", {
    className: styles17.SpinnerIcon
  }, /* @__PURE__ */ import_react79.default.createElement(Icon, {
    source: SvgChevronDownIcon
  }))));
});

// node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.js
var import_react82 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.css.js
var styles18 = {
  hidden: "Polaris-Labelled--hidden",
  LabelWrapper: "Polaris-Labelled__LabelWrapper",
  disabled: "Polaris-Labelled--disabled",
  HelpText: "Polaris-Labelled__HelpText",
  readOnly: "Polaris-Labelled--readOnly",
  Error: "Polaris-Labelled__Error",
  Action: "Polaris-Labelled__Action"
};

// node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.js
var import_react80 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.css.js
var styles19 = {
  InlineError: "Polaris-InlineError",
  Icon: "Polaris-InlineError__Icon"
};

// node_modules/@shopify/polaris/build/esm/components/InlineError/InlineError.js
function InlineError({
  message,
  fieldID
}) {
  return message ? /* @__PURE__ */ import_react80.default.createElement("div", {
    id: errorTextID(fieldID),
    className: styles19.InlineError
  }, /* @__PURE__ */ import_react80.default.createElement("div", {
    className: styles19.Icon
  }, /* @__PURE__ */ import_react80.default.createElement(Icon, {
    source: SvgAlertCircleIcon
  })), /* @__PURE__ */ import_react80.default.createElement(Text, {
    as: "span",
    variant: "bodyMd"
  }, message)) : null;
}
function errorTextID(id) {
  return `${id}Error`;
}

// node_modules/@shopify/polaris/build/esm/components/Label/Label.js
var import_react81 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Label/Label.css.js
var styles20 = {
  Label: "Polaris-Label",
  hidden: "Polaris-Label--hidden",
  Text: "Polaris-Label__Text",
  RequiredIndicator: "Polaris-Label__RequiredIndicator"
};

// node_modules/@shopify/polaris/build/esm/components/Label/Label.js
function labelID(id) {
  return `${id}Label`;
}
function Label({
  children,
  id,
  hidden,
  requiredIndicator
}) {
  let className = classNames(styles20.Label, hidden && styles20.hidden);
  return /* @__PURE__ */ import_react81.default.createElement("div", {
    className
  }, /* @__PURE__ */ import_react81.default.createElement("label", {
    id: labelID(id),
    htmlFor: id,
    className: classNames(styles20.Text, requiredIndicator && styles20.RequiredIndicator)
  }, /* @__PURE__ */ import_react81.default.createElement(Text, {
    as: "span",
    variant: "bodyMd"
  }, children)));
}

// node_modules/@shopify/polaris/build/esm/components/Labelled/Labelled.js
function Labelled({
  id,
  label,
  error,
  action: action8,
  helpText,
  children,
  labelHidden,
  requiredIndicator,
  disabled,
  readOnly,
  ...rest
}) {
  let className = classNames(labelHidden && styles18.hidden, disabled && styles18.disabled, readOnly && styles18.readOnly), actionMarkup = action8 ? /* @__PURE__ */ import_react82.default.createElement("div", {
    className: styles18.Action
  }, buttonFrom(action8, {
    variant: "plain"
  })) : null, helpTextMarkup = helpText ? /* @__PURE__ */ import_react82.default.createElement("div", {
    className: styles18.HelpText,
    id: helpTextID(id),
    "aria-disabled": disabled
  }, /* @__PURE__ */ import_react82.default.createElement(Text, {
    as: "span",
    tone: "subdued",
    variant: "bodyMd",
    breakWord: !0
  }, helpText)) : null, errorMarkup = error && typeof error != "boolean" && /* @__PURE__ */ import_react82.default.createElement("div", {
    className: styles18.Error
  }, /* @__PURE__ */ import_react82.default.createElement(InlineError, {
    message: error,
    fieldID: id
  })), labelMarkup = label ? /* @__PURE__ */ import_react82.default.createElement("div", {
    className: styles18.LabelWrapper
  }, /* @__PURE__ */ import_react82.default.createElement(Label, Object.assign({
    id,
    requiredIndicator
  }, rest, {
    hidden: !1
  }), label), actionMarkup) : null;
  return /* @__PURE__ */ import_react82.default.createElement("div", {
    className
  }, labelMarkup, children, errorMarkup, helpTextMarkup);
}
function helpTextID(id) {
  return `${id}HelpText`;
}

// node_modules/@shopify/polaris/build/esm/components/Connected/Connected.js
var import_react84 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Connected/Connected.css.js
var styles21 = {
  Connected: "Polaris-Connected",
  Item: "Polaris-Connected__Item",
  "Item-primary": "Polaris-Connected__Item--primary",
  "Item-focused": "Polaris-Connected__Item--focused"
};

// node_modules/@shopify/polaris/build/esm/components/Connected/components/Item/Item.js
var import_react83 = __toESM(require_react());
function Item2({
  children,
  position
}) {
  let {
    value: focused,
    setTrue: forceTrueFocused,
    setFalse: forceFalseFocused
  } = useToggle(!1), className = classNames(styles21.Item, focused && styles21["Item-focused"], position === "primary" ? styles21["Item-primary"] : styles21["Item-connection"]);
  return /* @__PURE__ */ import_react83.default.createElement("div", {
    onBlur: forceFalseFocused,
    onFocus: forceTrueFocused,
    className
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/Connected/Connected.js
function Connected({
  children,
  left,
  right
}) {
  let leftConnectionMarkup = left ? /* @__PURE__ */ import_react84.default.createElement(Item2, {
    position: "left"
  }, left) : null, rightConnectionMarkup = right ? /* @__PURE__ */ import_react84.default.createElement(Item2, {
    position: "right"
  }, right) : null;
  return /* @__PURE__ */ import_react84.default.createElement("div", {
    className: styles21.Connected
  }, leftConnectionMarkup, /* @__PURE__ */ import_react84.default.createElement(Item2, {
    position: "primary"
  }, children), rightConnectionMarkup);
}

// node_modules/@shopify/polaris/build/esm/components/TextField/components/Resizer/Resizer.js
var import_react85 = __toESM(require_react());
function Resizer({
  contents,
  currentHeight: currentHeightProp = null,
  minimumLines,
  onHeightChange
}) {
  let contentNode = (0, import_react85.useRef)(null), minimumLinesNode = (0, import_react85.useRef)(null), animationFrame = (0, import_react85.useRef)(), currentHeight = (0, import_react85.useRef)(currentHeightProp);
  currentHeightProp !== currentHeight.current && (currentHeight.current = currentHeightProp), (0, import_react85.useEffect)(() => () => {
    animationFrame.current && cancelAnimationFrame(animationFrame.current);
  }, []);
  let minimumLinesMarkup = minimumLines ? /* @__PURE__ */ import_react85.default.createElement("div", {
    ref: minimumLinesNode,
    className: styles17.DummyInput,
    dangerouslySetInnerHTML: {
      __html: getContentsForMinimumLines(minimumLines)
    }
  }) : null, handleHeightCheck = (0, import_react85.useCallback)(() => {
    animationFrame.current && cancelAnimationFrame(animationFrame.current), animationFrame.current = requestAnimationFrame(() => {
      if (!contentNode.current || !minimumLinesNode.current)
        return;
      let newHeight = Math.max(contentNode.current.offsetHeight, minimumLinesNode.current.offsetHeight);
      newHeight !== currentHeight.current && onHeightChange(newHeight);
    });
  }, [onHeightChange]);
  return useIsomorphicLayoutEffect2(() => {
    handleHeightCheck();
  }), /* @__PURE__ */ import_react85.default.createElement("div", {
    "aria-hidden": !0,
    className: styles17.Resizer
  }, /* @__PURE__ */ import_react85.default.createElement(EventListener, {
    event: "resize",
    handler: handleHeightCheck
  }), /* @__PURE__ */ import_react85.default.createElement("div", {
    ref: contentNode,
    className: styles17.DummyInput,
    dangerouslySetInnerHTML: {
      __html: getFinalContents(contents)
    }
  }), minimumLinesMarkup);
}
var ENTITIES_TO_REPLACE = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "\n": "<br>",
  "\r": ""
}, REPLACE_REGEX2 = new RegExp(`[${Object.keys(ENTITIES_TO_REPLACE).join()}]`, "g");
function replaceEntity(entity) {
  return ENTITIES_TO_REPLACE[entity];
}
function getContentsForMinimumLines(minimumLines) {
  let content = "";
  for (let line = 0; line < minimumLines; line++)
    content += "<br>";
  return content;
}
function getFinalContents(contents) {
  return contents ? `${contents.replace(REPLACE_REGEX2, replaceEntity)}<br>` : "<br>";
}

// node_modules/@shopify/polaris/build/esm/components/TextField/TextField.js
function TextField({
  prefix,
  suffix,
  verticalContent,
  placeholder,
  value = "",
  helpText,
  label,
  labelAction,
  labelHidden,
  disabled,
  clearButton,
  readOnly,
  autoFocus,
  focused,
  multiline,
  error,
  connectedRight,
  connectedLeft,
  type = "text",
  name,
  id: idProp,
  role,
  step,
  largeStep,
  autoComplete,
  max,
  maxLength,
  maxHeight,
  min,
  minLength,
  pattern,
  inputMode,
  spellCheck,
  ariaOwns,
  ariaControls,
  ariaExpanded,
  ariaActiveDescendant,
  ariaAutocomplete,
  showCharacterCount,
  align,
  requiredIndicator,
  monospaced,
  selectTextOnFocus,
  suggestion,
  variant = "inherit",
  size: size2 = "medium",
  onClearButtonClick,
  onChange,
  onSpinnerChange,
  onFocus,
  onBlur,
  tone,
  autoSize,
  loading
}) {
  let i18n = useI18n(), [height2, setHeight] = (0, import_react86.useState)(null), [focus, setFocus] = (0, import_react86.useState)(Boolean(focused)), isAfterInitial = useIsAfterInitialMount(), uniqId = (0, import_react86.useId)(), id = idProp ?? uniqId, textFieldRef = (0, import_react86.useRef)(null), inputRef = (0, import_react86.useRef)(null), textAreaRef = (0, import_react86.useRef)(null), prefixRef = (0, import_react86.useRef)(null), suffixRef = (0, import_react86.useRef)(null), loadingRef = (0, import_react86.useRef)(null), verticalContentRef = (0, import_react86.useRef)(null), buttonPressTimer = (0, import_react86.useRef)(), spinnerRef = (0, import_react86.useRef)(null), getInputRef = (0, import_react86.useCallback)(() => multiline ? textAreaRef.current : inputRef.current, [multiline]);
  (0, import_react86.useEffect)(() => {
    let input2 = getInputRef();
    !input2 || focused === void 0 || (focused ? input2.focus() : input2.blur());
  }, [focused, verticalContent, getInputRef]), (0, import_react86.useEffect)(() => {
    let input2 = inputRef.current;
    !input2 || !(type === "text" || type === "tel" || type === "search" || type === "url" || type === "password") || !suggestion || input2.setSelectionRange(value.length, suggestion.length);
  }, [focus, value, type, suggestion]);
  let normalizedValue = suggestion || value, normalizedStep = step ?? 1, normalizedMax = max ?? 1 / 0, normalizedMin = min ?? -1 / 0, className = classNames(styles17.TextField, Boolean(normalizedValue) && styles17.hasValue, disabled && styles17.disabled, readOnly && styles17.readOnly, error && styles17.error, tone && styles17[variationName("tone", tone)], multiline && styles17.multiline, focus && !disabled && styles17.focus, variant !== "inherit" && styles17[variant], size2 === "slim" && styles17.slim), inputType = type === "currency" ? "text" : type, isNumericType = type === "number" || type === "integer", iconPrefix = /* @__PURE__ */ import_react86.default.isValidElement(prefix) && prefix.type === Icon, prefixMarkup = prefix ? /* @__PURE__ */ import_react86.default.createElement("div", {
    className: classNames(styles17.Prefix, iconPrefix && styles17.PrefixIcon),
    id: `${id}-Prefix`,
    ref: prefixRef
  }, /* @__PURE__ */ import_react86.default.createElement(Text, {
    as: "span",
    variant: "bodyMd"
  }, prefix)) : null, suffixMarkup = suffix ? /* @__PURE__ */ import_react86.default.createElement("div", {
    className: styles17.Suffix,
    id: `${id}-Suffix`,
    ref: suffixRef
  }, /* @__PURE__ */ import_react86.default.createElement(Text, {
    as: "span",
    variant: "bodyMd"
  }, suffix)) : null, loadingMarkup = loading ? /* @__PURE__ */ import_react86.default.createElement("div", {
    className: styles17.Loading,
    id: `${id}-Loading`,
    ref: loadingRef
  }, /* @__PURE__ */ import_react86.default.createElement(Spinner, {
    size: "small"
  })) : null, characterCountMarkup = null;
  if (showCharacterCount) {
    let characterCount = normalizedValue.length, characterCountLabel = maxLength ? i18n.translate("Polaris.TextField.characterCountWithMaxLength", {
      count: characterCount,
      limit: maxLength
    }) : i18n.translate("Polaris.TextField.characterCount", {
      count: characterCount
    }), characterCountClassName = classNames(styles17.CharacterCount, multiline && styles17.AlignFieldBottom), characterCountText = maxLength ? `${characterCount}/${maxLength}` : characterCount;
    characterCountMarkup = /* @__PURE__ */ import_react86.default.createElement("div", {
      id: `${id}-CharacterCounter`,
      className: characterCountClassName,
      "aria-label": characterCountLabel,
      "aria-live": focus ? "polite" : "off",
      "aria-atomic": "true",
      onClick: handleClickChild
    }, /* @__PURE__ */ import_react86.default.createElement(Text, {
      as: "span",
      variant: "bodyMd"
    }, characterCountText));
  }
  let clearButtonMarkup = clearButton && normalizedValue !== "" ? /* @__PURE__ */ import_react86.default.createElement("button", {
    type: "button",
    className: styles17.ClearButton,
    onClick: handleClearButtonPress,
    disabled
  }, /* @__PURE__ */ import_react86.default.createElement(Text, {
    as: "span",
    visuallyHidden: !0
  }, i18n.translate("Polaris.Common.clear")), /* @__PURE__ */ import_react86.default.createElement(Icon, {
    source: SvgXCircleIcon,
    tone: "base"
  })) : null, handleNumberChange = (0, import_react86.useCallback)((steps, stepAmount = normalizedStep) => {
    if (onChange == null && onSpinnerChange == null)
      return;
    let dpl = (num) => (num.toString().split(".")[1] || []).length, numericValue = value ? parseFloat(value) : 0;
    if (isNaN(numericValue))
      return;
    let decimalPlaces = type === "integer" ? 0 : Math.max(dpl(numericValue), dpl(stepAmount)), newValue = Math.min(Number(normalizedMax), Math.max(numericValue + steps * stepAmount, Number(normalizedMin)));
    onSpinnerChange != null ? onSpinnerChange(String(newValue.toFixed(decimalPlaces)), id) : onChange?.(String(newValue.toFixed(decimalPlaces)), id);
  }, [id, normalizedMax, normalizedMin, onChange, onSpinnerChange, normalizedStep, type, value]), handleSpinnerButtonRelease = (0, import_react86.useCallback)(() => {
    clearTimeout(buttonPressTimer.current);
  }, []), handleSpinnerButtonPress = (0, import_react86.useCallback)((onChange2) => {
    let interval = 200, onChangeInterval = () => {
      interval > 50 && (interval -= 10), onChange2(0), buttonPressTimer.current = window.setTimeout(onChangeInterval, interval);
    };
    buttonPressTimer.current = window.setTimeout(onChangeInterval, interval), document.addEventListener("mouseup", handleSpinnerButtonRelease, {
      once: !0
    });
  }, [handleSpinnerButtonRelease]), spinnerMarkup = isNumericType && step !== 0 && !disabled && !readOnly ? /* @__PURE__ */ import_react86.default.createElement(Spinner2, {
    onClick: handleClickChild,
    onChange: handleNumberChange,
    onMouseDown: handleSpinnerButtonPress,
    onMouseUp: handleSpinnerButtonRelease,
    ref: spinnerRef,
    onBlur: handleOnBlur
  }) : null, style = multiline && height2 ? {
    height: height2,
    maxHeight
  } : null, handleExpandingResize = (0, import_react86.useCallback)((height3) => {
    setHeight(height3);
  }, []), resizer = multiline && isAfterInitial ? /* @__PURE__ */ import_react86.default.createElement(Resizer, {
    contents: normalizedValue || placeholder,
    currentHeight: height2,
    minimumLines: typeof multiline == "number" ? multiline : 1,
    onHeightChange: handleExpandingResize
  }) : null, describedBy = [];
  error && describedBy.push(`${id}Error`), helpText && describedBy.push(helpTextID(id)), showCharacterCount && describedBy.push(`${id}-CharacterCounter`);
  let labelledBy = [];
  prefix && labelledBy.push(`${id}-Prefix`), suffix && labelledBy.push(`${id}-Suffix`), verticalContent && labelledBy.push(`${id}-VerticalContent`), labelledBy.unshift(labelID(id));
  let inputClassName = classNames(styles17.Input, align && styles17[variationName("Input-align", align)], suffix && styles17["Input-suffixed"], clearButton && styles17["Input-hasClearButton"], monospaced && styles17.monospaced, suggestion && styles17.suggestion, autoSize && styles17["Input-autoSize"]), handleOnFocus = (event) => {
    setFocus(!0), selectTextOnFocus && !suggestion && getInputRef()?.select(), onFocus && onFocus(event);
  };
  useEventListener("wheel", handleOnWheel, inputRef);
  function handleOnWheel(event) {
    document.activeElement === event.target && isNumericType && event.stopPropagation();
  }
  let input = /* @__PURE__ */ (0, import_react86.createElement)(multiline ? "textarea" : "input", {
    name,
    id,
    disabled,
    readOnly,
    role,
    autoFocus,
    value: normalizedValue,
    placeholder,
    style,
    autoComplete,
    className: inputClassName,
    ref: multiline ? textAreaRef : inputRef,
    min,
    max,
    step,
    minLength,
    maxLength,
    spellCheck,
    pattern,
    inputMode,
    type: inputType,
    rows: getRows(multiline),
    size: autoSize ? 1 : void 0,
    "aria-describedby": describedBy.length ? describedBy.join(" ") : void 0,
    "aria-labelledby": labelledBy.join(" "),
    "aria-invalid": Boolean(error),
    "aria-owns": ariaOwns,
    "aria-activedescendant": ariaActiveDescendant,
    "aria-autocomplete": ariaAutocomplete,
    "aria-controls": ariaControls,
    "aria-expanded": ariaExpanded,
    "aria-required": requiredIndicator,
    ...normalizeAriaMultiline(multiline),
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    onClick: handleClickChild,
    onKeyPress: handleKeyPress,
    onKeyDown: handleKeyDown,
    onChange: suggestion ? void 0 : handleChange,
    onInput: suggestion ? handleChange : void 0,
    // 1Password disable data attribute
    "data-1p-ignore": autoComplete === "off" || void 0,
    // LastPass disable data attribute
    "data-lpignore": autoComplete === "off" || void 0,
    // Dashlane disable data attribute
    "data-form-type": autoComplete === "off" ? "other" : void 0
  }), inputWithVerticalContentMarkup = verticalContent ? /* @__PURE__ */ import_react86.default.createElement("div", {
    className: styles17.VerticalContent,
    id: `${id}-VerticalContent`,
    ref: verticalContentRef,
    onClick: handleClickChild
  }, verticalContent, input) : null, inputMarkup = verticalContent ? inputWithVerticalContentMarkup : input, backdropMarkup = /* @__PURE__ */ import_react86.default.createElement("div", {
    className: classNames(styles17.Backdrop, connectedLeft && styles17["Backdrop-connectedLeft"], connectedRight && styles17["Backdrop-connectedRight"])
  }), inputAndSuffixMarkup = autoSize ? /* @__PURE__ */ import_react86.default.createElement("div", {
    className: styles17.InputAndSuffixWrapper
  }, /* @__PURE__ */ import_react86.default.createElement("div", {
    className: classNames(styles17.AutoSizeWrapper, suffix && styles17.AutoSizeWrapperWithSuffix),
    "data-auto-size-value": value || placeholder
  }, inputMarkup), suffixMarkup) : /* @__PURE__ */ import_react86.default.createElement(import_react86.default.Fragment, null, inputMarkup, suffixMarkup);
  return /* @__PURE__ */ import_react86.default.createElement(Labelled, {
    label,
    id,
    error,
    action: labelAction,
    labelHidden,
    helpText,
    requiredIndicator,
    disabled,
    readOnly
  }, /* @__PURE__ */ import_react86.default.createElement(Connected, {
    left: connectedLeft,
    right: connectedRight
  }, /* @__PURE__ */ import_react86.default.createElement("div", {
    className,
    onClick: handleClick,
    ref: textFieldRef
  }, prefixMarkup, inputAndSuffixMarkup, characterCountMarkup, loadingMarkup, clearButtonMarkup, spinnerMarkup, backdropMarkup, resizer)));
  function handleChange(event) {
    onChange && onChange(event.currentTarget.value, id);
  }
  function handleClick(event) {
    let {
      target
    } = event, inputRefRole = inputRef?.current?.getAttribute("role");
    if (target === inputRef.current && inputRefRole === "combobox") {
      inputRef.current?.focus(), handleOnFocus(event);
      return;
    }
    isPrefixOrSuffix(target) || isVerticalContent(target) || isInput(target) || isSpinner(target) || isLoadingSpinner(target) || focus || getInputRef()?.focus();
  }
  function handleClickChild(event) {
    !isSpinner(event.target) && !isInput(event.target) && event.stopPropagation(), !(isPrefixOrSuffix(event.target) || isVerticalContent(event.target) || isInput(event.target) || isLoadingSpinner(event.target) || focus) && (setFocus(!0), getInputRef()?.focus());
  }
  function handleClearButtonPress() {
    onClearButtonClick && onClearButtonClick(id);
  }
  function handleKeyPress(event) {
    let {
      key,
      which
    } = event, numbersSpec = /[\d.,eE+-]$/, integerSpec = /[\deE+-]$/;
    !isNumericType || which === Key.Enter || type === "number" && numbersSpec.test(key) || type === "integer" && integerSpec.test(key) || event.preventDefault();
  }
  function handleKeyDown(event) {
    if (!isNumericType)
      return;
    let {
      key,
      which
    } = event;
    type === "integer" && (key === "ArrowUp" || which === Key.UpArrow) && (handleNumberChange(1), event.preventDefault()), type === "integer" && (key === "ArrowDown" || which === Key.DownArrow) && (handleNumberChange(-1), event.preventDefault()), (which === Key.Home || key === "Home") && min !== void 0 && (onSpinnerChange != null ? onSpinnerChange(String(min), id) : onChange?.(String(min), id)), (which === Key.End || key === "End") && max !== void 0 && (onSpinnerChange != null ? onSpinnerChange(String(max), id) : onChange?.(String(max), id)), (which === Key.PageUp || key === "PageUp") && largeStep !== void 0 && handleNumberChange(1, largeStep), (which === Key.PageDown || key === "PageDown") && largeStep !== void 0 && handleNumberChange(-1, largeStep);
  }
  function handleOnBlur(event) {
    setFocus(!1), !textFieldRef.current?.contains(event?.relatedTarget) && onBlur && onBlur(event);
  }
  function isInput(target) {
    let input2 = getInputRef();
    return target instanceof HTMLElement && input2 && (input2.contains(target) || input2.contains(document.activeElement));
  }
  function isPrefixOrSuffix(target) {
    return target instanceof Element && (prefixRef.current && prefixRef.current.contains(target) || suffixRef.current && suffixRef.current.contains(target));
  }
  function isSpinner(target) {
    return target instanceof Element && spinnerRef.current && spinnerRef.current.contains(target);
  }
  function isLoadingSpinner(target) {
    return target instanceof Element && loadingRef.current && loadingRef.current.contains(target);
  }
  function isVerticalContent(target) {
    return target instanceof Element && verticalContentRef.current && (verticalContentRef.current.contains(target) || verticalContentRef.current.contains(document.activeElement));
  }
}
function getRows(multiline) {
  if (multiline)
    return typeof multiline == "number" ? multiline : 1;
}
function normalizeAriaMultiline(multiline) {
  if (multiline)
    return Boolean(multiline) || typeof multiline == "number" && multiline > 0 ? {
      "aria-multiline": !0
    } : void 0;
}

// node_modules/@shopify/polaris/build/esm/components/ActionList/ActionList.js
var FILTER_ACTIONS_THRESHOLD = 8;
function ActionList({
  items,
  sections = [],
  actionRole,
  allowFiltering,
  onActionAnyItem
}) {
  let i18n = useI18n(), filterActions = (0, import_react87.useContext)(FilterActionsContext), finalSections = [], actionListRef = (0, import_react87.useRef)(null), [searchText, setSearchText] = (0, import_react87.useState)("");
  items ? finalSections = [{
    items
  }, ...sections] : sections && (finalSections = sections);
  let isFilterable = finalSections?.some((section) => section.items.some((item) => typeof item.content == "string")), hasMultipleSections = finalSections.length > 1, elementRole = hasMultipleSections && actionRole === "menuitem" ? "menu" : void 0, elementTabIndex = hasMultipleSections && actionRole === "menuitem" ? -1 : void 0, filteredSections = finalSections?.map((section) => ({
    ...section,
    items: section.items.filter(({
      content
    }) => typeof content == "string" ? content?.toLowerCase().includes(searchText.toLowerCase()) : content)
  })), sectionMarkup = filteredSections.map((section, index) => section.items.length > 0 ? /* @__PURE__ */ import_react87.default.createElement(Section, {
    key: typeof section.title == "string" ? section.title : index,
    section,
    hasMultipleSections,
    actionRole,
    onActionAnyItem,
    isFirst: index === 0
  }) : null), handleFocusPreviousItem = (evt) => {
    evt.preventDefault(), actionListRef.current && evt.target && actionListRef.current.contains(evt.target) && wrapFocusPreviousFocusableMenuItem(actionListRef.current, evt.target);
  }, handleFocusNextItem = (evt) => {
    evt.preventDefault(), actionListRef.current && evt.target && actionListRef.current.contains(evt.target) && wrapFocusNextFocusableMenuItem(actionListRef.current, evt.target);
  }, listeners = actionRole === "menuitem" ? /* @__PURE__ */ import_react87.default.createElement(import_react87.default.Fragment, null, /* @__PURE__ */ import_react87.default.createElement(KeypressListener, {
    keyEvent: "keydown",
    keyCode: Key.DownArrow,
    handler: handleFocusNextItem
  }), /* @__PURE__ */ import_react87.default.createElement(KeypressListener, {
    keyEvent: "keydown",
    keyCode: Key.UpArrow,
    handler: handleFocusPreviousItem
  })) : null, totalFilteredActions = (0, import_react87.useMemo)(() => filteredSections?.reduce((acc, section) => acc + section.items.length, 0) || 0, [filteredSections]), hasManyActions = (finalSections?.reduce((acc, section) => acc + section.items.length, 0) || 0) >= FILTER_ACTIONS_THRESHOLD;
  return /* @__PURE__ */ import_react87.default.createElement(import_react87.default.Fragment, null, (allowFiltering || filterActions) && hasManyActions && isFilterable && /* @__PURE__ */ import_react87.default.createElement(Box, {
    padding: "200",
    paddingBlockEnd: totalFilteredActions > 0 ? "0" : "200"
  }, /* @__PURE__ */ import_react87.default.createElement(TextField, {
    clearButton: !0,
    labelHidden: !0,
    label: i18n.translate("Polaris.ActionList.SearchField.placeholder"),
    placeholder: i18n.translate("Polaris.ActionList.SearchField.placeholder"),
    autoComplete: "off",
    value: searchText,
    onChange: (value) => setSearchText(value),
    prefix: /* @__PURE__ */ import_react87.default.createElement(Icon, {
      source: SvgSearchIcon
    }),
    onClearButtonClick: () => setSearchText("")
  })), /* @__PURE__ */ import_react87.default.createElement(Box, {
    as: hasMultipleSections ? "ul" : "div",
    ref: actionListRef,
    role: elementRole,
    tabIndex: elementTabIndex
  }, listeners, sectionMarkup));
}
ActionList.Item = Item;

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/ActionMenu.js
var import_react98 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/ActionMenu.css.js
var styles22 = {
  ActionMenu: "Polaris-ActionMenu"
};

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/RollupActions/RollupActions.js
var import_react93 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/RollupActions/RollupActions.css.js
var styles23 = {
  RollupActivator: "Polaris-ActionMenu-RollupActions__RollupActivator"
};

// node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js
var import_react92 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Popover/set-activator-attributes.js
function setActivatorAttributes(activator, {
  id,
  active = !1,
  ariaHaspopup,
  activatorDisabled = !1
}) {
  activatorDisabled || (activator.tabIndex = activator.tabIndex || 0), activator.setAttribute("aria-controls", id), activator.setAttribute("aria-owns", id), activator.setAttribute("aria-expanded", String(active)), activator.setAttribute("data-state", active ? "open" : "closed"), ariaHaspopup != null && activator.setAttribute("aria-haspopup", String(ariaHaspopup));
}

// node_modules/@shopify/polaris/build/esm/components/Popover/components/PopoverOverlay/PopoverOverlay.js
var import_react91 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/components.js
var import_react88 = __toESM(require_react());
function wrapWithComponent(element, Component5, props) {
  return element == null ? null : isElementOfType(element, Component5) ? element : /* @__PURE__ */ import_react88.default.createElement(Component5, props, element);
}
var isComponent = (AComponent, AnotherComponent) => AComponent === AnotherComponent;
function isElementOfType(element, Component5) {
  if (element == null || !/* @__PURE__ */ (0, import_react88.isValidElement)(element) || typeof element.type == "string")
    return !1;
  let {
    type: defaultType
  } = element, type = element.props?.__type__ || defaultType;
  return (Array.isArray(Component5) ? Component5 : [Component5]).some((AComponent) => typeof type != "string" && isComponent(AComponent, type));
}
function elementChildren(children, predicate = () => !0) {
  return import_react88.Children.toArray(children).filter((child) => /* @__PURE__ */ (0, import_react88.isValidElement)(child) && predicate(child));
}
function ConditionalWrapper({
  condition,
  wrapper,
  children
}) {
  return condition ? wrapper(children) : children;
}
function ConditionalRender({
  condition,
  children
}) {
  return condition ? children : null;
}

// node_modules/@shopify/polaris/build/esm/components/Popover/Popover.css.js
var styles24 = {
  Popover: "Polaris-Popover",
  PopoverOverlay: "Polaris-Popover__PopoverOverlay",
  "PopoverOverlay-noAnimation": "Polaris-Popover__PopoverOverlay--noAnimation",
  "PopoverOverlay-entering": "Polaris-Popover__PopoverOverlay--entering",
  "PopoverOverlay-open": "Polaris-Popover__PopoverOverlay--open",
  measuring: "Polaris-Popover--measuring",
  "PopoverOverlay-exiting": "Polaris-Popover__PopoverOverlay--exiting",
  fullWidth: "Polaris-Popover--fullWidth",
  Content: "Polaris-Popover__Content",
  positionedAbove: "Polaris-Popover--positionedAbove",
  positionedCover: "Polaris-Popover--positionedCover",
  ContentContainer: "Polaris-Popover__ContentContainer",
  "Content-fullHeight": "Polaris-Popover__Content--fullHeight",
  "Content-fluidContent": "Polaris-Popover__Content--fluidContent",
  Pane: "Polaris-Popover__Pane",
  "Pane-fixed": "Polaris-Popover__Pane--fixed",
  "Pane-subdued": "Polaris-Popover__Pane--subdued",
  "Pane-captureOverscroll": "Polaris-Popover__Pane--captureOverscroll",
  Section: "Polaris-Popover__Section",
  FocusTracker: "Polaris-Popover__FocusTracker",
  "PopoverOverlay-hideOnPrint": "Polaris-Popover__PopoverOverlay--hideOnPrint"
};

// node_modules/@shopify/polaris/build/esm/components/Popover/components/Pane/Pane.js
var import_react90 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Popover/components/Section/Section.js
var import_react89 = __toESM(require_react());
function Section2({
  children
}) {
  return /* @__PURE__ */ import_react89.default.createElement("div", {
    className: styles24.Section
  }, /* @__PURE__ */ import_react89.default.createElement(Box, {
    paddingInlineStart: "300",
    paddingInlineEnd: "300",
    paddingBlockStart: "200",
    paddingBlockEnd: "150"
  }, children));
}

// node_modules/@shopify/polaris/build/esm/components/Popover/components/Pane/Pane.js
function Pane({
  captureOverscroll = !1,
  fixed,
  sectioned,
  children,
  height: height2,
  subdued,
  onScrolledToBottom
}) {
  let className = classNames(styles24.Pane, fixed && styles24["Pane-fixed"], subdued && styles24["Pane-subdued"], captureOverscroll && styles24["Pane-captureOverscroll"]), content = sectioned ? wrapWithComponent(children, Section2, {}) : children, style = height2 ? {
    height: height2,
    maxHeight: height2,
    minHeight: height2
  } : void 0;
  return fixed ? /* @__PURE__ */ import_react90.default.createElement("div", {
    style,
    className
  }, content) : /* @__PURE__ */ import_react90.default.createElement(Scrollable, {
    shadow: !0,
    className,
    style,
    onScrolledToBottom,
    scrollbarWidth: "thin"
  }, content);
}

// node_modules/@shopify/polaris/build/esm/components/Popover/components/PopoverOverlay/PopoverOverlay.js
var PopoverCloseSource;
(function(PopoverCloseSource2) {
  PopoverCloseSource2[PopoverCloseSource2.Click = 0] = "Click", PopoverCloseSource2[PopoverCloseSource2.EscapeKeypress = 1] = "EscapeKeypress", PopoverCloseSource2[PopoverCloseSource2.FocusOut = 2] = "FocusOut", PopoverCloseSource2[PopoverCloseSource2.ScrollOut = 3] = "ScrollOut";
})(PopoverCloseSource || (PopoverCloseSource = {}));
var TransitionStatus;
(function(TransitionStatus3) {
  TransitionStatus3.Entering = "entering", TransitionStatus3.Entered = "entered", TransitionStatus3.Exiting = "exiting", TransitionStatus3.Exited = "exited";
})(TransitionStatus || (TransitionStatus = {}));
var PopoverOverlay = class extends import_react91.PureComponent {
  constructor(props) {
    super(props), this.state = {
      transitionStatus: this.props.active ? TransitionStatus.Entering : TransitionStatus.Exited
    }, this.contentNode = /* @__PURE__ */ (0, import_react91.createRef)(), this.renderPopover = (overlayDetails) => {
      let {
        measuring,
        desiredHeight,
        positioning
      } = overlayDetails, {
        id,
        children,
        sectioned,
        fullWidth,
        fullHeight,
        fluidContent,
        hideOnPrint,
        autofocusTarget,
        captureOverscroll
      } = this.props, isCovering = positioning === "cover", className = classNames(styles24.Popover, measuring && styles24.measuring, (fullWidth || isCovering) && styles24.fullWidth, hideOnPrint && styles24["PopoverOverlay-hideOnPrint"], positioning && styles24[variationName("positioned", positioning)]), contentStyles = measuring ? void 0 : {
        height: desiredHeight
      }, contentClassNames = classNames(styles24.Content, fullHeight && styles24["Content-fullHeight"], fluidContent && styles24["Content-fluidContent"]);
      return /* @__PURE__ */ import_react91.default.createElement("div", Object.assign({
        className
      }, overlay.props), /* @__PURE__ */ import_react91.default.createElement(EventListener, {
        event: "click",
        handler: this.handleClick
      }), /* @__PURE__ */ import_react91.default.createElement(EventListener, {
        event: "touchstart",
        handler: this.handleClick
      }), /* @__PURE__ */ import_react91.default.createElement(KeypressListener, {
        keyCode: Key.Escape,
        handler: this.handleEscape
      }), /* @__PURE__ */ import_react91.default.createElement("div", {
        className: styles24.FocusTracker,
        tabIndex: 0,
        onFocus: this.handleFocusFirstItem
      }), /* @__PURE__ */ import_react91.default.createElement("div", {
        className: styles24.ContentContainer
      }, /* @__PURE__ */ import_react91.default.createElement("div", {
        id,
        tabIndex: autofocusTarget === "none" ? void 0 : -1,
        className: contentClassNames,
        style: contentStyles,
        ref: this.contentNode
      }, renderPopoverContent(children, {
        captureOverscroll,
        sectioned
      }))), /* @__PURE__ */ import_react91.default.createElement("div", {
        className: styles24.FocusTracker,
        tabIndex: 0,
        onFocus: this.handleFocusLastItem
      }));
    }, this.handleClick = (event) => {
      let target = event.target, {
        contentNode,
        props: {
          activator,
          onClose,
          preventCloseOnChildOverlayClick
        }
      } = this, composedPath = event.composedPath(), wasDescendant = preventCloseOnChildOverlayClick ? wasPolarisPortalDescendant(composedPath, this.context.container) : wasContentNodeDescendant(composedPath, contentNode), isActivatorDescendant = nodeContainsDescendant(activator, target);
      wasDescendant || isActivatorDescendant || this.state.transitionStatus !== TransitionStatus.Entered || onClose(PopoverCloseSource.Click);
    }, this.handleScrollOut = () => {
      this.props.onClose(PopoverCloseSource.ScrollOut);
    }, this.handleEscape = (event) => {
      let target = event.target, {
        contentNode,
        props: {
          activator
        }
      } = this, composedPath = event.composedPath(), wasDescendant = wasContentNodeDescendant(composedPath, contentNode), isActivatorDescendant = nodeContainsDescendant(activator, target);
      (wasDescendant || isActivatorDescendant) && this.props.onClose(PopoverCloseSource.EscapeKeypress);
    }, this.handleFocusFirstItem = () => {
      this.props.onClose(PopoverCloseSource.FocusOut);
    }, this.handleFocusLastItem = () => {
      this.props.onClose(PopoverCloseSource.FocusOut);
    }, this.overlayRef = /* @__PURE__ */ (0, import_react91.createRef)();
  }
  forceUpdatePosition() {
    this.overlayRef.current?.forceUpdatePosition();
  }
  changeTransitionStatus(transitionStatus, cb) {
    this.setState({
      transitionStatus
    }, cb), this.contentNode.current && this.contentNode.current.getBoundingClientRect();
  }
  componentDidMount() {
    this.props.active && (this.focusContent(), this.changeTransitionStatus(TransitionStatus.Entered));
  }
  componentDidUpdate(oldProps) {
    this.props.active && !oldProps.active && (this.focusContent(), this.changeTransitionStatus(TransitionStatus.Entering, () => {
      this.clearTransitionTimeout(), this.enteringTimer = window.setTimeout(() => {
        this.setState({
          transitionStatus: TransitionStatus.Entered
        });
      }, parseInt(themeDefault.motion["motion-duration-100"], 10));
    })), !this.props.active && oldProps.active && (this.clearTransitionTimeout(), this.setState({
      transitionStatus: TransitionStatus.Exited
    }));
  }
  componentWillUnmount() {
    this.clearTransitionTimeout();
  }
  render() {
    let {
      active,
      activator,
      fullWidth,
      preferredPosition = "below",
      preferredAlignment = "center",
      preferInputActivator = !0,
      fixed,
      zIndexOverride
    } = this.props, {
      transitionStatus
    } = this.state;
    if (transitionStatus === TransitionStatus.Exited && !active)
      return null;
    let className = classNames(styles24.PopoverOverlay, transitionStatus === TransitionStatus.Entering && styles24["PopoverOverlay-entering"], transitionStatus === TransitionStatus.Entered && styles24["PopoverOverlay-open"], transitionStatus === TransitionStatus.Exiting && styles24["PopoverOverlay-exiting"], preferredPosition === "cover" && styles24["PopoverOverlay-noAnimation"]);
    return /* @__PURE__ */ import_react91.default.createElement(PositionedOverlay, {
      ref: this.overlayRef,
      fullWidth,
      active,
      activator,
      preferInputActivator,
      preferredPosition,
      preferredAlignment,
      render: this.renderPopover.bind(this),
      fixed,
      onScrollOut: this.handleScrollOut,
      classNames: className,
      zIndexOverride
    });
  }
  clearTransitionTimeout() {
    this.enteringTimer && window.clearTimeout(this.enteringTimer);
  }
  focusContent() {
    let {
      autofocusTarget = "container"
    } = this.props;
    autofocusTarget === "none" || this.contentNode == null || requestAnimationFrame(() => {
      if (this.contentNode.current == null)
        return;
      let focusableChild = findFirstKeyboardFocusableNode(this.contentNode.current);
      focusableChild && autofocusTarget === "first-node" ? focusableChild.focus({
        preventScroll: !1
      }) : this.contentNode.current.focus({
        preventScroll: !1
      });
    });
  }
  // eslint-disable-next-line @shopify/react-no-multiple-render-methods
};
PopoverOverlay.contextType = PortalsManagerContext;
function renderPopoverContent(children, props) {
  let childrenArray = import_react91.Children.toArray(children);
  return isElementOfType(childrenArray[0], Pane) ? childrenArray : wrapWithComponent(childrenArray, Pane, props);
}
function nodeContainsDescendant(rootNode, descendant) {
  if (rootNode === descendant)
    return !0;
  let parent = descendant.parentNode;
  for (; parent != null; ) {
    if (parent === rootNode)
      return !0;
    parent = parent.parentNode;
  }
  return !1;
}
function wasContentNodeDescendant(composedPath, contentNode) {
  return contentNode.current != null && composedPath.includes(contentNode.current);
}
function wasPolarisPortalDescendant(composedPath, portalsContainerElement) {
  return composedPath.some((eventTarget) => eventTarget instanceof Node && portalsContainerElement?.contains(eventTarget));
}

// node_modules/@shopify/polaris/build/esm/components/Popover/Popover.js
var PopoverComponent = /* @__PURE__ */ (0, import_react92.forwardRef)(function({
  activatorWrapper = "div",
  children,
  onClose,
  activator,
  preventFocusOnClose,
  active,
  fixed,
  ariaHaspopup,
  preferInputActivator = !0,
  zIndexOverride,
  ...rest
}, ref) {
  let [activatorNode, setActivatorNode] = (0, import_react92.useState)(), overlayRef = (0, import_react92.useRef)(null), activatorContainer = (0, import_react92.useRef)(null), WrapperComponent = activatorWrapper, id = (0, import_react92.useId)();
  function forceUpdatePosition() {
    overlayRef.current?.forceUpdatePosition();
  }
  (0, import_react92.useImperativeHandle)(ref, () => ({
    forceUpdatePosition
  }));
  let setAccessibilityAttributes = (0, import_react92.useCallback)(() => {
    if (activatorContainer.current == null)
      return;
    let focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current, activatorDisabled = "disabled" in focusableActivator && Boolean(focusableActivator.disabled);
    setActivatorAttributes(focusableActivator, {
      id,
      active,
      ariaHaspopup,
      activatorDisabled
    });
  }, [id, active, ariaHaspopup]), handleClose = (source) => {
    if (onClose(source), !(activatorContainer.current == null || preventFocusOnClose)) {
      if (source === PopoverCloseSource.FocusOut && activatorNode) {
        let focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;
        focusNextFocusableNode(focusableActivator, isInPortal) || focusableActivator.focus();
      } else if (source === PopoverCloseSource.EscapeKeypress && activatorNode) {
        let focusableActivator = findFirstFocusableNodeIncludingDisabled(activatorNode) || findFirstFocusableNodeIncludingDisabled(activatorContainer.current) || activatorContainer.current;
        focusableActivator ? focusableActivator.focus() : focusNextFocusableNode(focusableActivator, isInPortal);
      }
    }
  };
  (0, import_react92.useEffect)(() => {
    (!activatorNode && activatorContainer.current || activatorNode && activatorContainer.current && !activatorContainer.current.contains(activatorNode)) && setActivatorNode(activatorContainer.current.firstElementChild), setAccessibilityAttributes();
  }, [activatorNode, setAccessibilityAttributes]), (0, import_react92.useEffect)(() => {
    activatorNode && activatorContainer.current && setActivatorNode(activatorContainer.current.firstElementChild), setAccessibilityAttributes();
  }, [activatorNode, setAccessibilityAttributes]);
  let portal2 = activatorNode ? /* @__PURE__ */ import_react92.default.createElement(Portal, {
    idPrefix: "popover"
  }, /* @__PURE__ */ import_react92.default.createElement(PopoverOverlay, Object.assign({
    ref: overlayRef,
    id,
    activator: activatorNode,
    preferInputActivator,
    onClose: handleClose,
    active,
    fixed,
    zIndexOverride
  }, rest), children)) : null;
  return /* @__PURE__ */ import_react92.default.createElement(WrapperComponent, {
    ref: activatorContainer
  }, import_react92.Children.only(activator), portal2);
});
function isInPortal(element) {
  let parentElement = element.parentElement;
  for (; parentElement; ) {
    if (parentElement.matches(portal.selector))
      return !1;
    parentElement = parentElement.parentElement;
  }
  return !0;
}
var Popover2 = Object.assign(PopoverComponent, {
  Pane,
  Section: Section2
});

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/RollupActions/RollupActions.js
function RollupActions({
  accessibilityLabel,
  items = [],
  sections = []
}) {
  let i18n = useI18n(), {
    value: rollupOpen,
    toggle: toggleRollupOpen
  } = useToggle(!1);
  if (items.length === 0 && sections.length === 0)
    return null;
  let activatorMarkup = /* @__PURE__ */ import_react93.default.createElement("div", {
    className: styles23.RollupActivator
  }, /* @__PURE__ */ import_react93.default.createElement(Button, {
    icon: SvgMenuHorizontalIcon,
    accessibilityLabel: accessibilityLabel || i18n.translate("Polaris.ActionMenu.RollupActions.rollupButton"),
    onClick: toggleRollupOpen
  }));
  return /* @__PURE__ */ import_react93.default.createElement(Popover2, {
    active: rollupOpen,
    activator: activatorMarkup,
    preferredAlignment: "right",
    onClose: toggleRollupOpen,
    hideOnPrint: !0
  }, /* @__PURE__ */ import_react93.default.createElement(ActionList, {
    items,
    sections,
    onActionAnyItem: toggleRollupOpen
  }));
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/Actions/Actions.js
var import_react97 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/Actions/Actions.css.js
var styles25 = {
  ActionsLayoutOuter: "Polaris-ActionMenu-Actions__ActionsLayoutOuter",
  ActionsLayout: "Polaris-ActionMenu-Actions__ActionsLayout",
  "ActionsLayout--measuring": "Polaris-ActionMenu-Actions--actionsLayoutMeasuring",
  ActionsLayoutMeasurer: "Polaris-ActionMenu-Actions__ActionsLayoutMeasurer"
};

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/Actions/utilities.js
function getVisibleAndHiddenActionsIndices(actions = [], groups = [], disclosureWidth, actionsWidths, containerWidth) {
  let sumTabWidths = actionsWidths.reduce((sum, width2) => sum + width2, 0), arrayOfActionsIndices = actions.map((_, index) => index), arrayOfGroupsIndices = groups.map((_, index) => index), visibleActions = [], hiddenActions = [], visibleGroups = [], hiddenGroups = [];
  if (containerWidth > sumTabWidths)
    visibleActions.push(...arrayOfActionsIndices), visibleGroups.push(...arrayOfGroupsIndices);
  else {
    let accumulatedWidth = 0;
    arrayOfActionsIndices.forEach((currentActionsIndex) => {
      let currentActionsWidth = actionsWidths[currentActionsIndex];
      if (accumulatedWidth + currentActionsWidth >= containerWidth - disclosureWidth) {
        hiddenActions.push(currentActionsIndex);
        return;
      }
      visibleActions.push(currentActionsIndex), accumulatedWidth += currentActionsWidth;
    }), arrayOfGroupsIndices.forEach((currentGroupsIndex) => {
      let currentActionsWidth = actionsWidths[currentGroupsIndex + actions.length];
      if (accumulatedWidth + currentActionsWidth >= containerWidth - disclosureWidth) {
        hiddenGroups.push(currentGroupsIndex);
        return;
      }
      visibleGroups.push(currentGroupsIndex), accumulatedWidth += currentActionsWidth;
    });
  }
  return {
    visibleActions,
    hiddenActions,
    visibleGroups,
    hiddenGroups
  };
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/MenuGroup/MenuGroup.js
var import_react95 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/MenuGroup/MenuGroup.css.js
var styles26 = {
  Details: "Polaris-ActionMenu-MenuGroup__Details"
};

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/SecondaryAction/SecondaryAction.js
var import_react94 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/SecondaryAction/SecondaryAction.css.js
var styles27 = {
  SecondaryAction: "Polaris-ActionMenu-SecondaryAction",
  critical: "Polaris-ActionMenu-SecondaryAction--critical"
};

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/SecondaryAction/SecondaryAction.js
function SecondaryAction({
  children,
  tone,
  helpText,
  onAction,
  destructive,
  ...rest
}) {
  let buttonMarkup = /* @__PURE__ */ import_react94.default.createElement(Button, Object.assign({
    onClick: onAction,
    tone: destructive ? "critical" : void 0
  }, rest), children), actionMarkup = helpText ? /* @__PURE__ */ import_react94.default.createElement(Tooltip, {
    preferredPosition: "below",
    content: helpText
  }, buttonMarkup) : buttonMarkup;
  return /* @__PURE__ */ import_react94.default.createElement("div", {
    className: classNames(styles27.SecondaryAction, tone === "critical" && styles27.critical)
  }, actionMarkup);
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/MenuGroup/MenuGroup.js
function MenuGroup({
  accessibilityLabel,
  active,
  actions,
  details,
  title,
  icon,
  disabled,
  onClick,
  onClose,
  onOpen,
  sections
}) {
  let handleClose = (0, import_react95.useCallback)(() => {
    onClose(title);
  }, [onClose, title]), handleOpen = (0, import_react95.useCallback)(() => {
    onOpen(title);
  }, [onOpen, title]), handleClick = (0, import_react95.useCallback)(() => {
    onClick ? onClick(handleOpen) : handleOpen();
  }, [onClick, handleOpen]), popoverActivator = /* @__PURE__ */ import_react95.default.createElement(SecondaryAction, {
    disclosure: !0,
    disabled,
    icon,
    accessibilityLabel,
    onClick: handleClick
  }, title);
  return /* @__PURE__ */ import_react95.default.createElement(Popover2, {
    active: Boolean(active),
    activator: popoverActivator,
    preferredAlignment: "left",
    onClose: handleClose,
    hideOnPrint: !0
  }, /* @__PURE__ */ import_react95.default.createElement(ActionList, {
    items: actions,
    sections,
    onActionAnyItem: handleClose
  }), details && /* @__PURE__ */ import_react95.default.createElement("div", {
    className: styles26.Details
  }, details));
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/Actions/components/ActionsMeasurer/ActionsMeasurer.js
var import_react96 = __toESM(require_react());
var ACTION_SPACING = 8;
function ActionsMeasurer({
  actions = [],
  groups = [],
  handleMeasurement: handleMeasurementProp
}) {
  let i18n = useI18n(), containerNode = (0, import_react96.useRef)(null), defaultRollupGroup = {
    title: i18n.translate("Polaris.ActionMenu.Actions.moreActions"),
    actions: []
  }, activator = /* @__PURE__ */ import_react96.default.createElement(SecondaryAction, {
    disclosure: !0
  }, defaultRollupGroup.title), handleMeasurement = (0, import_react96.useCallback)(() => {
    if (!containerNode.current)
      return;
    let containerWidth = containerNode.current.offsetWidth, hiddenActionNodes = containerNode.current.children, hiddenActionsWidths = Array.from(hiddenActionNodes).map((node) => Math.ceil(node.getBoundingClientRect().width) + ACTION_SPACING), disclosureWidth = hiddenActionsWidths.pop() || 0;
    handleMeasurementProp({
      containerWidth,
      disclosureWidth,
      hiddenActionsWidths
    });
  }, [handleMeasurementProp]);
  (0, import_react96.useEffect)(() => {
    handleMeasurement();
  }, [handleMeasurement, actions, groups]);
  let actionsMarkup = actions.map((action8) => {
    let {
      content,
      onAction,
      ...rest
    } = action8;
    return /* @__PURE__ */ import_react96.default.createElement(SecondaryAction, Object.assign({
      key: content,
      onClick: onAction
    }, rest), content);
  }), groupsMarkup = groups.map((group) => {
    let {
      title,
      icon
    } = group;
    return /* @__PURE__ */ import_react96.default.createElement(SecondaryAction, {
      key: title,
      disclosure: !0,
      icon
    }, title);
  });
  return useEventListener("resize", handleMeasurement), /* @__PURE__ */ import_react96.default.createElement("div", {
    className: styles25.ActionsLayoutMeasurer,
    ref: containerNode
  }, actionsMarkup, groupsMarkup, activator);
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/components/Actions/Actions.js
function Actions({
  actions,
  groups,
  onActionRollup
}) {
  let i18n = useI18n(), rollupActiveRef = (0, import_react97.useRef)(null), [activeMenuGroup, setActiveMenuGroup] = (0, import_react97.useState)(void 0), [state, setState] = (0, import_react97.useReducer)((data3, partialData) => ({
    ...data3,
    ...partialData
  }), {
    disclosureWidth: 0,
    containerWidth: 1 / 0,
    actionsWidths: [],
    visibleActions: [],
    hiddenActions: [],
    visibleGroups: [],
    hiddenGroups: [],
    hasMeasured: !1
  }), {
    visibleActions,
    hiddenActions,
    visibleGroups,
    hiddenGroups,
    containerWidth,
    disclosureWidth,
    actionsWidths,
    hasMeasured
  } = state, defaultRollupGroup = {
    title: i18n.translate("Polaris.ActionMenu.Actions.moreActions"),
    actions: []
  }, handleMenuGroupToggle = (0, import_react97.useCallback)((group) => setActiveMenuGroup(activeMenuGroup ? void 0 : group), [activeMenuGroup]), handleMenuGroupClose = (0, import_react97.useCallback)(() => setActiveMenuGroup(void 0), []);
  (0, import_react97.useEffect)(() => {
    if (containerWidth === 0)
      return;
    let {
      visibleActions: visibleActions2,
      visibleGroups: visibleGroups2,
      hiddenActions: hiddenActions2,
      hiddenGroups: hiddenGroups2
    } = getVisibleAndHiddenActionsIndices(actions, groups, disclosureWidth, actionsWidths, containerWidth);
    setState({
      visibleActions: visibleActions2,
      visibleGroups: visibleGroups2,
      hiddenActions: hiddenActions2,
      hiddenGroups: hiddenGroups2,
      hasMeasured: containerWidth !== 1 / 0
    });
  }, [containerWidth, disclosureWidth, actions, groups, actionsWidths, setState]);
  let actionsOrDefault = (0, import_react97.useMemo)(() => actions ?? [], [actions]), groupsOrDefault = (0, import_react97.useMemo)(() => groups ?? [], [groups]), actionsMarkup = actionsOrDefault.filter((_, index) => !!visibleActions.includes(index)).map((action8) => {
    let {
      content,
      onAction,
      ...rest
    } = action8;
    return /* @__PURE__ */ import_react97.default.createElement(SecondaryAction, Object.assign({
      key: content,
      onClick: onAction
    }, rest), content);
  }), filteredGroups = (hiddenGroups.length > 0 || hiddenActions.length > 0 ? [...groupsOrDefault, defaultRollupGroup] : [...groupsOrDefault]).filter((group, index) => {
    let hasNoGroupsProp = groupsOrDefault.length === 0, isVisibleGroup = visibleGroups.includes(index), isDefaultGroup = group === defaultRollupGroup;
    return hasNoGroupsProp ? hiddenActions.length > 0 : isDefaultGroup ? !0 : isVisibleGroup;
  }), hiddenActionObjects = hiddenActions.map((index) => actionsOrDefault[index]).filter((action8) => action8 != null), hiddenGroupObjects = hiddenGroups.map((index) => groupsOrDefault[index]).filter((group) => group != null), groupsMarkup = filteredGroups.map((group) => {
    let {
      title,
      actions: groupActions,
      ...rest
    } = group, isDefaultGroup = group === defaultRollupGroup, allHiddenItems = [...hiddenActionObjects, ...hiddenGroupObjects], [finalRolledUpActions, finalRolledUpSectionGroups] = allHiddenItems.reduce(([actions2, sections], action8) => (isMenuGroup(action8) ? sections.push({
      title: action8.title,
      items: action8.actions.map((sectionAction) => ({
        ...sectionAction,
        disabled: action8.disabled || sectionAction.disabled
      }))
    }) : actions2.push(action8), [actions2, sections]), [[], []]);
    return isDefaultGroup ? /* @__PURE__ */ import_react97.default.createElement(MenuGroup, Object.assign({
      key: title,
      title,
      active: title === activeMenuGroup,
      actions: [...finalRolledUpActions, ...groupActions],
      sections: finalRolledUpSectionGroups
    }, rest, {
      onOpen: handleMenuGroupToggle,
      onClose: handleMenuGroupClose
    })) : /* @__PURE__ */ import_react97.default.createElement(MenuGroup, Object.assign({
      key: title,
      title,
      active: title === activeMenuGroup,
      actions: groupActions
    }, rest, {
      onOpen: handleMenuGroupToggle,
      onClose: handleMenuGroupClose
    }));
  }), handleMeasurement = (0, import_react97.useCallback)((measurements) => {
    let {
      hiddenActionsWidths: actionsWidths2,
      containerWidth: containerWidth2,
      disclosureWidth: disclosureWidth2
    } = measurements, {
      visibleActions: visibleActions2,
      hiddenActions: hiddenActions2,
      visibleGroups: visibleGroups2,
      hiddenGroups: hiddenGroups2
    } = getVisibleAndHiddenActionsIndices(actionsOrDefault, groupsOrDefault, disclosureWidth2, actionsWidths2, containerWidth2);
    if (onActionRollup) {
      let isRollupActive = hiddenActions2.length > 0 || hiddenGroups2.length > 0;
      rollupActiveRef.current !== isRollupActive && (onActionRollup(isRollupActive), rollupActiveRef.current = isRollupActive);
    }
    setState({
      visibleActions: visibleActions2,
      hiddenActions: hiddenActions2,
      visibleGroups: visibleGroups2,
      hiddenGroups: hiddenGroups2,
      actionsWidths: actionsWidths2,
      containerWidth: containerWidth2,
      disclosureWidth: disclosureWidth2,
      hasMeasured: !0
    });
  }, [actionsOrDefault, groupsOrDefault, onActionRollup]), actionsMeasurer = /* @__PURE__ */ import_react97.default.createElement(ActionsMeasurer, {
    actions,
    groups,
    handleMeasurement
  });
  return /* @__PURE__ */ import_react97.default.createElement("div", {
    className: styles25.ActionsLayoutOuter
  }, actionsMeasurer, /* @__PURE__ */ import_react97.default.createElement("div", {
    className: classNames(styles25.ActionsLayout, !hasMeasured && styles25["ActionsLayout--measuring"])
  }, actionsMarkup, groupsMarkup));
}
function isMenuGroup(actionOrMenuGroup) {
  return "title" in actionOrMenuGroup;
}

// node_modules/@shopify/polaris/build/esm/components/ActionMenu/ActionMenu.js
function ActionMenu({
  actions = [],
  groups = [],
  rollup,
  rollupActionsLabel,
  onActionRollup
}) {
  if (actions.length === 0 && groups.length === 0)
    return null;
  let actionMenuClassNames = classNames(styles22.ActionMenu, rollup && styles22.rollup), rollupSections = groups.map((group) => convertGroupToSection(group));
  return /* @__PURE__ */ import_react98.default.createElement("div", {
    className: actionMenuClassNames
  }, rollup ? /* @__PURE__ */ import_react98.default.createElement(RollupActions, {
    accessibilityLabel: rollupActionsLabel,
    items: actions,
    sections: rollupSections
  }) : /* @__PURE__ */ import_react98.default.createElement(Actions, {
    actions,
    groups,
    onActionRollup
  }));
}
function hasGroupsWithActions(groups = []) {
  return groups.length === 0 ? !1 : groups.some((group) => group.actions.length > 0);
}
function convertGroupToSection({
  title,
  actions,
  disabled
}) {
  return {
    title,
    items: actions.map((action8) => ({
      ...action8,
      disabled: disabled || action8.disabled
    }))
  };
}

// node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.js
var import_react101 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.css.js
var styles28 = {
  Backdrop: "Polaris-Backdrop",
  transparent: "Polaris-Backdrop--transparent",
  belowNavigation: "Polaris-Backdrop--belowNavigation"
};

// node_modules/@shopify/polaris/build/esm/components/ScrollLock/ScrollLock.js
var import_react100 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/scroll-lock-manager/hooks.js
var import_react99 = __toESM(require_react());
function useScrollLockManager() {
  let scrollLockManager = (0, import_react99.useContext)(ScrollLockManagerContext);
  if (!scrollLockManager)
    throw new MissingAppProviderError("No ScrollLockManager was provided.");
  return scrollLockManager;
}

// node_modules/@shopify/polaris/build/esm/components/ScrollLock/ScrollLock.js
function ScrollLock(_) {
  let scrollLockManager = useScrollLockManager();
  return (0, import_react100.useEffect)(() => (scrollLockManager.registerScrollLock(), () => {
    scrollLockManager.unregisterScrollLock();
  }), [scrollLockManager]), null;
}

// node_modules/@shopify/polaris/build/esm/components/Backdrop/Backdrop.js
function Backdrop(props) {
  let {
    onClick,
    onTouchStart,
    belowNavigation,
    transparent,
    setClosing
  } = props, className = classNames(styles28.Backdrop, belowNavigation && styles28.belowNavigation, transparent && styles28.transparent), handleMouseDown = () => {
    setClosing && setClosing(!0);
  }, handleClick = () => {
    setClosing && setClosing(!1), onClick && onClick();
  };
  return /* @__PURE__ */ import_react101.default.createElement(import_react101.default.Fragment, null, /* @__PURE__ */ import_react101.default.createElement(ScrollLock, null), /* @__PURE__ */ import_react101.default.createElement("div", {
    className,
    onClick: handleClick,
    onTouchStart,
    onMouseDown: handleMouseDown
  }));
}

// node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.js
var import_react103 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.css.js
var styles29 = {
  ButtonGroup: "Polaris-ButtonGroup",
  Item: "Polaris-ButtonGroup__Item",
  "Item-plain": "Polaris-ButtonGroup__Item--plain",
  variantSegmented: "Polaris-ButtonGroup--variantSegmented",
  "Item-focused": "Polaris-ButtonGroup__Item--focused",
  fullWidth: "Polaris-ButtonGroup--fullWidth",
  extraTight: "Polaris-ButtonGroup--extraTight",
  tight: "Polaris-ButtonGroup--tight",
  loose: "Polaris-ButtonGroup--loose",
  noWrap: "Polaris-ButtonGroup--noWrap"
};

// node_modules/@shopify/polaris/build/esm/components/ButtonGroup/components/Item/Item.js
var import_react102 = __toESM(require_react());
function Item3({
  button
}) {
  let {
    value: focused,
    setTrue: forceTrueFocused,
    setFalse: forceFalseFocused
  } = useToggle(!1), className = classNames(styles29.Item, focused && styles29["Item-focused"], button.props.variant === "plain" && styles29["Item-plain"]);
  return /* @__PURE__ */ import_react102.default.createElement("div", {
    className,
    onFocus: forceTrueFocused,
    onBlur: forceFalseFocused
  }, button);
}

// node_modules/@shopify/polaris/build/esm/components/ButtonGroup/ButtonGroup.js
function ButtonGroup({
  children,
  gap,
  variant,
  fullWidth,
  connectedTop,
  noWrap
}) {
  let className = classNames(styles29.ButtonGroup, gap && styles29[gap], variant && styles29[variationName("variant", variant)], fullWidth && styles29.fullWidth, noWrap && styles29.noWrap), contents = elementChildren(children).map((child, index) => /* @__PURE__ */ import_react103.default.createElement(Item3, {
    button: child,
    key: index
  }));
  return /* @__PURE__ */ import_react103.default.createElement("div", {
    className,
    "data-buttongroup-variant": variant,
    "data-buttongroup-connected-top": connectedTop,
    "data-buttongroup-full-width": fullWidth,
    "data-buttongroup-no-wrap": noWrap
  }, contents);
}

// node_modules/@shopify/polaris/build/esm/components/Bleed/Bleed.js
var import_react104 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Bleed/Bleed.css.js
var styles30 = {
  Bleed: "Polaris-Bleed"
};

// node_modules/@shopify/polaris/build/esm/components/Bleed/Bleed.js
var Bleed = ({
  marginInline,
  marginBlock,
  marginBlockStart,
  marginBlockEnd,
  marginInlineStart,
  marginInlineEnd,
  children
}) => {
  let getNegativeMargins = (direction) => {
    let xAxis = ["marginInlineStart", "marginInlineEnd"], yAxis = ["marginBlockStart", "marginBlockEnd"], directionValues = {
      marginBlockStart,
      marginBlockEnd,
      marginInlineStart,
      marginInlineEnd,
      marginInline,
      marginBlock
    };
    if (directionValues[direction])
      return directionValues[direction];
    if (xAxis.includes(direction) && marginInline)
      return directionValues.marginInline;
    if (yAxis.includes(direction) && marginBlock)
      return directionValues.marginBlock;
  }, negativeMarginBlockStart = getNegativeMargins("marginBlockStart"), negativeMarginBlockEnd = getNegativeMargins("marginBlockEnd"), negativeMarginInlineStart = getNegativeMargins("marginInlineStart"), negativeMarginInlineEnd = getNegativeMargins("marginInlineEnd"), style = {
    ...getResponsiveProps("bleed", "margin-block-start", "space", negativeMarginBlockStart),
    ...getResponsiveProps("bleed", "margin-block-end", "space", negativeMarginBlockEnd),
    ...getResponsiveProps("bleed", "margin-inline-start", "space", negativeMarginInlineStart),
    ...getResponsiveProps("bleed", "margin-inline-end", "space", negativeMarginInlineEnd)
  };
  return /* @__PURE__ */ import_react104.default.createElement("div", {
    className: styles30.Bleed,
    style: sanitizeCustomProperties(style)
  }, children);
};

// node_modules/@shopify/polaris/build/esm/components/Breadcrumbs/Breadcrumbs.js
var import_react105 = __toESM(require_react());
function Breadcrumbs({
  backAction
}) {
  let {
    content
  } = backAction;
  return /* @__PURE__ */ import_react105.default.createElement(Button, {
    key: content,
    url: "url" in backAction ? backAction.url : void 0,
    onClick: "onAction" in backAction ? backAction.onAction : void 0,
    onPointerDown: handleMouseUpByBlurring,
    icon: SvgArrowLeftIcon,
    accessibilityLabel: backAction.accessibilityLabel ?? content
  });
}

// node_modules/@shopify/polaris/build/esm/components/LegacyStack/LegacyStack.js
var import_react107 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/LegacyStack/LegacyStack.css.js
var styles31 = {
  LegacyStack: "Polaris-LegacyStack",
  Item: "Polaris-LegacyStack__Item",
  noWrap: "Polaris-LegacyStack--noWrap",
  spacingNone: "Polaris-LegacyStack--spacingNone",
  spacingExtraTight: "Polaris-LegacyStack--spacingExtraTight",
  spacingTight: "Polaris-LegacyStack--spacingTight",
  spacingBaseTight: "Polaris-LegacyStack--spacingBaseTight",
  spacingLoose: "Polaris-LegacyStack--spacingLoose",
  spacingExtraLoose: "Polaris-LegacyStack--spacingExtraLoose",
  distributionLeading: "Polaris-LegacyStack--distributionLeading",
  distributionTrailing: "Polaris-LegacyStack--distributionTrailing",
  distributionCenter: "Polaris-LegacyStack--distributionCenter",
  distributionEqualSpacing: "Polaris-LegacyStack--distributionEqualSpacing",
  distributionFill: "Polaris-LegacyStack--distributionFill",
  distributionFillEvenly: "Polaris-LegacyStack--distributionFillEvenly",
  alignmentLeading: "Polaris-LegacyStack--alignmentLeading",
  alignmentTrailing: "Polaris-LegacyStack--alignmentTrailing",
  alignmentCenter: "Polaris-LegacyStack--alignmentCenter",
  alignmentFill: "Polaris-LegacyStack--alignmentFill",
  alignmentBaseline: "Polaris-LegacyStack--alignmentBaseline",
  vertical: "Polaris-LegacyStack--vertical",
  "Item-fill": "Polaris-LegacyStack__Item--fill"
};

// node_modules/@shopify/polaris/build/esm/components/LegacyStack/components/Item/Item.js
var import_react106 = __toESM(require_react());
function Item4({
  children,
  fill
}) {
  let className = classNames(styles31.Item, fill && styles31["Item-fill"]);
  return /* @__PURE__ */ import_react106.default.createElement("div", {
    className
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/LegacyStack/LegacyStack.js
var LegacyStack = /* @__PURE__ */ (0, import_react107.memo)(function({
  children,
  vertical,
  spacing,
  distribution,
  alignment,
  wrap
}) {
  let className = classNames(styles31.LegacyStack, vertical && styles31.vertical, spacing && styles31[variationName("spacing", spacing)], distribution && styles31[variationName("distribution", distribution)], alignment && styles31[variationName("alignment", alignment)], wrap === !1 && styles31.noWrap), itemMarkup = elementChildren(children).map((child, index) => wrapWithComponent(child, Item4, {
    key: index
  }));
  return /* @__PURE__ */ import_react107.default.createElement("div", {
    className
  }, itemMarkup);
});
LegacyStack.Item = Item4;

// node_modules/@shopify/polaris/build/esm/components/Collapsible/Collapsible.js
var import_react108 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Collapsible/Collapsible.css.js
var styles32 = {
  Collapsible: "Polaris-Collapsible",
  isFullyClosed: "Polaris-Collapsible--isFullyClosed",
  expandOnPrint: "Polaris-Collapsible--expandOnPrint"
};

// node_modules/@shopify/polaris/build/esm/components/Collapsible/Collapsible.js
function Collapsible({
  id,
  expandOnPrint,
  open,
  transition = !0,
  children,
  onAnimationEnd
}) {
  let [height2, setHeight] = (0, import_react108.useState)(0), [isOpen, setIsOpen] = (0, import_react108.useState)(open), [animationState, setAnimationState] = (0, import_react108.useState)("idle"), collapsibleContainer = (0, import_react108.useRef)(null), isFullyOpen = animationState === "idle" && open && isOpen, isFullyClosed = animationState === "idle" && !open && !isOpen, content = expandOnPrint || !isFullyClosed ? children : null, wrapperClassName = classNames(styles32.Collapsible, isFullyClosed && styles32.isFullyClosed, expandOnPrint && styles32.expandOnPrint), transitionDisabled = isTransitionDisabled(transition), collapsibleStyles = {
    ...typeof transition == "object" && {
      transitionDuration: transition.duration,
      transitionTimingFunction: transition.timingFunction
    },
    maxHeight: isFullyOpen ? "none" : `${height2}px`,
    overflow: isFullyOpen ? "visible" : "hidden"
  }, handleCompleteAnimation = (0, import_react108.useCallback)(({
    target
  }) => {
    target === collapsibleContainer.current && (setAnimationState("idle"), setIsOpen(open), onAnimationEnd && onAnimationEnd());
  }, [onAnimationEnd, open]), startAnimation = (0, import_react108.useCallback)(() => {
    transitionDisabled ? (setIsOpen(open), setAnimationState("idle"), open && collapsibleContainer.current ? setHeight(collapsibleContainer.current.scrollHeight) : setHeight(0)) : setAnimationState("measuring");
  }, [open, transitionDisabled]);
  return (0, import_react108.useEffect)(() => {
    open !== isOpen && startAnimation();
  }, [open, isOpen]), (0, import_react108.useEffect)(() => {
    !open || !collapsibleContainer.current || setHeight(collapsibleContainer.current.scrollHeight);
  }, []), (0, import_react108.useEffect)(() => {
    if (collapsibleContainer.current)
      switch (animationState) {
        case "idle":
          break;
        case "measuring":
          setHeight(collapsibleContainer.current.scrollHeight), setAnimationState("animating");
          break;
        case "animating":
          setHeight(open ? collapsibleContainer.current.scrollHeight : 0);
      }
  }, [animationState, open, isOpen]), /* @__PURE__ */ import_react108.default.createElement("div", {
    id,
    style: collapsibleStyles,
    ref: collapsibleContainer,
    className: wrapperClassName,
    onTransitionEnd: handleCompleteAnimation,
    "aria-hidden": !open
  }, content);
}
var zeroDurationRegex = /^0(ms|s)$/;
function isTransitionDisabled(transitionProp) {
  if (typeof transitionProp == "boolean")
    return !transitionProp;
  let {
    duration
  } = transitionProp;
  return !!(duration && zeroDurationRegex.test(duration.trim()));
}

// node_modules/@shopify/polaris/build/esm/components/InlineGrid/InlineGrid.js
var import_react109 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/InlineGrid/InlineGrid.css.js
var styles33 = {
  InlineGrid: "Polaris-InlineGrid"
};

// node_modules/@shopify/polaris/build/esm/components/InlineGrid/InlineGrid.js
function InlineGrid({
  children,
  columns,
  gap,
  alignItems
}) {
  let style = {
    ...getResponsiveValue("inline-grid", "grid-template-columns", formatInlineGrid(columns)),
    ...getResponsiveProps("inline-grid", "gap", "space", gap),
    "--pc-inline-grid-align-items": alignItems
  };
  return /* @__PURE__ */ import_react109.default.createElement("div", {
    className: styles33.InlineGrid,
    style: sanitizeCustomProperties(style)
  }, children);
}
function formatInlineGrid(columns) {
  return typeof columns == "object" && columns !== null && !Array.isArray(columns) ? Object.fromEntries(Object.entries(columns).map(([breakpointAlias, breakpointInlineGrid]) => [breakpointAlias, getColumnValue(breakpointInlineGrid)])) : getColumnValue(columns);
}
function getColumnValue(columns) {
  if (columns)
    return typeof columns == "number" || !isNaN(Number(columns)) ? `repeat(${Number(columns)}, minmax(0, 1fr))` : typeof columns == "string" ? columns : columns.map((column) => {
      switch (column) {
        case "oneThird":
          return "minmax(0, 1fr)";
        case "oneHalf":
          return "minmax(0, 1fr)";
        case "twoThirds":
          return "minmax(0, 2fr)";
      }
    }).join(" ");
}

// node_modules/@shopify/polaris/build/esm/utilities/frame/hooks.js
var import_react111 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/frame/context.js
var import_react110 = __toESM(require_react()), FrameContext = /* @__PURE__ */ (0, import_react110.createContext)(void 0);

// node_modules/@shopify/polaris/build/esm/utilities/frame/hooks.js
function useFrame() {
  let frame = (0, import_react111.useContext)(FrameContext);
  if (!frame)
    throw new Error("No Frame context was provided. Your component must be wrapped in a <Frame> component. See https://polaris.shopify.com/components/internal-only/frame for implementation instructions.");
  return frame;
}

// node_modules/@shopify/polaris/build/esm/components/DataTable/DataTable.js
var import_react118 = __toESM(require_react()), import_react_fast_compare = __toESM(require_react_fast_compare());

// node_modules/@shopify/polaris/build/esm/components/DataTable/utilities.js
function measureColumn(tableData) {
  return function(column, index) {
    let {
      firstVisibleColumnIndex,
      tableLeftVisibleEdge: tableStart,
      tableRightVisibleEdge: tableEnd
    } = tableData, leftEdge = column.offsetLeft, rightEdge = leftEdge + column.offsetWidth, isVisibleLeft = isEdgeVisible(leftEdge, tableStart, tableEnd, "left"), isVisibleRight = isEdgeVisible(rightEdge, tableStart, tableEnd, "right"), isVisible = isVisibleLeft || isVisibleRight, width2 = column.offsetWidth;
    return isVisible && (tableData.firstVisibleColumnIndex = Math.min(firstVisibleColumnIndex, index)), {
      leftEdge,
      rightEdge,
      isVisible,
      width: width2,
      index
    };
  };
}
function isEdgeVisible(position, start, end, edgeType) {
  return position >= start + (edgeType === "left" ? 0 : 30) && position <= end - 30;
}
function getPrevAndCurrentColumns(tableData, columnData) {
  let {
    firstVisibleColumnIndex
  } = tableData, previousColumnIndex = Math.max(firstVisibleColumnIndex - 1, 0), previousColumn = columnData[previousColumnIndex], currentColumn = columnData[firstVisibleColumnIndex];
  return {
    previousColumn,
    currentColumn
  };
}

// node_modules/@shopify/polaris/build/esm/components/DataTable/DataTable.css.js
var styles34 = {
  DataTable: "Polaris-DataTable",
  condensed: "Polaris-DataTable--condensed",
  Navigation: "Polaris-DataTable__Navigation",
  Pip: "Polaris-DataTable__Pip",
  "Pip-visible": "Polaris-DataTable__Pip--visible",
  ScrollContainer: "Polaris-DataTable__ScrollContainer",
  Table: "Polaris-DataTable__Table",
  TableRow: "Polaris-DataTable__TableRow",
  Cell: "Polaris-DataTable__Cell",
  IncreasedTableDensity: "Polaris-DataTable__IncreasedTableDensity",
  ZebraStripingOnData: "Polaris-DataTable__ZebraStripingOnData",
  RowCountIsEven: "Polaris-DataTable__RowCountIsEven",
  ShowTotalsInFooter: "Polaris-DataTable__ShowTotalsInFooter",
  "Cell-separate": "Polaris-DataTable__Cell--separate",
  "Cell-firstColumn": "Polaris-DataTable__Cell--firstColumn",
  "Cell-numeric": "Polaris-DataTable__Cell--numeric",
  "Cell-truncated": "Polaris-DataTable__Cell--truncated",
  "Cell-header": "Polaris-DataTable__Cell--header",
  "Cell-sortable": "Polaris-DataTable__Cell--sortable",
  "Heading-left": "Polaris-DataTable__Heading--left",
  "Cell-verticalAlignTop": "Polaris-DataTable__Cell--verticalAlignTop",
  "Cell-verticalAlignBottom": "Polaris-DataTable__Cell--verticalAlignBottom",
  "Cell-verticalAlignMiddle": "Polaris-DataTable__Cell--verticalAlignMiddle",
  "Cell-verticalAlignBaseline": "Polaris-DataTable__Cell--verticalAlignBaseline",
  hoverable: "Polaris-DataTable--hoverable",
  "Cell-hovered": "Polaris-DataTable__Cell--hovered",
  Icon: "Polaris-DataTable__Icon",
  Heading: "Polaris-DataTable__Heading",
  StickyHeaderEnabled: "Polaris-DataTable__StickyHeaderEnabled",
  StickyHeaderWrapper: "Polaris-DataTable__StickyHeaderWrapper",
  "Cell-sorted": "Polaris-DataTable__Cell--sorted",
  "Cell-total": "Polaris-DataTable__Cell--total",
  ShowTotals: "Polaris-DataTable__ShowTotals",
  "Cell-total-footer": "Polaris-DataTable--cellTotalFooter",
  Footer: "Polaris-DataTable__Footer",
  StickyHeaderInner: "Polaris-DataTable__StickyHeaderInner",
  "StickyHeaderInner-isSticky": "Polaris-DataTable__StickyHeaderInner--isSticky",
  StickyHeaderTable: "Polaris-DataTable__StickyHeaderTable",
  FixedFirstColumn: "Polaris-DataTable__FixedFirstColumn",
  StickyTableHeadingsRow: "Polaris-DataTable__StickyTableHeadingsRow",
  TooltipContent: "Polaris-DataTable__TooltipContent"
};

// node_modules/@shopify/polaris/build/esm/components/DataTable/components/Cell/Cell.js
var import_react112 = __toESM(require_react());
function Cell({
  content,
  contentType,
  nthColumn,
  firstColumn,
  truncate,
  header,
  total,
  totalInFooter,
  sorted,
  sortable,
  sortDirection,
  inFixedNthColumn,
  verticalAlign = "top",
  defaultSortDirection = "ascending",
  onSort,
  colSpan,
  setRef = () => {
  },
  stickyHeadingCell = !1,
  stickyCellWidth,
  hovered = !1,
  handleFocus = () => {
  },
  hasFixedNthColumn = !1,
  fixedCellVisible = !1,
  firstColumnMinWidth,
  style,
  lastFixedFirstColumn
}) {
  let i18n = useI18n(), numeric = contentType === "numeric", className = classNames(styles34.Cell, styles34[`Cell-${variationName("verticalAlign", verticalAlign)}`], firstColumn && styles34["Cell-firstColumn"], truncate && styles34["Cell-truncated"], header && styles34["Cell-header"], total && styles34["Cell-total"], totalInFooter && styles34["Cell-total-footer"], numeric && styles34["Cell-numeric"], sortable && styles34["Cell-sortable"], sorted && styles34["Cell-sorted"], stickyHeadingCell && styles34.StickyHeaderCell, hovered && styles34["Cell-hovered"], lastFixedFirstColumn && inFixedNthColumn && fixedCellVisible && styles34["Cell-separate"], nthColumn && inFixedNthColumn && stickyHeadingCell && styles34.FixedFirstColumn), headerClassName = classNames(header && styles34.Heading, header && contentType === "text" && styles34["Heading-left"]), iconClassName = classNames(sortable && styles34.Icon), direction = sorted && sortDirection ? sortDirection : defaultSortDirection, source = direction === "descending" ? SvgSortDescendingIcon : SvgSortAscendingIcon, oppositeDirection = sortDirection === "ascending" ? "descending" : "ascending", sortAccessibilityLabel = i18n.translate("Polaris.DataTable.sortAccessibilityLabel", {
    direction: sorted ? oppositeDirection : direction
  }), iconMarkup = /* @__PURE__ */ import_react112.default.createElement("span", {
    className: iconClassName
  }, /* @__PURE__ */ import_react112.default.createElement(Icon, {
    source,
    accessibilityLabel: sortAccessibilityLabel
  })), focusable = !(stickyHeadingCell && hasFixedNthColumn && nthColumn && !inFixedNthColumn), columnHeadingContent = sortable ? /* @__PURE__ */ import_react112.default.createElement("button", {
    className: headerClassName,
    onClick: onSort,
    onFocus: handleFocus,
    tabIndex: focusable ? 0 : -1
  }, iconMarkup, content) : content, colSpanProp = colSpan && colSpan > 1 ? {
    colSpan
  } : {}, minWidthStyles = nthColumn && firstColumnMinWidth ? {
    minWidth: firstColumnMinWidth
  } : {
    minWidth: stickyCellWidth
  }, stickyHeading = /* @__PURE__ */ import_react112.default.createElement("th", Object.assign({
    ref: setRef
  }, headerCell.props, colSpanProp, {
    className,
    "aria-sort": sortDirection,
    style: {
      ...style,
      ...minWidthStyles
    },
    "data-index-table-sticky-heading": !0
  }), columnHeadingContent), headingMarkup = header ? /* @__PURE__ */ import_react112.default.createElement("th", Object.assign({}, headerCell.props, {
    "aria-sort": sortDirection
  }, colSpanProp, {
    ref: setRef,
    className,
    scope: "col",
    style: {
      ...minWidthStyles
    }
  }), columnHeadingContent) : /* @__PURE__ */ import_react112.default.createElement("th", Object.assign({}, colSpanProp, {
    ref: setRef,
    className,
    scope: "row",
    style: {
      ...minWidthStyles
    }
  }), truncate ? /* @__PURE__ */ import_react112.default.createElement(TruncatedText, {
    className: styles34.TooltipContent
  }, content) : content), cellMarkup = header || firstColumn || nthColumn ? headingMarkup : /* @__PURE__ */ import_react112.default.createElement("td", Object.assign({
    className
  }, colSpanProp), content);
  return stickyHeadingCell ? stickyHeading : cellMarkup;
}
var TruncatedText = ({
  children,
  className = ""
}) => {
  let textRef = (0, import_react112.useRef)(null), {
    current
  } = textRef, text2 = /* @__PURE__ */ import_react112.default.createElement("span", {
    ref: textRef,
    className
  }, children);
  return current?.scrollWidth > current?.offsetWidth ? /* @__PURE__ */ import_react112.default.createElement(Tooltip, {
    content: textRef.current.innerText
  }, text2) : text2;
};

// node_modules/@shopify/polaris/build/esm/components/Pagination/Pagination.js
var import_react113 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/is-input-focused.js
var EditableTarget;
(function(EditableTarget2) {
  EditableTarget2.Input = "INPUT", EditableTarget2.Textarea = "TEXTAREA", EditableTarget2.Select = "SELECT", EditableTarget2.ContentEditable = "contenteditable";
})(EditableTarget || (EditableTarget = {}));
function isInputFocused() {
  if (document == null || document.activeElement == null)
    return !1;
  let {
    tagName
  } = document.activeElement;
  return tagName === EditableTarget.Input || tagName === EditableTarget.Textarea || tagName === EditableTarget.Select || document.activeElement.hasAttribute(EditableTarget.ContentEditable);
}

// node_modules/@shopify/polaris/build/esm/components/Pagination/Pagination.css.js
var styles35 = {
  Pagination: "Polaris-Pagination",
  table: "Polaris-Pagination--table",
  TablePaginationActions: "Polaris-Pagination__TablePaginationActions"
};

// node_modules/@shopify/polaris/build/esm/components/Pagination/Pagination.js
function Pagination({
  hasNext,
  hasPrevious,
  nextURL,
  previousURL,
  onNext,
  onPrevious,
  nextTooltip,
  previousTooltip,
  nextKeys,
  previousKeys,
  accessibilityLabel,
  accessibilityLabels,
  label,
  type = "page"
}) {
  let i18n = useI18n(), node = /* @__PURE__ */ (0, import_react113.createRef)(), navLabel = accessibilityLabel || i18n.translate("Polaris.Pagination.pagination"), previousLabel = accessibilityLabels?.previous || i18n.translate("Polaris.Pagination.previous"), nextLabel = accessibilityLabels?.next || i18n.translate("Polaris.Pagination.next"), prev = /* @__PURE__ */ import_react113.default.createElement(Button, {
    icon: SvgChevronLeftIcon,
    accessibilityLabel: previousLabel,
    url: previousURL,
    onClick: onPrevious,
    disabled: !hasPrevious,
    id: "previousURL"
  }), constructedPrevious = previousTooltip && hasPrevious ? /* @__PURE__ */ import_react113.default.createElement(Tooltip, {
    activatorWrapper: "span",
    content: previousTooltip,
    preferredPosition: "below"
  }, prev) : prev, next = /* @__PURE__ */ import_react113.default.createElement(Button, {
    icon: SvgChevronRightIcon,
    accessibilityLabel: nextLabel,
    url: nextURL,
    onClick: onNext,
    disabled: !hasNext,
    id: "nextURL"
  }), constructedNext = nextTooltip && hasNext ? /* @__PURE__ */ import_react113.default.createElement(Tooltip, {
    activatorWrapper: "span",
    content: nextTooltip,
    preferredPosition: "below"
  }, next) : next, previousHandler = onPrevious || noop4, previousButtonEvents = previousKeys && (previousURL || onPrevious) && hasPrevious && previousKeys.map((key) => /* @__PURE__ */ import_react113.default.createElement(KeypressListener, {
    key,
    keyCode: key,
    handler: handleCallback(previousURL ? clickPaginationLink("previousURL", node) : previousHandler)
  })), nextHandler = onNext || noop4, nextButtonEvents = nextKeys && (nextURL || onNext) && hasNext && nextKeys.map((key) => /* @__PURE__ */ import_react113.default.createElement(KeypressListener, {
    key,
    keyCode: key,
    handler: handleCallback(nextURL ? clickPaginationLink("nextURL", node) : nextHandler)
  }));
  if (type === "table") {
    let labelMarkup2 = label ? /* @__PURE__ */ import_react113.default.createElement(Box, {
      padding: "300",
      paddingBlockStart: "0",
      paddingBlockEnd: "0"
    }, /* @__PURE__ */ import_react113.default.createElement(Text, {
      as: "span",
      variant: "bodySm",
      fontWeight: "medium"
    }, label)) : null;
    return /* @__PURE__ */ import_react113.default.createElement("nav", {
      "aria-label": navLabel,
      ref: node,
      className: classNames(styles35.Pagination, styles35.table)
    }, previousButtonEvents, nextButtonEvents, /* @__PURE__ */ import_react113.default.createElement(Box, {
      background: "bg-surface-secondary",
      paddingBlockStart: "150",
      paddingBlockEnd: "150",
      paddingInlineStart: "300",
      paddingInlineEnd: "200"
    }, /* @__PURE__ */ import_react113.default.createElement(InlineStack, {
      align: "center",
      blockAlign: "center"
    }, /* @__PURE__ */ import_react113.default.createElement("div", {
      className: styles35.TablePaginationActions,
      "data-buttongroup-variant": "segmented"
    }, /* @__PURE__ */ import_react113.default.createElement("div", null, constructedPrevious), labelMarkup2, /* @__PURE__ */ import_react113.default.createElement("div", null, constructedNext)))));
  }
  let labelTextMarkup = hasNext && hasPrevious ? /* @__PURE__ */ import_react113.default.createElement("span", null, label) : /* @__PURE__ */ import_react113.default.createElement(Text, {
    tone: "subdued",
    as: "span"
  }, label), labelMarkup = label ? /* @__PURE__ */ import_react113.default.createElement(Box, {
    padding: "300",
    paddingBlockStart: "0",
    paddingBlockEnd: "0"
  }, /* @__PURE__ */ import_react113.default.createElement("div", {
    "aria-live": "polite"
  }, labelTextMarkup)) : null;
  return /* @__PURE__ */ import_react113.default.createElement("nav", {
    "aria-label": navLabel,
    ref: node,
    className: styles35.Pagination
  }, previousButtonEvents, nextButtonEvents, /* @__PURE__ */ import_react113.default.createElement(ButtonGroup, {
    variant: "segmented"
  }, constructedPrevious, labelMarkup, constructedNext));
}
function clickPaginationLink(id, node) {
  return () => {
    if (node.current == null)
      return;
    let link = node.current.querySelector(`#${id}`);
    link && link.click();
  };
}
function handleCallback(fn) {
  return () => {
    isInputFocused() || fn();
  };
}
function noop4() {
}

// node_modules/@shopify/polaris/build/esm/components/AfterInitialMount/AfterInitialMount.js
var import_react114 = __toESM(require_react());
function AfterInitialMount({
  children,
  onMount,
  fallback = null
}) {
  let isMounted = useIsAfterInitialMount(), content = isMounted ? children : fallback;
  return (0, import_react114.useEffect)(() => {
    isMounted && onMount && onMount();
  }, [isMounted, onMount]), /* @__PURE__ */ import_react114.default.createElement(import_react114.default.Fragment, null, content);
}

// node_modules/@shopify/polaris/build/esm/components/Sticky/Sticky.js
var import_react116 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/hooks.js
var import_react115 = __toESM(require_react());
function useStickyManager() {
  let stickyManager = (0, import_react115.useContext)(StickyManagerContext);
  if (!stickyManager)
    throw new MissingAppProviderError("No StickyManager was provided.");
  return stickyManager;
}

// node_modules/@shopify/polaris/build/esm/components/Sticky/Sticky.js
var StickyInner = class extends import_react116.Component {
  constructor(...args) {
    super(...args), this.state = {
      isSticky: !1,
      style: {}
    }, this.placeHolderNode = null, this.stickyNode = null, this.setPlaceHolderNode = (node) => {
      this.placeHolderNode = node;
    }, this.setStickyNode = (node) => {
      this.stickyNode = node;
    }, this.handlePositioning = (stick, top = 0, left = 0, width2 = 0) => {
      let {
        isSticky
      } = this.state;
      (stick && !isSticky || !stick && isSticky) && (this.adjustPlaceHolderNode(stick), this.setState({
        isSticky: !isSticky
      }, () => {
        if (this.props.onStickyChange == null || (this.props.onStickyChange(!isSticky), this.props.boundingElement == null))
          return null;
        this.props.boundingElement.toggleAttribute("data-sticky-active");
      }));
      let style = stick ? {
        position: "fixed",
        top,
        left,
        width: width2
      } : {};
      this.setState({
        style
      });
    }, this.adjustPlaceHolderNode = (add) => {
      this.placeHolderNode && this.stickyNode && (this.placeHolderNode.style.paddingBottom = add ? `${getRectForNode(this.stickyNode).height}px` : "0px");
    };
  }
  componentDidMount() {
    let {
      boundingElement,
      offset = !1,
      disableWhenStacked = !1,
      stickyManager
    } = this.props;
    !this.stickyNode || !this.placeHolderNode || stickyManager.registerStickyItem({
      stickyNode: this.stickyNode,
      placeHolderNode: this.placeHolderNode,
      handlePositioning: this.handlePositioning,
      offset,
      boundingElement,
      disableWhenStacked
    });
  }
  componentWillUnmount() {
    let {
      stickyManager
    } = this.props;
    this.stickyNode && stickyManager.unregisterStickyItem(this.stickyNode);
  }
  render() {
    let {
      style,
      isSticky
    } = this.state, {
      children
    } = this.props, childrenContent = isFunction(children) ? children(isSticky) : children;
    return /* @__PURE__ */ import_react116.default.createElement("div", null, /* @__PURE__ */ import_react116.default.createElement("div", {
      ref: this.setPlaceHolderNode
    }), /* @__PURE__ */ import_react116.default.createElement("div", {
      ref: this.setStickyNode,
      style
    }, childrenContent));
  }
};
function isFunction(arg) {
  return typeof arg == "function";
}
function Sticky(props) {
  let stickyManager = useStickyManager();
  return /* @__PURE__ */ import_react116.default.createElement(StickyInner, Object.assign({}, props, {
    stickyManager
  }));
}

// node_modules/@shopify/polaris/build/esm/components/DataTable/components/Navigation/Navigation.js
var import_react117 = __toESM(require_react());
function Navigation({
  columnVisibilityData,
  isScrolledFarthestLeft,
  isScrolledFarthestRight,
  navigateTableLeft,
  navigateTableRight,
  fixedFirstColumns,
  setRef = () => {
  }
}) {
  let i18n = useI18n(), pipMarkup = columnVisibilityData.map((column, index) => {
    if (index < fixedFirstColumns)
      return;
    let className = classNames(styles34.Pip, column.isVisible && styles34["Pip-visible"]);
    return /* @__PURE__ */ import_react117.default.createElement("div", {
      className,
      key: `pip-${index}`
    });
  }), leftA11yLabel = i18n.translate("Polaris.DataTable.navAccessibilityLabel", {
    direction: "left"
  }), rightA11yLabel = i18n.translate("Polaris.DataTable.navAccessibilityLabel", {
    direction: "right"
  });
  return /* @__PURE__ */ import_react117.default.createElement("div", {
    className: styles34.Navigation,
    ref: setRef
  }, /* @__PURE__ */ import_react117.default.createElement(Button, {
    variant: "tertiary",
    icon: SvgChevronLeftIcon,
    disabled: isScrolledFarthestLeft,
    accessibilityLabel: leftA11yLabel,
    onClick: navigateTableLeft
  }), pipMarkup, /* @__PURE__ */ import_react117.default.createElement(Button, {
    variant: "tertiary",
    icon: SvgChevronRightIcon,
    disabled: isScrolledFarthestRight,
    accessibilityLabel: rightA11yLabel,
    onClick: navigateTableRight
  }));
}

// node_modules/@shopify/polaris/build/esm/components/DataTable/DataTable.js
var getRowClientHeights = (rows) => {
  let heights = [];
  return rows && rows.forEach((row) => {
    heights.push(row.clientHeight);
  }), heights;
}, DataTableInner = class extends import_react118.PureComponent {
  constructor(...args) {
    super(...args), this.state = {
      condensed: !1,
      columnVisibilityData: [],
      isScrolledFarthestLeft: !0,
      isScrolledFarthestRight: !1,
      rowHovered: void 0
    }, this.dataTable = /* @__PURE__ */ (0, import_react118.createRef)(), this.scrollContainer = /* @__PURE__ */ (0, import_react118.createRef)(), this.table = /* @__PURE__ */ (0, import_react118.createRef)(), this.stickyTable = /* @__PURE__ */ (0, import_react118.createRef)(), this.stickyNav = null, this.headerNav = null, this.tableHeadings = [], this.stickyHeadings = [], this.tableHeadingWidths = [], this.stickyHeaderActive = !1, this.scrollStopTimer = null, this.handleResize = debounce(() => {
      let {
        table: {
          current: table
        },
        scrollContainer: {
          current: scrollContainer
        }
      } = this, condensed = !1;
      table && scrollContainer && (condensed = table.scrollWidth > scrollContainer.clientWidth + 1), this.setState({
        condensed,
        ...this.calculateColumnVisibilityData(condensed)
      });
    }), this.setCellRef = ({
      ref,
      index,
      inStickyHeader
    }) => {
      if (ref != null)
        if (inStickyHeader) {
          this.stickyHeadings[index] = ref;
          let button = ref.querySelector("button");
          if (button == null)
            return;
          button.addEventListener("focus", this.handleHeaderButtonFocus);
        } else
          this.tableHeadings[index] = ref, this.tableHeadingWidths[index] = ref.clientWidth;
    }, this.changeHeadingFocus = () => {
      let {
        tableHeadings,
        stickyHeadings,
        stickyNav,
        headerNav
      } = this, stickyFocusedItemIndex = stickyHeadings.findIndex((item) => item === document.activeElement?.parentElement), tableFocusedItemIndex = tableHeadings.findIndex((item) => item === document.activeElement?.parentElement), arrowsInStickyNav = stickyNav?.querySelectorAll("button"), arrowsInHeaderNav = headerNav?.querySelectorAll("button"), stickyFocusedNavIndex = -1;
      arrowsInStickyNav?.forEach((item, index) => {
        item === document.activeElement && (stickyFocusedNavIndex = index);
      });
      let headerFocusedNavIndex = -1;
      if (arrowsInHeaderNav?.forEach((item, index) => {
        item === document.activeElement && (headerFocusedNavIndex = index);
      }), stickyFocusedItemIndex < 0 && tableFocusedItemIndex < 0 && stickyFocusedNavIndex < 0 && headerFocusedNavIndex < 0)
        return null;
      let button;
      if (stickyFocusedItemIndex >= 0 ? button = tableHeadings[stickyFocusedItemIndex].querySelector("button") : tableFocusedItemIndex >= 0 && (button = stickyHeadings[tableFocusedItemIndex].querySelector("button")), stickyFocusedNavIndex >= 0 ? button = arrowsInHeaderNav?.[stickyFocusedNavIndex] : headerFocusedNavIndex >= 0 && (button = arrowsInStickyNav?.[headerFocusedNavIndex]), button == null)
        return null;
      button.style.visibility = "visible", button.focus(), button.style.removeProperty("visibility");
    }, this.calculateColumnVisibilityData = (condensed) => {
      let fixedFirstColumns = this.fixedFirstColumns(), {
        table: {
          current: table
        },
        scrollContainer: {
          current: scrollContainer
        },
        dataTable: {
          current: dataTable
        }
      } = this, {
        stickyHeader
      } = this.props;
      if ((stickyHeader || condensed) && table && scrollContainer && dataTable) {
        let headerCells = table.querySelectorAll(headerCell.selector), rightMostHeader = headerCells[fixedFirstColumns - 1], nthColumnWidth = fixedFirstColumns ? rightMostHeader.offsetLeft + rightMostHeader.offsetWidth : 0;
        if (headerCells.length > 0) {
          let firstVisibleColumnIndex = headerCells.length - 1, tableLeftVisibleEdge = scrollContainer.scrollLeft + nthColumnWidth, tableRightVisibleEdge = scrollContainer.scrollLeft + dataTable.offsetWidth, tableData = {
            firstVisibleColumnIndex,
            tableLeftVisibleEdge,
            tableRightVisibleEdge
          }, columnVisibilityData = [...headerCells].map(measureColumn(tableData)), lastColumn = columnVisibilityData[columnVisibilityData.length - 1], isScrolledFarthestLeft = fixedFirstColumns ? tableLeftVisibleEdge === nthColumnWidth : tableLeftVisibleEdge === 0;
          return {
            columnVisibilityData,
            ...getPrevAndCurrentColumns(tableData, columnVisibilityData),
            isScrolledFarthestLeft,
            isScrolledFarthestRight: lastColumn.rightEdge <= tableRightVisibleEdge
          };
        }
      }
      return {
        columnVisibilityData: [],
        previousColumn: void 0,
        currentColumn: void 0
      };
    }, this.handleHeaderButtonFocus = (event) => {
      let fixedFirstColumns = this.fixedFirstColumns();
      if (this.scrollContainer.current == null || event.target == null || this.state.columnVisibilityData.length === 0)
        return;
      let currentCell = event.target.parentNode, tableScrollLeft = this.scrollContainer.current.scrollLeft, tableViewableWidth = this.scrollContainer.current.offsetWidth, tableRightEdge = tableScrollLeft + tableViewableWidth, nthColumnWidth = this.state.columnVisibilityData.length > 0 ? this.state.columnVisibilityData[fixedFirstColumns]?.rightEdge : 0, currentColumnLeftEdge = currentCell.offsetLeft, currentColumnRightEdge = currentCell.offsetLeft + currentCell.offsetWidth;
      tableScrollLeft > currentColumnLeftEdge - nthColumnWidth && (this.scrollContainer.current.scrollLeft = currentColumnLeftEdge - nthColumnWidth), currentColumnRightEdge > tableRightEdge && (this.scrollContainer.current.scrollLeft = currentColumnRightEdge - tableViewableWidth);
    }, this.stickyHeaderScrolling = () => {
      let {
        current: stickyTable
      } = this.stickyTable, {
        current: scrollContainer
      } = this.scrollContainer;
      stickyTable == null || scrollContainer == null || (stickyTable.scrollLeft = scrollContainer.scrollLeft);
    }, this.scrollListener = () => {
      this.scrollStopTimer && clearTimeout(this.scrollStopTimer), this.scrollStopTimer = setTimeout(() => {
        this.setState((prevState) => ({
          ...this.calculateColumnVisibilityData(prevState.condensed)
        }));
      }, 100), this.setState({
        isScrolledFarthestLeft: this.scrollContainer.current?.scrollLeft === 0
      }), this.props.stickyHeader && this.stickyHeaderActive && this.stickyHeaderScrolling();
    }, this.handleHover = (row) => () => {
      this.setState({
        rowHovered: row
      });
    }, this.handleFocus = (event) => {
      let fixedFirstColumns = this.fixedFirstColumns();
      if (this.scrollContainer.current == null || event.target == null)
        return;
      let currentCell = event.target.parentNode, nthColumnWidth = this.props ? this.state.columnVisibilityData[fixedFirstColumns]?.rightEdge : 0, desiredScrollLeft = currentCell.offsetLeft - nthColumnWidth;
      this.scrollContainer.current.scrollLeft > desiredScrollLeft && (this.scrollContainer.current.scrollLeft = desiredScrollLeft);
    }, this.navigateTable = (direction) => {
      let fixedFirstColumns = this.fixedFirstColumns(), {
        currentColumn,
        previousColumn
      } = this.state, nthColumnWidth = this.state.columnVisibilityData[fixedFirstColumns - 1]?.rightEdge;
      if (!currentColumn || !previousColumn)
        return;
      let prevWidths = 0;
      for (let index = 0; index < currentColumn.index; index++)
        prevWidths += this.state.columnVisibilityData[index].width;
      let {
        current: scrollContainer
      } = this.scrollContainer;
      return () => {
        let newScrollLeft = 0;
        fixedFirstColumns ? newScrollLeft = direction === "right" ? prevWidths - nthColumnWidth + currentColumn.width : prevWidths - previousColumn.width - nthColumnWidth : newScrollLeft = direction === "right" ? currentColumn.rightEdge : previousColumn.leftEdge, scrollContainer && (scrollContainer.scrollLeft = newScrollLeft, requestAnimationFrame(() => {
          this.setState((prevState) => ({
            ...this.calculateColumnVisibilityData(prevState.condensed)
          }));
        }));
      };
    }, this.renderHeading = ({
      heading,
      headingIndex,
      inFixedNthColumn,
      inStickyHeader
    }) => {
      let {
        sortable,
        truncate = !1,
        columnContentTypes,
        defaultSortDirection,
        initialSortColumnIndex = 0,
        verticalAlign,
        firstColumnMinWidth
      } = this.props, fixedFirstColumns = this.fixedFirstColumns(), {
        sortDirection = defaultSortDirection,
        sortedColumnIndex = initialSortColumnIndex,
        isScrolledFarthestLeft
      } = this.state, sortableHeadingProps, headingCellId = `heading-cell-${headingIndex}`, stickyHeaderId = `stickyheader-${headingIndex}`, id = inStickyHeader ? stickyHeaderId : headingCellId;
      if (sortable) {
        let isSortable = sortable[headingIndex], isSorted = isSortable && sortedColumnIndex === headingIndex;
        sortableHeadingProps = {
          defaultSortDirection,
          sorted: isSorted,
          sortable: isSortable,
          sortDirection: isSorted ? sortDirection : "none",
          onSort: this.defaultOnSort(headingIndex),
          fixedNthColumn: fixedFirstColumns,
          inFixedNthColumn: fixedFirstColumns
        };
      }
      let stickyCellWidth = inStickyHeader ? this.tableHeadingWidths[headingIndex] : void 0, fixedCellVisible = !isScrolledFarthestLeft, cellProps = {
        header: !0,
        stickyHeadingCell: inStickyHeader,
        content: heading,
        contentType: columnContentTypes[headingIndex],
        nthColumn: headingIndex < fixedFirstColumns,
        fixedFirstColumns,
        truncate,
        headingIndex,
        ...sortableHeadingProps,
        verticalAlign,
        handleFocus: this.handleFocus,
        stickyCellWidth,
        fixedCellVisible,
        firstColumnMinWidth
      };
      return inFixedNthColumn && inStickyHeader ? [/* @__PURE__ */ import_react118.default.createElement(Cell, Object.assign({
        key: id
      }, cellProps, {
        setRef: (ref) => {
          this.setCellRef({
            ref,
            index: headingIndex,
            inStickyHeader
          });
        },
        inFixedNthColumn: !1
      })), /* @__PURE__ */ import_react118.default.createElement(Cell, Object.assign({
        key: `${id}-sticky`
      }, cellProps, {
        setRef: (ref) => {
          this.setCellRef({
            ref,
            index: headingIndex,
            inStickyHeader
          });
        },
        inFixedNthColumn: Boolean(fixedFirstColumns),
        lastFixedFirstColumn: headingIndex === fixedFirstColumns - 1,
        style: {
          left: this.state.columnVisibilityData[headingIndex]?.leftEdge
        }
      }))] : /* @__PURE__ */ import_react118.default.createElement(Cell, Object.assign({
        key: id
      }, cellProps, {
        setRef: (ref) => {
          this.setCellRef({
            ref,
            index: headingIndex,
            inStickyHeader
          });
        },
        lastFixedFirstColumn: headingIndex === fixedFirstColumns - 1,
        inFixedNthColumn
      }));
    }, this.totalsRowHeading = () => {
      let {
        i18n,
        totals,
        totalsName
      } = this.props, totalsLabel = totalsName || {
        singular: i18n.translate("Polaris.DataTable.totalRowHeading"),
        plural: i18n.translate("Polaris.DataTable.totalsRowHeading")
      };
      return totals && totals.filter((total) => total !== "").length > 1 ? totalsLabel.plural : totalsLabel.singular;
    }, this.renderTotals = ({
      total,
      index
    }) => {
      let fixedFirstColumns = this.fixedFirstColumns(), id = `totals-cell-${index}`, {
        truncate = !1,
        verticalAlign,
        columnContentTypes
      } = this.props, content, contentType;
      index === 0 && (content = this.totalsRowHeading()), total !== "" && index > 0 && (contentType = columnContentTypes[index], content = total);
      let totalInFooter = this.props.showTotalsInFooter;
      return /* @__PURE__ */ import_react118.default.createElement(Cell, {
        total: !0,
        totalInFooter,
        nthColumn: index <= fixedFirstColumns - 1,
        firstColumn: index === 0,
        key: id,
        content,
        contentType,
        truncate,
        verticalAlign
      });
    }, this.getColSpan = (rowLength, headingsLength, contentTypesLength, cellIndex) => {
      if (this.fixedFirstColumns())
        return 1;
      let rowLen = rowLength || 1, colLen = headingsLength || contentTypesLength, colSpan = Math.floor(colLen / rowLen), remainder = colLen % rowLen;
      return cellIndex === 0 ? colSpan + remainder : colSpan;
    }, this.defaultRenderRow = ({
      row,
      index,
      inFixedNthColumn,
      rowHeights
    }) => {
      let {
        columnContentTypes,
        truncate = !1,
        verticalAlign,
        hoverable = !0,
        headings
      } = this.props, {
        condensed
      } = this.state, fixedFirstColumns = this.fixedFirstColumns(), className = classNames(styles34.TableRow, hoverable && styles34.hoverable);
      return /* @__PURE__ */ import_react118.default.createElement("tr", {
        key: `row-${index}`,
        className,
        onMouseEnter: this.handleHover(index),
        onMouseLeave: this.handleHover()
      }, row.map((content, cellIndex) => {
        let hovered = index === this.state.rowHovered, id = `cell-${cellIndex}-row-${index}`, colSpan = this.getColSpan(row.length, headings.length, columnContentTypes.length, cellIndex);
        return /* @__PURE__ */ import_react118.default.createElement(Cell, {
          key: id,
          content,
          contentType: columnContentTypes[cellIndex],
          nthColumn: cellIndex <= fixedFirstColumns - 1,
          firstColumn: cellIndex === 0,
          truncate,
          verticalAlign,
          colSpan,
          hovered,
          style: rowHeights ? {
            height: `${rowHeights[index]}px`
          } : {},
          inFixedNthColumn: condensed && inFixedNthColumn
        });
      }));
    }, this.defaultOnSort = (headingIndex) => {
      let {
        onSort,
        defaultSortDirection = "ascending",
        initialSortColumnIndex
      } = this.props, {
        sortDirection = defaultSortDirection,
        sortedColumnIndex = initialSortColumnIndex
      } = this.state, newSortDirection = defaultSortDirection;
      return sortedColumnIndex === headingIndex && (newSortDirection = sortDirection === "ascending" ? "descending" : "ascending"), () => {
        this.setState({
          sortDirection: newSortDirection,
          sortedColumnIndex: headingIndex
        }, () => {
          onSort && onSort(headingIndex, newSortDirection);
        });
      };
    };
  }
  componentDidMount() {
    this.handleResize();
  }
  componentDidUpdate(prevProps) {
    (0, import_react_fast_compare.default)(prevProps, this.props) || this.handleResize();
  }
  componentWillUnmount() {
    this.handleResize.cancel();
  }
  render() {
    let {
      headings,
      totals,
      showTotalsInFooter,
      rows,
      footerContent,
      hideScrollIndicator = !1,
      increasedTableDensity = !1,
      hasZebraStripingOnData = !1,
      stickyHeader = !1,
      hasFixedFirstColumn: fixedFirstColumn = !1,
      pagination
    } = this.props, {
      condensed,
      columnVisibilityData,
      isScrolledFarthestLeft,
      isScrolledFarthestRight
    } = this.state, fixedFirstColumns = this.fixedFirstColumns(), rowCountIsEven = rows.length % 2 === 0, className = classNames(styles34.DataTable, condensed && styles34.condensed, totals && styles34.ShowTotals, showTotalsInFooter && styles34.ShowTotalsInFooter, hasZebraStripingOnData && styles34.ZebraStripingOnData, hasZebraStripingOnData && rowCountIsEven && styles34.RowCountIsEven), wrapperClassName = classNames(styles34.TableWrapper, condensed && styles34.condensed, increasedTableDensity && styles34.IncreasedTableDensity, stickyHeader && styles34.StickyHeaderEnabled), headingMarkup = /* @__PURE__ */ import_react118.default.createElement("tr", null, headings.map((heading, index) => this.renderHeading({
      heading,
      headingIndex: index,
      inFixedNthColumn: !1,
      inStickyHeader: !1
    }))), totalsMarkup = totals ? /* @__PURE__ */ import_react118.default.createElement("tr", null, totals.map((total, index) => this.renderTotals({
      total,
      index
    }))) : null, nthColumns = rows.map((row) => row.slice(0, fixedFirstColumns)), nthHeadings = headings.slice(0, fixedFirstColumns), nthTotals = totals?.slice(0, fixedFirstColumns), tableHeaderRows = this.table.current?.children[0].childNodes, tableBodyRows = this.table.current?.children[1].childNodes, headerRowHeights = getRowClientHeights(tableHeaderRows), bodyRowHeights = getRowClientHeights(tableBodyRows), fixedNthColumnMarkup = condensed && fixedFirstColumns !== 0 && /* @__PURE__ */ import_react118.default.createElement("table", {
      className: classNames(styles34.FixedFirstColumn, !isScrolledFarthestLeft && styles34.separate),
      style: {
        width: `${columnVisibilityData[fixedFirstColumns - 1]?.rightEdge}px`
      }
    }, /* @__PURE__ */ import_react118.default.createElement("thead", null, /* @__PURE__ */ import_react118.default.createElement("tr", {
      style: {
        height: `${headerRowHeights[0]}px`
      }
    }, nthHeadings.map((heading, index) => this.renderHeading({
      heading,
      headingIndex: index,
      inFixedNthColumn: !0,
      inStickyHeader: !1
    }))), totals && !showTotalsInFooter && /* @__PURE__ */ import_react118.default.createElement("tr", {
      style: {
        height: `${headerRowHeights[1]}px`
      }
    }, nthTotals?.map((total, index) => this.renderTotals({
      total,
      index
    })))), /* @__PURE__ */ import_react118.default.createElement("tbody", null, nthColumns.map((row, index) => this.defaultRenderRow({
      row,
      index,
      inFixedNthColumn: !0,
      rowHeights: bodyRowHeights
    }))), totals && showTotalsInFooter && /* @__PURE__ */ import_react118.default.createElement("tfoot", null, /* @__PURE__ */ import_react118.default.createElement("tr", null, nthTotals?.map((total, index) => this.renderTotals({
      total,
      index
    }))))), bodyMarkup = rows.map((row, index) => this.defaultRenderRow({
      row,
      index,
      inFixedNthColumn: !1
    })), footerMarkup = footerContent ? /* @__PURE__ */ import_react118.default.createElement("div", {
      className: styles34.Footer
    }, footerContent) : null, paginationMarkup = pagination ? /* @__PURE__ */ import_react118.default.createElement(Pagination, Object.assign({
      type: "table"
    }, pagination)) : null, headerTotalsMarkup = showTotalsInFooter ? null : totalsMarkup, footerTotalsMarkup = showTotalsInFooter ? /* @__PURE__ */ import_react118.default.createElement("tfoot", null, totalsMarkup) : null, navigationMarkup = (location) => hideScrollIndicator ? null : /* @__PURE__ */ import_react118.default.createElement(Navigation, {
      columnVisibilityData,
      isScrolledFarthestLeft,
      isScrolledFarthestRight,
      navigateTableLeft: this.navigateTable("left"),
      navigateTableRight: this.navigateTable("right"),
      fixedFirstColumns,
      setRef: (ref) => {
        location === "header" ? this.headerNav = ref : location === "sticky" && (this.stickyNav = ref);
      }
    }), stickyHeaderMarkup = stickyHeader ? /* @__PURE__ */ import_react118.default.createElement(AfterInitialMount, null, /* @__PURE__ */ import_react118.default.createElement("div", {
      className: styles34.StickyHeaderWrapper,
      role: "presentation"
    }, /* @__PURE__ */ import_react118.default.createElement(Sticky, {
      boundingElement: this.dataTable.current,
      onStickyChange: (isSticky) => {
        this.changeHeadingFocus(), this.stickyHeaderActive = isSticky;
      }
    }, (isSticky) => {
      let stickyHeaderInnerClassNames = classNames(styles34.StickyHeaderInner, isSticky && styles34["StickyHeaderInner-isSticky"]), stickyHeaderTableClassNames = classNames(styles34.StickyHeaderTable, !isScrolledFarthestLeft && styles34.separate);
      return /* @__PURE__ */ import_react118.default.createElement("div", {
        className: stickyHeaderInnerClassNames
      }, /* @__PURE__ */ import_react118.default.createElement("div", null, navigationMarkup("sticky")), /* @__PURE__ */ import_react118.default.createElement("table", {
        className: stickyHeaderTableClassNames,
        ref: this.stickyTable
      }, /* @__PURE__ */ import_react118.default.createElement("thead", null, /* @__PURE__ */ import_react118.default.createElement("tr", {
        className: styles34.StickyTableHeadingsRow
      }, headings.map((heading, index) => this.renderHeading({
        heading,
        headingIndex: index,
        inFixedNthColumn: Boolean(index <= fixedFirstColumns - 1 && fixedFirstColumns),
        inStickyHeader: !0
      }))))));
    }))) : null;
    return /* @__PURE__ */ import_react118.default.createElement("div", {
      className: wrapperClassName,
      ref: this.dataTable
    }, stickyHeaderMarkup, navigationMarkup("header"), /* @__PURE__ */ import_react118.default.createElement("div", {
      className
    }, /* @__PURE__ */ import_react118.default.createElement("div", {
      className: styles34.ScrollContainer,
      ref: this.scrollContainer
    }, /* @__PURE__ */ import_react118.default.createElement(EventListener, {
      event: "resize",
      handler: this.handleResize
    }), /* @__PURE__ */ import_react118.default.createElement(EventListener, {
      capture: !0,
      passive: !0,
      event: "scroll",
      handler: this.scrollListener
    }), fixedNthColumnMarkup, /* @__PURE__ */ import_react118.default.createElement("table", {
      className: styles34.Table,
      ref: this.table
    }, /* @__PURE__ */ import_react118.default.createElement("thead", null, headingMarkup, headerTotalsMarkup), /* @__PURE__ */ import_react118.default.createElement("tbody", null, bodyMarkup), footerTotalsMarkup)), paginationMarkup, footerMarkup));
  }
  fixedFirstColumns() {
    let {
      hasFixedFirstColumn,
      fixedFirstColumns = 0,
      headings
    } = this.props, numberOfFixedFirstColumns = hasFixedFirstColumn && !fixedFirstColumns ? 1 : fixedFirstColumns;
    return numberOfFixedFirstColumns >= headings.length ? 0 : numberOfFixedFirstColumns;
  }
  // eslint-disable-next-line @shopify/react-no-multiple-render-methods
  // eslint-disable-next-line @shopify/react-no-multiple-render-methods
};
function DataTable(props) {
  let i18n = useI18n();
  return /* @__PURE__ */ import_react118.default.createElement(DataTableInner, Object.assign({}, props, {
    i18n
  }));
}

// node_modules/@shopify/polaris/build/esm/components/Focus/Focus.js
var import_react119 = __toESM(require_react());
var Focus = /* @__PURE__ */ (0, import_react119.memo)(function({
  children,
  disabled,
  root
}) {
  return (0, import_react119.useEffect)(() => {
    if (disabled || !root)
      return;
    let node = isRef(root) ? root.current : root;
    !node || node.querySelector("[autofocus]") || focusFirstFocusableNode(node, !1);
  }, [disabled, root]), /* @__PURE__ */ import_react119.default.createElement(import_react119.default.Fragment, null, children);
});
function isRef(ref) {
  return ref.current !== void 0;
}

// node_modules/@shopify/polaris/build/esm/components/Frame/Frame.js
var import_react144 = __toESM(require_react());

// node_modules/react-transition-group/esm/CSSTransition.js
var import_react122 = __toESM(require_react());
import _extends5 from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose3 from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _inheritsLoose2 from "@babel/runtime/helpers/esm/inheritsLoose";
import "prop-types";
import addOneClass from "dom-helpers/addClass";
import removeOneClass from "dom-helpers/removeClass";

// node_modules/react-transition-group/esm/Transition.js
var import_react121 = __toESM(require_react()), import_react_dom2 = __toESM(require_react_dom());
import _objectWithoutPropertiesLoose2 from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import "prop-types";

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: !1
};

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react120 = __toESM(require_react()), TransitionGroupContext_default = import_react120.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function(node) {
  return node.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context, appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear, initialStatus;
    return _this.appearStatus = null, props.in ? appear ? (initialStatus = EXITED, _this.appearStatus = ENTERING) : initialStatus = ENTERED : props.unmountOnExit || props.mountOnEnter ? initialStatus = UNMOUNTED : initialStatus = EXITED, _this.state = {
      status: initialStatus
    }, _this.nextCallback = null, _this;
  }
  Transition2.getDerivedStateFromProps = function(_ref, prevState) {
    var nextIn = _ref.in;
    return nextIn && prevState.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var _proto = Transition2.prototype;
  return _proto.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, _proto.componentDidUpdate = function(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      this.props.in ? status !== ENTERING && status !== ENTERED && (nextStatus = ENTERING) : (status === ENTERING || status === ENTERED) && (nextStatus = EXITING);
    }
    this.updateStatus(!1, nextStatus);
  }, _proto.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, _proto.getTimeouts = function() {
    var timeout2 = this.props.timeout, exit, enter, appear;
    return exit = enter = appear = timeout2, timeout2 != null && typeof timeout2 != "number" && (exit = timeout2.exit, enter = timeout2.enter, appear = timeout2.appear !== void 0 ? timeout2.appear : enter), {
      exit,
      enter,
      appear
    };
  }, _proto.updateStatus = function(mounting, nextStatus) {
    if (mounting === void 0 && (mounting = !1), nextStatus !== null)
      if (this.cancelNextCallback(), nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
          node && forceReflow(node);
        }
        this.performEnter(mounting);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, _proto.performEnter = function(mounting) {
    var _this2 = this, enter = this.props.enter, appearing = this.context ? this.context.isMounting : mounting, _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom2.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1], timeouts = this.getTimeouts(), enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing), this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing), _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  }, _proto.performExit = function() {
    var _this3 = this, exit = this.props.exit, timeouts = this.getTimeouts(), maybeNode = this.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode), this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode), _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  }, _proto.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, _proto.safeSetState = function(nextState, callback2) {
    callback2 = this.setNextCallback(callback2), this.setState(nextState, callback2);
  }, _proto.setNextCallback = function(callback2) {
    var _this4 = this, active = !0;
    return this.nextCallback = function(event) {
      active && (active = !1, _this4.nextCallback = null, callback2(event));
    }, this.nextCallback.cancel = function() {
      active = !1;
    }, this.nextCallback;
  }, _proto.onTransitionEnd = function(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this), doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    timeout2 != null && setTimeout(this.nextCallback, timeout2);
  }, _proto.render = function() {
    var status = this.state.status;
    if (status === UNMOUNTED)
      return null;
    var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose2(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ import_react121.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children == "function" ? children(status, childProps) : import_react121.default.cloneElement(import_react121.default.Children.only(children), childProps))
    );
  }, Transition2;
}(import_react121.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = {};
function noop5() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop5,
  onEntering: noop5,
  onEntered: noop5,
  onExit: noop5,
  onExiting: noop5,
  onExited: noop5
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addOneClass(node, c);
  });
}, removeClass = function(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeOneClass(node, c);
  });
}, CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose2(CSSTransition2, _React$Component);
  function CSSTransition2() {
    for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    return _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this, _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit"), _this.addClass(node, appearing ? "appear" : "enter", "base"), _this.props.onEnter && _this.props.onEnter(maybeNode, maybeAppearing);
    }, _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1], type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active"), _this.props.onEntering && _this.props.onEntering(maybeNode, maybeAppearing);
    }, _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1], type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type), _this.addClass(node, type, "done"), _this.props.onEntered && _this.props.onEntered(maybeNode, maybeAppearing);
    }, _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear"), _this.removeClasses(node, "enter"), _this.addClass(node, "exit", "base"), _this.props.onExit && _this.props.onExit(maybeNode);
    }, _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active"), _this.props.onExiting && _this.props.onExiting(maybeNode);
    }, _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit"), _this.addClass(node, "exit", "done"), _this.props.onExited && _this.props.onExited(maybeNode);
    }, _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    }, _this.getClassNames = function(type) {
      var classNames2 = _this.props.classNames, isStringClassNames = typeof classNames2 == "string", prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "", baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type], activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"], doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    }, _this;
  }
  var _proto = CSSTransition2.prototype;
  return _proto.addClass = function(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"], _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    type === "appear" && phase === "done" && doneClassName && (className += " " + doneClassName), phase === "active" && node && forceReflow(node), className && (this.appliedClasses[type][phase] = className, _addClass(node, className));
  }, _proto.removeClasses = function(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {}, baseClassName && removeClass(node, baseClassName), activeClassName && removeClass(node, activeClassName), doneClassName && removeClass(node, doneClassName);
  }, _proto.render = function() {
    var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose3(_this$props, ["classNames"]);
    return /* @__PURE__ */ import_react122.default.createElement(Transition_default, _extends5({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, CSSTransition2;
}(import_react122.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
var CSSTransition_default = CSSTransition;

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_react124 = __toESM(require_react());
import _objectWithoutPropertiesLoose4 from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _extends6 from "@babel/runtime/helpers/esm/extends";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose3 from "@babel/runtime/helpers/esm/inheritsLoose";
import "prop-types";

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react123 = __toESM(require_react());
function getChildMapping(children, mapFn) {
  var mapper = function(child) {
    return mapFn && (0, import_react123.isValidElement)(child) ? mapFn(child) : child;
  }, result = /* @__PURE__ */ Object.create(null);
  return children && import_react123.Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  }), result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {}, next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null), pendingKeys = [];
  for (var prevKey in prev)
    prevKey in next ? pendingKeys.length && (nextKeysPending[prevKey] = pendingKeys, pendingKeys = []) : pendingKeys.push(prevKey);
  var i, childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey])
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++)
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react123.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: !0,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children), children = mergeChildMappings(prevChildMapping, nextChildMapping);
  return Object.keys(children).forEach(function(key) {
    var child = children[key];
    if ((0, import_react123.isValidElement)(child)) {
      var hasPrev = key in prevChildMapping, hasNext = key in nextChildMapping, prevChild = prevChildMapping[key], isLeaving = (0, import_react123.isValidElement)(prevChild) && !prevChild.props.in;
      hasNext && (!hasPrev || isLeaving) ? children[key] = (0, import_react123.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: !0,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      }) : !hasNext && hasPrev && !isLeaving ? children[key] = (0, import_react123.cloneElement)(child, {
        in: !1
      }) : hasNext && hasPrev && (0, import_react123.isValidElement)(prevChild) && (children[key] = (0, import_react123.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      }));
    }
  }), children;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
}, defaultProps = {
  component: "div",
  childFactory: function(child) {
    return child;
  }
}, TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose3(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    return _this.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited,
      firstRender: !0
    }, _this;
  }
  var _proto = TransitionGroup2.prototype;
  return _proto.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, _proto.componentWillUnmount = function() {
    this.mounted = !1;
  }, TransitionGroup2.getDerivedStateFromProps = function(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: !1
    };
  }, _proto.handleExited = function(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    child.key in currentChildMapping || (child.props.onExited && child.props.onExited(node), this.mounted && this.setState(function(state) {
      var children = _extends6({}, state.children);
      return delete children[child.key], {
        children
      };
    }));
  }, _proto.render = function() {
    var _this$props = this.props, Component5 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose4(_this$props, ["component", "childFactory"]), contextValue = this.state.contextValue, children = values(this.state.children).map(childFactory2);
    return delete props.appear, delete props.enter, delete props.exit, Component5 === null ? /* @__PURE__ */ import_react124.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, children) : /* @__PURE__ */ import_react124.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, /* @__PURE__ */ import_react124.default.createElement(Component5, props, children));
  }, TransitionGroup2;
}(import_react124.default.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;

// node_modules/@shopify/polaris/build/esm/utilities/set-root-property.js
function setRootProperty(name, value, node) {
  if (!document)
    return;
  (node || document.documentElement).style.setProperty(name, value);
}

// node_modules/@shopify/polaris/build/esm/components/Frame/Frame.css.js
var styles36 = {
  Frame: "Polaris-Frame",
  Navigation: "Polaris-Frame__Navigation",
  hasTopBar: "Polaris-Frame--hasTopBar",
  "Navigation-enter": "Polaris-Frame__Navigation--enter",
  "Navigation-enterActive": "Polaris-Frame__Navigation--enterActive",
  "Navigation-exit": "Polaris-Frame__Navigation--exit",
  "Navigation-exitActive": "Polaris-Frame__Navigation--exitActive",
  NavigationDismiss: "Polaris-Frame__NavigationDismiss",
  "Navigation-visible": "Polaris-Frame__Navigation--visible",
  TopBar: "Polaris-Frame__TopBar",
  ContextualSaveBar: "Polaris-Frame__ContextualSaveBar",
  Main: "Polaris-Frame__Main",
  hasNav: "Polaris-Frame--hasNav",
  Content: "Polaris-Frame__Content",
  hasSidebar: "Polaris-Frame--hasSidebar",
  GlobalRibbonContainer: "Polaris-Frame__GlobalRibbonContainer",
  LoadingBar: "Polaris-Frame__LoadingBar",
  Skip: "Polaris-Frame__Skip",
  focused: "Polaris-Frame--focused",
  pressed: "Polaris-Frame--pressed"
};

// node_modules/@shopify/polaris/build/esm/utilities/media-query/hooks.js
var import_react125 = __toESM(require_react());
function useMediaQuery() {
  let mediaQuery = (0, import_react125.useContext)(MediaQueryContext);
  if (!mediaQuery)
    throw new Error("No mediaQuery was provided. Your application must be wrapped in an <AppProvider> component. See https://polaris.shopify.com/components/app-provider for implementation instructions.");
  return mediaQuery;
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.js
var import_react127 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-is-mounted-ref.js
var import_react126 = __toESM(require_react());
function useIsMountedRef() {
  let isMounted = (0, import_react126.useRef)(!1);
  return (0, import_react126.useEffect)(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.css.js
var styles37 = {
  Loading: "Polaris-Frame-Loading",
  Level: "Polaris-Frame-Loading__Level"
};

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Loading/Loading.js
var STUCK_THRESHOLD = 99;
function Loading() {
  let i18n = useI18n(), isMountedRef = useIsMountedRef(), [progress, setProgress] = (0, import_react127.useState)(0), [animating, setAnimating] = (0, import_react127.useState)(!1);
  (0, import_react127.useEffect)(() => {
    progress >= STUCK_THRESHOLD || animating || requestAnimationFrame(() => {
      if (!isMountedRef.current)
        return;
      let step = Math.max((STUCK_THRESHOLD - progress) / 10, 1);
      setAnimating(!0), setProgress(progress + step);
    });
  }, [progress, animating, isMountedRef]);
  let customStyles = {
    transform: `scaleX(${Math.floor(progress) / 100})`
  };
  return /* @__PURE__ */ import_react127.default.createElement("div", {
    className: styles37.Loading,
    "aria-valuenow": progress,
    "aria-valuemin": 0,
    "aria-valuemax": 100,
    role: "progressbar",
    "aria-label": i18n.translate("Polaris.Loading.label")
  }, /* @__PURE__ */ import_react127.default.createElement("div", {
    className: styles37.Level,
    style: customStyles,
    onTransitionEnd: () => setAnimating(!1)
  }));
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.js
var import_react128 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.css.js
var styles38 = {
  startFade: "Polaris-Frame-CSSAnimation--startFade",
  endFade: "Polaris-Frame-CSSAnimation--endFade"
};

// node_modules/@shopify/polaris/build/esm/components/Frame/components/CSSAnimation/CSSAnimation.js
var TransitionStatus2;
(function(TransitionStatus3) {
  TransitionStatus3.Entering = "entering", TransitionStatus3.Entered = "entered", TransitionStatus3.Exiting = "exiting", TransitionStatus3.Exited = "exited";
})(TransitionStatus2 || (TransitionStatus2 = {}));
function CSSAnimation({
  in: inProp,
  className,
  type,
  children
}) {
  let [transitionStatus, setTransitionStatus] = (0, import_react128.useState)(inProp ? TransitionStatus2.Entering : TransitionStatus2.Exited), isMounted = (0, import_react128.useRef)(!1), node = (0, import_react128.useRef)(null);
  (0, import_react128.useEffect)(() => {
    isMounted.current && transitionStatus === TransitionStatus2.Entering && changeTransitionStatus(TransitionStatus2.Entered);
  }, [transitionStatus]), (0, import_react128.useEffect)(() => {
    isMounted.current && (inProp && changeTransitionStatus(TransitionStatus2.Entering), !inProp && changeTransitionStatus(TransitionStatus2.Exiting));
  }, [inProp]), (0, import_react128.useEffect)(() => {
    isMounted.current = !0;
  }, []);
  let wrapperClassName = classNames(className, styles38[variationName("start", type)], inProp && styles38[variationName("end", type)]), content = transitionStatus === TransitionStatus2.Exited && !inProp ? null : children;
  return /* @__PURE__ */ import_react128.default.createElement("div", {
    className: wrapperClassName,
    ref: node,
    onTransitionEnd: handleTransitionEnd
  }, content);
  function handleTransitionEnd() {
    transitionStatus === TransitionStatus2.Exiting && changeTransitionStatus(TransitionStatus2.Exited);
  }
  function changeTransitionStatus(transitionStatus2) {
    setTransitionStatus(transitionStatus2), transitionStatus2 === TransitionStatus2.Entering && node.current && node.current.getBoundingClientRect();
  }
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.js
var import_react138 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/pluck-deep.js
function pluckDeep(obj, key) {
  if (!obj)
    return null;
  let keys = Object.keys(obj);
  for (let currKey of keys) {
    if (currKey === key)
      return obj[key];
    if (isObject(obj[currKey])) {
      let plucked = pluckDeep(obj[currKey], key);
      if (plucked)
        return plucked;
    }
  }
  return null;
}

// node_modules/@shopify/polaris/build/esm/utilities/get-width.js
function getWidth(value = {}, defaultWidth = 0, key = "width") {
  let width2 = typeof value == "number" ? value : pluckDeep(value, key);
  return width2 ? `${width2}px` : `${defaultWidth}px`;
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.css.js
var styles39 = {
  ContextualSaveBar: "Polaris-Frame-ContextualSaveBar",
  LogoContainer: "Polaris-Frame-ContextualSaveBar__LogoContainer",
  ContextControl: "Polaris-Frame-ContextualSaveBar__ContextControl",
  Contents: "Polaris-Frame-ContextualSaveBar__Contents",
  fullWidth: "Polaris-Frame-ContextualSaveBar--fullWidth",
  MessageContainer: "Polaris-Frame-ContextualSaveBar__MessageContainer",
  ActionContainer: "Polaris-Frame-ContextualSaveBar__ActionContainer",
  Action: "Polaris-Frame-ContextualSaveBar__Action"
};

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/components/DiscardConfirmationModal/DiscardConfirmationModal.js
var import_react137 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Modal/Modal.js
var import_react136 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Modal/Modal.css.js
var styles40 = {
  Body: "Polaris-Modal__Body",
  NoScrollBody: "Polaris-Modal__NoScrollBody",
  IFrame: "Polaris-Modal__IFrame"
};

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.js
var import_react129 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.css.js
var styles41 = {
  Section: "Polaris-Modal-Section",
  titleHidden: "Polaris-Modal-Section--titleHidden"
};

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Section/Section.js
function Section3({
  children,
  flush = !1,
  subdued = !1,
  titleHidden = !1
}) {
  let className = classNames(styles41.Section, titleHidden && styles41.titleHidden);
  return /* @__PURE__ */ import_react129.default.createElement("div", {
    className
  }, /* @__PURE__ */ import_react129.default.createElement(Box, Object.assign({
    as: "section",
    padding: flush ? "0" : "400"
  }, titleHidden && {
    paddingInlineEnd: "0"
  }, subdued && {
    background: "bg-surface-tertiary"
  }), children));
}

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.js
var import_react132 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.css.js
var styles42 = {
  Container: "Polaris-Modal-Dialog__Container",
  Dialog: "Polaris-Modal-Dialog",
  Modal: "Polaris-Modal-Dialog__Modal",
  limitHeight: "Polaris-Modal-Dialog--limitHeight",
  sizeSmall: "Polaris-Modal-Dialog--sizeSmall",
  sizeLarge: "Polaris-Modal-Dialog--sizeLarge",
  sizeFullScreen: "Polaris-Modal-Dialog--sizeFullScreen",
  animateFadeUp: "Polaris-Modal-Dialog--animateFadeUp",
  entering: "Polaris-Modal-Dialog--entering",
  exiting: "Polaris-Modal-Dialog--exiting",
  exited: "Polaris-Modal-Dialog--exited",
  entered: "Polaris-Modal-Dialog--entered"
};

// node_modules/@shopify/polaris/build/esm/components/TrapFocus/TrapFocus.js
var import_react131 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/focus-manager/hooks.js
var import_react130 = __toESM(require_react());
function useFocusManager({
  trapping
}) {
  let focusManager = (0, import_react130.useContext)(FocusManagerContext), id = (0, import_react130.useId)();
  if (!focusManager)
    throw new MissingAppProviderError("No FocusManager was provided.");
  let {
    trapFocusList,
    add: addFocusItem,
    remove: removeFocusItem
  } = focusManager, canSafelyFocus = trapFocusList[0] === id, value = (0, import_react130.useMemo)(() => ({
    canSafelyFocus
  }), [canSafelyFocus]);
  return (0, import_react130.useEffect)(() => {
    if (trapping)
      return addFocusItem(id), () => {
        removeFocusItem(id);
      };
  }, [addFocusItem, id, removeFocusItem, trapping]), value;
}

// node_modules/@shopify/polaris/build/esm/components/TrapFocus/TrapFocus.js
function TrapFocus({
  trapping = !0,
  children
}) {
  let {
    canSafelyFocus
  } = useFocusManager({
    trapping
  }), focusTrapWrapper = (0, import_react131.useRef)(null), [disableFocus, setDisableFocus] = (0, import_react131.useState)(!0);
  (0, import_react131.useEffect)(() => {
    let disable = canSafelyFocus && !(focusTrapWrapper.current && focusTrapWrapper.current.contains(document.activeElement)) ? !trapping : !0;
    setDisableFocus(disable);
  }, [canSafelyFocus, trapping]);
  let handleFocusIn = (event) => {
    let containerContentsHaveFocus = focusTrapWrapper.current && focusTrapWrapper.current.contains(document.activeElement);
    trapping === !1 || !focusTrapWrapper.current || containerContentsHaveFocus || event.target instanceof Element && event.target.matches(`${portal.selector} *`) || canSafelyFocus && event.target instanceof HTMLElement && focusTrapWrapper.current !== event.target && !focusTrapWrapper.current.contains(event.target) && focusFirstFocusableNode(focusTrapWrapper.current);
  }, handleTab = (event) => {
    if (trapping === !1 || !focusTrapWrapper.current)
      return;
    let firstFocusableNode = findFirstKeyboardFocusableNode(focusTrapWrapper.current), lastFocusableNode = findLastKeyboardFocusableNode(focusTrapWrapper.current);
    event.target === lastFocusableNode && !event.shiftKey && (event.preventDefault(), focusFirstKeyboardFocusableNode(focusTrapWrapper.current)), event.target === firstFocusableNode && event.shiftKey && (event.preventDefault(), focusLastKeyboardFocusableNode(focusTrapWrapper.current));
  };
  return /* @__PURE__ */ import_react131.default.createElement(Focus, {
    disabled: disableFocus,
    root: focusTrapWrapper.current
  }, /* @__PURE__ */ import_react131.default.createElement("div", {
    ref: focusTrapWrapper
  }, /* @__PURE__ */ import_react131.default.createElement(EventListener, {
    event: "focusin",
    handler: handleFocusIn
  }), /* @__PURE__ */ import_react131.default.createElement(KeypressListener, {
    keyCode: Key.Tab,
    keyEvent: "keydown",
    handler: handleTab
  }), children));
}

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Dialog/Dialog.js
function Dialog({
  instant,
  labelledBy,
  children,
  limitHeight,
  size: size2,
  onClose,
  onExited,
  onEntered,
  setClosing,
  hasToasts,
  ...props
}) {
  let theme = useTheme(), containerNode = (0, import_react132.useRef)(null), frameContext = (0, import_react132.useContext)(FrameContext), toastMessages;
  frameContext && (toastMessages = frameContext.toastMessages);
  let classes = classNames(styles42.Modal, size2 && styles42[variationName("size", size2)], limitHeight && styles42.limitHeight), TransitionChild = instant ? Transition_default : FadeUp;
  (0, import_react132.useEffect)(() => {
    containerNode.current && !containerNode.current.contains(document.activeElement) && focusFirstFocusableNode(containerNode.current);
  }, []);
  let handleKeyDown = () => {
    setClosing && setClosing(!0);
  }, handleKeyUp = () => {
    setClosing && setClosing(!1), onClose();
  }, ariaLiveAnnouncements = /* @__PURE__ */ import_react132.default.createElement("div", {
    "aria-live": "assertive"
  }, toastMessages ? toastMessages.map((toastMessage) => /* @__PURE__ */ import_react132.default.createElement(Text, {
    visuallyHidden: !0,
    as: "p",
    key: toastMessage.id
  }, toastMessage.content)) : null);
  return /* @__PURE__ */ import_react132.default.createElement(TransitionChild, Object.assign({}, props, {
    nodeRef: containerNode,
    mountOnEnter: !0,
    unmountOnExit: !0,
    timeout: parseInt(theme.motion["motion-duration-200"], 10),
    onEntered,
    onExited
  }), /* @__PURE__ */ import_react132.default.createElement("div", {
    className: styles42.Container,
    "data-polaris-layer": !0,
    "data-polaris-overlay": !0,
    ref: containerNode
  }, /* @__PURE__ */ import_react132.default.createElement(TrapFocus, null, /* @__PURE__ */ import_react132.default.createElement("div", {
    role: "dialog",
    "aria-modal": !0,
    "aria-label": labelledBy,
    "aria-labelledby": labelledBy,
    tabIndex: -1,
    className: styles42.Dialog
  }, /* @__PURE__ */ import_react132.default.createElement("div", {
    className: classes
  }, /* @__PURE__ */ import_react132.default.createElement(KeypressListener, {
    keyCode: Key.Escape,
    keyEvent: "keydown",
    handler: handleKeyDown
  }), /* @__PURE__ */ import_react132.default.createElement(KeypressListener, {
    keyCode: Key.Escape,
    handler: handleKeyUp
  }), children), ariaLiveAnnouncements))));
}
var fadeUpClasses = {
  appear: classNames(styles42.animateFadeUp, styles42.entering),
  appearActive: classNames(styles42.animateFadeUp, styles42.entered),
  enter: classNames(styles42.animateFadeUp, styles42.entering),
  enterActive: classNames(styles42.animateFadeUp, styles42.entered),
  exit: classNames(styles42.animateFadeUp, styles42.exiting),
  exitActive: classNames(styles42.animateFadeUp, styles42.exited)
};
function FadeUp({
  children,
  ...props
}) {
  return /* @__PURE__ */ import_react132.default.createElement(CSSTransition_default, Object.assign({}, props, {
    classNames: fadeUpClasses
  }), children);
}

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Header/Header.js
var import_react134 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Modal/components/CloseButton/CloseButton.js
var import_react133 = __toESM(require_react());
function CloseButton({
  pressed,
  onClick
}) {
  let i18n = useI18n();
  return /* @__PURE__ */ import_react133.default.createElement(Button, {
    variant: "tertiary",
    pressed,
    icon: SvgXIcon,
    onClick,
    accessibilityLabel: i18n.translate("Polaris.Common.close")
  });
}

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Header/Header.js
function Header({
  id,
  children,
  closing,
  titleHidden,
  onClose
}) {
  let headerPaddingInline = "400", headerPaddingBlock = "400";
  return titleHidden || !children ? /* @__PURE__ */ import_react134.default.createElement(Box, {
    position: "absolute",
    insetInlineEnd: headerPaddingInline,
    insetBlockStart: headerPaddingBlock,
    zIndex: "1"
  }, /* @__PURE__ */ import_react134.default.createElement(CloseButton, {
    onClick: onClose
  })) : /* @__PURE__ */ import_react134.default.createElement(Box, {
    paddingBlockStart: "400",
    paddingBlockEnd: "400",
    paddingInlineStart: headerPaddingInline,
    paddingInlineEnd: headerPaddingInline,
    borderBlockEndWidth: "025",
    borderColor: "border",
    background: "bg-surface-tertiary"
  }, /* @__PURE__ */ import_react134.default.createElement(InlineGrid, {
    columns: {
      xs: "1fr auto"
    },
    gap: "400"
  }, /* @__PURE__ */ import_react134.default.createElement(InlineStack, {
    gap: "400",
    blockAlign: "center"
  }, /* @__PURE__ */ import_react134.default.createElement(Text, {
    id,
    as: "h2",
    variant: "headingMd",
    breakWord: !0
  }, children)), /* @__PURE__ */ import_react134.default.createElement(CloseButton, {
    pressed: closing,
    onClick: onClose
  })));
}

// node_modules/@shopify/polaris/build/esm/components/Modal/components/Footer/Footer.js
var import_react135 = __toESM(require_react());
function Footer({
  primaryAction,
  secondaryActions,
  children
}) {
  let primaryActionButton = primaryAction && buttonsFrom(primaryAction, {
    variant: "primary"
  }) || null, secondaryActionButtons = secondaryActions && buttonsFrom(secondaryActions) || null, actions = primaryActionButton || secondaryActionButtons ? /* @__PURE__ */ import_react135.default.createElement(InlineStack, {
    gap: "200"
  }, secondaryActionButtons, primaryActionButton) : null;
  return /* @__PURE__ */ import_react135.default.createElement(InlineStack, {
    gap: "400",
    blockAlign: "center"
  }, /* @__PURE__ */ import_react135.default.createElement(Box, {
    borderColor: "border",
    borderBlockStartWidth: "025",
    padding: "400",
    width: "100%"
  }, /* @__PURE__ */ import_react135.default.createElement(InlineStack, {
    gap: "400",
    blockAlign: "center",
    align: "space-between"
  }, /* @__PURE__ */ import_react135.default.createElement(Box, null, children), actions)));
}

// node_modules/@shopify/polaris/build/esm/components/Modal/Modal.js
var IFRAME_LOADING_HEIGHT = 200, DEFAULT_IFRAME_CONTENT_HEIGHT = 400, Modal = function({
  children,
  title,
  titleHidden = !1,
  src,
  iFrameName,
  open,
  instant,
  sectioned,
  loading,
  size: size2,
  limitHeight,
  footer,
  primaryAction,
  secondaryActions,
  onScrolledToBottom,
  activator,
  activatorWrapper = "div",
  onClose,
  onIFrameLoad,
  onTransitionEnd,
  noScroll
}) {
  let [iframeHeight, setIframeHeight] = (0, import_react136.useState)(IFRAME_LOADING_HEIGHT), [closing, setClosing] = (0, import_react136.useState)(!1), headerId = (0, import_react136.useId)(), activatorRef = (0, import_react136.useRef)(null), iframeTitle = useI18n().translate("Polaris.Modal.iFrameTitle"), dialog, backdrop, handleEntered = (0, import_react136.useCallback)(() => {
    onTransitionEnd && onTransitionEnd();
  }, [onTransitionEnd]), handleExited = (0, import_react136.useCallback)(() => {
    setIframeHeight(IFRAME_LOADING_HEIGHT);
    let activatorElement = activator && isRef2(activator) ? activator && activator.current : activatorRef.current;
    activatorElement && requestAnimationFrame(() => focusFirstFocusableNode(activatorElement));
  }, [activator]), handleIFrameLoad = (0, import_react136.useCallback)((evt) => {
    let iframe = evt.target;
    if (iframe && iframe.contentWindow)
      try {
        setIframeHeight(iframe.contentWindow.document.body.scrollHeight);
      } catch {
        setIframeHeight(DEFAULT_IFRAME_CONTENT_HEIGHT);
      }
    onIFrameLoad?.(evt);
  }, [onIFrameLoad]);
  if (open) {
    let footerMarkup = !footer && !primaryAction && !secondaryActions ? null : /* @__PURE__ */ import_react136.default.createElement(Footer, {
      primaryAction,
      secondaryActions
    }, footer), content = sectioned ? wrapWithComponent(children, Section3, {
      titleHidden
    }) : children, body = loading ? /* @__PURE__ */ import_react136.default.createElement(Box, {
      padding: "400"
    }, /* @__PURE__ */ import_react136.default.createElement(InlineStack, {
      gap: "400",
      align: "center",
      blockAlign: "center"
    }, /* @__PURE__ */ import_react136.default.createElement(Spinner, null))) : content, scrollContainerMarkup = noScroll ? /* @__PURE__ */ import_react136.default.createElement("div", {
      className: styles40.NoScrollBody
    }, /* @__PURE__ */ import_react136.default.createElement(Box, {
      width: "100%",
      overflowX: "hidden",
      overflowY: "hidden"
    }, body)) : /* @__PURE__ */ import_react136.default.createElement(Scrollable, {
      shadow: !0,
      className: styles40.Body,
      onScrolledToBottom
    }, body), bodyMarkup = src ? /* @__PURE__ */ import_react136.default.createElement("iframe", {
      name: iFrameName,
      title: iframeTitle,
      src,
      className: styles40.IFrame,
      onLoad: handleIFrameLoad,
      style: {
        height: `${iframeHeight}px`
      }
    }) : scrollContainerMarkup;
    dialog = /* @__PURE__ */ import_react136.default.createElement(Dialog, {
      instant,
      labelledBy: headerId,
      onClose,
      onEntered: handleEntered,
      onExited: handleExited,
      size: size2,
      limitHeight,
      setClosing
    }, /* @__PURE__ */ import_react136.default.createElement(Header, {
      titleHidden,
      id: headerId,
      closing,
      onClose
    }, title), bodyMarkup, footerMarkup), backdrop = /* @__PURE__ */ import_react136.default.createElement(Backdrop, {
      setClosing,
      onClick: onClose
    });
  }
  let animated = !instant, activatorMarkup = activator && !isRef2(activator) ? /* @__PURE__ */ import_react136.default.createElement(Box, {
    ref: activatorRef,
    as: activatorWrapper
  }, activator) : null;
  return /* @__PURE__ */ import_react136.default.createElement(WithinContentContext.Provider, {
    value: !0
  }, activatorMarkup, /* @__PURE__ */ import_react136.default.createElement(Portal, {
    idPrefix: "modal"
  }, /* @__PURE__ */ import_react136.default.createElement(TransitionGroup_default, {
    appear: animated,
    enter: animated,
    exit: animated
  }, dialog), backdrop));
};
function isRef2(ref) {
  return Object.prototype.hasOwnProperty.call(ref, "current");
}
Modal.Section = Section3;

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/components/DiscardConfirmationModal/DiscardConfirmationModal.js
function DiscardConfirmationModal({
  open,
  onDiscard,
  onCancel
}) {
  let i18n = useI18n();
  return /* @__PURE__ */ import_react137.default.createElement(Modal, {
    title: i18n.translate("Polaris.DiscardConfirmationModal.title"),
    open,
    onClose: onCancel,
    primaryAction: {
      content: i18n.translate("Polaris.DiscardConfirmationModal.primaryAction"),
      destructive: !0,
      onAction: onDiscard
    },
    secondaryActions: [{
      content: i18n.translate("Polaris.DiscardConfirmationModal.secondaryAction"),
      onAction: onCancel
    }],
    sectioned: !0
  }, i18n.translate("Polaris.DiscardConfirmationModal.message"));
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ContextualSaveBar/ContextualSaveBar.js
function ContextualSaveBar({
  alignContentFlush,
  message,
  saveAction,
  discardAction,
  fullWidth,
  contextControl,
  secondaryMenu
}) {
  let i18n = useI18n(), {
    logo
  } = useFrame(), {
    value: discardConfirmationModalVisible,
    toggle: toggleDiscardConfirmationModal,
    setFalse: closeDiscardConfirmationModal
  } = useToggle(!1), handleDiscardAction = (0, import_react138.useCallback)(() => {
    discardAction && discardAction.onAction && discardAction.onAction(), closeDiscardConfirmationModal();
  }, [closeDiscardConfirmationModal, discardAction]), discardActionContent = discardAction && discardAction.content ? discardAction.content : i18n.translate("Polaris.ContextualSaveBar.discard"), discardActionHandler;
  discardAction && discardAction.discardConfirmationModal ? discardActionHandler = toggleDiscardConfirmationModal : discardAction && (discardActionHandler = discardAction.onAction);
  let discardConfirmationModalMarkup = discardAction && discardAction.onAction && discardAction.discardConfirmationModal && /* @__PURE__ */ import_react138.default.createElement(DiscardConfirmationModal, {
    open: discardConfirmationModalVisible,
    onCancel: toggleDiscardConfirmationModal,
    onDiscard: handleDiscardAction
  }), discardActionMarkup = discardAction && /* @__PURE__ */ import_react138.default.createElement(Button, {
    variant: "tertiary",
    size: "large",
    url: discardAction.url,
    onClick: discardActionHandler,
    loading: discardAction.loading,
    disabled: discardAction.disabled,
    accessibilityLabel: discardAction.content
  }, discardActionContent), saveActionContent = saveAction && saveAction.content ? saveAction.content : i18n.translate("Polaris.ContextualSaveBar.save"), saveActionMarkup = saveAction && /* @__PURE__ */ import_react138.default.createElement(Button, {
    variant: "primary",
    tone: "success",
    size: "large",
    url: saveAction.url,
    onClick: saveAction.onAction,
    loading: saveAction.loading,
    disabled: saveAction.disabled,
    accessibilityLabel: saveAction.content
  }, saveActionContent), width2 = getWidth(logo, 104), imageMarkup = logo && /* @__PURE__ */ import_react138.default.createElement(Image, {
    style: {
      width: width2
    },
    source: logo.contextualSaveBarSource || "",
    alt: ""
  }), logoMarkup = alignContentFlush || contextControl ? null : /* @__PURE__ */ import_react138.default.createElement("div", {
    className: styles39.LogoContainer,
    style: {
      width: width2
    }
  }, imageMarkup), contextControlMarkup = contextControl ? /* @__PURE__ */ import_react138.default.createElement("div", {
    className: styles39.ContextControl
  }, contextControl) : null, contentsClassName = classNames(styles39.Contents, fullWidth && styles39.fullWidth);
  return /* @__PURE__ */ import_react138.default.createElement(import_react138.default.Fragment, null, /* @__PURE__ */ import_react138.default.createElement("div", {
    className: styles39.ContextualSaveBar
  }, contextControlMarkup, logoMarkup, /* @__PURE__ */ import_react138.default.createElement("div", {
    className: contentsClassName
  }, /* @__PURE__ */ import_react138.default.createElement("div", {
    className: styles39.MessageContainer
  }, /* @__PURE__ */ import_react138.default.createElement(Icon, {
    source: SvgAlertTriangleIcon
  }), message && /* @__PURE__ */ import_react138.default.createElement(Text, {
    as: "h2",
    variant: "headingMd",
    tone: "text-inverse",
    truncate: !0
  }, message)), /* @__PURE__ */ import_react138.default.createElement("div", {
    className: styles39.ActionContainer
  }, /* @__PURE__ */ import_react138.default.createElement(LegacyStack, {
    spacing: "tight",
    wrap: !1
  }, secondaryMenu, discardActionMarkup, saveActionMarkup)))), discardConfirmationModalMarkup);
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.js
var import_react143 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-deep-effect.js
var import_react140 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/use-deep-compare-ref.js
var import_react139 = __toESM(require_react()), import_react_fast_compare2 = __toESM(require_react_fast_compare());
function useDeepCompareRef(dependencies, comparator = import_react_fast_compare2.default) {
  let dependencyList = (0, import_react139.useRef)(dependencies);
  return comparator(dependencyList.current, dependencies) || (dependencyList.current = dependencies), dependencyList.current;
}

// node_modules/@shopify/polaris/build/esm/utilities/use-deep-effect.js
function useDeepEffect(callback2, dependencies, customCompare) {
  (0, import_react140.useEffect)(callback2, useDeepCompareRef(dependencies, customCompare));
}

// node_modules/@shopify/polaris/build/esm/utilities/use-deep-callback.js
var import_react141 = __toESM(require_react());
function useDeepCallback(callback2, dependencies, customCompare) {
  return (0, import_react141.useCallback)(callback2, useDeepCompareRef(dependencies, customCompare));
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.css.js
var styles43 = {
  ToastManager: "Polaris-Frame-ToastManager",
  ToastWrapper: "Polaris-Frame-ToastManager__ToastWrapper",
  "ToastWrapper-enter": "Polaris-Frame-ToastManager__ToastWrapper--enter",
  "ToastWrapper-exit": "Polaris-Frame-ToastManager__ToastWrapper--exit",
  "ToastWrapper-enter-done": "Polaris-Frame-ToastManager--toastWrapperEnterDone",
  "ToastWrapper--hoverable": "Polaris-Frame-ToastManager--toastWrapperHoverable"
};

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.js
var import_react142 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.css.js
var styles44 = {
  Toast: "Polaris-Frame-Toast",
  Action: "Polaris-Frame-Toast__Action",
  error: "Polaris-Frame-Toast--error",
  CloseButton: "Polaris-Frame-Toast__CloseButton",
  LeadingIcon: "Polaris-Frame-Toast__LeadingIcon",
  toneMagic: "Polaris-Frame-Toast--toneMagic",
  WithActionOnComponent: "Polaris-Frame-Toast__WithActionOnComponent"
};

// node_modules/@shopify/polaris/build/esm/components/Frame/components/Toast/Toast.js
var DEFAULT_TOAST_DURATION = 5e3, DEFAULT_TOAST_DURATION_WITH_ACTION = 1e4;
function Toast({
  content,
  onDismiss,
  duration,
  error,
  action: action8,
  tone,
  onClick,
  icon,
  isHovered
}) {
  let durationRemaining = (0, import_react142.useRef)(action8 && !duration ? DEFAULT_TOAST_DURATION_WITH_ACTION : duration || DEFAULT_TOAST_DURATION), timeoutStart = (0, import_react142.useRef)(null), timer = (0, import_react142.useRef)(null);
  (0, import_react142.useEffect)(() => {
    function resume() {
      timeoutStart.current = Date.now(), timer.current = setTimeout(() => {
        onDismiss();
      }, durationRemaining.current);
    }
    function pause() {
      timeoutStart.current && (durationRemaining.current -= Date.now() - timeoutStart.current), timer.current && clearTimeout(timer.current), timer.current = null;
    }
    return isHovered ? pause() : resume(), () => {
      timer.current && clearTimeout(timer.current);
    };
  }, [isHovered, onDismiss]), (0, import_react142.useEffect)(() => {
    action8 && duration && duration < DEFAULT_TOAST_DURATION_WITH_ACTION && console.log("Toast with action should persist for at least 10,000 milliseconds to give the merchant enough time to act on it.");
  }, [action8, duration]);
  let dismissMarkup = /* @__PURE__ */ import_react142.default.createElement("button", {
    type: "button",
    className: styles44.CloseButton,
    onClick: onDismiss
  }, /* @__PURE__ */ import_react142.default.createElement(Icon, {
    source: SvgXSmallIcon,
    tone: "inherit"
  })), actionMarkup = action8 ? /* @__PURE__ */ import_react142.default.createElement("div", {
    className: styles44.Action
  }, /* @__PURE__ */ import_react142.default.createElement(Button, {
    variant: "monochromePlain",
    removeUnderline: !0,
    size: "slim",
    onClick: action8.onAction
  }, action8.content)) : null, leadingIconMarkup = null;
  error ? leadingIconMarkup = /* @__PURE__ */ import_react142.default.createElement("div", {
    className: styles44.LeadingIcon
  }, /* @__PURE__ */ import_react142.default.createElement(Icon, {
    source: SvgAlertCircleIcon,
    tone: "inherit"
  })) : icon && (leadingIconMarkup = /* @__PURE__ */ import_react142.default.createElement("div", {
    className: styles44.LeadingIcon
  }, /* @__PURE__ */ import_react142.default.createElement(Icon, {
    source: icon,
    tone: "inherit"
  })));
  let className = classNames(styles44.Toast, error && styles44.error, tone && styles44[variationName("tone", tone)]);
  return !action8 && onClick ? /* @__PURE__ */ import_react142.default.createElement("button", {
    "aria-live": "assertive",
    className: classNames(className, styles44.WithActionOnComponent),
    type: "button",
    onClick
  }, /* @__PURE__ */ import_react142.default.createElement(KeypressListener, {
    keyCode: Key.Escape,
    handler: onDismiss
  }), leadingIconMarkup, /* @__PURE__ */ import_react142.default.createElement(InlineStack, {
    gap: "400",
    blockAlign: "center"
  }, /* @__PURE__ */ import_react142.default.createElement(Text, Object.assign({
    as: "span",
    variant: "bodyMd",
    fontWeight: "medium"
  }, tone === "magic" && {
    tone: "magic"
  }), content))) : /* @__PURE__ */ import_react142.default.createElement("div", {
    className,
    "aria-live": "assertive"
  }, /* @__PURE__ */ import_react142.default.createElement(KeypressListener, {
    keyCode: Key.Escape,
    handler: onDismiss
  }), leadingIconMarkup, /* @__PURE__ */ import_react142.default.createElement(InlineStack, {
    gap: "400",
    blockAlign: "center"
  }, /* @__PURE__ */ import_react142.default.createElement(Text, Object.assign({
    as: "span",
    variant: "bodyMd",
    fontWeight: "medium"
  }, tone === "magic" && {
    tone: "magic"
  }), content)), actionMarkup, dismissMarkup);
}

// node_modules/@shopify/polaris/build/esm/components/Frame/components/ToastManager/ToastManager.js
var ADDITIONAL_TOAST_BASE_MOVEMENT = 10, TOAST_TRANSITION_DELAY = 30;
function generateAdditionalVerticalMovement(index) {
  let getAmountToRemove = (idx) => (idx - 1) * idx / 2;
  return index * ADDITIONAL_TOAST_BASE_MOVEMENT - getAmountToRemove(index);
}
var ToastManager = /* @__PURE__ */ (0, import_react143.memo)(function({
  toastMessages
}) {
  let toastNodes = [], [shouldExpand, setShouldExpand] = (0, import_react143.useState)(!1), isFullyExpanded = (0, import_react143.useRef)(!1), fullyExpandedTimeout = (0, import_react143.useRef)(null), firstToast = (0, import_react143.useRef)(null), updateToasts = useDeepCallback(() => {
    let zeroIndexTotalMessages = toastMessages.length - 1;
    toastMessages.forEach((_, index) => {
      let reversedOrder = zeroIndexTotalMessages - index, currentToast = toastNodes[index];
      if (!currentToast.current)
        return;
      let toastHeight = currentToast.current.clientHeight, scale = shouldExpand ? 1 : 0.9 ** reversedOrder, additionalVerticalMovement = generateAdditionalVerticalMovement(reversedOrder), targetInPos = shouldExpand ? toastHeight + (toastHeight - 8) * reversedOrder : toastHeight + additionalVerticalMovement;
      currentToast.current.style.setProperty("--pc-toast-manager-translate-y-in", `-${targetInPos}px`), currentToast.current.style.setProperty("--pc-toast-manager-scale-in", `${scale}`), currentToast.current.style.setProperty("--pc-toast-manager-blur-in", shouldExpand ? "0" : `${reversedOrder * 0.5}px`), currentToast.current.style.setProperty("--pc-toast-manager-transition-delay-in", `${shouldExpand ? reversedOrder * TOAST_TRANSITION_DELAY : 0}ms`), currentToast.current.style.setProperty("--pc-toast-manager-scale-out", `${reversedOrder === 0 ? 0.85 : scale ** 2}`), currentToast.current.style.setProperty("--pc-toast-manager-translate-y-out", `${-targetInPos}px`);
    });
  }, [toastMessages, toastNodes, shouldExpand]);
  useDeepEffect(() => {
    updateToasts(), toastMessages.length === 0 && setShouldExpand(!1), shouldExpand ? fullyExpandedTimeout.current = setTimeout(() => {
      isFullyExpanded.current = !0;
    }, toastMessages.length * TOAST_TRANSITION_DELAY + 400) : fullyExpandedTimeout.current && (clearTimeout(fullyExpandedTimeout.current), isFullyExpanded.current = !1);
  }, [toastMessages, shouldExpand]);
  let toastsMarkup = toastMessages.map((toast, index) => {
    let reverseOrderIndex = toastMessages.length - index - 1, toastNode = /* @__PURE__ */ (0, import_react143.createRef)();
    toastNodes[index] = toastNode;
    function handleMouseEnter() {
      setShouldExpand(!0);
    }
    function handleMouseEnterFirstToast() {
      isFullyExpanded.current && setShouldExpand(!1);
    }
    return /* @__PURE__ */ import_react143.default.createElement(CSSTransition_default, {
      nodeRef: toastNodes[index],
      key: toast.id,
      timeout: {
        enter: 0,
        exit: 200
      },
      classNames: toastClasses
    }, /* @__PURE__ */ import_react143.default.createElement("div", {
      ref: toastNode,
      onMouseEnter: reverseOrderIndex > 0 ? handleMouseEnter : handleMouseEnterFirstToast
    }, /* @__PURE__ */ import_react143.default.createElement("div", {
      ref: (node) => reverseOrderIndex === 0 ? firstToast.current = node : null
    }, /* @__PURE__ */ import_react143.default.createElement(Toast, Object.assign({}, toast, {
      isHovered: shouldExpand
    })))));
  });
  return /* @__PURE__ */ import_react143.default.createElement(Portal, {
    idPrefix: "toast"
  }, /* @__PURE__ */ import_react143.default.createElement(EventListener, {
    event: "resize",
    handler: updateToasts
  }), /* @__PURE__ */ import_react143.default.createElement("div", {
    className: styles43.ToastManager,
    "aria-live": "assertive",
    onMouseEnter: function(event) {
      let target = event.target, isInFirstToast = firstToast.current?.contains(target);
      setShouldExpand(!isInFirstToast);
    },
    onMouseLeave: function() {
      setShouldExpand(!1);
    }
  }, /* @__PURE__ */ import_react143.default.createElement(TransitionGroup_default, {
    component: null
  }, toastsMarkup)));
}), toastClasses = {
  enter: classNames(styles43.ToastWrapper, styles43["ToastWrapper-enter"]),
  enterDone: classNames(styles43.ToastWrapper, styles43["ToastWrapper-enter-done"]),
  exit: classNames(styles43.ToastWrapper, styles43["ToastWrapper-exit"])
};

// node_modules/@shopify/polaris/build/esm/components/Frame/Frame.js
var APP_FRAME_MAIN = "AppFrameMain", APP_FRAME_NAV = "AppFrameNav", APP_FRAME_TOP_BAR = "AppFrameTopBar", APP_FRAME_LOADING_BAR = "AppFrameLoadingBar", FrameInner = class extends import_react144.PureComponent {
  constructor(...args) {
    super(...args), this.state = {
      skipFocused: !1,
      globalRibbonHeight: 0,
      loadingStack: 0,
      toastMessages: [],
      showContextualSaveBar: !1
    }, this.contextualSaveBar = null, this.globalRibbonContainer = null, this.navigationNode = /* @__PURE__ */ (0, import_react144.createRef)(), this.setGlobalRibbonHeight = () => {
      let {
        globalRibbonContainer
      } = this;
      globalRibbonContainer && this.setState({
        globalRibbonHeight: globalRibbonContainer.offsetHeight
      }, this.setGlobalRibbonRootProperty);
    }, this.setOffset = () => {
      let {
        offset = "0px"
      } = this.props;
      setRootProperty("--pc-frame-offset", offset);
    }, this.setGlobalRibbonRootProperty = () => {
      let {
        globalRibbonHeight
      } = this.state;
      setRootProperty("--pc-frame-global-ribbon-height", `${globalRibbonHeight}px`);
    }, this.showToast = (toast) => {
      this.setState(({
        toastMessages
      }) => ({
        toastMessages: toastMessages.find(({
          id
        }) => id === toast.id) != null ? toastMessages : [...toastMessages, toast]
      }));
    }, this.hideToast = ({
      id
    }) => {
      this.setState(({
        toastMessages
      }) => ({
        toastMessages: toastMessages.filter(({
          id: toastId
        }) => id !== toastId)
      }));
    }, this.setContextualSaveBar = (props) => {
      let {
        showContextualSaveBar
      } = this.state;
      this.contextualSaveBar = {
        ...props
      }, showContextualSaveBar === !0 ? this.forceUpdate() : this.setState({
        showContextualSaveBar: !0
      });
    }, this.removeContextualSaveBar = () => {
      this.contextualSaveBar = null, this.setState({
        showContextualSaveBar: !1
      });
    }, this.startLoading = () => {
      this.setState(({
        loadingStack
      }) => ({
        loadingStack: loadingStack + 1
      }));
    }, this.stopLoading = () => {
      this.setState(({
        loadingStack
      }) => ({
        loadingStack: Math.max(0, loadingStack - 1)
      }));
    }, this.handleResize = () => {
      this.props.globalRibbon && this.setGlobalRibbonHeight();
    }, this.handleFocus = () => {
      this.setState({
        skipFocused: !0
      });
    }, this.handleBlur = () => {
      this.setState({
        skipFocused: !1
      });
    }, this.handleClick = (event) => {
      let {
        skipToContentTarget
      } = this.props;
      skipToContentTarget && skipToContentTarget.current && (skipToContentTarget.current.focus(), event?.preventDefault());
    }, this.handleNavigationDismiss = () => {
      let {
        onNavigationDismiss
      } = this.props;
      onNavigationDismiss?.();
    }, this.setGlobalRibbonContainer = (node) => {
      this.globalRibbonContainer = node;
    }, this.handleNavKeydown = (event) => {
      let {
        key
      } = event, {
        mediaQuery: {
          isNavigationCollapsed
        },
        showMobileNavigation
      } = this.props;
      isNavigationCollapsed && showMobileNavigation && key === "Escape" && this.handleNavigationDismiss();
    };
  }
  componentDidMount() {
    this.handleResize(), !this.props.globalRibbon && (this.setGlobalRibbonRootProperty(), this.setOffset());
  }
  componentDidUpdate(prevProps) {
    this.props.globalRibbon !== prevProps.globalRibbon && this.setGlobalRibbonHeight(), this.setOffset();
  }
  render() {
    let {
      skipFocused,
      loadingStack,
      toastMessages,
      showContextualSaveBar
    } = this.state, {
      logo,
      children,
      navigation,
      topBar,
      globalRibbon,
      showMobileNavigation = !1,
      skipToContentTarget,
      i18n,
      sidebar,
      mediaQuery: {
        isNavigationCollapsed
      }
    } = this.props, navClassName = classNames(styles36.Navigation, showMobileNavigation && styles36["Navigation-visible"]), mobileNavHidden = isNavigationCollapsed && !showMobileNavigation, mobileNavShowing = isNavigationCollapsed && showMobileNavigation, tabIndex = mobileNavShowing ? 0 : -1, mobileNavAttributes = {
      ...mobileNavShowing && {
        "aria-modal": !0,
        role: "dialog"
      }
    }, navigationMarkup = navigation ? /* @__PURE__ */ import_react144.default.createElement(UseTheme, null, (theme) => /* @__PURE__ */ import_react144.default.createElement(TrapFocus, {
      trapping: mobileNavShowing
    }, /* @__PURE__ */ import_react144.default.createElement(CSSTransition_default, {
      nodeRef: this.navigationNode,
      appear: isNavigationCollapsed,
      exit: isNavigationCollapsed,
      in: showMobileNavigation,
      timeout: parseInt(theme.motion["motion-duration-300"], 10),
      classNames: navTransitionClasses
    }, /* @__PURE__ */ import_react144.default.createElement("div", Object.assign({
      key: "NavContent"
    }, mobileNavAttributes, {
      "aria-label": i18n.translate("Polaris.Frame.navigationLabel"),
      ref: this.navigationNode,
      className: navClassName,
      onKeyDown: this.handleNavKeydown,
      id: APP_FRAME_NAV,
      hidden: mobileNavHidden
    }), navigation, /* @__PURE__ */ import_react144.default.createElement("button", {
      type: "button",
      className: styles36.NavigationDismiss,
      onClick: this.handleNavigationDismiss,
      "aria-hidden": mobileNavHidden || !isNavigationCollapsed && !showMobileNavigation,
      "aria-label": i18n.translate("Polaris.Frame.Navigation.closeMobileNavigationLabel"),
      tabIndex
    }, /* @__PURE__ */ import_react144.default.createElement(Icon, {
      source: SvgXIcon
    })))))) : null, loadingMarkup = loadingStack > 0 ? /* @__PURE__ */ import_react144.default.createElement("div", {
      className: styles36.LoadingBar,
      id: APP_FRAME_LOADING_BAR
    }, /* @__PURE__ */ import_react144.default.createElement(Loading, null)) : null, topBarMarkup = topBar ? /* @__PURE__ */ import_react144.default.createElement("div", Object.assign({
      className: styles36.TopBar
    }, layer.props, dataPolarisTopBar.props, {
      id: APP_FRAME_TOP_BAR
    }), topBar) : null, globalRibbonMarkup = globalRibbon ? /* @__PURE__ */ import_react144.default.createElement("div", {
      className: styles36.GlobalRibbonContainer,
      ref: this.setGlobalRibbonContainer
    }, globalRibbon) : null, skipClassName = classNames(styles36.Skip, skipFocused && styles36.focused), skipTarget = skipToContentTarget?.current ? skipToContentTarget.current.id : APP_FRAME_MAIN, skipMarkup = /* @__PURE__ */ import_react144.default.createElement("div", {
      className: skipClassName
    }, /* @__PURE__ */ import_react144.default.createElement("a", {
      href: `#${skipTarget}`,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onClick: this.handleClick
    }, /* @__PURE__ */ import_react144.default.createElement(Text, {
      as: "span",
      variant: "bodyLg",
      fontWeight: "medium"
    }, i18n.translate("Polaris.Frame.skipToContent")))), navigationAttributes = navigation ? {
      "data-has-navigation": !0
    } : {}, frameClassName = classNames(styles36.Frame, navigation && styles36.hasNav, topBar && styles36.hasTopBar, sidebar && styles36.hasSidebar), contextualSaveBarMarkup = /* @__PURE__ */ import_react144.default.createElement(CSSAnimation, {
      in: showContextualSaveBar,
      className: styles36.ContextualSaveBar,
      type: "fade"
    }, /* @__PURE__ */ import_react144.default.createElement(ContextualSaveBar, this.contextualSaveBar)), navigationOverlayMarkup = showMobileNavigation && isNavigationCollapsed ? /* @__PURE__ */ import_react144.default.createElement(Backdrop, {
      belowNavigation: !0,
      onClick: this.handleNavigationDismiss,
      onTouchStart: this.handleNavigationDismiss
    }) : null, context = {
      logo,
      showToast: this.showToast,
      hideToast: this.hideToast,
      toastMessages,
      startLoading: this.startLoading,
      stopLoading: this.stopLoading,
      setContextualSaveBar: this.setContextualSaveBar,
      removeContextualSaveBar: this.removeContextualSaveBar
    };
    return /* @__PURE__ */ import_react144.default.createElement(FrameContext.Provider, {
      value: context
    }, /* @__PURE__ */ import_react144.default.createElement("div", Object.assign({
      className: frameClassName
    }, layer.props, navigationAttributes), skipMarkup, topBarMarkup, navigationMarkup, contextualSaveBarMarkup, loadingMarkup, navigationOverlayMarkup, /* @__PURE__ */ import_react144.default.createElement("main", {
      className: styles36.Main,
      id: APP_FRAME_MAIN,
      "data-has-global-ribbon": Boolean(globalRibbon)
    }, /* @__PURE__ */ import_react144.default.createElement("div", {
      className: styles36.Content
    }, children)), /* @__PURE__ */ import_react144.default.createElement(ToastManager, {
      toastMessages
    }), globalRibbonMarkup, /* @__PURE__ */ import_react144.default.createElement(EventListener, {
      event: "resize",
      handler: this.handleResize
    })));
  }
}, navTransitionClasses = {
  enter: classNames(styles36["Navigation-enter"]),
  enterActive: classNames(styles36["Navigation-enterActive"]),
  enterDone: classNames(styles36["Navigation-enterActive"]),
  exit: classNames(styles36["Navigation-exit"]),
  exitActive: classNames(styles36["Navigation-exitActive"])
};
function Frame(props) {
  let i18n = useI18n(), mediaQuery = useMediaQuery();
  return /* @__PURE__ */ import_react144.default.createElement(FrameInner, Object.assign({}, props, {
    i18n,
    mediaQuery
  }));
}

// node_modules/@shopify/polaris/build/esm/components/Layout/Layout.js
var import_react148 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Layout/Layout.css.js
var styles45 = {
  Layout: "Polaris-Layout",
  Section: "Polaris-Layout__Section",
  "Section-fullWidth": "Polaris-Layout__Section--fullWidth",
  "Section-oneHalf": "Polaris-Layout__Section--oneHalf",
  "Section-oneThird": "Polaris-Layout__Section--oneThird",
  AnnotatedSection: "Polaris-Layout__AnnotatedSection",
  AnnotationWrapper: "Polaris-Layout__AnnotationWrapper",
  AnnotationContent: "Polaris-Layout__AnnotationContent",
  Annotation: "Polaris-Layout__Annotation"
};

// node_modules/@shopify/polaris/build/esm/components/Layout/components/AnnotatedSection/AnnotatedSection.js
var import_react146 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/TextContainer/TextContainer.js
var import_react145 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/TextContainer/TextContainer.css.js
var styles46 = {
  TextContainer: "Polaris-TextContainer",
  spacingTight: "Polaris-TextContainer--spacingTight",
  spacingLoose: "Polaris-TextContainer--spacingLoose"
};

// node_modules/@shopify/polaris/build/esm/components/TextContainer/TextContainer.js
function TextContainer({
  spacing,
  children
}) {
  let className = classNames(styles46.TextContainer, spacing && styles46[variationName("spacing", spacing)]);
  return /* @__PURE__ */ import_react145.default.createElement("div", {
    className
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/Layout/components/AnnotatedSection/AnnotatedSection.js
function AnnotatedSection({
  children,
  title,
  description,
  id
}) {
  let descriptionMarkup = typeof description == "string" ? /* @__PURE__ */ import_react146.default.createElement(Text, {
    as: "p",
    variant: "bodyMd"
  }, description) : description;
  return /* @__PURE__ */ import_react146.default.createElement("div", {
    className: styles45.AnnotatedSection
  }, /* @__PURE__ */ import_react146.default.createElement("div", {
    className: styles45.AnnotationWrapper
  }, /* @__PURE__ */ import_react146.default.createElement("div", {
    className: styles45.Annotation
  }, /* @__PURE__ */ import_react146.default.createElement(TextContainer, {
    spacing: "tight"
  }, /* @__PURE__ */ import_react146.default.createElement(Text, {
    id,
    variant: "headingMd",
    as: "h2"
  }, title), descriptionMarkup && /* @__PURE__ */ import_react146.default.createElement(Box, {
    color: "text-secondary"
  }, descriptionMarkup))), /* @__PURE__ */ import_react146.default.createElement("div", {
    className: styles45.AnnotationContent
  }, children)));
}

// node_modules/@shopify/polaris/build/esm/components/Layout/components/Section/Section.js
var import_react147 = __toESM(require_react());
function Section4({
  children,
  variant
}) {
  let className = classNames(styles45.Section, styles45[`Section-${variant}`]);
  return /* @__PURE__ */ import_react147.default.createElement("div", {
    className
  }, children);
}

// node_modules/@shopify/polaris/build/esm/components/Layout/Layout.js
var Layout = function({
  sectioned,
  children
}) {
  let content = sectioned ? /* @__PURE__ */ import_react148.default.createElement(Section4, null, children) : children;
  return /* @__PURE__ */ import_react148.default.createElement("div", {
    className: styles45.Layout
  }, content);
};
Layout.AnnotatedSection = AnnotatedSection;
Layout.Section = Section4;

// node_modules/@shopify/polaris/build/esm/components/Page/Page.js
var import_react153 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/utilities/is-interface.js
var import_react149 = __toESM(require_react());
function isInterface(x) {
  return !/* @__PURE__ */ (0, import_react149.isValidElement)(x) && x !== void 0;
}

// node_modules/@shopify/polaris/build/esm/utilities/is-react-element.js
var import_react150 = __toESM(require_react());
function isReactElement(x) {
  return /* @__PURE__ */ (0, import_react150.isValidElement)(x) && x !== void 0;
}

// node_modules/@shopify/polaris/build/esm/components/Page/Page.css.js
var styles47 = {
  Page: "Polaris-Page",
  fullWidth: "Polaris-Page--fullWidth",
  narrowWidth: "Polaris-Page--narrowWidth",
  Content: "Polaris-Page__Content"
};

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/Header.js
var import_react152 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/Header.css.js
var styles48 = {
  TitleWrapper: "Polaris-Page-Header__TitleWrapper",
  TitleWrapperExpand: "Polaris-Page-Header__TitleWrapperExpand",
  BreadcrumbWrapper: "Polaris-Page-Header__BreadcrumbWrapper",
  PaginationWrapper: "Polaris-Page-Header__PaginationWrapper",
  PrimaryActionWrapper: "Polaris-Page-Header__PrimaryActionWrapper",
  Row: "Polaris-Page-Header__Row",
  mobileView: "Polaris-Page-Header--mobileView",
  RightAlign: "Polaris-Page-Header__RightAlign",
  noBreadcrumbs: "Polaris-Page-Header--noBreadcrumbs",
  AdditionalMetaData: "Polaris-Page-Header__AdditionalMetaData",
  Actions: "Polaris-Page-Header__Actions",
  longTitle: "Polaris-Page-Header--longTitle",
  mediumTitle: "Polaris-Page-Header--mediumTitle",
  isSingleRow: "Polaris-Page-Header--isSingleRow"
};

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/components/Title/Title.js
var import_react151 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/components/Title/Title.css.js
var styles49 = {
  Title: "Polaris-Header-Title",
  TitleWithSubtitle: "Polaris-Header-Title__TitleWithSubtitle",
  TitleWrapper: "Polaris-Header-Title__TitleWrapper",
  SubTitle: "Polaris-Header-Title__SubTitle",
  SubtitleCompact: "Polaris-Header-Title__SubtitleCompact",
  SubtitleMaxWidth: "Polaris-Header-Title__SubtitleMaxWidth"
};

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/components/Title/Title.js
function Title({
  title,
  subtitle,
  titleMetadata,
  compactTitle,
  hasSubtitleMaxWidth
}) {
  let className = classNames(styles49.Title, subtitle && styles49.TitleWithSubtitle), titleMarkup = title ? /* @__PURE__ */ import_react151.default.createElement("h1", {
    className
  }, /* @__PURE__ */ import_react151.default.createElement(Text, {
    as: "span",
    variant: "headingLg",
    fontWeight: "bold"
  }, title)) : null, titleMetadataMarkup = titleMetadata ? /* @__PURE__ */ import_react151.default.createElement(Bleed, {
    marginBlock: "100"
  }, titleMetadata) : null, wrappedTitleMarkup = /* @__PURE__ */ import_react151.default.createElement("div", {
    className: styles49.TitleWrapper
  }, titleMarkup, titleMetadataMarkup), subtitleMarkup = subtitle ? /* @__PURE__ */ import_react151.default.createElement("div", {
    className: classNames(styles49.SubTitle, compactTitle && styles49.SubtitleCompact, hasSubtitleMaxWidth && styles49.SubtitleMaxWidth)
  }, /* @__PURE__ */ import_react151.default.createElement(Text, {
    as: "p",
    variant: "bodySm",
    tone: "subdued"
  }, subtitle)) : null;
  return /* @__PURE__ */ import_react151.default.createElement(import_react151.default.Fragment, null, wrappedTitleMarkup, subtitleMarkup);
}

// node_modules/@shopify/polaris/build/esm/components/Page/components/Header/Header.js
var SHORT_TITLE = 20, REALLY_SHORT_TITLE = 8, LONG_TITLE = 34;
function Header2({
  title,
  subtitle,
  pageReadyAccessibilityLabel,
  titleMetadata,
  additionalMetadata,
  titleHidden = !1,
  primaryAction,
  pagination,
  filterActions,
  backAction,
  secondaryActions = [],
  actionGroups = [],
  compactTitle = !1,
  onActionRollup
}) {
  let i18n = useI18n(), {
    isNavigationCollapsed
  } = useMediaQuery(), isSingleRow = !primaryAction && !pagination && (isInterface(secondaryActions) && !secondaryActions.length || isReactElement(secondaryActions)) && !actionGroups.length, hasActionGroupsOrSecondaryActions = actionGroups.length > 0 || isInterface(secondaryActions) && secondaryActions.length > 0 || isReactElement(secondaryActions), breadcrumbMarkup = backAction ? /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.BreadcrumbWrapper
  }, /* @__PURE__ */ import_react152.default.createElement(Box, {
    maxWidth: "100%",
    paddingInlineEnd: "100",
    printHidden: !0
  }, /* @__PURE__ */ import_react152.default.createElement(Breadcrumbs, {
    backAction
  }))) : null, paginationMarkup = pagination && !isNavigationCollapsed ? /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.PaginationWrapper
  }, /* @__PURE__ */ import_react152.default.createElement(Box, {
    printHidden: !0
  }, /* @__PURE__ */ import_react152.default.createElement(Pagination, Object.assign({}, pagination, {
    hasPrevious: pagination.hasPrevious,
    hasNext: pagination.hasNext
  })))) : null, pageTitleMarkup = /* @__PURE__ */ import_react152.default.createElement("div", {
    className: classNames(styles48.TitleWrapper, !hasActionGroupsOrSecondaryActions && styles48.TitleWrapperExpand)
  }, /* @__PURE__ */ import_react152.default.createElement(Title, {
    title,
    subtitle,
    titleMetadata,
    compactTitle,
    hasSubtitleMaxWidth: hasActionGroupsOrSecondaryActions
  })), labelForPageReadyAccessibilityLabel = pageReadyAccessibilityLabel || title, pageReadyAccessibilityLabelMarkup = labelForPageReadyAccessibilityLabel ? /* @__PURE__ */ import_react152.default.createElement("div", {
    role: "status"
  }, /* @__PURE__ */ import_react152.default.createElement(Text, {
    visuallyHidden: !0,
    as: "p"
  }, i18n.translate("Polaris.Page.Header.pageReadyAccessibilityLabel", {
    title: labelForPageReadyAccessibilityLabel
  }))) : void 0, primaryActionMarkup = primaryAction ? /* @__PURE__ */ import_react152.default.createElement(PrimaryActionMarkup, {
    primaryAction
  }) : null, actionMenuMarkup = null;
  isInterface(secondaryActions) && (secondaryActions.length > 0 || hasGroupsWithActions(actionGroups)) ? actionMenuMarkup = /* @__PURE__ */ import_react152.default.createElement(ActionMenu, {
    actions: secondaryActions,
    groups: actionGroups,
    rollup: isNavigationCollapsed,
    rollupActionsLabel: title ? i18n.translate("Polaris.Page.Header.rollupActionsLabel", {
      title
    }) : void 0,
    onActionRollup
  }) : isReactElement(secondaryActions) && (actionMenuMarkup = /* @__PURE__ */ import_react152.default.createElement(import_react152.default.Fragment, null, secondaryActions));
  let navigationMarkup = breadcrumbMarkup || paginationMarkup ? /* @__PURE__ */ import_react152.default.createElement(Box, {
    printHidden: !0,
    paddingBlockEnd: "100",
    paddingInlineEnd: actionMenuMarkup && isNavigationCollapsed ? "1000" : void 0
  }, /* @__PURE__ */ import_react152.default.createElement(InlineStack, {
    gap: "400",
    align: "space-between",
    blockAlign: "center"
  }, breadcrumbMarkup, paginationMarkup)) : null, additionalMetadataMarkup = additionalMetadata ? /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.AdditionalMetaData
  }, /* @__PURE__ */ import_react152.default.createElement(Text, {
    tone: "subdued",
    as: "span",
    variant: "bodySm"
  }, additionalMetadata)) : null, headerClassNames = classNames(isSingleRow && styles48.isSingleRow, navigationMarkup && styles48.hasNavigation, actionMenuMarkup && styles48.hasActionMenu, isNavigationCollapsed && styles48.mobileView, !backAction && styles48.noBreadcrumbs, title && title.length < LONG_TITLE && styles48.mediumTitle, title && title.length > LONG_TITLE && styles48.longTitle), {
    slot1,
    slot2,
    slot3,
    slot4,
    slot5
  } = determineLayout({
    actionMenuMarkup,
    additionalMetadataMarkup,
    breadcrumbMarkup,
    isNavigationCollapsed,
    pageTitleMarkup,
    paginationMarkup,
    primaryActionMarkup,
    title
  });
  return /* @__PURE__ */ import_react152.default.createElement(Box, {
    position: "relative",
    paddingBlockStart: {
      xs: "400",
      md: "600"
    },
    paddingBlockEnd: {
      xs: "400",
      md: "600"
    },
    paddingInlineStart: {
      xs: "400",
      sm: "0"
    },
    paddingInlineEnd: {
      xs: "400",
      sm: "0"
    },
    visuallyHidden: titleHidden
  }, pageReadyAccessibilityLabelMarkup, /* @__PURE__ */ import_react152.default.createElement("div", {
    className: headerClassNames
  }, /* @__PURE__ */ import_react152.default.createElement(FilterActionsProvider, {
    filterActions: Boolean(filterActions)
  }, /* @__PURE__ */ import_react152.default.createElement(ConditionalRender, {
    condition: [slot1, slot2, slot3, slot4].some(notNull)
  }, /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.Row
  }, slot1, slot2, /* @__PURE__ */ import_react152.default.createElement(ConditionalRender, {
    condition: [slot3, slot4].some(notNull)
  }, /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.RightAlign
  }, /* @__PURE__ */ import_react152.default.createElement(ConditionalWrapper, {
    condition: [slot3, slot4].every(notNull),
    wrapper: (children) => /* @__PURE__ */ import_react152.default.createElement("div", {
      className: styles48.Actions
    }, children)
  }, slot3, slot4))))), /* @__PURE__ */ import_react152.default.createElement(ConditionalRender, {
    condition: [slot5].some(notNull)
  }, /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.Row
  }, /* @__PURE__ */ import_react152.default.createElement(InlineStack, {
    gap: "400"
  }, slot5))))));
}
function PrimaryActionMarkup({
  primaryAction
}) {
  let {
    isNavigationCollapsed
  } = useMediaQuery(), actionMarkup;
  if (isInterface(primaryAction)) {
    let {
      primary: isPrimary,
      helpText
    } = primaryAction, primary = isPrimary === void 0 ? !0 : isPrimary, content = buttonFrom(shouldShowIconOnly(isNavigationCollapsed, primaryAction), {
      variant: primary ? "primary" : void 0
    });
    actionMarkup = helpText ? /* @__PURE__ */ import_react152.default.createElement(Tooltip, {
      content: helpText
    }, content) : content;
  } else
    actionMarkup = primaryAction;
  return /* @__PURE__ */ import_react152.default.createElement("div", {
    className: styles48.PrimaryActionWrapper
  }, /* @__PURE__ */ import_react152.default.createElement(Box, {
    printHidden: !0
  }, actionMarkup));
}
function shouldShowIconOnly(isMobile, action8) {
  let {
    content,
    accessibilityLabel
  } = action8, {
    icon
  } = action8;
  return icon == null ? {
    ...action8,
    icon: void 0
  } : (isMobile && (accessibilityLabel = accessibilityLabel || content, content = void 0), {
    ...action8,
    content,
    accessibilityLabel,
    icon
  });
}
function notNull(value) {
  return value != null;
}
function determineLayout({
  actionMenuMarkup,
  additionalMetadataMarkup,
  breadcrumbMarkup,
  isNavigationCollapsed,
  pageTitleMarkup,
  paginationMarkup,
  primaryActionMarkup,
  title
}) {
  let layouts = {
    mobileCompact: {
      slots: {
        slot1: null,
        slot2: pageTitleMarkup,
        slot3: actionMenuMarkup,
        slot4: primaryActionMarkup,
        slot5: additionalMetadataMarkup
      },
      condition: isNavigationCollapsed && breadcrumbMarkup == null && title != null && title.length <= REALLY_SHORT_TITLE
    },
    mobileDefault: {
      slots: {
        slot1: breadcrumbMarkup,
        slot2: pageTitleMarkup,
        slot3: actionMenuMarkup,
        slot4: primaryActionMarkup,
        slot5: additionalMetadataMarkup
      },
      condition: isNavigationCollapsed
    },
    desktopCompact: {
      slots: {
        slot1: breadcrumbMarkup,
        slot2: pageTitleMarkup,
        slot3: actionMenuMarkup,
        slot4: primaryActionMarkup,
        slot5: additionalMetadataMarkup
      },
      condition: !isNavigationCollapsed && paginationMarkup == null && actionMenuMarkup == null && title != null && title.length <= SHORT_TITLE
    },
    desktopDefault: {
      slots: {
        slot1: breadcrumbMarkup,
        slot2: pageTitleMarkup,
        slot3: /* @__PURE__ */ import_react152.default.createElement(import_react152.default.Fragment, null, actionMenuMarkup, primaryActionMarkup),
        slot4: paginationMarkup,
        slot5: additionalMetadataMarkup
      },
      condition: !isNavigationCollapsed
    }
  };
  return (Object.values(layouts).find((layout2) => layout2.condition) || layouts.desktopDefault).slots;
}

// node_modules/@shopify/polaris/build/esm/components/Page/Page.js
function Page({
  children,
  fullWidth,
  narrowWidth,
  ...rest
}) {
  let pageClassName = classNames(styles47.Page, fullWidth && styles47.fullWidth, narrowWidth && styles47.narrowWidth), hasHeaderContent = rest.title != null && rest.title !== "" || rest.subtitle != null && rest.subtitle !== "" || rest.primaryAction != null || rest.secondaryActions != null && (isInterface(rest.secondaryActions) && rest.secondaryActions.length > 0 || isReactElement(rest.secondaryActions)) || rest.actionGroups != null && rest.actionGroups.length > 0 || rest.backAction != null, contentClassName = classNames(!hasHeaderContent && styles47.Content), headerMarkup = hasHeaderContent ? /* @__PURE__ */ import_react153.default.createElement(Header2, Object.assign({
    filterActions: !0
  }, rest)) : null;
  return /* @__PURE__ */ import_react153.default.createElement("div", {
    className: pageClassName
  }, headerMarkup, /* @__PURE__ */ import_react153.default.createElement("div", {
    className: contentClassName
  }, children));
}

// node_modules/@shopify/polaris/build/esm/components/ProgressBar/ProgressBar.js
var import_react154 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/ProgressBar/ProgressBar.css.js
var styles50 = {
  ProgressBar: "Polaris-ProgressBar",
  sizeSmall: "Polaris-ProgressBar--sizeSmall",
  sizeMedium: "Polaris-ProgressBar--sizeMedium",
  sizeLarge: "Polaris-ProgressBar--sizeLarge",
  toneHighlight: "Polaris-ProgressBar--toneHighlight",
  tonePrimary: "Polaris-ProgressBar--tonePrimary",
  toneSuccess: "Polaris-ProgressBar--toneSuccess",
  toneCritical: "Polaris-ProgressBar--toneCritical",
  Indicator: "Polaris-ProgressBar__Indicator",
  IndicatorAppearActive: "Polaris-ProgressBar__IndicatorAppearActive",
  IndicatorAppearDone: "Polaris-ProgressBar__IndicatorAppearDone",
  Progress: "Polaris-ProgressBar__Progress",
  Label: "Polaris-ProgressBar__Label"
};

// node_modules/@shopify/polaris/build/esm/components/ProgressBar/ProgressBar.js
function ProgressBar({
  progress = 0,
  size: size2 = "medium",
  tone = "highlight",
  animated: hasAppearAnimation = !0,
  ariaLabelledBy
}) {
  let theme = useTheme(), i18n = useI18n(), indicatorRef = (0, import_react154.useRef)(null), className = classNames(styles50.ProgressBar, size2 && styles50[variationName("size", size2)], tone && styles50[variationName("tone", tone)]), warningMessage = i18n.translate(progress < 0 ? "Polaris.ProgressBar.negativeWarningMessage" : "Polaris.ProgressBar.exceedWarningMessage", {
    progress
  }), parsedProgress = parseProgress(progress, warningMessage), progressBarDuration = hasAppearAnimation ? theme.motion["motion-duration-500"] : theme.motion["motion-duration-0"];
  return /* @__PURE__ */ import_react154.default.createElement("div", {
    className
  }, /* @__PURE__ */ import_react154.default.createElement("progress", {
    "aria-labelledby": ariaLabelledBy,
    className: styles50.Progress,
    value: parsedProgress,
    max: "100"
  }), /* @__PURE__ */ import_react154.default.createElement(CSSTransition_default, {
    in: !0,
    appear: !0,
    timeout: parseInt(progressBarDuration, 10),
    nodeRef: indicatorRef,
    classNames: {
      appearActive: styles50.IndicatorAppearActive,
      appearDone: styles50.IndicatorAppearDone
    }
  }, /* @__PURE__ */ import_react154.default.createElement("div", {
    ref: indicatorRef,
    className: styles50.Indicator,
    style: {
      "--pc-progress-bar-duration": progressBarDuration,
      "--pc-progress-bar-percent": parsedProgress / 100
    }
  }, /* @__PURE__ */ import_react154.default.createElement("span", {
    className: styles50.Label
  }, parsedProgress, "%"))));
}
function parseProgress(progress, warningMessage) {
  let progressWidth;
  return progress < 0 ? progressWidth = 0 : progress > 100 ? progressWidth = 100 : progressWidth = progress, progressWidth;
}

// node_modules/@shopify/polaris/build/esm/components/Select/Select.js
var import_react155 = __toESM(require_react());

// node_modules/@shopify/polaris/build/esm/components/Select/Select.css.js
var styles51 = {
  Select: "Polaris-Select",
  disabled: "Polaris-Select--disabled",
  error: "Polaris-Select--error",
  Backdrop: "Polaris-Select__Backdrop",
  Input: "Polaris-Select__Input",
  Content: "Polaris-Select__Content",
  InlineLabel: "Polaris-Select__InlineLabel",
  Icon: "Polaris-Select__Icon",
  SelectedOption: "Polaris-Select__SelectedOption",
  Prefix: "Polaris-Select__Prefix",
  hover: "Polaris-Select--hover",
  toneMagic: "Polaris-Select--toneMagic"
};

// node_modules/@shopify/polaris/build/esm/components/Select/Select.js
var PLACEHOLDER_VALUE = "";
function Select({
  options: optionsProp,
  label,
  labelAction,
  labelHidden: labelHiddenProp,
  labelInline,
  disabled,
  helpText,
  placeholder,
  id: idProp,
  name,
  value = PLACEHOLDER_VALUE,
  error,
  onChange,
  onFocus,
  onBlur,
  requiredIndicator,
  tone
}) {
  let {
    value: focused,
    toggle: toggleFocused
  } = useToggle(!1), uniqId = (0, import_react155.useId)(), id = idProp ?? uniqId, labelHidden = labelInline ? !0 : labelHiddenProp, className = classNames(styles51.Select, error && styles51.error, tone && styles51[variationName("tone", tone)], disabled && styles51.disabled), handleFocus = (0, import_react155.useCallback)((event) => {
    toggleFocused(), onFocus?.(event);
  }, [onFocus, toggleFocused]), handleBlur = (0, import_react155.useCallback)((event) => {
    toggleFocused(), onBlur?.(event);
  }, [onBlur, toggleFocused]), handleChange = onChange ? (event) => onChange(event.currentTarget.value, id) : void 0, describedBy = [];
  helpText && describedBy.push(helpTextID(id)), error && describedBy.push(`${id}Error`);
  let normalizedOptions = (optionsProp || []).map(normalizeOption);
  placeholder && (normalizedOptions = [{
    label: placeholder,
    value: PLACEHOLDER_VALUE,
    disabled: !0
  }, ...normalizedOptions]);
  let inlineLabelMarkup = labelInline && /* @__PURE__ */ import_react155.default.createElement(Box, {
    paddingInlineEnd: "100"
  }, /* @__PURE__ */ import_react155.default.createElement(Text, {
    as: "span",
    variant: "bodyMd",
    tone: tone && tone === "magic" && !focused ? "magic-subdued" : "subdued",
    truncate: !0
  }, label)), selectedOption = getSelectedOption(normalizedOptions, value), prefixMarkup = selectedOption.prefix && /* @__PURE__ */ import_react155.default.createElement("div", {
    className: styles51.Prefix
  }, selectedOption.prefix), contentMarkup = /* @__PURE__ */ import_react155.default.createElement("div", {
    className: styles51.Content,
    "aria-hidden": !0,
    "aria-disabled": disabled
  }, inlineLabelMarkup, prefixMarkup, /* @__PURE__ */ import_react155.default.createElement("span", {
    className: styles51.SelectedOption
  }, selectedOption.label), /* @__PURE__ */ import_react155.default.createElement("span", {
    className: styles51.Icon
  }, /* @__PURE__ */ import_react155.default.createElement(Icon, {
    source: SvgSelectIcon
  }))), optionsMarkup = normalizedOptions.map(renderOption);
  return /* @__PURE__ */ import_react155.default.createElement(Labelled, {
    id,
    label,
    error,
    action: labelAction,
    labelHidden,
    helpText,
    requiredIndicator,
    disabled
  }, /* @__PURE__ */ import_react155.default.createElement("div", {
    className
  }, /* @__PURE__ */ import_react155.default.createElement("select", {
    id,
    name,
    value,
    className: styles51.Input,
    disabled,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onChange: handleChange,
    "aria-invalid": Boolean(error),
    "aria-describedby": describedBy.length ? describedBy.join(" ") : void 0,
    "aria-required": requiredIndicator
  }, optionsMarkup), contentMarkup, /* @__PURE__ */ import_react155.default.createElement("div", {
    className: styles51.Backdrop
  })));
}
function isString(option) {
  return typeof option == "string";
}
function isGroup(option) {
  return typeof option == "object" && "options" in option && option.options != null;
}
function normalizeStringOption(option) {
  return {
    label: option,
    value: option
  };
}
function normalizeOption(option) {
  if (isString(option))
    return normalizeStringOption(option);
  if (isGroup(option)) {
    let {
      title,
      options
    } = option;
    return {
      title,
      options: options.map((option2) => isString(option2) ? normalizeStringOption(option2) : option2)
    };
  }
  return option;
}
function getSelectedOption(options, value) {
  let flatOptions = flattenOptions(options), selectedOption = flatOptions.find((option) => value === option.value);
  return selectedOption === void 0 && (selectedOption = flatOptions.find((option) => !option.hidden)), selectedOption || {
    value: "",
    label: ""
  };
}
function flattenOptions(options) {
  let flatOptions = [];
  return options.forEach((optionOrGroup) => {
    isGroup(optionOrGroup) ? flatOptions = flatOptions.concat(optionOrGroup.options) : flatOptions.push(optionOrGroup);
  }), flatOptions;
}
function renderSingleOption(option) {
  let {
    value,
    label,
    prefix: _prefix,
    key,
    ...rest
  } = option;
  return /* @__PURE__ */ import_react155.default.createElement("option", Object.assign({
    key: key ?? value,
    value
  }, rest), label);
}
function renderOption(optionOrGroup) {
  if (isGroup(optionOrGroup)) {
    let {
      title,
      options
    } = optionOrGroup;
    return /* @__PURE__ */ import_react155.default.createElement("optgroup", {
      label: title,
      key: title
    }, options.map(renderSingleOption));
  }
  return renderSingleOption(optionOrGroup);
}

// node_modules/@shopify/polaris/build/esm/components/Toast/Toast.js
var import_react156 = __toESM(require_react());
var Toast2 = /* @__PURE__ */ (0, import_react156.memo)(function(props) {
  let id = (0, import_react156.useId)(), {
    showToast,
    hideToast
  } = useFrame();
  return useDeepEffect(() => (showToast({
    id,
    ...props
  }), () => {
    hideToast({
      id
    });
  }), [props]), null;
});

// app/root.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1), meta = () => [
  { title: "CatalogAI Optimizer" },
  { name: "description", content: "AI-powered Shopify catalog optimization" }
], links = () => [
  { rel: "stylesheet", href: "https://unpkg.com/@shopify/polaris@12.27.0/build/esm/styles.css" }
];
function App() {
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1" }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Meta, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Links, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(AppProvider, { i18n: {}, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Frame, { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Outlet, {}) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ScrollRestoration2, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Scripts, {}),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(LiveReload, {})
    ] })
  ] });
}

// app/routes/api.test-health-check.ts
var api_test_health_check_exports = {};
__export(api_test_health_check_exports, {
  loader: () => loader
});
var import_node2 = __toESM(require_dist(), 1);
init_shopify_server();
init_db();

// app/utils/healthCheckTest.ts
init_db();
var HealthCheckTester = class {
  testResults = [];
  async runAllTests(userId, shopDomain, accessToken) {
    return this.testResults = [], console.log("\u{1F9EA} Starting health check system tests..."), await this.testHealthCheckerInitialization(shopDomain, accessToken), await this.testProductValidation(), await this.testUrlPings(), await this.testInventoryValidation(), await this.testHealthScoreCalculation(), await this.testDatabaseOperations(userId), await this.testQueueOperations(userId, shopDomain), await this.testErrorHandling(shopDomain, accessToken), await this.testPerformanceLargeDataset(), await this.testEdgeCases(), console.log(`\u2705 Health check tests completed: ${this.testResults.filter((r) => r.passed).length}/${this.testResults.length} passed`), this.testResults;
  }
  async testHealthCheckerInitialization(shopDomain, accessToken) {
    let startTime = Date.now();
    try {
      if (!new HealthCheckerService(shopDomain, accessToken))
        throw new Error("Failed to initialize HealthCheckerService");
      this.testResults.push({
        testName: "Health Checker Initialization",
        passed: !0,
        duration: Date.now() - startTime,
        details: { shopDomain, hasAccessToken: !!accessToken }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Health Checker Initialization",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testProductValidation() {
    let startTime = Date.now();
    try {
      let mockProducts = [
        {
          id: "test-1",
          title: "Valid Product",
          description: "This is a valid product description",
          vendor: "Test Vendor",
          productType: "Test Type",
          tags: ["tag1", "tag2"],
          images: [{ src: "image1.jpg" }],
          variants: [{ id: "v1", title: "Variant 1" }],
          options: [{ name: "Size", values: ["S", "M", "L"] }],
          status: "active"
        },
        {
          id: "test-2",
          title: "",
          // Missing title
          description: "Valid description",
          vendor: "Test Vendor",
          productType: "Test Type",
          tags: [],
          images: [],
          variants: [],
          options: [],
          status: "active"
        },
        {
          id: "test-3",
          title: "Valid Product",
          description: "",
          // Missing description
          vendor: "",
          productType: "Test Type",
          tags: ["tag1"],
          images: [{ src: "image1.jpg" }],
          variants: [{ id: "v1", title: "Variant 1" }],
          options: [{ name: "Size", values: ["S", "M", "L"] }],
          status: "active"
        }
      ], requiredFields = ["title", "description", "vendor", "productType", "tags", "images", "variants", "options", "status"], validCount = 0, gaps = [];
      for (let product of mockProducts) {
        let isValid = !0;
        for (let field of requiredFields)
          (!product[field] || Array.isArray(product[field]) && product[field].length === 0 || typeof product[field] == "string" && product[field].trim() === "") && (gaps.push({ field, productId: product.id }), isValid = !1);
        isValid && validCount++;
      }
      let expectedValidCount = 1, expectedGapsCount = 4;
      if (validCount !== expectedValidCount)
        throw new Error(`Expected ${expectedValidCount} valid products, got ${validCount}`);
      if (gaps.length !== expectedGapsCount)
        throw new Error(`Expected ${expectedGapsCount} gaps, got ${gaps.length}`);
      this.testResults.push({
        testName: "Product Validation",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalProducts: mockProducts.length,
          validProducts: validCount,
          gapsFound: gaps.length,
          gaps
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Product Validation",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testUrlPings() {
    let startTime = Date.now();
    try {
      let testUrls = [
        "https://httpbin.org/status/200",
        // Should succeed
        "https://httpbin.org/status/404",
        // Should fail with 404
        "https://invalid-domain-that-does-not-exist.com",
        // Should fail
        "https://httpbin.org/delay/10"
        // Should timeout
      ], results = [];
      for (let url of testUrls)
        try {
          let response = await fetch(url, {
            method: "HEAD",
            signal: AbortSignal.timeout(5e3)
          });
          results.push({ url, success: response.ok, status: response.status });
        } catch (error) {
          results.push({ url, success: !1, error: error instanceof Error ? error.message : "Unknown error" });
        }
      let successCount = results.filter((r) => r.success).length, expectedSuccessCount = 1;
      if (successCount !== expectedSuccessCount)
        throw new Error(`Expected ${expectedSuccessCount} successful pings, got ${successCount}`);
      this.testResults.push({
        testName: "URL Pings",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalUrls: testUrls.length,
          successfulPings: successCount,
          results
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "URL Pings",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testInventoryValidation() {
    let startTime = Date.now();
    try {
      let mockVariants = [
        { id: "v1", inventoryQuantity: 10 },
        // Normal stock
        { id: "v2", inventoryQuantity: 3 },
        // Low stock
        { id: "v3", inventoryQuantity: 0 },
        // Out of stock
        { id: "v4", inventoryQuantity: 1 },
        // Low stock
        { id: "v5", inventoryQuantity: 15 }
        // Normal stock
      ], lowStock = [], outOfStock = [];
      for (let variant of mockVariants)
        variant.inventoryQuantity === 0 ? outOfStock.push(variant.id) : variant.inventoryQuantity < 5 && lowStock.push(variant.id);
      let expectedLowStock = 2, expectedOutOfStock = 1;
      if (lowStock.length !== expectedLowStock)
        throw new Error(`Expected ${expectedLowStock} low stock variants, got ${lowStock.length}`);
      if (outOfStock.length !== expectedOutOfStock)
        throw new Error(`Expected ${expectedOutOfStock} out of stock variants, got ${outOfStock.length}`);
      this.testResults.push({
        testName: "Inventory Validation",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalVariants: mockVariants.length,
          lowStock: lowStock.length,
          outOfStock: outOfStock.length,
          lowStockVariants: lowStock,
          outOfStockVariants: outOfStock
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Inventory Validation",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testHealthScoreCalculation() {
    let startTime = Date.now();
    try {
      let testCases = [
        { totalProducts: 100, validProducts: 100, gaps: [], expectedScore: 100 },
        { totalProducts: 100, validProducts: 90, gaps: [], expectedScore: 90 },
        { totalProducts: 100, validProducts: 80, gaps: [{ severity: "warning", count: 10 }], expectedScore: 70 },
        { totalProducts: 100, validProducts: 70, gaps: [{ severity: "error", count: 20 }], expectedScore: 10 },
        { totalProducts: 0, validProducts: 0, gaps: [], expectedScore: 100 }
      ], results = [];
      for (let testCase of testCases) {
        let score = testCase.totalProducts === 0 ? 100 : testCase.validProducts / testCase.totalProducts * 100;
        for (let gap of testCase.gaps) {
          let penalty = gap.severity === "critical" ? 5 : gap.severity === "error" ? 3 : 1;
          score -= Math.min(penalty * (gap.count / testCase.totalProducts), 10);
        }
        score = Math.max(0, Math.round(score));
        let passed = score === testCase.expectedScore;
        results.push({ ...testCase, calculatedScore: score, passed });
      }
      let failedTests = results.filter((r) => !r.passed);
      if (failedTests.length > 0)
        throw new Error(`${failedTests.length} health score calculations failed`);
      this.testResults.push({
        testName: "Health Score Calculation",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalTestCases: testCases.length,
          allPassed: !0,
          results
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Health Score Calculation",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testDatabaseOperations(userId) {
    let startTime = Date.now();
    try {
      let testAudit = await db.audit.create({
        data: {
          userId,
          score: 85,
          totalProducts: 100,
          validProducts: 85,
          gaps: [{ field: "title", severity: "warning", count: 15 }],
          timestamp: /* @__PURE__ */ new Date()
        }
      });
      if (!testAudit.id)
        throw new Error("Failed to create audit record");
      if (!await db.audit.findUnique({
        where: { id: testAudit.id }
      }))
        throw new Error("Failed to retrieve audit record");
      await db.audit.delete({
        where: { id: testAudit.id }
      }), this.testResults.push({
        testName: "Database Operations",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          auditId: testAudit.id,
          score: testAudit.score,
          totalProducts: testAudit.totalProducts
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Database Operations",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testQueueOperations(userId, shopDomain) {
    let startTime = Date.now();
    try {
      if (!healthCheckQueue)
        throw new Error("Health check queue not available");
      let testJob = await healthCheckQueue.add("health-scan", {
        shopId: shopDomain,
        userId,
        options: {
          maxProducts: 10,
          includePings: !1,
          includeInventory: !1,
          includeValidation: !0
        }
      });
      if (!testJob.id)
        throw new Error("Failed to create queue job");
      this.testResults.push({
        testName: "Queue Operations",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          jobId: testJob.id,
          jobName: testJob.name,
          jobData: testJob.data
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Queue Operations",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testErrorHandling(shopDomain, accessToken) {
    let startTime = Date.now();
    try {
      let healthChecker = new HealthCheckerService(shopDomain, accessToken);
      try {
        await healthChecker.performHealthCheck({
          maxProducts: -1,
          // Invalid value
          includePings: !0,
          includeInventory: !0,
          includeValidation: !0
        });
      } catch {
      }
      try {
        await new HealthCheckerService("", accessToken).performHealthCheck();
      } catch {
      }
      try {
        await new HealthCheckerService(shopDomain, "").performHealthCheck();
      } catch {
      }
      this.testResults.push({
        testName: "Error Handling",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          errorHandlingTests: 3,
          allErrorsHandled: !0
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Error Handling",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testPerformanceLargeDataset() {
    let startTime = Date.now();
    try {
      let largeProductSet = Array.from({ length: 1e3 }, (_, i) => ({
        id: `product-${i}`,
        title: i % 10 === 0 ? "" : `Product ${i}`,
        // 10% missing titles
        description: i % 20 === 0 ? "" : `Description for product ${i}`,
        // 5% missing descriptions
        vendor: i % 15 === 0 ? "" : "Test Vendor",
        // ~6.7% missing vendors
        productType: "Test Type",
        tags: i % 25 === 0 ? [] : ["tag1", "tag2"],
        // 4% missing tags
        images: i % 30 === 0 ? [] : [{ src: `image-${i}.jpg` }],
        // ~3.3% missing images
        variants: i % 40 === 0 ? [] : [{ id: `v-${i}`, title: `Variant ${i}` }],
        // 2.5% missing variants
        options: i % 50 === 0 ? [] : [{ name: "Size", values: ["S", "M", "L"] }],
        // 2% missing options
        status: "active"
      })), requiredFields = ["title", "description", "vendor", "productType", "tags", "images", "variants", "options", "status"], validCount = 0, gaps = [];
      for (let product of largeProductSet) {
        let isValid = !0;
        for (let field of requiredFields)
          (!product[field] || Array.isArray(product[field]) && product[field].length === 0 || typeof product[field] == "string" && product[field].trim() === "") && (gaps.push({ field, productId: product.id }), isValid = !1);
        isValid && validCount++;
      }
      let processingTime = Date.now() - startTime, expectedValidCount = Math.floor(1e3 * 0.7), tolerance = 50;
      if (Math.abs(validCount - expectedValidCount) > tolerance)
        throw new Error(`Performance test failed: expected ~${expectedValidCount} valid products, got ${validCount}`);
      if (processingTime > 5e3)
        throw new Error(`Performance test failed: processing took ${processingTime}ms, expected < 5000ms`);
      this.testResults.push({
        testName: "Performance Large Dataset",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalProducts: largeProductSet.length,
          validProducts: validCount,
          gapsFound: gaps.length,
          processingTime,
          productsPerSecond: Math.round(largeProductSet.length / (processingTime / 1e3))
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Performance Large Dataset",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  async testEdgeCases() {
    let startTime = Date.now();
    try {
      let edgeCases = [
        // Empty product
        {
          id: "empty",
          title: "",
          description: "",
          vendor: "",
          productType: "",
          tags: [],
          images: [],
          variants: [],
          options: [],
          status: ""
        },
        // Product with only spaces
        {
          id: "spaces",
          title: "   ",
          description: "   ",
          vendor: "   ",
          productType: "Test Type",
          tags: [],
          images: [],
          variants: [],
          options: [],
          status: "active"
        },
        // Product with null/undefined values
        {
          id: "nulls",
          title: null,
          description: void 0,
          vendor: "Test Vendor",
          productType: "Test Type",
          tags: null,
          images: void 0,
          variants: [],
          options: [],
          status: "active"
        }
      ], results = [];
      for (let product of edgeCases) {
        let isValid = !0, gaps = [], requiredFields = ["title", "description", "vendor", "productType", "tags", "images", "variants", "options", "status"];
        for (let field of requiredFields) {
          let value = product[field];
          (!value || Array.isArray(value) && value.length === 0 || typeof value == "string" && value.trim() === "") && (gaps.push(field), isValid = !1);
        }
        results.push({ productId: product.id, isValid, gaps });
      }
      let validCount = results.filter((r) => r.isValid).length;
      if (validCount > 0)
        throw new Error(`Expected all edge cases to be invalid, but ${validCount} were valid`);
      this.testResults.push({
        testName: "Edge Cases",
        passed: !0,
        duration: Date.now() - startTime,
        details: {
          totalEdgeCases: edgeCases.length,
          allInvalid: !0,
          results
        }
      });
    } catch (error) {
      this.testResults.push({
        testName: "Edge Cases",
        passed: !1,
        error: error instanceof Error ? error.message : "Unknown error",
        duration: Date.now() - startTime
      });
    }
  }
  getTestSummary() {
    let total = this.testResults.length, passed = this.testResults.filter((r) => r.passed).length, failed = total - passed, duration = this.testResults.reduce((sum, r) => sum + r.duration, 0);
    return { total, passed, failed, duration };
  }
}, healthCheckTester = new HealthCheckTester();

// app/routes/api.test-health-check.ts
var loader = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2), user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    if (!user)
      return (0, import_node2.json)({
        success: !1,
        error: "User not found"
      }, { status: 404 });
    let testResults = await healthCheckTester.runAllTests(
      user.id,
      session.shop,
      user.accessToken
    ), summary = healthCheckTester.getTestSummary();
    return await db.log.create({
      data: {
        userId: user.id,
        type: "health_check_test",
        message: `Health check tests completed: ${summary.passed}/${summary.total} passed`,
        metadata: {
          totalTests: summary.total,
          passedTests: summary.passed,
          failedTests: summary.failed,
          duration: summary.duration,
          results: testResults
        }
      }
    }), (0, import_node2.json)({
      success: !0,
      summary,
      results: testResults,
      message: `Health check tests completed: ${summary.passed}/${summary.total} passed`
    });
  } catch (error) {
    return console.error("Health check test error:", error), (0, import_node2.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to run health check tests"
    }, { status: 500 });
  }
};

// app/routes/api.health-check.ts
var api_health_check_exports = {};
__export(api_health_check_exports, {
  action: () => action,
  loader: () => loader2
});
var import_node3 = __toESM(require_dist(), 1);
init_shopify_server();
init_db();
var loader2 = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2);
    if (console.log("Health check API called", {
      redisHost: process.env.REDIS_HOST,
      redisPort: process.env.REDIS_PORT,
      hasRedisPassword: !!process.env.REDIS_PASSWORD,
      healthCheckQueueExists: !!healthCheckQueue,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }), !healthCheckQueue)
      return console.error("Health check queue is null - Redis connection failed"), (0, import_node3.json)({
        success: !1,
        error: "Health check system not available - Redis connection failed"
      }, { status: 503 });
    let user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    if (!user)
      return (0, import_node3.json)({
        success: !1,
        error: "User not found"
      }, { status: 404 });
    let healthScanJob = await healthCheckQueue.add("health-scan", {
      shopId: session.shop,
      userId: user.id,
      options: {
        maxProducts: 100,
        includePings: !0,
        includeInventory: !0,
        includeValidation: !0
      }
    }), latestAudit = await db.audit.findFirst({
      where: { userId: user.id },
      orderBy: { timestamp: "desc" }
    });
    return (0, import_node3.json)({
      success: !0,
      jobId: healthScanJob.id,
      currentScore: latestAudit?.score || 0,
      currentGaps: latestAudit?.gaps || [],
      message: "Health scan initiated"
    });
  } catch (error) {
    return console.error("Health check API error:", error), (0, import_node3.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to initiate health checks"
    }, { status: 500 });
  }
}, action = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2), formData = await request2.formData(), action8 = formData.get("action");
    if (action8 === "trigger-scan") {
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node3.json)({
          success: !1,
          error: "User not found"
        }, { status: 404 });
      if (!healthCheckQueue)
        return console.error("Health check queue is null - Redis connection failed"), (0, import_node3.json)({
          success: !1,
          error: "Health check system not available - Redis connection failed"
        }, { status: 503 });
      let healthScanJob = await healthCheckQueue.add("health-scan", {
        shopId: session.shop,
        userId: user.id,
        options: {
          maxProducts: 100,
          includePings: !0,
          includeInventory: !0,
          includeValidation: !0
        }
      }), latestAudit = await db.audit.findFirst({
        where: { userId: user.id },
        orderBy: { timestamp: "desc" }
      });
      return (0, import_node3.json)({
        success: !0,
        jobId: healthScanJob.id,
        currentScore: latestAudit?.score || 0,
        currentGaps: latestAudit?.gaps || [],
        message: "Health scan initiated"
      });
    }
    if (action8 === "get-results") {
      if (!formData.get("jobId"))
        return (0, import_node3.json)({
          success: !1,
          error: "Job ID is required"
        }, { status: 400 });
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node3.json)({
          success: !1,
          error: "User not found"
        }, { status: 404 });
      let latestAudit = await db.audit.findFirst({
        where: { userId: user.id },
        orderBy: { timestamp: "desc" }
      }), sevenDaysAgo = /* @__PURE__ */ new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      let trends = await db.audit.findMany({
        where: {
          userId: user.id,
          timestamp: {
            gte: sevenDaysAgo
          }
        },
        orderBy: {
          timestamp: "asc"
        }
      });
      return (0, import_node3.json)({
        success: !0,
        result: latestAudit ? {
          score: latestAudit.score,
          totalProducts: latestAudit.totalProducts,
          validProducts: latestAudit.validProducts,
          gaps: latestAudit.gaps,
          timestamp: latestAudit.timestamp,
          trends: trends.map((t) => ({
            date: t.timestamp.toISOString().split("T")[0],
            score: t.score,
            totalProducts: t.totalProducts,
            validProducts: t.validProducts
          }))
        } : null
      });
    }
    if (action8 === "auto-fix") {
      let gapTypes = formData.get("gapTypes");
      if (!gapTypes)
        return (0, import_node3.json)({
          success: !1,
          error: "Gap types are required"
        }, { status: 400 });
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node3.json)({
          success: !1,
          error: "User not found"
        }, { status: 404 });
      let aiEnrichmentJob = await backgroundJobsQueue?.add("ai-enrichment", {
        shopId: session.shop,
        userId: user.id,
        productIds: [],
        // Will be determined by gap types
        gapTypes: JSON.parse(gapTypes)
      });
      return (0, import_node3.json)({
        success: !0,
        jobId: aiEnrichmentJob?.id,
        message: "Auto-fix initiated"
      });
    }
    return (0, import_node3.json)({
      success: !1,
      error: "Invalid action"
    }, { status: 400 });
  } catch (error) {
    return console.error("Health check action error:", error), (0, import_node3.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to process action"
    }, { status: 500 });
  }
};

// app/routes/api.queue-status.ts
var api_queue_status_exports = {};
__export(api_queue_status_exports, {
  loader: () => loader3
});
var import_node4 = __toESM(require_dist(), 1);
init_shopify_server();
var loader3 = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2);
    if (!healthCheckQueue || !backgroundJobsQueue)
      return (0, import_node4.json)({
        success: !1,
        error: "Queue system not available - Redis not configured"
      }, { status: 503 });
    let healthCheckStats = await healthCheckQueue.getJobCounts(), backgroundJobsStats = await backgroundJobsQueue.getJobCounts(), recentHealthChecks = await healthCheckQueue.getJobs(["completed"], 0, 5), recentBackgroundJobs = await backgroundJobsQueue.getJobs(["completed"], 0, 5);
    return (0, import_node4.json)({
      success: !0,
      queues: {
        healthChecks: {
          ...healthCheckStats,
          recentJobs: recentHealthChecks.map((job) => ({
            id: job.id,
            name: job.name,
            data: job.data,
            result: job.returnvalue,
            completedOn: job.finishedOn
          }))
        },
        backgroundJobs: {
          ...backgroundJobsStats,
          recentJobs: recentBackgroundJobs.map((job) => ({
            id: job.id,
            name: job.name,
            data: job.data,
            result: job.returnvalue,
            completedOn: job.finishedOn
          }))
        }
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    return (0, import_node4.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to get queue status"
    }, { status: 500 });
  }
};

// app/routes/api.settings.ts
var api_settings_exports = {};
__export(api_settings_exports, {
  action: () => action2,
  loader: () => loader4
});
var import_node5 = __toESM(require_dist(), 1);
init_shopify_server();
init_db();
var loader4 = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2), user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    return user ? (0, import_node5.json)({
      success: !0,
      settings: {
        healthChecksEnabled: !0,
        healthCheckTime: "02:00",
        // 2 AM UTC
        autoFixEnabled: !0,
        emailNotifications: !0,
        maxProductsPerScan: user.tier === "enterprise" ? 500 : 100,
        includeUrlPings: !0,
        includeInventoryChecks: !0,
        includeValidation: !0
      }
    }) : (0, import_node5.json)({
      success: !1,
      error: "User not found"
    }, { status: 404 });
  } catch (error) {
    return console.error("Settings API error:", error), (0, import_node5.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to fetch settings"
    }, { status: 500 });
  }
}, action2 = async ({ request: request2 }) => {
  try {
    let { session } = await authenticate.admin(request2), formData = await request2.formData(), action8 = formData.get("action"), user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    if (!user)
      return (0, import_node5.json)({
        success: !1,
        error: "User not found"
      }, { status: 404 });
    if (action8 === "update") {
      let healthChecksEnabled = formData.get("healthChecksEnabled") === "true", healthCheckTime = formData.get("healthCheckTime"), autoFixEnabled = formData.get("autoFixEnabled") === "true", emailNotifications = formData.get("emailNotifications") === "true", maxProductsPerScan = parseInt(formData.get("maxProductsPerScan")) || 100, includeUrlPings = formData.get("includeUrlPings") === "true", includeInventoryChecks = formData.get("includeInventoryChecks") === "true", includeValidation = formData.get("includeValidation") === "true";
      return await db.log.create({
        data: {
          userId: user.id,
          type: "settings_update",
          message: `Settings updated: health checks ${healthChecksEnabled ? "enabled" : "disabled"}, auto-fix ${autoFixEnabled ? "enabled" : "disabled"}`,
          metadata: {
            healthChecksEnabled,
            healthCheckTime,
            autoFixEnabled,
            emailNotifications,
            maxProductsPerScan,
            includeUrlPings,
            includeInventoryChecks,
            includeValidation
          }
        }
      }), (0, import_node5.json)({
        success: !0,
        message: "Settings updated successfully"
      });
    }
    return (0, import_node5.json)({
      success: !1,
      error: "Invalid action"
    }, { status: 400 });
  } catch (error) {
    return console.error("Settings action error:", error), (0, import_node5.json)({
      success: !1,
      error: error instanceof Error ? error.message : "Failed to update settings"
    }, { status: 500 });
  }
};

// app/routes/api.validate.ts
var api_validate_exports = {};
__export(api_validate_exports, {
  action: () => action3
});
var import_node6 = __toESM(require_dist(), 1);
init_shopify_server();
init_shopifySync();
init_fieldMapper();

// app/utils/validator.ts
init_openaiSpec();
import Ajv2 from "ajv";
import addFormats2 from "ajv-formats";
import axios2 from "axios";
var ajv2 = new Ajv2({ allErrors: !0 });
addFormats2(ajv2);
var validate = ajv2.compile(OPENAI_PRODUCT_SCHEMA);
function validateProduct(product) {
  let errors = [], warnings = [];
  if (!validate(product) && validate.errors)
    for (let error of validate.errors)
      errors.push({
        field: error.instancePath ? error.instancePath.slice(1) : "root",
        message: error.message || "Validation error",
        value: error.data
      });
  return validateDescription(product, warnings), validatePrice(product, errors), validateImageUrls(product, warnings), validateLinks(product, warnings), {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function validateDescription(product, warnings) {
  if (!product.description)
    return;
  let desc = product.description;
  /<[^>]*>/g.test(desc) && warnings.push({
    field: "description",
    message: "Description contains HTML tags",
    suggestion: "Use plain text for better AI search compatibility"
  }), desc.length < 100 && warnings.push({
    field: "description",
    message: "Description is too short",
    suggestion: "Add more details about features, benefits, and use cases"
  }), desc.length > 4e3 && warnings.push({
    field: "description",
    message: "Description is too long",
    suggestion: "Consider shortening to under 4000 characters"
  });
  let genericPhrases = [
    "great product",
    "high quality",
    "perfect for",
    "amazing",
    "wonderful",
    "excellent"
  ], lowerDesc = desc.toLowerCase();
  genericPhrases.filter((phrase) => lowerDesc.includes(phrase)).length > 2 && warnings.push({
    field: "description",
    message: "Description contains too many generic phrases",
    suggestion: "Use more specific, descriptive language"
  });
}
function validatePrice(product, errors) {
  if (!product.price)
    return;
  /^\d+\.\d{2} [A-Z]{3}$/.test(product.price) || errors.push({
    field: "price",
    message: 'Price must be in format "XX.XX USD"',
    value: product.price
  });
}
async function validateImageUrls(product, warnings) {
  if (!(!product.image_urls || product.image_urls.length === 0))
    for (let [index, url] of product.image_urls.entries())
      try {
        let response = await axios2.head(url, { timeout: 5e3 });
        response.status !== 200 && warnings.push({
          field: `image_urls[${index}]`,
          message: `Image URL returned status ${response.status}`,
          suggestion: "Check if the image URL is accessible"
        });
        let contentType = response.headers["content-type"];
        contentType && !contentType.startsWith("image/") && warnings.push({
          field: `image_urls[${index}]`,
          message: "URL does not appear to be an image",
          suggestion: "Ensure the URL points to an image file"
        });
      } catch {
        warnings.push({
          field: `image_urls[${index}]`,
          message: "Failed to validate image URL",
          suggestion: "Check if the URL is accessible and points to an image"
        });
      }
}
async function validateLinks(product, warnings) {
  let linksToValidate = [];
  product.documentation_url && linksToValidate.push({ url: product.documentation_url, field: "documentation_url" }), product.video_urls && product.video_urls.forEach((url, index) => {
    linksToValidate.push({ url, field: `video_urls[${index}]` });
  });
  for (let { url, field } of linksToValidate)
    try {
      let response = await axios2.head(url, { timeout: 5e3 });
      response.status !== 200 && warnings.push({
        field,
        message: `Link returned status ${response.status}`,
        suggestion: "Check if the link is accessible"
      });
    } catch {
      warnings.push({
        field,
        message: "Failed to validate link",
        suggestion: "Check if the link is accessible"
      });
    }
}
async function validateProducts(products) {
  let results = [];
  for (let product of products) {
    let result = validateProduct(product);
    results.push(result);
  }
  return results;
}
function getValidationSummary(results) {
  let totalProducts = results.length, validProducts = results.filter((r) => r.valid).length, totalErrors = results.reduce((sum, r) => sum + r.errors.length, 0), totalWarnings = results.reduce((sum, r) => sum + r.warnings.length, 0), commonErrors = getCommonIssues(results.map((r) => r.errors).flat(), "error"), commonWarnings = getCommonIssues(results.map((r) => r.warnings).flat(), "warning");
  return {
    totalProducts,
    validProducts,
    invalidProducts: totalProducts - validProducts,
    totalErrors,
    totalWarnings,
    validationRate: totalProducts > 0 ? Math.round(validProducts / totalProducts * 100) : 0,
    commonErrors,
    commonWarnings
  };
}
function getCommonIssues(issues, type) {
  let fieldCounts = /* @__PURE__ */ new Map();
  for (let issue of issues) {
    let key = issue.field;
    fieldCounts.has(key) ? fieldCounts.get(key).count++ : fieldCounts.set(key, { count: 1, message: issue.message });
  }
  return Array.from(fieldCounts.entries()).map(([field, data3]) => ({ field, ...data3 })).sort((a, b) => b.count - a.count).slice(0, 10);
}

// app/routes/api.validate.ts
init_db();
var action3 = async ({ request: request2 }) => {
  let { session } = await authenticate.admin(request2), user = await db.user.findUnique({
    where: { shopId: session.shop }
  });
  if (!user)
    return (0, import_node6.json)({ error: "User not found" }, { status: 404 });
  try {
    if ((await request2.formData()).get("action") === "validate") {
      let sampleProducts = (await new ShopifySyncService(session.shop, user.accessToken).syncProducts(user.id)).slice(0, 10), mappedProducts = mapProductsToSpec(sampleProducts), validationResults = await validateProducts(mappedProducts.map((p) => {
        let { originalId, score, ...spec } = p;
        return spec;
      })), summary = getValidationSummary(validationResults), audit = await db.audit.create({
        data: {
          userId: user.id,
          score: summary.validationRate,
          totalProducts: summary.totalProducts,
          validProducts: summary.validProducts,
          gaps: summary.commonErrors.map((error) => ({
            field: error.field,
            count: error.count,
            message: error.message
          }))
        }
      });
      return await db.log.create({
        data: {
          userId: user.id,
          type: "validation",
          message: `Validated ${summary.totalProducts} products - ${summary.validationRate}% passed validation`,
          metadata: {
            summary,
            auditId: audit.id,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      }), (0, import_node6.json)({
        success: !0,
        data: {
          auditId: audit.id,
          summary,
          products: mappedProducts.map((product, index) => ({
            id: product.originalId,
            title: product.title,
            score: product.score,
            validation: validationResults[index]
          }))
        }
      });
    }
    return (0, import_node6.json)({ error: "Invalid action" }, { status: 400 });
  } catch (error) {
    return console.error("Validation error:", error), await db.log.create({
      data: {
        userId: user.id,
        type: "error",
        message: `Validation error: ${error instanceof Error ? error.message : "Unknown error"}`,
        error: error instanceof Error ? error.stack : String(error),
        metadata: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      }
    }), (0, import_node6.json)(
      {
        success: !1,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      },
      { status: 500 }
    );
  }
};

// app/routes/api.enrich.ts
var api_enrich_exports = {};
__export(api_enrich_exports, {
  action: () => action4,
  loader: () => loader5
});
var import_node7 = __toESM(require_dist(), 1);
init_shopify_server();
init_shopifySync();
init_aiEnrich();
init_db();
var loader5 = async ({ request: request2 }) => {
  console.log("\u{1F3AF} AI ENRICH LOADER CALLED");
  try {
    let { session } = await authenticate.admin(request2);
    return console.log("\u2705 AI Enrich loader authentication successful for shop:", session.shop), (0, import_node7.json)({ success: !0, message: "AI Enrichment API ready" });
  } catch (error) {
    return console.error("\u274C AI Enrich loader authentication failed:", error), (0, import_node7.json)({ success: !1, error: "Authentication failed" }, { status: 401 });
  }
}, action4 = async ({ request: request2 }) => {
  console.log("\u{1F3AF} AI ENRICH ACTION CALLED - Fixed Syntax Error");
  try {
    console.log("\u{1F50D} Attempting authentication for AI enrichment..."), console.log("\u{1F50D} Request URL:", request2.url), console.log("\u{1F50D} Request method:", request2.method), console.log("\u{1F50D} Request headers:", Object.fromEntries(request2.headers.entries()));
    let { session } = await authenticate.admin(request2);
    console.log("\u2705 AI Enrich authentication successful for shop:", session.shop);
    let user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    if (!user)
      return console.log("\u274C User not found for shop:", session.shop), (0, import_node7.json)({ error: "User not found" }, { status: 404 });
    console.log("\u{1F464} User found:", user.id);
    let formData = await request2.formData(), action8 = formData.get("action"), shopFromForm = formData.get("shop");
    if (console.log("\u{1F4DD} Form data action:", action8), console.log("\u{1F3EA} Shop from form:", shopFromForm), action8 === "enrich") {
      console.log("\u{1F680} Starting AI enrichment process...");
      let productIds = formData.getAll("productIds"), maxProducts = parseInt(formData.get("maxProducts")) || 5, tierLimits = {
        starter: 5,
        pro: 25,
        enterprise: 100
      }, limit = tierLimits[user.tier] || tierLimits.starter;
      if (maxProducts > limit)
        return (0, import_node7.json)({
          success: !1,
          error: `Your ${user.tier} tier allows up to ${limit} products per enrichment. Please upgrade to process more products.`
        }, { status: 400 });
      console.log("\u{1F511} Loading offline session for AI enrichment...");
      let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`, offlineSession = await sessionStorage3.loadSession(offlineSessionId);
      if (!offlineSession?.accessToken)
        return console.log("\u274C Offline session not found for AI enrichment"), (0, import_node7.json)({
          success: !1,
          error: "Offline session not found. Please reinstall the app."
        }, { status: 401 });
      console.log("\u2705 Offline session loaded for AI enrichment"), console.log("\u{1F4E6} Fetching products for AI enrichment...");
      let allProducts = await new ShopifySyncService(session.shop, offlineSession.accessToken).syncProducts(user.id);
      console.log("\u{1F4E6} Products fetched:", allProducts.length);
      let productsToEnrich = productIds.length > 0 ? allProducts.filter((p) => productIds.includes(p.id)) : allProducts.slice(0, maxProducts);
      if (console.log("\u{1F3AF} Products selected for enrichment:", productsToEnrich.length), productsToEnrich.length === 0)
        return console.log("\u274C No products found to enrich"), (0, import_node7.json)({
          success: !1,
          error: "No products found to enrich"
        }, { status: 400 });
      console.log("\u{1F916} Starting AI enrichment service...");
      let enrichmentService = new AIEnrichmentService();
      console.log("\u{1F916} Calling enrichProducts with", productsToEnrich.length, "products");
      let enrichmentResults = await enrichmentService.enrichProducts(
        user.id,
        productsToEnrich,
        {
          enrichDescription: !0,
          inferMaterial: !0,
          generateUseCases: !0,
          generateFeatures: !0,
          generateKeywords: !0
        },
        maxProducts
      );
      console.log("\u2705 AI enrichment completed, results:", enrichmentResults.length);
      let applyToShopify = formData.get("applyToShopify") === "true", appliedResults = [];
      if (applyToShopify)
        for (let result of enrichmentResults)
          try {
            let success = await enrichmentService.applyEnrichmentToShopify(
              user.id,
              session.shop,
              offlineSession.accessToken,
              result
            );
            appliedResults.push({
              productId: result.originalProduct.id,
              success,
              improvements: result.improvements
            });
          } catch (error) {
            appliedResults.push({
              productId: result.originalProduct.id,
              success: !1,
              error: error instanceof Error ? error.message : "Unknown error"
            });
          }
      let totalUsage = enrichmentResults.reduce((sum, result) => sum + result.totalUsage, 0);
      console.log("\u{1F4B0} Total usage calculated:", totalUsage), console.log("\u{1F4DD} Creating database log..."), await db.log.create({
        data: {
          userId: user.id,
          type: "enrichment",
          message: `AI enrichment completed for ${enrichmentResults.length} products`,
          metadata: {
            productsProcessed: enrichmentResults.length,
            totalUsage,
            appliedToShopify: applyToShopify,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      }), console.log("\u2705 Database log created");
      let response = {
        success: !0,
        data: {
          productsProcessed: enrichmentResults.length,
          totalUsage,
          appliedToShopify: applyToShopify,
          results: enrichmentResults.map((result) => ({
            productId: result.originalProduct.id,
            title: result.originalProduct.title,
            improvements: result.improvements,
            totalUsage: result.totalUsage,
            errors: result.errors
          })),
          appliedResults
        }
      };
      return console.log("\u{1F389} Returning successful response:", response), (0, import_node7.json)(response);
    }
    return (0, import_node7.json)({ error: "Invalid action" }, { status: 400 });
  } catch (error) {
    console.error("\u274C CRITICAL ERROR in AI enrichment:", error), console.error("\u274C Error stack:", error instanceof Error ? error.stack : "No stack trace");
    try {
      let { session } = await authenticate.admin(request2).catch(() => null);
      if (session) {
        let user = await db.user.findUnique({
          where: { shopId: session.shop }
        }).catch(() => null);
        user && (await db.log.create({
          data: {
            userId: user.id,
            type: "error",
            message: `Enrichment error: ${error instanceof Error ? error.message : "Unknown error"}`,
            error: error instanceof Error ? error.stack : String(error),
            metadata: {
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            }
          }
        }), console.log("\u{1F4DD} Error logged to database"));
      }
    } catch (logError) {
      console.error("\u274C Failed to log error to database:", logError);
    }
    return (0, import_node7.json)(
      {
        success: !1,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      },
      { status: 500 }
    );
  }
};

// app/routes/api.sync.ts
var api_sync_exports = {};
__export(api_sync_exports, {
  action: () => action5,
  loader: () => loader6
});
var import_node8 = __toESM(require_dist(), 1);
init_shopify_server();
init_shopifySync();
init_db();
var loader6 = async ({ request: request2 }) => {
  let { session } = await authenticate.admin(request2), user = await db.user.findUnique({
    where: { shopId: session.shop }
  });
  if (!user)
    return (0, import_node8.json)({ error: "User not found" }, { status: 404 });
  let recentLogs = await db.log.findMany({
    where: {
      userId: user.id,
      type: "sync"
    },
    orderBy: {
      createdAt: "desc"
    },
    take: 10
  });
  return (0, import_node8.json)({
    logs: recentLogs.map((log2) => ({
      id: log2.id,
      type: log2.type,
      message: log2.message,
      createdAt: log2.createdAt,
      metadata: log2.metadata
    }))
  });
}, action5 = async ({ request: request2 }) => {
  console.log("\u{1F3AF} SYNC ACTION CALLED - Request method:", request2.method), console.log("\u{1F3AF} SYNC ACTION CALLED - Request URL:", request2.url), console.log("\u{1F3AF} Request headers:", Object.fromEntries(request2.headers.entries()));
  try {
    console.log("\u{1F510} Attempting authentication...");
    let { session } = await authenticate.admin(request2);
    console.log("\u{1F3AF} Authentication successful for shop:", session.shop);
    let user = await db.user.findUnique({
      where: { shopId: session.shop }
    });
    if (!user)
      return console.log("\u274C User not found for shop:", session.shop), (0, import_node8.json)({ error: "User not found" }, { status: 404 });
    console.log("\u{1F680} Starting sync for shop:", session.shop), console.log("\u{1F464} User ID:", user.id);
    let syncService = new ShopifySyncService(session.shop, user.accessToken);
    console.log("\u{1F527} Sync service initialized"), console.log("\u{1F4E6} Starting product sync...");
    let products = await syncService.syncProducts(user.id);
    console.log("\u2705 Product sync completed:", products.length, "products"), console.log("\u{1F4CA} Fetching inventory levels...");
    let inventoryLevels = await syncService.getInventoryLevels(session.shop, user.accessToken);
    console.log("\u{1F4C8} Inventory levels:", inventoryLevels.length), console.log("\u{1F6D2} Fetching recent orders...");
    let recentOrders = await syncService.getRecentOrders(session.shop, user.accessToken, 50);
    console.log("\u{1F4CB} Recent orders:", recentOrders.length), console.log("\u{1F4DD} Creating audit record...");
    let audit = await db.audit.create({
      data: {
        userId: user.id,
        score: 0,
        // Will be calculated after field mapping
        totalProducts: products.length,
        validProducts: 0,
        // Will be calculated after validation
        gaps: []
        // Will be populated after field mapping and validation
      }
    });
    console.log("\u2705 Audit record created:", audit.id);
    let response = {
      success: !0,
      message: `Successfully synced ${products.length} products`,
      data: {
        productsCount: products.length,
        inventoryLevelsCount: inventoryLevels.length,
        recentOrdersCount: recentOrders.length,
        auditId: audit.id
      }
    };
    return console.log("\u{1F389} Sync response:", response), (0, import_node8.json)(response);
  } catch (error) {
    if (console.error("\u274C SYNC ACTION ERROR:", error), console.error("\u274C Error type:", error?.constructor?.name), console.error("\u274C Error details:", {
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : String(error),
      isResponse: error instanceof Response,
      responseStatus: error instanceof Response ? error.status : "N/A",
      responseHeaders: error instanceof Response ? Object.fromEntries(error.headers.entries()) : "N/A"
    }), error instanceof Response)
      throw console.log("\u{1F504} Re-throwing OAuth redirect response - Status:", error.status), console.log("\u{1F504} Redirect location:", error.headers.get("location")), error;
    return (0, import_node8.json)(
      {
        success: !1,
        error: error instanceof Error ? error.message : "Unknown error occurred"
      },
      { status: 500 }
    );
  }
};

// app/routes/webhooks.ts
var webhooks_exports = {};
__export(webhooks_exports, {
  action: () => action6
});
var import_node9 = __toESM(require_dist(), 1);
init_shopify_server();
init_db();
var action6 = async ({ request: request2 }) => {
  let { topic, shop, session } = await authenticate.webhook(request2);
  if (!session)
    return (0, import_node9.json)({ error: "No session found" }, { status: 401 });
  try {
    let user = await db.user.findUnique({
      where: { shopId: shop }
    });
    if (!user)
      return (0, import_node9.json)({ error: "User not found" }, { status: 404 });
    switch (topic) {
      case "PRODUCTS_CREATE":
      case "PRODUCTS_UPDATE":
        await handleProductWebhook(user.id, session.shop, user.accessToken, topic);
        break;
      case "PRODUCTS_DELETE":
        await handleProductDelete(user.id, topic);
        break;
      default:
        console.log(`Unhandled webhook topic: ${topic}`);
    }
    return (0, import_node9.json)({ success: !0 });
  } catch (error) {
    if (console.error("Webhook error:", error), session?.shop) {
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      user && await db.log.create({
        data: {
          userId: user.id,
          type: "error",
          message: `Webhook error: ${error instanceof Error ? error.message : "Unknown error"}`,
          error: error instanceof Error ? error.stack : String(error),
          metadata: {
            topic,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      });
    }
    return (0, import_node9.json)(
      { error: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
};
async function handleProductWebhook(userId, shopDomain, accessToken, topic) {
  try {
    await db.log.create({
      data: {
        userId,
        type: "webhook",
        message: `Product webhook triggered: ${topic}`,
        metadata: {
          topic,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      }
    }), console.log(`Product webhook received: ${topic} for shop: ${shopDomain}`);
  } catch (error) {
    throw console.error("Error handling product webhook:", error), error;
  }
}
async function handleProductDelete(userId, topic) {
  try {
    await db.log.create({
      data: {
        userId,
        type: "webhook",
        message: `Product deleted: ${topic}`,
        metadata: {
          topic,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      }
    }), console.log(`Product deletion webhook: ${topic}`);
  } catch (error) {
    throw console.error("Error handling product deletion webhook:", error), error;
  }
}

// app/routes/_index.tsx
var index_exports = {};
__export(index_exports, {
  action: () => action7,
  default: () => Index,
  loader: () => loader7
});
var import_node10 = __toESM(require_dist(), 1);
var import_react160 = __toESM(require_react(), 1);
init_shopify_server();
init_db();

// app/components/HealthCheckModal.tsx
var import_react158 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function HealthCheckModal({
  isOpen,
  onClose,
  jobId,
  currentScore = 0,
  currentGaps = []
}) {
  let [loading, setLoading] = (0, import_react158.useState)(!1), [results, setResults] = (0, import_react158.useState)(null), [toast, setToast] = (0, import_react158.useState)(null), [autoFixing, setAutoFixing] = (0, import_react158.useState)(!1);
  (0, import_react158.useEffect)(() => {
    isOpen && jobId && fetchResults();
  }, [isOpen, jobId]);
  let fetchResults = async () => {
    setLoading(!0);
    try {
      let formData = new FormData();
      formData.append("action", "get-results"), formData.append("jobId", jobId);
      let data3 = await (await fetch("/api/health-check", {
        method: "POST",
        body: formData
      })).json();
      data3.success && data3.result ? setResults(data3.result) : setToast({ content: data3.error || "Failed to fetch results", error: !0 });
    } catch {
      setToast({ content: "Failed to fetch results", error: !0 });
    } finally {
      setLoading(!1);
    }
  }, handleAutoFix = async () => {
    if (!results)
      return;
    let fixableGaps = results.gaps.filter((gap) => gap.fixable);
    if (fixableGaps.length === 0) {
      setToast({ content: "No fixable gaps found", error: !0 });
      return;
    }
    setAutoFixing(!0);
    try {
      let formData = new FormData();
      formData.append("action", "auto-fix"), formData.append("gapTypes", JSON.stringify(fixableGaps.map((gap) => gap.field)));
      let data3 = await (await fetch("/api/health-check", {
        method: "POST",
        body: formData
      })).json();
      data3.success ? (setToast({ content: `Auto-fix initiated for ${fixableGaps.length} gaps` }), setTimeout(fetchResults, 2e3)) : setToast({ content: data3.error || "Auto-fix failed", error: !0 });
    } catch {
      setToast({ content: "Auto-fix failed", error: !0 });
    } finally {
      setAutoFixing(!1);
    }
  }, getScoreColor = (score) => score >= 90 ? "success" : score >= 70 ? "warning" : "critical", getSeverityIcon = (severity) => {
    switch (severity) {
      case "critical":
        return SvgXCircleIcon;
      case "error":
        return SvgAlertTriangleIcon;
      case "warning":
        return SvgAlertTriangleIcon;
      default:
        return SvgCheckCircleIcon;
    }
  }, getSeverityColor = (severity) => {
    switch (severity) {
      case "critical":
        return "critical";
      case "error":
        return "critical";
      case "warning":
        return "warning";
      default:
        return "success";
    }
  }, formatTrend = (trends) => {
    if (trends.length < 2)
      return null;
    let latest = trends[trends.length - 1], previous = trends[trends.length - 2], diff = latest.score - previous.score;
    return {
      value: diff,
      icon: diff >= 0 ? SvgArrowUpIcon : SvgArrowDownIcon,
      color: diff >= 0 ? "success" : "critical"
    };
  }, gapsTableRows = results?.gaps.map((gap, index) => [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { gap: "200", align: "start", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Icon, { source: getSeverityIcon(gap.severity) }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", fontWeight: "medium", children: gap.field })
    ] }, index),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Badge, { tone: getSeverityColor(gap.severity), children: gap.severity }, `badge-${index}`),
    gap.count,
    gap.fixable ? "Yes" : "No"
  ]) || [], trendsTableRows = results?.trends.slice(-7).map((trend, index) => [
    new Date(trend.date).toLocaleDateString(),
    `${trend.score}%`,
    trend.totalProducts,
    trend.validProducts
  ]) || [];
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Modal,
      {
        open: isOpen,
        onClose,
        title: "Health Check Results",
        size: "large",
        children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Modal.Section, { children: loading ? /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { align: "center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Spinner, { size: "large" }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", children: "Analyzing your catalog..." })
        ] }) : results ? /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(BlockStack, { gap: "400", children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(BlockStack, { gap: "300", children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { align: "space-between", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: "Overall Health Score" }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Badge, { tone: getScoreColor(results.score), children: [
                results.score,
                "%"
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              ProgressBar,
              {
                progress: results.score,
                size: "large",
                color: getScoreColor(results.score)
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { gap: "400", align: "start", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Box, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "Total Products" }),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: results.totalProducts })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Box, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "Valid Products" }),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: results.validProducts })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Box, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "Issues Found" }),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: results.gaps.length })
              ] })
            ] }),
            results.trends.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Box, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { gap: "200", align: "start", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "7-Day Trend" }),
              (() => {
                let trend = formatTrend(results.trends);
                return trend ? /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { gap: "100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Icon, { source: trend.icon }),
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(Text, { variant: "bodyMd", color: trend.color, children: [
                    trend.value > 0 ? "+" : "",
                    trend.value.toFixed(1),
                    "%"
                  ] })
                ] }) : null;
              })()
            ] }) })
          ] }) }),
          results.gaps.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(BlockStack, { gap: "300", children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { align: "space-between", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: "Issues Found" }),
              results.gaps.some((gap) => gap.fixable) && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                Button,
                {
                  variant: "primary",
                  onClick: handleAutoFix,
                  loading: autoFixing,
                  disabled: autoFixing,
                  children: "Auto-Fix Fixable Issues"
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              DataTable,
              {
                columnContentTypes: ["text", "text", "numeric", "text"],
                headings: ["Field", "Severity", "Count", "Fixable"],
                rows: gapsTableRows
              }
            )
          ] }) }),
          results.trends.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(BlockStack, { gap: "300", children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: "Health Score Trends (Last 7 Days)" }),
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              DataTable,
              {
                columnContentTypes: ["text", "numeric", "numeric", "numeric"],
                headings: ["Date", "Score", "Total Products", "Valid Products"],
                rows: trendsTableRows
              }
            )
          ] }) }),
          results.gaps.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(InlineStack, { align: "center", gap: "300", children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Icon, { source: SvgCheckCircleIcon }),
            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(BlockStack, { gap: "200", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "headingMd", children: "Excellent!" }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "Your catalog is in great health. No issues were found." })
            ] })
          ] }) })
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Text, { variant: "bodyMd", color: "subdued", children: "No results available. Please try running the health check again." }) })
      }
    ),
    toast && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      Toast2,
      {
        content: toast.content,
        error: toast.error,
        onDismiss: () => setToast(null)
      }
    )
  ] });
}

// app/routes/_index.tsx
init_openaiSpec();
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1), loader7 = async ({ request: request2 }) => {
  try {
    console.log("\u{1F50D} DEBUG - Starting authentication for request:", request2.url);
    let { session } = await authenticate.admin(request2);
    console.log("\u{1F50D} DEBUG - Session shop:", session.shop), console.log("\u{1F50D} DEBUG - Session exists:", !!session), console.log("\u{1F50D} DEBUG - Access token exists:", !!session.accessToken), console.log("\u{1F50D} DEBUG - Session ID:", session.id);
    let user = null, latestAudit = null, recentLogs = [];
    try {
      user = await db.user.findUnique({
        where: { shopId: session.shop }
      }), user && (latestAudit = await db.audit.findFirst({
        where: { userId: user.id },
        orderBy: { timestamp: "desc" }
      }), await db.log.deleteMany({
        where: {
          userId: user.id,
          message: {
            contains: "GraphQL Error"
          }
        }
      }), recentLogs = await db.log.findMany({
        where: {
          userId: user.id,
          // Filter out logs with raw error details
          message: {
            not: {
              contains: "GraphQL Error"
            }
          }
        },
        orderBy: { createdAt: "desc" },
        take: 3
      }));
    } catch (dbError) {
      console.error("Database error in loader:", dbError);
    }
    let products = [], totalProducts = 0, averageScore = 0;
    if (user)
      try {
        let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`, offlineSession = await sessionStorage3.loadSession(offlineSessionId);
        if (offlineSession?.accessToken) {
          let { ShopifySyncService: ShopifySyncService2 } = await Promise.resolve().then(() => (init_shopifySync(), shopifySync_exports)), { mapShopifyToSpec: mapShopifyToSpec2, calculateProductScore: calculateProductScore2 } = await Promise.resolve().then(() => (init_fieldMapper(), fieldMapper_exports)), shopifyProducts = await new ShopifySyncService2(session.shop, offlineSession.accessToken).syncProducts(user.id), storedProducts = await db.product.findMany({
            where: { userId: user.id },
            select: {
              shopifyId: !0,
              recommendations: !0
            }
          }), recommendationsMap = /* @__PURE__ */ new Map();
          storedProducts.forEach((sp) => {
            sp.recommendations && recommendationsMap.set(sp.shopifyId, sp.recommendations);
          }), products = shopifyProducts.map((shopifyProduct) => {
            let spec = mapShopifyToSpec2(shopifyProduct), scoreData = calculateProductScore2(spec), productId = shopifyProduct.id.replace("gid://shopify/Product/", "");
            return {
              id: productId,
              title: shopifyProduct.title || "Untitled Product",
              description: shopifyProduct.description || "No description",
              score: scoreData.score,
              gaps: scoreData.gaps,
              rawProduct: shopifyProduct,
              // Store raw product for detail view
              spec,
              // Store mapped spec for recommendations
              recommendations: recommendationsMap.get(productId) || null
              // Include stored recommendations
            };
          }), totalProducts = shopifyProducts.length, averageScore = products.length > 0 ? Math.round(products.reduce((sum, p) => sum + p.score, 0) / products.length) : 0;
        }
      } catch (error) {
        console.error("Error fetching products in loader:", error), products = [
          {
            id: "1",
            title: "Sample Product 1",
            description: "Basic product description",
            score: 75,
            gaps: ["material", "weight"]
          },
          {
            id: "2",
            title: "Sample Product 2",
            description: "Another product with minimal details",
            score: 60,
            gaps: ["material", "dimensions", "use_cases"]
          },
          {
            id: "3",
            title: "Sample Product 3",
            description: "Well-described product with comprehensive details",
            score: 95,
            gaps: []
          }
        ];
      }
    let dashboardMetrics = ((products2, user2) => {
      let totalProducts2 = products2.length, validProducts = products2.filter((p) => p.score >= 90).length, warningProducts = products2.filter((p) => p.score >= 70 && p.score < 90).length, invalidProducts = products2.filter((p) => p.score < 70).length, productsPassedPercentage = totalProducts2 > 0 ? Math.round(validProducts / totalProducts2 * 100) : 0, aiReadinessScore = Math.round(averageScore), optimizationProgress = Math.round(averageScore), lastSyncTime = null;
      return user2 && (lastSyncTime = /* @__PURE__ */ new Date()), {
        aiReadinessScore,
        totalProducts: totalProducts2,
        validProducts,
        warningProducts,
        invalidProducts,
        productsPassedPercentage,
        lastSyncTime,
        optimizationProgress
      };
    })(products, user);
    return (0, import_node10.json)({
      shop: session.shop,
      user,
      products,
      totalProducts,
      averageScore,
      dashboardMetrics,
      lastSync: recentLogs.find((log2) => log2.type === "sync")?.createdAt || null,
      recentLogs: recentLogs.map((log2) => ({
        id: log2.id,
        type: log2.type,
        message: log2.message,
        createdAt: log2.createdAt
      }))
    });
  } catch (error) {
    if (console.error("\u274C ERROR in index loader:", error), console.error("\u274C ERROR details:", {
      message: error.message,
      stack: error.stack,
      name: error.name
    }), error instanceof Response)
      throw console.log("\u{1F504} Re-throwing OAuth redirect response"), error;
    return (0, import_node10.json)({
      shop: "unknown",
      products: [],
      user: null,
      totalProducts: 0,
      averageScore: 0,
      lastSync: null,
      recentLogs: []
    });
  }
}, action7 = async ({ request: request2 }) => {
  console.log("\u{1F3AF} INDEX ACTION CALLED");
  try {
    let { admin, session } = await authenticate.admin(request2);
    console.log("\u2705 Authentication successful in index action"), console.log("\u{1F511} Admin API client available:", !!admin), console.log("\u{1F4CD} Session shop:", session.shop);
    let formData = await request2.formData(), actionType = formData.get("action");
    if (actionType === "sync") {
      console.log("\u{1F680} Starting sync in index action");
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return console.log("\u274C User not found for shop:", session.shop), (0, import_node10.json)({ success: !1, error: "User not found" }, { status: 404 });
      console.log("\u{1F464} User ID:", user.id);
      let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`;
      console.log("\u{1F511} Loading offline session:", offlineSessionId);
      let offlineSession = await sessionStorage3.loadSession(offlineSessionId);
      if (!offlineSession)
        return console.log("\u274C Offline session not found"), (0, import_node10.json)({ success: !1, error: "Offline session not found. Please reinstall the app." }, { status: 401 });
      console.log("\u2705 Offline session loaded, has accessToken:", !!offlineSession.accessToken), console.log("\u{1F511} Access token prefix:", offlineSession.accessToken?.substring(0, 15) + "..."), console.log("\u{1F511} Access token length:", offlineSession.accessToken?.length), console.log("\u{1F50D} Session scope:", offlineSession.scope), console.log("\u{1F50D} Session isOnline:", offlineSession.isOnline);
      let { GraphQLClient: GraphQLClient2 } = await import("graphql-request"), graphqlClient = new GraphQLClient2(
        `https://${session.shop}/admin/api/2025-10/graphql`,
        {
          headers: {
            "X-Shopify-Access-Token": offlineSession.accessToken,
            "Content-Type": "application/json"
          }
        }
      );
      console.log("\u{1F4E6} Starting product sync with offline access token...");
      let PRODUCTS_QUERY2 = `
        query getProducts($first: Int!, $after: String) {
          products(first: $first, after: $after) {
            pageInfo {
              hasNextPage
              endCursor
            }
            edges {
              node {
                id
                title
                description
                handle
                productType
                vendor
                tags
                variants(first: 100) {
                  edges {
                    node {
                      id
                      title
                      price
                      compareAtPrice
                      sku
                      inventoryQuantity
                      availableForSale
                    }
                  }
                }
                metafields(first: 100) {
                  edges {
                    node {
                      id
                      namespace
                      key
                      value
                      type
                    }
                  }
                }
                images(first: 10) {
                  edges {
                    node {
                      id
                      url
                      altText
                    }
                  }
                }
              }
            }
          }
        }
      `, allProducts = [], hasNextPage = !0, after, pageCount = 0;
      for (; hasNextPage; ) {
        pageCount++, console.log(`\u{1F4C4} Fetching page ${pageCount}${after ? " (after cursor)" : " (first page)"}`);
        let response = await graphqlClient.request(PRODUCTS_QUERY2, {
          first: 250,
          after
        });
        console.log("\u{1F4E6} Products in this page:", response.products?.edges?.length || 0), response.products?.edges && allProducts.push(...response.products.edges), hasNextPage = response.products?.pageInfo?.hasNextPage || !1, after = response.products?.pageInfo?.endCursor, hasNextPage && (console.log("\u23F3 Waiting 500ms before next request..."), await new Promise((resolve) => setTimeout(resolve, 500)));
      }
      console.log("\u2705 Product sync completed:", allProducts.length, "products"), await db.log.create({
        data: {
          userId: user.id,
          type: "sync",
          message: `Synchronized ${allProducts.length} products from Shopify`,
          metadata: {
            productsCount: allProducts.length,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      }), console.log("\u{1F4DD} Creating audit record...");
      let audit = await db.audit.create({
        data: {
          userId: user.id,
          score: 0,
          // Will be calculated after field mapping
          totalProducts: allProducts.length,
          validProducts: 0,
          // Will be calculated after validation
          gaps: []
          // Will be populated after field mapping and validation
        }
      });
      return console.log("\u2705 Audit record created:", audit.id), (0, import_node10.json)({
        success: !0,
        message: `Successfully synced ${allProducts.length} products`,
        data: {
          productsCount: allProducts.length,
          auditId: audit.id
        }
      });
    }
    if (actionType === "generate-recommendations") {
      console.log("\u{1F916} Generating AI recommendations for single product");
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node10.json)({ success: !1, error: "User not found" }, { status: 404 });
      let productId = formData.get("productId");
      if (console.log("\u{1F3AF} Product ID:", productId), !(formData.get("forceRegenerate") === "true")) {
        let existingProduct = await db.product.findFirst({
          where: {
            userId: user.id,
            shopifyId: productId
          }
        });
        if (existingProduct?.recommendations) {
          let recData = existingProduct.recommendations;
          return console.log("\u{1F4CB} Returning existing recommendations for product:", productId), (0, import_node10.json)({
            success: !0,
            recommendations: recData.recommendations || [],
            isExisting: !0
          });
        }
      }
      let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`, offlineSession = await sessionStorage3.loadSession(offlineSessionId);
      if (!offlineSession?.accessToken)
        return (0, import_node10.json)({
          success: !1,
          error: "Offline session not found. Please reinstall the app."
        }, { status: 401 });
      let { ShopifySyncService: ShopifySyncService2 } = await Promise.resolve().then(() => (init_shopifySync(), shopifySync_exports)), { AIEnrichmentService: AIEnrichmentService2 } = await Promise.resolve().then(() => (init_aiEnrich(), aiEnrich_exports)), product = (await new ShopifySyncService2(session.shop, offlineSession.accessToken).syncProducts(user.id)).find((p) => p.id.includes(productId));
      if (!product)
        return (0, import_node10.json)({ success: !1, error: "Product not found" }, { status: 404 });
      let { mapShopifyToSpec: mapShopifyToSpec2, calculateProductScore: calculateProductScore2 } = await Promise.resolve().then(() => (init_fieldMapper(), fieldMapper_exports)), spec = mapShopifyToSpec2(product), gaps = calculateProductScore2(spec).gaps;
      console.log("\u{1F3AF} Product gaps identified:", gaps);
      let result = await new AIEnrichmentService2().enrichProduct(user.id, product, gaps);
      console.log("\u2705 Generated recommendations:", result.improvements.length);
      let recommendationData = {
        recommendations: result.improvements.map((rec) => ({
          ...rec,
          status: "pending"
          // pending, approved, rejected, applied
        })),
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      };
      return await db.product.upsert({
        where: {
          userId_shopifyId: {
            userId: user.id,
            shopifyId: productId
          }
        },
        create: {
          userId: user.id,
          shopifyId: productId,
          title: product.title,
          recommendations: recommendationData
        },
        update: {
          recommendations: recommendationData
        }
      }), console.log("\u{1F4BE} Stored recommendations in database for product:", productId), (0, import_node10.json)({
        success: !0,
        recommendations: recommendationData.recommendations,
        isExisting: !1
      });
    }
    if (actionType === "apply-recommendations") {
      console.log("\u{1F4DD} Applying approved recommendations to Shopify");
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node10.json)({ success: !1, error: "User not found" }, { status: 404 });
      let productId = formData.get("productId"), approvedRecommendationsJson = formData.get("approvedRecommendations"), approvedRecommendations = JSON.parse(approvedRecommendationsJson);
      if (console.log("\u{1F3AF} Product ID:", productId), console.log("\u2705 Approved recommendations:", approvedRecommendations.length), console.log("\u{1F4CB} Approved recommendation fields:", approvedRecommendations.map((r) => r.field)), !Array.isArray(approvedRecommendations) || approvedRecommendations.length === 0)
        return (0, import_node10.json)({
          success: !1,
          error: "No approved recommendations provided"
        }, { status: 400 });
      let productRecord = await db.product.findFirst({
        where: {
          userId: user.id,
          shopifyId: productId
        }
      }), updatedRecommendationData = null;
      if (productRecord?.recommendations) {
        let recData = productRecord.recommendations, approvedFields = approvedRecommendations.map((r) => r.field);
        updatedRecommendationData = {
          ...recData,
          recommendations: recData.recommendations.map((rec) => ({
            ...rec,
            status: approvedFields.includes(rec.field) ? "applied" : rec.status
          })),
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`, offlineSession = await sessionStorage3.loadSession(offlineSessionId);
      if (!offlineSession?.accessToken)
        return (0, import_node10.json)({
          success: !1,
          error: "Offline session not found. Please reinstall the app."
        }, { status: 401 });
      let { ShopifySyncService: ShopifySyncService2 } = await Promise.resolve().then(() => (init_shopifySync(), shopifySync_exports)), { mapShopifyToSpec: mapShopifyToSpec2, calculateProductScore: calculateProductScore2 } = await Promise.resolve().then(() => (init_fieldMapper(), fieldMapper_exports)), syncService = new ShopifySyncService2(session.shop, offlineSession.accessToken), product = (await syncService.syncProducts(user.id)).find((p) => p.id.includes(productId));
      if (!product)
        return (0, import_node10.json)({ success: !1, error: "Product not found" }, { status: 404 });
      let initialSpec = mapShopifyToSpec2(product), initialScore = calculateProductScore2(initialSpec).score;
      console.log("\u{1F4CA} Initial product score:", initialScore);
      let { AIEnrichmentService: AIEnrichmentService2 } = await Promise.resolve().then(() => (init_aiEnrich(), aiEnrich_exports)), enrichmentService = new AIEnrichmentService2(), partialResult = {
        originalProduct: product,
        enrichedSpec: {},
        improvements: approvedRecommendations,
        totalUsage: 0,
        errors: []
      }, success = await enrichmentService.applyEnrichmentToShopify(
        user.id,
        session.shop,
        offlineSession.accessToken,
        partialResult
      );
      console.log("\u2705 Applied changes to Shopify:", success);
      let finalScore = initialScore;
      if (success)
        try {
          let updatedProduct = (await syncService.syncProducts(user.id)).find((p) => p.id.includes(productId));
          if (updatedProduct) {
            let updatedSpec = mapShopifyToSpec2(updatedProduct);
            finalScore = calculateProductScore2(updatedSpec).score, console.log("\u{1F4CA} Final product score:", finalScore), console.log("\u{1F4C8} Score improvement:", finalScore - initialScore);
          }
        } catch (error) {
          console.warn("Could not validate score improvement:", error);
        }
      return updatedRecommendationData && productRecord && (await db.product.update({
        where: { id: productRecord.id },
        data: {
          recommendations: updatedRecommendationData
        }
      }), console.log("\u{1F4BE} Updated recommendation status to applied in database")), await db.log.create({
        data: {
          userId: user.id,
          type: "enrichment",
          message: `Applied ${approvedRecommendations.length} approved AI recommendations to product ${productId}`,
          metadata: {
            productId,
            approvedCount: approvedRecommendations.length,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      }), (0, import_node10.json)({
        success: !0,
        appliedCount: approvedRecommendations.length,
        scoreImprovement: {
          initial: initialScore,
          final: finalScore,
          improvement: finalScore - initialScore
        }
      });
    }
    if (actionType === "save-customer-input") {
      console.log("\u{1F4BE} Saving customer input data");
      let user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      if (!user)
        return (0, import_node10.json)({ success: !1, error: "User not found" }, { status: 404 });
      let productId = formData.get("productId"), inputDataJson = formData.get("inputData"), inputData = JSON.parse(inputDataJson);
      console.log("\u{1F3AF} Product ID:", productId), console.log("\u{1F4DD} Input data:", inputData);
      let { sessionStorage: sessionStorage3 } = await Promise.resolve().then(() => (init_shopify_server(), shopify_server_exports)), offlineSessionId = `offline_${session.shop}`, offlineSession = await sessionStorage3.loadSession(offlineSessionId);
      if (!offlineSession?.accessToken)
        return (0, import_node10.json)({
          success: !1,
          error: "Offline session not found. Please reinstall the app."
        }, { status: 401 });
      let { GraphQLClient: GraphQLClient2 } = await import("graphql-request"), graphqlClient = new GraphQLClient2(
        `https://${session.shop}/admin/api/2025-10/graphql`,
        {
          headers: {
            "X-Shopify-Access-Token": offlineSession.accessToken,
            "Content-Type": "application/json"
          }
        }
      ), appliedCount = 0, appliedFields = [];
      for (let [field, value] of Object.entries(inputData))
        try {
          let metafieldValue = value, metafieldType = "single_line_text_field";
          if (field.startsWith("dimensions_"))
            continue;
          (field === "specifications" || field === "warranty" || field === "return_policy") && (metafieldType = "multi_line_text_field");
          let CREATE_METAFIELD_MUTATION = `
            mutation metafieldsSet($metafields: [MetafieldsSetInput!]!) {
              metafieldsSet(metafields: $metafields) {
                metafields {
                  id
                  namespace
                  key
                  value
                }
                userErrors {
                  field
                  message
                }
              }
            }
          `, response = await graphqlClient.request(CREATE_METAFIELD_MUTATION, {
            metafields: [
              {
                ownerId: `gid://shopify/Product/${productId}`,
                namespace: "catalogai",
                key: field,
                type: metafieldType,
                value: metafieldValue
              }
            ]
          });
          response.metafieldsSet.userErrors?.length ? console.error(`\u274C Error applying ${field}:`, response.metafieldsSet.userErrors) : (appliedCount++, appliedFields.push(field), console.log(`\u2705 Applied ${field}: ${metafieldValue}`));
        } catch (error) {
          console.error(`\u274C Error applying ${field}:`, error);
        }
      let dimensionData = ["dimensions_length", "dimensions_width", "dimensions_height"].reduce((acc, key) => {
        if (inputData[key]) {
          let dimKey = key.replace("dimensions_", "");
          acc[dimKey] = inputData[key];
        }
        return acc;
      }, {});
      if (Object.keys(dimensionData).length > 0)
        try {
          let CREATE_METAFIELD_MUTATION = `
            mutation metafieldsSet($metafields: [MetafieldsSetInput!]!) {
              metafieldsSet(metafields: $metafields) {
                metafields {
                  id
                  namespace
                  key
                  value
                }
                userErrors {
                  field
                  message
                }
              }
            }
          `;
          (await graphqlClient.request(CREATE_METAFIELD_MUTATION, {
            metafields: [
              {
                ownerId: `gid://shopify/Product/${productId}`,
                namespace: "catalogai",
                key: "dimensions",
                type: "json",
                value: JSON.stringify(dimensionData)
              }
            ]
          })).metafieldsSet.userErrors?.length || (appliedCount++, appliedFields.push("dimensions"), console.log("\u2705 Applied dimensions:", dimensionData));
        } catch (error) {
          console.error("\u274C Error applying dimensions:", error);
        }
      return await db.log.create({
        data: {
          userId: user.id,
          type: "customer_input",
          message: `Applied ${appliedCount} customer input fields to product ${productId}`,
          metadata: {
            productId,
            appliedFields,
            appliedCount,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }
        }
      }), (0, import_node10.json)({
        success: !0,
        appliedCount,
        appliedFields,
        message: `Successfully saved ${appliedCount} fields to your product!`
      });
    }
    return (0, import_node10.json)({ success: !0 });
  } catch (error) {
    if (console.error("\u274C Error in index action:", error), error instanceof Response)
      throw console.log("\u{1F504} Re-throwing OAuth redirect response"), error;
    let userFriendlyError = "Sync failed. Please try again.";
    error instanceof Error && (error.message.includes("401") || error.message.includes("Unauthorized") ? userFriendlyError = "Authentication failed. Please reinstall the app." : error.message.includes("403") || error.message.includes("Forbidden") ? userFriendlyError = "Insufficient permissions. Please check app permissions." : error.message.includes("429") || error.message.includes("rate limit") ? userFriendlyError = "Rate limit exceeded. Please try again in a few minutes." : error.message.includes("GraphQL") && (userFriendlyError = "API connection failed. Please try again."));
    try {
      let { session } = await authenticate.admin(request2), user = await db.user.findUnique({
        where: { shopId: session.shop }
      });
      user && await db.log.create({
        data: {
          userId: user.id,
          type: "error",
          message: userFriendlyError,
          error: error instanceof Error ? error.message : "Unknown error",
          metadata: {
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            action: "sync"
          }
        }
      });
    } catch (logError) {
      console.error("Failed to log error:", logError);
    }
    return (0, import_node10.json)(
      {
        success: !1,
        error: userFriendlyError
      },
      { status: 500 }
    );
  }
};
function Index() {
  let loaderData = useLoaderData2(), { shop, totalProducts, averageScore, dashboardMetrics, lastSync, recentLogs, user } = loaderData, [products, setProducts] = (0, import_react160.useState)(loaderData.products), [isSyncing, setIsSyncing] = (0, import_react160.useState)(!1), [isHealthChecking, setIsHealthChecking] = (0, import_react160.useState)(!1), [toastActive, setToastActive] = (0, import_react160.useState)(!1), [toastMessage, setToastMessage] = (0, import_react160.useState)(""), [healthModalOpen, setHealthModalOpen] = (0, import_react160.useState)(!1), [healthCheckJobId, setHealthCheckJobId] = (0, import_react160.useState)(), [selectedProduct, setSelectedProduct] = (0, import_react160.useState)(null), [productModalOpen, setProductModalOpen] = (0, import_react160.useState)(!1), [recommendations, setRecommendations] = (0, import_react160.useState)([]), [approvalState, setApprovalState] = (0, import_react160.useState)({}), [isGeneratingRecommendations, setIsGeneratingRecommendations] = (0, import_react160.useState)(!1), [isApplyingChanges, setIsApplyingChanges] = (0, import_react160.useState)(!1), [justAppliedChanges, setJustAppliedChanges] = (0, import_react160.useState)(!1), [customerInputOpen, setCustomerInputOpen] = (0, import_react160.useState)(!1), [customerInputData, setCustomerInputData] = (0, import_react160.useState)({}), [isSavingCustomerInput, setIsSavingCustomerInput] = (0, import_react160.useState)(!1), [showOnlyLowHealth, setShowOnlyLowHealth] = (0, import_react160.useState)(!1), [showOnlyNoDescription, setShowOnlyNoDescription] = (0, import_react160.useState)(!1), syncFetcher = useFetcher2(), healthCheckFetcher = useFetcher2(), recommendationFetcher = useFetcher2(), customerInputFetcher = useFetcher2();
  (0, import_react160.useEffect)(() => {
    setProducts(loaderData.products);
  }, [loaderData.products]);
  let handleSync = () => {
    setIsSyncing(!0), syncFetcher.submit(
      { action: "sync" },
      { method: "post" }
      // Same route action, no need to specify action path
    );
  }, handleHealthCheck = () => {
    setIsHealthChecking(!0), healthCheckFetcher.submit(
      {},
      { method: "get", action: "/api/health-check" }
    );
  }, handleProductClick = (product) => {
    if (setSelectedProduct(product), setProductModalOpen(!0), setJustAppliedChanges(!1), product.recommendations?.recommendations) {
      console.log("\u{1F4CB} Loading existing recommendations for product:", product.id);
      let existingRecs = product.recommendations.recommendations;
      setRecommendations(existingRecs);
      let approvalState2 = {};
      existingRecs.forEach((rec) => {
        rec.status === "approved" || rec.status === "applied" ? approvalState2[rec.field] = !0 : rec.status === "rejected" && (approvalState2[rec.field] = !1);
      }), setApprovalState(approvalState2);
    } else
      setRecommendations([]), setApprovalState({});
  }, handleGenerateRecommendations = () => {
    selectedProduct && (setIsGeneratingRecommendations(!0), setJustAppliedChanges(!1), recommendationFetcher.submit(
      {
        action: "generate-recommendations",
        productId: selectedProduct.id,
        forceRegenerate: recommendations.length > 0 ? "true" : "false"
        // Force regenerate if called from regenerate button
      },
      { method: "post" }
    ));
  }, handleToggleApproval = (fieldName, newState) => {
    setApprovalState((prev) => ({
      ...prev,
      [fieldName]: newState !== void 0 ? newState : prev[fieldName] === !0 ? !1 : prev[fieldName] === !1 ? void 0 : !0
    }));
  }, handleApplyChanges = () => {
    if (!selectedProduct)
      return;
    let approvedRecommendations = recommendations.filter(
      (rec) => approvalState[rec.field] === !0
    ), rejectedRecommendations = recommendations.filter(
      (rec) => approvalState[rec.field] === !1
    ), pendingRecommendations = recommendations.filter(
      (rec) => approvalState[rec.field] === void 0
    );
    if (console.log("\u{1F4CA} Approval Summary:", {
      total: recommendations.length,
      approved: approvedRecommendations.length,
      rejected: rejectedRecommendations.length,
      pending: pendingRecommendations.length,
      approvedFields: approvedRecommendations.map((r) => r.field),
      rejectedFields: rejectedRecommendations.map((r) => r.field)
    }), approvedRecommendations.length === 0) {
      setToastMessage("Please approve at least one recommendation before applying changes"), setToastActive(!0);
      return;
    }
    console.log("\u{1F680} Starting apply changes..."), console.log("\u{1F4CB} Approved recommendations to apply:", approvedRecommendations), setIsApplyingChanges(!0), recommendationFetcher.submit(
      {
        action: "apply-recommendations",
        productId: selectedProduct.id,
        approvedRecommendations: JSON.stringify(approvedRecommendations)
      },
      { method: "post" }
    );
  };
  if (syncFetcher.data && isSyncing) {
    let data3 = syncFetcher.data;
    data3.success ? (setToastMessage(`Successfully synced ${data3.data?.productsCount || 0} products`), setToastActive(!0)) : (setToastMessage(`Sync failed: ${data3.error}`), setToastActive(!0)), setIsSyncing(!1);
  }
  if (healthCheckFetcher.data && isHealthChecking) {
    let data3 = healthCheckFetcher.data;
    data3.success ? (setHealthCheckJobId(data3.jobId), setHealthModalOpen(!0), setToastMessage(`Health scan initiated - analyzing ${data3.currentScore}% current score`), setToastActive(!0)) : (setToastMessage(`Health check failed: ${data3.error}`), setToastActive(!0)), setIsHealthChecking(!1);
  }
  if (recommendationFetcher.data && isGeneratingRecommendations) {
    let data3 = recommendationFetcher.data;
    if (data3.success && data3.recommendations) {
      if (setRecommendations(data3.recommendations), data3.isExisting ? setToastMessage(`Loaded existing ${data3.recommendations.length} AI recommendations`) : setToastMessage(`Generated ${data3.recommendations.length} new AI recommendations`), setToastActive(!0), data3.isExisting) {
        let approvalState2 = {};
        data3.recommendations.forEach((rec) => {
          rec.status === "approved" || rec.status === "applied" ? approvalState2[rec.field] = !0 : rec.status === "rejected" && (approvalState2[rec.field] = !1);
        }), setApprovalState(approvalState2);
      }
    } else
      data3.error && (setToastMessage(`Failed to generate recommendations: ${data3.error}`), setToastActive(!0));
    setIsGeneratingRecommendations(!1);
  }
  if (recommendationFetcher.data && isApplyingChanges) {
    let data3 = recommendationFetcher.data;
    if (console.log("\u{1F50D} Apply changes response:", data3), console.log("\u{1F50D} Response type:", typeof data3), console.log("\u{1F50D} Response keys:", Object.keys(data3)), data3.success && selectedProduct) {
      let appliedFields = recommendations.filter((rec) => approvalState[rec.field] === !0).map((rec) => rec.field), getFieldCelebration = (field) => ({
        keywords: "\u{1F3AF} Awesome! Keywords added - your product is now more discoverable!",
        description: "\u{1F4DD} Great work! Enhanced description will help customers understand your product better!",
        features: "\u2728 Fantastic! Feature list added - customers can see what makes your product special!",
        use_cases: "\u{1F4A1} Perfect! Use cases added - customers now know how to use your product!",
        target_audience: "\u{1F465} Excellent! Target audience defined - your marketing just got more focused!",
        material: "\u{1F52C} Nice! Material info added - customers can make informed decisions!",
        dimensions: "\u{1F4CF} Great! Dimensions added - no more size surprises for customers!",
        weight: "\u2696\uFE0F Perfect! Weight information helps with shipping expectations!",
        color: "\u{1F3A8} Colorful! Color info added - visual buyers will love this!",
        brand: "\u{1F3F7}\uFE0F Brand power! Brand info strengthens customer trust!",
        warranty: "\u{1F6E1}\uFE0F Security boost! Warranty info builds customer confidence!",
        sku: "\u{1F4E6} Organized! SKU added for better inventory management!",
        tags: "\u{1F3F7}\uFE0F Tagged! Product categorization just got better!",
        ai_search_queries: "\u{1F916} AI-ready! Search queries optimized for AI discovery!",
        semantic_description: "\u{1F9E0} Smart! AI-optimized description for better search matching!"
      })[field] || `\u2705 ${field.charAt(0).toUpperCase() + field.slice(1).replace(/_/g, " ")} updated!`, message = "";
      appliedFields.length === 1 ? message = getFieldCelebration(appliedFields[0]) : appliedFields.length === 2 ? message = `\u{1F389} Double win! Updated ${appliedFields.map((f) => f.replace(/_/g, " ")).join(" and ")}!` : appliedFields.length >= 3 && (message = `\u{1F680} Amazing progress! Applied ${appliedFields.length} improvements - you're on fire!`);
      let finalScore = selectedProduct.score, pointsEarned = 0;
      if (data3.scoreImprovement) {
        finalScore = data3.scoreImprovement.final;
        let improvement = data3.scoreImprovement.improvement;
        pointsEarned = appliedFields.length * 15, improvement > 0 ? message += ` \u{1F4C8} Score: ${data3.scoreImprovement.initial}% \u2192 ${data3.scoreImprovement.final}% (+${improvement.toFixed(0)}%) | +${pointsEarned} points!` : message += ` \u{1F4CA} Score: ${data3.scoreImprovement.final}%`;
      }
      let updatedGaps = selectedProduct.gaps.filter((gap) => !appliedFields.includes(gap)), updatedSelectedProduct = {
        ...selectedProduct,
        score: finalScore,
        gaps: updatedGaps
      };
      setProducts((prev) => prev.map(
        (p) => p.id === selectedProduct.id ? updatedSelectedProduct : p
      )), setSelectedProduct(updatedSelectedProduct), setRecommendations([]), setApprovalState({}), setJustAppliedChanges(!0);
      let safeMessage = typeof message == "string" && message.length > 0 && !message.match(/^\d{3}$/) ? message : "Changes applied successfully!";
      setToastMessage(safeMessage), setToastActive(!0);
    } else
      data3.error ? (setToastMessage(`Failed to apply changes: ${data3.error}`), setToastActive(!0)) : (console.error("\u{1F6A8} Unexpected response format:", data3), setToastMessage(`Unexpected response: ${JSON.stringify(data3)}`), setToastActive(!0));
    setIsApplyingChanges(!1);
  }
  if (customerInputFetcher.data && isSavingCustomerInput) {
    let data3 = customerInputFetcher.data;
    if (console.log("\u{1F50D} Customer input save response:", data3), data3.success && selectedProduct) {
      let appliedFields = data3.appliedFields || [], appliedCount = data3.appliedCount || 0, message = "";
      appliedCount === 1 ? message = `\u{1F389} Great! ${appliedFields[0]?.replace(/_/g, " ")} added to your product specs!` : appliedCount > 1 && (message = `\u{1F680} Excellent! Added ${appliedCount} product specifications!`);
      let estimatedImprovement = appliedCount * 4;
      message += ` \u{1F4C8} Health score boost: ~+${estimatedImprovement}% | +${appliedCount * 15} points!`;
      let updatedGaps = selectedProduct.gaps.filter((gap) => !appliedFields.includes(gap)), updatedScore = Math.min(100, selectedProduct.score + estimatedImprovement), updatedSelectedProduct = {
        ...selectedProduct,
        score: updatedScore,
        gaps: updatedGaps
      };
      setProducts((prev) => prev.map(
        (p) => p.id === selectedProduct.id ? updatedSelectedProduct : p
      )), setSelectedProduct(updatedSelectedProduct), setCustomerInputData({}), setCustomerInputOpen(!1), setJustAppliedChanges(!0), setToastMessage(message), setToastActive(!0);
    } else
      data3.error && (setToastMessage(`Failed to save: ${data3.error}`), setToastActive(!0));
    setIsSavingCustomerInput(!1);
  }
  let getFieldPlaceholder = (field) => ({
    material: "e.g., Cotton, Polyester, Steel, Wood",
    weight: "e.g., 2.5 lbs, 1.2 kg",
    color: "e.g., Navy Blue, Black, Red",
    size: "e.g., Large, XL, 12x8x4",
    brand: "e.g., Your Brand Name",
    model: "e.g., Model ABC-123",
    upc: "e.g., 123456789012",
    vendor: "e.g., Supplier Company",
    age_range: "e.g., 18-65, Adults, 3+",
    compatibility: "e.g., iPhone 12, Samsung Galaxy",
    warranty: "e.g., 1 year limited warranty",
    return_policy: "e.g., 30-day returns accepted",
    shipping_info: "e.g., Free shipping over $50",
    specifications: "e.g., Power: 110V, Material: ABS Plastic",
    documentation_url: "e.g., https://yoursite.com/manual.pdf",
    video_urls: "e.g., https://youtube.com/watch?v=abc123"
  })[field] || `Enter ${field.replace(/_/g, " ")}`, getFieldHelpText = (field) => ({
    material: "Primary material or fabric composition",
    weight: "Product weight with unit (lbs, kg, oz)",
    color: "Primary color or color options",
    brand: "Manufacturer or brand name",
    warranty: "Warranty terms and duration",
    upc: "Universal Product Code for inventory",
    specifications: "Technical specs, one per line"
  })[field] || "", getFieldPoints = (field) => {
    let fieldCategories = {
      required: 25,
      high: 20,
      medium: 15,
      low: 10
    }, highFields = ["material", "dimensions", "weight", "brand"], mediumFields = ["color", "size", "upc", "compatibility", "age_range", "gender"];
    return highFields.includes(field) ? fieldCategories.high : mediumFields.includes(field) ? fieldCategories.medium : fieldCategories.low;
  }, getFieldImpact = (field) => {
    let highFields = ["material", "dimensions", "weight", "brand"], mediumFields = ["color", "size", "upc", "compatibility", "age_range", "gender"];
    return highFields.includes(field) ? "4-5" : mediumFields.includes(field) ? "3-4" : "2-3";
  }, handleSaveCustomerInput = () => {
    if (!selectedProduct)
      return;
    let validationErrors = [], filledData = {};
    if (Object.entries(customerInputData).forEach(([field, value]) => {
      let trimmedValue = value.trim();
      trimmedValue && (field === "upc" && trimmedValue.length < 8 ? validationErrors.push("UPC must be at least 8 digits") : field === "weight" && !/\d+(\.\d+)?\s*(lbs?|kgs?|oz|pounds?|kilograms?|ounces?)/i.test(trimmedValue) ? validationErrors.push('Weight must include unit (e.g., "2.5 lbs", "1.2 kg")') : (field === "documentation_url" || field === "video_urls") && trimmedValue && !trimmedValue.startsWith("http") ? validationErrors.push(`${field.replace(/_/g, " ")} must be a valid URL starting with http`) : field === "age_range" && trimmedValue && !/\d+/.test(trimmedValue) ? validationErrors.push('Age range must contain numbers (e.g., "18+", "3-12")') : filledData[field] = trimmedValue);
    }), validationErrors.length > 0) {
      setToastMessage(`Validation errors: ${validationErrors.join(", ")}`), setToastActive(!0);
      return;
    }
    if (Object.keys(filledData).length === 0) {
      setToastMessage("Please fill in at least one field before saving"), setToastActive(!0);
      return;
    }
    setIsSavingCustomerInput(!0), customerInputFetcher.submit(
      {
        action: "save-customer-input",
        productId: selectedProduct.id,
        inputData: JSON.stringify(filledData)
      },
      { method: "post" }
    );
  }, filteredProducts = products.filter((product) => !(showOnlyLowHealth && product.score >= 70 || showOnlyNoDescription && product.description && product.description !== "No description")), rows = products.map(
    (product) => [
      product.id,
      product.title,
      product.description.length > 50 ? `${product.description.substring(0, 50)}...` : product.description,
      `${product.score}%`,
      product.gaps.length > 0 ? product.gaps.join(", ") : "None"
    ]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Page, { title: "CatalogAI Optimizer Dashboard", children: [
    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Layout, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: "20px" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { align: "center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { position: "relative", width: "80px", height: "80px", marginBottom: "10px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("svg", { width: "80", height: "80", style: { transform: "rotate(-90deg)" }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("circle", { cx: "40", cy: "40", r: "35", fill: "none", stroke: "#e5e7eb", strokeWidth: "8" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "circle",
                {
                  cx: "40",
                  cy: "40",
                  r: "35",
                  fill: "none",
                  stroke: dashboardMetrics.aiReadinessScore >= 90 ? "#10b981" : dashboardMetrics.aiReadinessScore >= 50 ? "#f59e0b" : "#ef4444",
                  strokeWidth: "8",
                  strokeDasharray: `${dashboardMetrics.aiReadinessScore / 100 * 220} 220`,
                  strokeLinecap: "round"
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              fontSize: "18px",
              fontWeight: "bold",
              color: dashboardMetrics.aiReadinessScore >= 90 ? "#10b981" : dashboardMetrics.aiReadinessScore >= 50 ? "#f59e0b" : "#ef4444"
            }, children: [
              dashboardMetrics.aiReadinessScore,
              "%"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "headingLg", as: "p", children: [
            dashboardMetrics.aiReadinessScore,
            " / 100"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Excellent AI readiness" })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { align: "center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "headingLg", as: "p", children: [
            dashboardMetrics.productsPassedPercentage,
            "%"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
            dashboardMetrics.validProducts,
            " of ",
            dashboardMetrics.totalProducts,
            " products"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "success", as: "p", children: "\u2191 5% from last week" })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { align: "center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingLg", as: "p", children: dashboardMetrics.lastSyncTime ? `${Math.floor((Date.now() - new Date(dashboardMetrics.lastSyncTime).getTime()) / (1e3 * 60 * 60))}h ago` : "Never" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", as: "p", children: "Last synced successfully" })
        ] }) })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingLg", as: "h2", children: "Feed Health" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Product validation distribution" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { marginTop: "20px" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { display: "flex", alignItems: "center", marginBottom: "10px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: {
              width: `${dashboardMetrics.validProducts / dashboardMetrics.totalProducts * 200}px`,
              height: "8px",
              background: "#10b981",
              borderRadius: "4px",
              marginRight: "10px",
              minWidth: "20px"
            } }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
              dashboardMetrics.validProducts,
              " products"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { display: "flex", alignItems: "center", marginBottom: "10px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: {
              width: `${dashboardMetrics.warningProducts / dashboardMetrics.totalProducts * 200}px`,
              height: "8px",
              background: "#f59e0b",
              borderRadius: "4px",
              marginRight: "10px",
              minWidth: "20px"
            } }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
              dashboardMetrics.warningProducts,
              " products"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { display: "flex", alignItems: "center", marginBottom: "20px" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: {
              width: `${dashboardMetrics.invalidProducts / dashboardMetrics.totalProducts * 200}px`,
              height: "8px",
              background: "#ef4444",
              borderRadius: "4px",
              marginRight: "10px",
              minWidth: "20px"
            } }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
              dashboardMetrics.invalidProducts,
              " products"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { variant: "primary", children: "View Validation Report" })
        ] })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingLg", as: "h2", children: "Next Actions" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Recommended optimizations for your catalog" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: {
          display: "grid",
          gridTemplateColumns: "repeat(2, 1fr)",
          gap: "20px",
          marginTop: "20px"
        }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
              dashboardMetrics.invalidProducts,
              " products need attention"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { variant: "primary", tone: "critical", children: "Take Action" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
              "Optimize ",
              dashboardMetrics.warningProducts,
              " products"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { variant: "primary", children: "Take Action" })
          ] }) })
        ] })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: { marginBottom: "10px" }, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: {
          width: "100%",
          height: "8px",
          background: "#e5e7eb",
          borderRadius: "4px",
          overflow: "hidden"
        }, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: {
          width: `${dashboardMetrics.optimizationProgress}%`,
          height: "100%",
          background: "#3b82f6",
          transition: "width 0.3s ease"
        } }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", as: "p", children: [
            "Your catalog is ",
            dashboardMetrics.optimizationProgress,
            "% AI-ready \u2014 ",
            100 - dashboardMetrics.optimizationProgress,
            "% left to optimize!"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: [
            dashboardMetrics.optimizationProgress,
            "% Complete"
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: { marginTop: "5px" }, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: "Keep going! \u{1F680}" }) })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingLg", as: "h2", children: "\u{1F4E6} Product Catalog" }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Browse and manage your product inventory" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(InlineStack, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            Button,
            {
              onClick: handleSync,
              loading: isSyncing,
              variant: "primary",
              size: "large",
              children: isSyncing ? "Syncing..." : "\u{1F504} Sync Products"
            }
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Filter by:" }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              Button,
              {
                variant: showOnlyLowHealth ? "primary" : "tertiary",
                size: "slim",
                onClick: () => setShowOnlyLowHealth(!showOnlyLowHealth),
                children: "\u{1F6A8} Low Health Only"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              Button,
              {
                variant: showOnlyNoDescription ? "primary" : "tertiary",
                size: "slim",
                onClick: () => setShowOnlyNoDescription(!showOnlyNoDescription),
                children: "\u{1F4DD} Missing Descriptions"
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
            "Showing ",
            filteredProducts.length,
            " of ",
            products.length,
            " products"
          ] })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "div",
          {
            className: "product-grid",
            style: {
              display: "grid",
              gridTemplateColumns: "repeat(auto-fit, minmax(350px, 1fr))",
              gap: "20px",
              marginTop: "20px",
              width: "100%"
            },
            children: filteredProducts.map(
              (product, index) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                Card,
                {
                  children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                          Button,
                          {
                            variant: "plain",
                            onClick: () => handleProductClick(product),
                            children: product.title
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
                          "ID: ",
                          product.id
                        ] })
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", as: "p", children: product.description && product.description !== "No description" ? product.description.length > 100 ? `${product.description.substring(0, 100)}...` : product.description : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { tone: "subdued", variant: "bodyMd", as: "p", children: "No description available" }) }),
                        product.gaps.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { wrap: !0, children: [
                          product.gaps.slice(0, 3).map(
                            (gap, gapIndex) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "warning", size: "small", children: gap }, gapIndex)
                          ),
                          product.gaps.length > 3 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "info", size: "small", children: `+${product.gaps.length - 3} more` })
                        ] })
                      ] })
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                          ProgressBar,
                          {
                            progress: product.score,
                            size: "small"
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                          Badge,
                          {
                            tone: product.score >= 90 ? "success" : product.score >= 70 ? "warning" : "critical",
                            size: "small",
                            children: `${product.score}%`
                          }
                        )
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        Button,
                        {
                          size: "slim",
                          variant: "primary",
                          onClick: () => handleProductClick(product),
                          children: "\u{1F527} Optimize"
                        }
                      )
                    ] })
                  ] })
                },
                product.id
              )
            )
          }
        ),
        filteredProducts.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "\u{1F389} No products match your filters!" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: showOnlyLowHealth ? "All your products are healthy! Great job maintaining your catalog." : showOnlyNoDescription ? "All your products have descriptions! Your catalog is well-documented." : "No products found matching your current filters." }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            Button,
            {
              variant: "tertiary",
              onClick: () => {
                setShowOnlyLowHealth(!1), setShowOnlyNoDescription(!1);
              },
              children: "Clear Filters"
            }
          )
        ] }) })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { variant: "oneHalf", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "Quick Actions" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            Button,
            {
              fullWidth: !0,
              onClick: handleHealthCheck,
              loading: isHealthChecking,
              variant: averageScore < 90 ? "primary" : "secondary",
              children: averageScore < 90 ? "Quick Scan Now" : "Run Health Check"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { fullWidth: !0, children: "Generate Feed" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { fullWidth: !0, children: "View Analytics" })
        ] })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Layout.Section, { variant: "oneHalf", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "Recent Activity" }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(BlockStack, { children: recentLogs.length > 0 ? recentLogs.map(
          (log2) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { as: "span", children: [
              log2.type === "sync" && "\u{1F504} ",
              log2.type === "push" && "\u{1F4E4} ",
              log2.type === "error" && "\u274C ",
              log2.type === "health_scan" && "\u{1F50D} ",
              log2.type === "auto_fix" && "\u{1F527} ",
              log2.type === "ai_enrichment" && "\u{1F916} ",
              log2.type === "settings_update" && "\u2699\uFE0F ",
              log2.message
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { as: "p", variant: "bodySm", tone: "subdued", children: new Date(log2.createdAt).toLocaleString() })
          ] }, log2.id)
        ) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { as: "p", tone: "subdued", children: "No recent activity" }) })
      ] }) }) })
    ] }),
    toastActive && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      Toast2,
      {
        content: toastMessage,
        onDismiss: () => setToastActive(!1)
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      HealthCheckModal,
      {
        isOpen: healthModalOpen,
        onClose: () => setHealthModalOpen(!1),
        jobId: healthCheckJobId,
        currentScore: averageScore,
        currentGaps: []
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      Modal,
      {
        open: productModalOpen,
        onClose: () => setProductModalOpen(!1),
        title: "",
        size: "large",
        primaryAction: {
          content: "Close",
          onAction: () => setProductModalOpen(!1)
        },
        children: selectedProduct && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Modal.Section, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "headingLg", as: "h2", children: [
                  "\u{1F4E6} ",
                  selectedProduct.title
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: [
                  "Product ID: ",
                  selectedProduct.id
                ] }),
                selectedProduct.description && selectedProduct.description !== "No description" && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", as: "p", children: selectedProduct.description })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
                  Badge,
                  {
                    tone: selectedProduct.score >= 90 ? "success" : selectedProduct.score >= 70 ? "warning" : "critical",
                    size: "large",
                    children: [
                      selectedProduct.score,
                      "% Health"
                    ]
                  }
                ),
                justAppliedChanges && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "small", children: "\u2728 Just Updated!" })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Box, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Overall Health Progress" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: `${Math.round(selectedProduct.score / 100 * 500)} / 500 points` })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Box, { paddingBlockStart: "200", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                ProgressBar,
                {
                  progress: selectedProduct.score,
                  size: "large"
                }
              ) })
            ] })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "\u{1F4CA} Category Breakdown" }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(InlineStack, { children: [
              {
                name: "\u{1F6A8} Required Fields",
                icon: "\u{1F6A8}",
                fields: ["title", "description", "price", "availability", "category"],
                color: "critical",
                description: "Essential for product visibility"
              },
              {
                name: "\u26A1 High Priority",
                icon: "\u26A1",
                fields: ["material", "dimensions", "weight", "brand", "use_cases", "features", "image_urls"],
                color: "warning",
                description: "Important for customer decisions"
              },
              {
                name: "\u{1F4CB} Medium Priority",
                icon: "\u{1F4CB}",
                fields: ["color", "size", "target_audience", "keywords", "upc", "compatibility", "age_range", "gender", "video_urls"],
                color: "attention",
                description: "Enhances product discovery"
              },
              {
                name: "\u2728 Enhancement",
                icon: "\u2728",
                fields: ["model", "sku", "tags", "vendor", "warranty", "return_policy", "shipping_info", "documentation_url", "specifications", "ai_search_queries", "semantic_description"],
                color: "success",
                description: "Optimizes for AI search"
              }
            ].map((category, index) => {
              let missingInCategory = selectedProduct.gaps.filter((gap) => category.fields.includes(gap)).length, completedInCategory = category.fields.length - missingInCategory, progress = Math.round(completedInCategory / category.fields.length * 100);
              return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "headingSm", as: "h4", children: [
                    category.icon,
                    " ",
                    category.name
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: category.description }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { wrap: !0, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", as: "p", children: [
                      completedInCategory,
                      "/",
                      category.fields.length,
                      " complete"
                    ] }),
                    missingInCategory > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "warning", size: "small", children: `${missingInCategory} missing` })
                  ] })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                    ProgressBar,
                    {
                      progress,
                      size: "small"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: `${progress}% complete` })
                ] })
              ] }) }, index);
            }) })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "\u{1F50D} Missing Fields Analysis" }),
              selectedProduct.gaps.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "large", children: "\u{1F389} Perfect Score!" }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "critical", size: "large", children: `${selectedProduct.gaps.length} fields missing` })
            ] }),
            selectedProduct.gaps.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "These fields are missing and could improve your product's visibility and AI search performance:" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(InlineStack, { wrap: !0, children: selectedProduct.gaps.map(
                (gap, index) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "warning", size: "small", children: gap.replace(/_/g, " ") }, index)
              ) })
            ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "success", as: "p", children: "\u{1F389} Congratulations! Your product has all the essential fields completed." }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: "This product is optimized for search engines and AI-powered discovery." })
            ] })
          ] }) }),
          selectedProduct.gaps.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "\u{1F916} AI Recommendations" }),
              recommendations.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                Button,
                {
                  onClick: () => {
                    setRecommendations([]), setApprovalState({}), handleGenerateRecommendations();
                  },
                  variant: "secondary",
                  size: "slim",
                  loading: isGeneratingRecommendations,
                  children: "\u{1F504} Regenerate"
                }
              )
            ] }),
            recommendations.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "\u{1F3AF} Ready to improve your product's health score?" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: "Our AI will analyze your missing fields and suggest improvements for:" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { wrap: !0, children: [
                  selectedProduct.gaps.slice(0, 5).map(
                    (gap, index) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "warning", size: "small", children: gap.replace(/_/g, " ") }, index)
                  ),
                  selectedProduct.gaps.length > 5 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "info", size: "small", children: `+${selectedProduct.gaps.length - 5} more` })
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                Button,
                {
                  onClick: handleGenerateRecommendations,
                  variant: "primary",
                  size: "large",
                  loading: isGeneratingRecommendations,
                  children: isGeneratingRecommendations ? "\u{1F916} Generating..." : "\u{1F680} Generate AI Recommendations"
                }
              )
            ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
              selectedProduct.recommendations?.generatedAt && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
                "Generated: ",
                new Date(selectedProduct.recommendations.generatedAt).toLocaleString()
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Review and approve the AI-generated suggestions below. Only approved changes will be applied to your product." })
            ] })
          ] }) }),
          recommendations.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "\u270F\uFE0F Review & Approve Recommendations" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "small", children: `${Object.values(approvalState).filter(Boolean).length} approved` }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "critical", size: "small", children: `${Object.values(approvalState).filter((val) => val === !1).length} rejected` })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Review each AI suggestion below. Use \u2705 to approve or \u274C to reject. Only approved changes will be applied to your product." }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Quick Actions:" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  Button,
                  {
                    size: "slim",
                    variant: "secondary",
                    tone: "success",
                    onClick: () => {
                      let allApproved = recommendations.reduce((acc, rec) => ({
                        ...acc,
                        [rec.field]: !0
                      }), {});
                      setApprovalState(allApproved);
                    },
                    children: "\u2705 Approve All"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  Button,
                  {
                    size: "slim",
                    variant: "secondary",
                    tone: "critical",
                    onClick: () => {
                      let allRejected = recommendations.reduce((acc, rec) => ({
                        ...acc,
                        [rec.field]: !1
                      }), {});
                      setApprovalState(allRejected);
                    },
                    children: "\u274C Reject All"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  Button,
                  {
                    size: "slim",
                    variant: "secondary",
                    onClick: () => setApprovalState({}),
                    children: "Clear All"
                  }
                )
              ] })
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(BlockStack, { children: recommendations.map((rec, index) => {
              let isApproved = approvalState[rec.field] === !0, isRejected = approvalState[rec.field] === !1, isPending = approvalState[rec.field] === void 0, isApplied = rec.status === "applied", fieldInfo = ((field) => {
                let fieldCategories = {
                  required: { fields: ["title", "description", "price", "availability", "category"], points: "25", impact: "5-6%", color: "critical", icon: "\u{1F6A8}" },
                  high: { fields: ["material", "dimensions", "weight", "brand", "use_cases", "features", "image_urls"], points: "20", impact: "4-5%", color: "warning", icon: "\u26A1" },
                  medium: { fields: ["color", "size", "target_audience", "keywords", "upc", "compatibility", "age_range", "gender", "video_urls"], points: "15", impact: "3-4%", color: "attention", icon: "\u{1F4CB}" },
                  low: { fields: ["model", "sku", "tags", "vendor", "warranty", "return_policy", "shipping_info", "documentation_url", "specifications", "ai_search_queries", "semantic_description"], points: "10", impact: "2-3%", color: "info", icon: "\u2728" }
                };
                for (let [category, info] of Object.entries(fieldCategories))
                  if (info.fields.includes(field))
                    return { category, ...info };
                return { category: "low", fields: [], points: "10", impact: "2%", color: "info", icon: "\u2728" };
              })(rec.field);
              return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "headingSm", as: "h4", children: [
                        fieldInfo.icon,
                        " ",
                        rec.field.charAt(0).toUpperCase() + rec.field.slice(1).replace(/_/g, " ")
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: fieldInfo.color, size: "small", children: fieldInfo.category.charAt(0).toUpperCase() + fieldInfo.category.slice(1) })
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { wrap: !0, children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Badge, { tone: "info", size: "small", children: [
                        "+",
                        fieldInfo.points,
                        " pts"
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Badge, { tone: "subdued", size: "small", children: [
                        "~",
                        fieldInfo.impact,
                        " impact"
                      ] }),
                      isApplied && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "small", children: "\u{1F680} Applied" }),
                      !isApplied && isApproved && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "small", children: "\u2705 Approved" }),
                      !isApplied && isRejected && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "critical", size: "small", children: "\u274C Rejected" }),
                      !isApplied && isPending && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "attention", size: "small", children: "\u23F3 Pending" })
                    ] })
                  ] }),
                  !isApplied && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                      Button,
                      {
                        size: "slim",
                        onClick: () => handleToggleApproval(rec.field, !1),
                        variant: isRejected ? "primary" : "secondary",
                        tone: isRejected ? "critical" : void 0,
                        children: isRejected ? "\u274C Rejected" : "\u274C Reject"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                      Button,
                      {
                        size: "slim",
                        onClick: () => handleToggleApproval(rec.field, !0),
                        variant: isApproved ? "primary" : "secondary",
                        tone: isApproved ? "success" : void 0,
                        children: isApproved ? "\u2705 Approved" : "\u2705 Approve"
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Current Value" }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Box, { padding: "200", borderRadius: "100", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", as: "p", children: rec.originalValue || /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { tone: "subdued", as: "p", children: "(empty)" }) }) })
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "success", as: "p", children: "AI Recommendation" }),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Box, { padding: "200", borderRadius: "100", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", as: "p", children: rec.newValue }) })
                    ] })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
                    "\u{1F4A1} ",
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("em", { children: rec.improvement })
                  ] })
                ] }) })
              ] }) }, index);
            }) }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodyMd", tone: "subdued", as: "p", children: "Ready to apply your approved changes?" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
                  recommendations.filter(
                    (rec) => rec.status !== "applied" && approvalState[rec.field] === !0
                  ).length,
                  " changes approved for application"
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  Button,
                  {
                    onClick: () => setRecommendations([]),
                    variant: "secondary",
                    children: "Cancel"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  Button,
                  {
                    variant: "primary",
                    size: "large",
                    onClick: handleApplyChanges,
                    loading: isApplyingChanges,
                    disabled: recommendations.filter(
                      (rec) => rec.status !== "applied" && approvalState[rec.field] === !0
                    ).length === 0,
                    children: isApplyingChanges ? "\u{1F680} Applying..." : `\u2705 Apply ${recommendations.filter(
                      (rec) => rec.status !== "applied" && approvalState[rec.field] === !0
                    ).length} Changes`
                  }
                )
              ] })
            ] }) })
          ] }) }),
          selectedProduct.gaps.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { align: "space-between", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: "Manual Product Information" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: "Fill in product specs that only you know. These can't be generated by AI." })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                Button,
                {
                  onClick: () => setCustomerInputOpen(!customerInputOpen),
                  variant: "secondary",
                  size: "slim",
                  children: customerInputOpen ? "Hide Fields" : "Add Product Info"
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Collapsible, { id: "customer-input-collapsible", open: customerInputOpen, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
              selectedProduct.gaps.filter((gap) => getFieldInputType(gap) === "customer_required").map((field, index) => {
                let label = FIELD_LABELS[field] || field.charAt(0).toUpperCase() + field.slice(1).replace(/_/g, " ");
                return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Box, { children: [
                  field === "dimensions" ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", as: "p", children: label }),
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { gap: "300", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        TextField,
                        {
                          label: "Length",
                          value: customerInputData[`${field}_length`] || "",
                          onChange: (value) => setCustomerInputData((prev) => ({
                            ...prev,
                            [`${field}_length`]: value
                          })),
                          placeholder: "e.g., 12 inches",
                          autoComplete: "off"
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        TextField,
                        {
                          label: "Width",
                          value: customerInputData[`${field}_width`] || "",
                          onChange: (value) => setCustomerInputData((prev) => ({
                            ...prev,
                            [`${field}_width`]: value
                          })),
                          placeholder: "e.g., 8 inches",
                          autoComplete: "off"
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        TextField,
                        {
                          label: "Height",
                          value: customerInputData[`${field}_height`] || "",
                          onChange: (value) => setCustomerInputData((prev) => ({
                            ...prev,
                            [`${field}_height`]: value
                          })),
                          placeholder: "e.g., 4 inches",
                          autoComplete: "off"
                        }
                      )
                    ] })
                  ] }) : field === "gender" ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                    Select,
                    {
                      label,
                      options: [
                        { label: "Select target gender", value: "" },
                        { label: "Male", value: "male" },
                        { label: "Female", value: "female" },
                        { label: "Unisex", value: "unisex" },
                        { label: "Kids", value: "kids" }
                      ],
                      value: customerInputData[field] || "",
                      onChange: (value) => setCustomerInputData((prev) => ({
                        ...prev,
                        [field]: value
                      }))
                    }
                  ) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                    TextField,
                    {
                      label,
                      value: customerInputData[field] || "",
                      onChange: (value) => setCustomerInputData((prev) => ({
                        ...prev,
                        [field]: value
                      })),
                      placeholder: getFieldPlaceholder(field),
                      helpText: getFieldHelpText(field),
                      multiline: field === "specifications" || field === "warranty" || field === "return_policy",
                      autoComplete: "off"
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Box, { paddingBlockStart: "200", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { gap: "200", blockAlign: "center", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Text, { variant: "bodySm", tone: "subdued", as: "p", children: [
                      "Impact: +",
                      getFieldPoints(field),
                      " points, ~",
                      getFieldImpact(field),
                      "% health boost"
                    ] }),
                    customerInputData[field] && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Badge, { tone: "success", size: "small", children: "\u2705 Ready to save" })
                  ] }) })
                ] }, index);
              }),
              Object.keys(customerInputData).length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(InlineStack, { align: "end", children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Button, { onClick: () => setCustomerInputData({}), children: "Clear All" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
                  Button,
                  {
                    variant: "primary",
                    onClick: handleSaveCustomerInput,
                    loading: isSavingCustomerInput,
                    children: [
                      "Save ",
                      Object.values(customerInputData).filter((v) => v.trim()).length,
                      " Fields"
                    ]
                  }
                )
              ] })
            ] }) })
          ] }) }),
          selectedProduct.score >= 90 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(BlockStack, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "headingMd", as: "h3", children: selectedProduct.score === 100 ? "\u{1F389} Perfect Product Health!" : "\u2705 Product Health: Excellent" }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { as: "p", children: selectedProduct.score === 100 ? "Congratulations! This product has achieved perfect health with all OpenAI spec requirements met." : "This product has a high health score and does not need immediate attention." }),
            selectedProduct.gaps.length === 0 && selectedProduct.score === 100 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Text, { variant: "bodySm", tone: "success", as: "p", children: "\u{1F680} Ready for OpenAI ChatGPT discovery!" })
          ] }) })
        ] }) })
      }
    )
  ] });
}

// app/routes/auth.$.tsx
var auth_exports = {};
__export(auth_exports, {
  loader: () => loader8
});
init_shopify_server();
var loader8 = async ({ request: request2 }) => (await authenticate.admin(request2), null);

// app/routes/health.tsx
var health_exports = {};
__export(health_exports, {
  loader: () => loader9
});
var import_node11 = __toESM(require_dist(), 1);
async function loader9() {
  try {
    return (0, import_node11.json)(
      {
        status: "healthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        service: "catalogai-optimizer",
        environment: "production",
        uptime: process.uptime()
      },
      { status: 200 }
    );
  } catch (error) {
    return console.error("Health check failed:", error), (0, import_node11.json)(
      {
        status: "unhealthy",
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      },
      { status: 500 }
    );
  }
}

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { entry: { module: "/build/entry.client-M56MYHAT.js", imports: ["/build/_shared/chunk-LOR64ATL.js", "/build/_shared/chunk-Q3IECNXJ.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-K32HGFXB.js", imports: ["/build/_shared/chunk-H2DI5CET.js"], hasAction: !1, hasLoader: !1, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/_index": { id: "routes/_index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/_index-N7MP4PBU.js", imports: ["/build/_shared/chunk-MWF276KD.js", "/build/_shared/chunk-ADGUJX5W.js", "/build/_shared/chunk-LCJSGTVF.js"], hasAction: !0, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.enrich": { id: "routes/api.enrich", parentId: "root", path: "api/enrich", index: void 0, caseSensitive: void 0, module: "/build/routes/api.enrich-SFXHLYSE.js", imports: void 0, hasAction: !0, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.health-check": { id: "routes/api.health-check", parentId: "root", path: "api/health-check", index: void 0, caseSensitive: void 0, module: "/build/routes/api.health-check-4K2OQFHX.js", imports: void 0, hasAction: !0, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.queue-status": { id: "routes/api.queue-status", parentId: "root", path: "api/queue-status", index: void 0, caseSensitive: void 0, module: "/build/routes/api.queue-status-BGLNO3UC.js", imports: void 0, hasAction: !1, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.settings": { id: "routes/api.settings", parentId: "root", path: "api/settings", index: void 0, caseSensitive: void 0, module: "/build/routes/api.settings-FJ3TID6M.js", imports: void 0, hasAction: !0, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.sync": { id: "routes/api.sync", parentId: "root", path: "api/sync", index: void 0, caseSensitive: void 0, module: "/build/routes/api.sync-64X2SDGK.js", imports: void 0, hasAction: !0, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.test-health-check": { id: "routes/api.test-health-check", parentId: "root", path: "api/test-health-check", index: void 0, caseSensitive: void 0, module: "/build/routes/api.test-health-check-IYEKKCWC.js", imports: void 0, hasAction: !1, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/api.validate": { id: "routes/api.validate", parentId: "root", path: "api/validate", index: void 0, caseSensitive: void 0, module: "/build/routes/api.validate-HG5RCGQI.js", imports: void 0, hasAction: !0, hasLoader: !1, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/auth.$": { id: "routes/auth.$", parentId: "root", path: "auth/*", index: void 0, caseSensitive: void 0, module: "/build/routes/auth.$-QXGTKEOT.js", imports: void 0, hasAction: !1, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/health": { id: "routes/health", parentId: "root", path: "health", index: void 0, caseSensitive: void 0, module: "/build/routes/health-TTCX2HYV.js", imports: void 0, hasAction: !1, hasLoader: !0, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 }, "routes/webhooks": { id: "routes/webhooks", parentId: "root", path: "webhooks", index: void 0, caseSensitive: void 0, module: "/build/routes/webhooks-PBKDGD5Z.js", imports: void 0, hasAction: !0, hasLoader: !1, hasClientAction: !1, hasClientLoader: !1, hasErrorBoundary: !1 } }, version: "8f1ac200", hmr: void 0, url: "/build/manifest-8F1AC200.js" };

// server-entry-module:@remix-run/dev/server-build
var mode = "production", assetsBuildDirectory = "public/build", future = { v3_fetcherPersist: !0, v3_relativeSplatPath: !0, v3_throwAbortReason: !0, v3_routeConfig: !1, v3_singleFetch: !0, v3_lazyRouteDiscovery: !0, unstable_optimizeDeps: !1 }, publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/api.test-health-check": {
    id: "routes/api.test-health-check",
    parentId: "root",
    path: "api/test-health-check",
    index: void 0,
    caseSensitive: void 0,
    module: api_test_health_check_exports
  },
  "routes/api.health-check": {
    id: "routes/api.health-check",
    parentId: "root",
    path: "api/health-check",
    index: void 0,
    caseSensitive: void 0,
    module: api_health_check_exports
  },
  "routes/api.queue-status": {
    id: "routes/api.queue-status",
    parentId: "root",
    path: "api/queue-status",
    index: void 0,
    caseSensitive: void 0,
    module: api_queue_status_exports
  },
  "routes/api.settings": {
    id: "routes/api.settings",
    parentId: "root",
    path: "api/settings",
    index: void 0,
    caseSensitive: void 0,
    module: api_settings_exports
  },
  "routes/api.validate": {
    id: "routes/api.validate",
    parentId: "root",
    path: "api/validate",
    index: void 0,
    caseSensitive: void 0,
    module: api_validate_exports
  },
  "routes/api.enrich": {
    id: "routes/api.enrich",
    parentId: "root",
    path: "api/enrich",
    index: void 0,
    caseSensitive: void 0,
    module: api_enrich_exports
  },
  "routes/api.sync": {
    id: "routes/api.sync",
    parentId: "root",
    path: "api/sync",
    index: void 0,
    caseSensitive: void 0,
    module: api_sync_exports
  },
  "routes/webhooks": {
    id: "routes/webhooks",
    parentId: "root",
    path: "webhooks",
    index: void 0,
    caseSensitive: void 0,
    module: webhooks_exports
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: index_exports
  },
  "routes/auth.$": {
    id: "routes/auth.$",
    parentId: "root",
    path: "auth/*",
    index: void 0,
    caseSensitive: void 0,
    module: auth_exports
  },
  "routes/health": {
    id: "routes/health",
    parentId: "root",
    path: "health",
    index: void 0,
    caseSensitive: void 0,
    module: health_exports
  }
};
export {
  assets_manifest_default as assets,
  assetsBuildDirectory,
  entry,
  future,
  mode,
  publicPath,
  routes
};
/*! Bundled license information:

@remix-run/node/dist/globals.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/warnings.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/cookies.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/formData.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.23.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/mode.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/errors.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/responses.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/headers.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/single-fetch.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/entry.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/invariant.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/routeMatching.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/data.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/routes.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/markup.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/serverHandoff.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/dev.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/deprecations.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/server.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/sessions.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/upload/errors.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/esm/index.js:
  (**
   * @remix-run/server-runtime v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/crypto.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/implementations.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/sessions/fileStorage.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/stream.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/upload/fileUploadHandler.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/index.js:
  (**
   * @remix-run/node v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/index.js:
  (**
   * React Router v6.30.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.30.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-dom/cjs/react-dom-server-legacy.node.production.min.js:
  (**
   * @license React
   * react-dom-server-legacy.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.production.min.js:
  (**
   * @license React
   * react-dom-server.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/invariant.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/routeModules.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/links.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/markup.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/single-fetch.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/errorBoundaries.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/fallback.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/routes.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/fog-of-war.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/components.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/scroll-restoration.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/server.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/esm/index.js:
  (**
   * @remix-run/react v2.17.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
